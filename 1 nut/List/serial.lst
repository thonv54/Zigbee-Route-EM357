###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Apr/2016  13:01:49
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Work Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\util\serial\serial.c
#    Command line =  
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\util\serial\serial.c" -D
#        SWITCH_1_BUTTON -D NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D
#        CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"serial.c\"" -lC "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\List\" --diag_suppress Pa050 -o "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\Obj\" --debug --endian=little --cpu=Cortex-M3
#        --no_path_in_file_macros --separate_cluster_for_initialized_variables
#        -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        "D:\Work Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\util\serial\" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\"
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\List\serial.lst
#    Object file  =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\Obj\serial.o
#
###############################################################################

D:\Work Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\util\serial\serial.c
      1          /***************************************************************************//**
      2           * @file serial.c
      3           * @brief Serial Layer, legacy support
      4           *******************************************************************************
      5           * @section License
      6           * <b>(C) Copyright 2014 Silicon Labs, http://www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * This file is licensed under the Silabs License Agreement. See the file
     10           * "Silabs_License_Agreement.txt" for details. Before using this software for
     11           * any purpose, you must agree to the terms of that agreement.
     12           *
     13          
     14           ******************************************************************************/
     15          
     16          #include PLATFORM_HEADER
     17          #include "stack/include/ember-types.h"
     18          #include "stack/include/error.h"
     19          
     20          //Host processors do not use Ember Message Buffers.
     21          #ifndef EZSP_HOST
     22            #include "stack/include/packet-buffer.h"
     23          #endif
     24          
     25          #include "hal/hal.h"
     26          #include "serial.h"
     27          #ifdef CORTEXM3_EFM32_MICRO
     28            #include "com.h"
     29          #endif
     30          #include "ember-printf.h"
     31          
     32          #include <stdarg.h>
     33          
     34          #ifdef EMBER_SERIAL_USE_STDIO
     35          #include <stdio.h>
     36          #endif //EMBER_SERIAL_USE_STDIO
     37          
     38          // AppBuilder and Afv2 will define the characteristics of the Serial ports here.
     39          #if defined(ZA_GENERATED_HEADER)
     40            #include ZA_GENERATED_HEADER
     41          #endif
     42          
     43          // Crude method of mashing together com and serial layers before all the drivers
     44          // are properly ported over into ember world. NT 2014-09-16
     45          #ifdef CORTEXM3_EFM32_MICRO
     46          //------------------------------------------------------
     47          // Serial initialization
     48          
     49          EmberStatus emberSerialInit(int8u port,
     50                                                    SerialBaudRate rate,
     51                                                    SerialParity parity,
     52                                                    int8u stopBits)
     53          {
     54            EmberStatus status = EMBER_ERR_FATAL;
     55          #ifdef COM_VCP_ENABLE
     56            if (port==COM_VCP)
     57            {
     58              status = COM_Init((COM_Port_t) port, NULL);
     59            }
     60          #endif
     61          #ifdef COM_USART0_ENABLE
     62            if (port==COM_USART0)
     63            {
     64              // ignoring baudrate/parity/stopbits for now
     65              COM_Init_t initdata = COM_INITUART(USART0_INIT);
     66              status = COM_Init((COM_Port_t) port, &initdata);
     67            }
     68          #endif
     69          #ifdef COM_USART1_ENABLE
     70            if (port==COM_USART1)
     71            {
     72              // ignoring baudrate/parity/stopbits for now
     73              COM_Init_t initdata = COM_INITUART(USART1_INIT);
     74              status = COM_Init((COM_Port_t) port, &initdata);
     75            }
     76          #endif
     77          #ifdef COM_USART2_ENABLE
     78            if (port==COM_USART2)
     79            {
     80              // ignoring baudrate/parity/stopbits for now
     81              COM_Init_t initdata = COM_INITUART(USART2_INIT);
     82              status = COM_Init((COM_Port_t) port, &initdata);
     83            }
     84          #endif
     85            return status;
     86          }
     87          
     88          
     89          //------------------------------------------------------
     90          // Serial Input
     91          
     92          // returns # bytes available for reading
     93          int16u emberSerialReadAvailable(int8u port)
     94          {
     95            return COM_ReadAvailable((COM_Port_t) port);
     96          }
     97          
     98          EmberStatus emberSerialReadByte(int8u port, int8u *dataByte)
     99          {
    100            return COM_ReadByte((COM_Port_t) port, dataByte);
    101          }
    102          
    103          EmberStatus emberSerialReadData(int8u port,
    104                                          int8u *data,
    105                                          int16u length,
    106                                          int16u *bytesRead)
    107          {
    108            int16u bytesReadInternal = 0;
    109            EmberStatus status;
    110          
    111            while (bytesReadInternal < length) {
    112              status = emberSerialReadByte(port, data);
    113          
    114              switch (status) {
    115                case EMBER_SUCCESS:
    116                  ++data;
    117                  ++bytesReadInternal;
    118                  break;
    119          
    120                case EMBER_SERIAL_RX_EMPTY:
    121                  // empty queue is not an error for us, we just want to keep waiting
    122                  break;
    123          
    124                default:
    125                  // only store number of bytes read if the caller provided a non-NULL pointer
    126                  if (bytesRead) {
    127                    *bytesRead = bytesReadInternal;
    128                  }
    129                  return status;
    130              }
    131            }
    132          
    133            // only store number of bytes read if the caller provided a non-NULL pointer
    134            if (bytesRead) {
    135              *bytesRead = bytesReadInternal;
    136            }
    137          
    138            return EMBER_SUCCESS;
    139          
    140          }
    141          
    142          #ifndef EMBER_TEST
    143          EmberStatus emberSerialReadDataTimeout(int8u port,
    144                                                 int8u *data,
    145                                                 int16u length,
    146                                                 int16u *bytesRead,
    147                                                 int16u firstByteTimeout,
    148                                                 int16u subsequentByteTimeout)
    149          {
    150            int16u bytesReadInternal = 0;
    151            EmberStatus status;
    152            int16u timeout = firstByteTimeout;
    153            int16u startTime = halCommonGetInt16uMillisecondTick();
    154          
    155            // loop until we read the max number of bytes or the timeout elapses
    156            while (bytesReadInternal < length
    157                   && elapsedTimeInt16u(startTime,halCommonGetInt16uMillisecondTick()) < timeout) {
    158              status = emberSerialReadByte(port, data);
    159          
    160              switch (status) {
    161                case EMBER_SUCCESS:
    162                  ++data;
    163                  ++bytesReadInternal;
    164                  // reset timer and timeout for next character
    165                  startTime = halCommonGetInt16uMillisecondTick();
    166                  timeout = subsequentByteTimeout;
    167                  break;
    168          
    169                case EMBER_SERIAL_RX_EMPTY:
    170                  // empty queue is not an error for us, we just want to keep waiting
    171                  break;
    172          
    173                default:
    174                  // only store number of bytes read if the caller provided a non-NULL pointer
    175                  if (bytesRead) {
    176                    *bytesRead = bytesReadInternal;
    177                  }
    178                  return status;
    179              }
    180            }
    181          
    182            // only store number of bytes read if the caller provided a non-NULL pointer
    183            if (bytesRead) {
    184              *bytesRead = bytesReadInternal;
    185            }
    186          
    187            return bytesReadInternal == length ? EMBER_SUCCESS : EMBER_SERIAL_RX_EMPTY;
    188          }
    189          #endif // EMBER_TEST
    190          
    191          EmberStatus emberSerialReadPartialLine(int8u port, char *data, int8u max, int8u *index)
    192          {
    193            return COM_ReadPartialLine((COM_Port_t) port, data, max, index);
    194          }
    195          
    196          EmberStatus emberSerialReadLine(int8u port, char *data, int8u max)
    197          {
    198            int8u index=0;
    199          
    200            while(emberSerialReadPartialLine(port, data, max, &index) != EMBER_SUCCESS) {
    201              halResetWatchdog();
    202            }
    203            return EMBER_SUCCESS;
    204          }
    205          
    206          //------------------------------------------------------
    207          // Serial Output
    208          
    209          // returns # bytes (if fifo mode)/messages (if buffer mode) that can be written
    210          int16u emberSerialWriteAvailable(int8u port)
    211          {
    212            return COM_WriteAvailable((COM_Port_t) port);
    213          }
    214          
    215          int16u emberSerialWriteUsed(int8u port)
    216          {
    217            return COM_WriteUsed((COM_Port_t) port);
    218          }
    219          
    220          EmberStatus emberSerialWriteByte(int8u port, int8u dataByte)
    221          {
    222            return COM_WriteByte((COM_Port_t) port, dataByte);
    223          }
    224          
    225          EmberStatus emberSerialWriteString(int8u port, PGM_P string)
    226          {
    227            return COM_WriteString((COM_Port_t) port, string);
    228          }
    229          
    230          EmberStatus emberSerialWriteData(int8u port, int8u *data, int8u length)
    231          {
    232            return COM_WriteData((COM_Port_t) port, data, length);
    233          }
    234          
    235          EmberStatus emberSerialWriteBuffer(int8u port,
    236                                             EmberMessageBuffer buffer,
    237                                             int8u start,
    238                                             int8u length)
    239          {
    240            return EMBER_ERR_FATAL;  //This function is invalid.
    241          }
    242          
    243          
    244          EmberStatus emberSerialWaitSend(int8u port)  // waits for all byte to be written out of a port
    245          {
    246            return COM_WaitSend((COM_Port_t) port);
    247          }
    248          
    249          //------------------------------------------------------
    250          // Guaranteed output
    251          
    252          // The _only_ Guaranteed API:  The usage model for this api
    253          //   Does not require efficiency
    254          
    255          #if !defined(EMBER_AF_PLUGIN_STANDARD_PRINTF_SUPPORT)
    256          
    257          EmberStatus emberSerialGuaranteedPrintf(int8u port, PGM_P formatString, ...)
    258          {
    259            Ecode_t stat;
    260            va_list ap;
    261            va_start (ap, formatString);
    262            if(!emPrintfInternal(COM_ForceWriteData, (COM_Port_t) port, formatString, ap))
    263              stat = EMBER_ERR_FATAL;
    264            va_end (ap);
    265            return stat;
    266          }
    267          
    268          #endif
    269          
    270          //------------------------------------------------------
    271          // Serial buffer maintenance
    272          void emberSerialFlushRx(int8u port)
    273          {
    274            COM_FlushRx((COM_Port_t) port);
    275          }
    276          void emberSerialBufferTick ( void ) { }
    277          
    278          
    279          boolean emberSerialUnused(int8u port)
    280          {
    281          #ifdef EMBER_SERIAL_USE_STDIO
    282            return FALSE;
    283          #else //EMBER_SERIAL_USE_STDIO
    284            return COM_Unused((COM_Port_t) port);
    285          #endif //EMBER_SERIAL_USE_STDIO
    286          }
    287          #else //CORTEXM3_EFM32_MICRO
    288          
    289          //Documentary comments:
    290          // To conserve precious flash, there is very little validity checking
    291          //  on the given parameters.  Be sure not to use an invalid port number
    292          //  or a port that is unused.
    293          // Blocking routines will always wait for room (but not buffers - if buffers
    294          //  cannot be allocated, no part of the message will be sent)
    295          // Non-blocking routines will never wait for room, and may cause partial
    296          //  messages to be sent.  If a contiguous message needs to be sent, available
    297          //  space should be checked _before_ calling the appropriate write API.
    298          
    299          //------------------------------------------------------
    300          // Determine if blocking code needs to be enabled
    301          #if defined(EMBER_SERIAL0_BLOCKING) || \
    302              defined(EMBER_SERIAL1_BLOCKING) || \
    303              defined(EMBER_SERIAL2_BLOCKING) || \
    304              defined(EMBER_SERIAL3_BLOCKING) || \
    305              defined(EMBER_SERIAL4_BLOCKING)
    306            #define EM_ENABLE_SERIAL_BLOCKING
    307          #endif
    308          #ifdef EMBER_SERIAL0_BLOCKING
    309            #define EM_SERIAL0_BLOCKSTATE TRUE
    310          #else
    311            #define EM_SERIAL0_BLOCKSTATE FALSE
    312          #endif
    313          #ifdef EMBER_SERIAL1_BLOCKING
    314            #define EM_SERIAL1_BLOCKSTATE TRUE
    315          #else
    316            #define EM_SERIAL1_BLOCKSTATE FALSE
    317          #endif
    318          #ifdef EMBER_SERIAL2_BLOCKING
    319            #define EM_SERIAL2_BLOCKSTATE TRUE
    320          #else
    321            #define EM_SERIAL2_BLOCKSTATE FALSE
    322          #endif
    323          #ifdef EMBER_SERIAL3_BLOCKING
    324            #define EM_SERIAL3_BLOCKSTATE TRUE
    325          #else
    326            #define EM_SERIAL3_BLOCKSTATE FALSE
    327          #endif
    328          #ifdef EMBER_SERIAL4_BLOCKING
    329            #define EM_SERIAL4_BLOCKSTATE TRUE
    330          #else
    331            #define EM_SERIAL4_BLOCKSTATE FALSE
    332          #endif
    333          
    334          #ifndef EMBER_SERIAL_USE_STDIO
    335          //------------------------------------------------------
    336          // Memory allocations for Queue data structures
    337          
    338          //Macros to define fifo and buffer queues, can't use a typedef becuase the size
    339          // of the fifo array in the queues can change
    340          #define DEFINE_FIFO_QUEUE(qSize, qName)             \
    341            static struct {                                   \
    342              /*! Indexes of next byte to send*/              \
    343              int16u head;                                     \
    344              /*! Index of where to enqueue next message*/    \
    345              int16u tail;                                     \
    346              /*! Number of bytes queued*/                    \
    347              volatile int16u used;                            \
    348              /*! FIFO of queue data*/                        \
    349              int8u fifo[qSize];                              \
    350            } qName;
    351          
    352          #define DEFINE_BUFFER_QUEUE(qSize, qName)           \
    353            static struct {                                   \
    354              /*! Indexes of next message to send*/           \
    355              int8u head;                                     \
    356              /*! Index of where to enqueue next message*/    \
    357              int8u tail;                                     \
    358              /*! Number of messages queued*/                 \
    359              volatile int8u used;                            \
    360              int8u dead;                                     \
    361              EmberMessageBuffer currentBuffer;               \
    362              int8u *nextByte, *lastByte;                     \
    363              /*! FIFO of messages*/                          \
    364              EmSerialBufferQueueEntry fifo[qSize];           \
    365            } qName;
    366          
    367          
    368          // Allocate Appropriate TX Queue for port 0
    369          #if EMBER_SERIAL0_MODE == EMBER_SERIAL_FIFO
    370            DEFINE_FIFO_QUEUE(EMBER_SERIAL0_TX_QUEUE_SIZE,emSerial0TxQueue)
    371            #define EM_SERIAL0_TX_QUEUE_ADDR (&emSerial0TxQueue)
    372          #elif EMBER_SERIAL0_MODE == EMBER_SERIAL_BUFFER
    373            DEFINE_BUFFER_QUEUE(EMBER_SERIAL0_TX_QUEUE_SIZE,emSerial0TxQueue)
    374            #define EM_SERIAL0_TX_QUEUE_ADDR (&emSerial0TxQueue)
    375          #elif EMBER_SERIAL0_MODE == EMBER_SERIAL_UNUSED || \
    376                EMBER_SERIAL0_MODE == EMBER_SERIAL_LOWLEVEL
    377            #define EM_SERIAL0_TX_QUEUE_ADDR (NULL)
    378            #define EMBER_SERIAL0_TX_QUEUE_SIZE 0
    379            #define EMBER_SERIAL0_RX_QUEUE_SIZE 0
    380          #endif
    381          
    382          // Allocate Appropriate TX Queue for port 1
    383          #if EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO

   \                                 In section .bss, align 4
    384            DEFINE_FIFO_QUEUE(EMBER_SERIAL1_TX_QUEUE_SIZE,emSerial1TxQueue)
   \                     emSerial1TxQueue:
   \   00000000                      DS8 136
    385            #define EM_SERIAL1_TX_QUEUE_ADDR (&emSerial1TxQueue)
    386          #elif EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER
    387            DEFINE_BUFFER_QUEUE(EMBER_SERIAL1_TX_QUEUE_SIZE,emSerial1TxQueue)
    388            #define EM_SERIAL1_TX_QUEUE_ADDR (&emSerial1TxQueue)
    389          #elif EMBER_SERIAL1_MODE == EMBER_SERIAL_UNUSED || \
    390                EMBER_SERIAL1_MODE == EMBER_SERIAL_LOWLEVEL
    391            #define EM_SERIAL1_TX_QUEUE_ADDR (NULL)
    392            #define EMBER_SERIAL1_TX_QUEUE_SIZE 0
    393            #define EMBER_SERIAL1_RX_QUEUE_SIZE 0
    394          #endif
    395          
    396          // Allocate Appropriate TX Queue for port 2
    397          #if EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO
    398            DEFINE_FIFO_QUEUE(EMBER_SERIAL2_TX_QUEUE_SIZE,emSerial2TxQueue)
    399            #define EM_SERIAL2_TX_QUEUE_ADDR (&emSerial2TxQueue)
    400          #elif EMBER_SERIAL2_MODE == EMBER_SERIAL_BUFFER
    401            DEFINE_BUFFER_QUEUE(EMBER_SERIAL2_TX_QUEUE_SIZE,emSerial2TxQueue)
    402            #define EM_SERIAL2_TX_QUEUE_ADDR (&emSerial2TxQueue)
    403          #elif EMBER_SERIAL2_MODE == EMBER_SERIAL_UNUSED || \
    404                EMBER_SERIAL2_MODE == EMBER_SERIAL_LOWLEVEL
    405            #define EM_SERIAL2_TX_QUEUE_ADDR (NULL)
    406            #define EMBER_SERIAL2_TX_QUEUE_SIZE 0
    407            #define EMBER_SERIAL2_RX_QUEUE_SIZE 0
    408          #endif
    409          
    410          // Allocate Appropriate TX Queue for port 3
    411          #if EMBER_SERIAL3_MODE == EMBER_SERIAL_FIFO
    412            DEFINE_FIFO_QUEUE(EMBER_SERIAL3_TX_QUEUE_SIZE,emSerial3TxQueue)
    413            #define EM_SERIAL3_TX_QUEUE_ADDR (&emSerial3TxQueue)
    414          #elif EMBER_SERIAL3_MODE == EMBER_SERIAL_BUFFER
    415            DEFINE_BUFFER_QUEUE(EMBER_SERIAL3_TX_QUEUE_SIZE,emSerial3TxQueue)
    416            #define EM_SERIAL3_TX_QUEUE_ADDR (&emSerial3TxQueue)
    417          #elif EMBER_SERIAL3_MODE == EMBER_SERIAL_UNUSED || \
    418                EMBER_SERIAL3_MODE == EMBER_SERIAL_LOWLEVEL
    419            #define EM_SERIAL3_TX_QUEUE_ADDR (NULL)
    420            #define EMBER_SERIAL3_TX_QUEUE_SIZE 0
    421            #define EMBER_SERIAL3_RX_QUEUE_SIZE 0
    422          #endif
    423          
    424          // Allocate Appropriate TX Queue for port 4
    425          #if EMBER_SERIAL4_MODE == EMBER_SERIAL_FIFO
    426            DEFINE_FIFO_QUEUE(EMBER_SERIAL4_TX_QUEUE_SIZE,emSerial4TxQueue)
    427            #define EM_SERIAL4_TX_QUEUE_ADDR (&emSerial4TxQueue)
    428          #elif EMBER_SERIAL4_MODE == EMBER_SERIAL_BUFFER
    429            DEFINE_BUFFER_QUEUE(EMBER_SERIAL4_TX_QUEUE_SIZE,emSerial4TxQueue)
    430            #define EM_SERIAL4_TX_QUEUE_ADDR (&emSerial4TxQueue)
    431          #elif EMBER_SERIAL4_MODE == EMBER_SERIAL_UNUSED || \
    432                EMBER_SERIAL4_MODE == EMBER_SERIAL_LOWLEVEL
    433            #define EM_SERIAL4_TX_QUEUE_ADDR (NULL)
    434            #define EMBER_SERIAL4_TX_QUEUE_SIZE 0
    435            #define EMBER_SERIAL4_RX_QUEUE_SIZE 0
    436          #endif
    437          
    438          // Allocate RX Queues (Always FIFOs)
    439          #if EMBER_SERIAL0_MODE != EMBER_SERIAL_UNUSED
    440            DEFINE_FIFO_QUEUE(EMBER_SERIAL0_RX_QUEUE_SIZE,emSerial0RxQueue)
    441            #define EM_SERIAL0_RX_QUEUE_ADDR (&emSerial0RxQueue)
    442          #else
    443            #define EM_SERIAL0_RX_QUEUE_ADDR (NULL)
    444          #endif
    445          
    446          #if EMBER_SERIAL1_MODE != EMBER_SERIAL_UNUSED

   \                                 In section .bss, align 4
    447            DEFINE_FIFO_QUEUE(EMBER_SERIAL1_RX_QUEUE_SIZE,emSerial1RxQueue)
   \                     emSerial1RxQueue:
   \   00000000                      DS8 136
    448            #define EM_SERIAL1_RX_QUEUE_ADDR (&emSerial1RxQueue)
    449          #else
    450            #define EM_SERIAL1_RX_QUEUE_ADDR (NULL)
    451            #define emSerial1RxQueue (NULL)
    452          #endif
    453          
    454          #if EMBER_SERIAL2_MODE != EMBER_SERIAL_UNUSED
    455            DEFINE_FIFO_QUEUE(EMBER_SERIAL2_RX_QUEUE_SIZE,emSerial2RxQueue)
    456            #define EM_SERIAL2_RX_QUEUE_ADDR (&emSerial2RxQueue)
    457          #else
    458            #define EM_SERIAL2_RX_QUEUE_ADDR (NULL)
    459            #define emSerial2RxQueue (NULL)
    460          #endif
    461          
    462          #if EMBER_SERIAL3_MODE != EMBER_SERIAL_UNUSED
    463            DEFINE_FIFO_QUEUE(EMBER_SERIAL3_RX_QUEUE_SIZE,emSerial3RxQueue)
    464            #define EM_SERIAL3_RX_QUEUE_ADDR (&emSerial3RxQueue)
    465          #else
    466            #define EM_SERIAL3_RX_QUEUE_ADDR (NULL)
    467            #define emSerial3RxQueue (NULL)
    468          #endif
    469          
    470          #if EMBER_SERIAL4_MODE != EMBER_SERIAL_UNUSED
    471            DEFINE_FIFO_QUEUE(EMBER_SERIAL4_RX_QUEUE_SIZE,emSerial4RxQueue)
    472            #define EM_SERIAL4_RX_QUEUE_ADDR (&emSerial4RxQueue)
    473          #else
    474            #define EM_SERIAL4_RX_QUEUE_ADDR (NULL)
    475            #define emSerial4RxQueue (NULL)
    476          #endif
    477          
    478          //------------------------------------------------------
    479          // Easy access to data structures for a particular port
    480          
    481          // The FOR_EACH_PORT(CAST,PREFIX_,_SUFFIX) macro will expand in to something like:
    482          //    CAST(PREFIX_0_SUFFIX),
    483          //    CAST(PREFIX_1_SUFFIX)
    484          // with a line & number for each port of EM_NUM_SERIAL_PORTS
    485          
    486          // Data structure for referencing TX Queues
    487          //  (allows for different modes and queue sizes)
    488          void *emSerialTxQueues[EM_NUM_SERIAL_PORTS] =
    489            { FOR_EACH_PORT( (void *),EM_SERIAL,_TX_QUEUE_ADDR ) };
    490          

   \                                 In section .text, align 4, keep-with-next
    491          int16u PGM emSerialTxQueueSizes[EM_NUM_SERIAL_PORTS] =
   \                     emSerialTxQueueSizes:
   \   00000000   0x0000 0x0080      DC16 0, 128, 0, 0
   \              0x0000 0x0000
    492            { FOR_EACH_PORT( (int16u),EMBER_SERIAL,_TX_QUEUE_SIZE ) };
    493          

   \                                 In section .rodata, align 4, keep-with-next
    494          int16u PGM emSerialTxQueueMasks[EM_NUM_SERIAL_PORTS] =
   \                     emSerialTxQueueMasks:
   \   00000000   0xFFFF 0x007F      DC16 65535, 127, 65535, 65535
   \              0xFFFF 0xFFFF

   \                                 In section .data, align 4
   \                     emSerialTxQueues:
   \   00000000   0x00000000         DC32 0H, emSerial1TxQueue, 0H, 0H
   \              0x........   
   \              0x00000000   
   \              0x00000000   
    495            { FOR_EACH_PORT( (int16u),EMBER_SERIAL,_TX_QUEUE_SIZE-1 ) };
    496          
    497          // Data structure for referencing RX Queues
    498          //  (allows for different queue sizes)
    499          EmSerialFifoQueue *emSerialRxQueues[EM_NUM_SERIAL_PORTS] =
   \                     emSerialRxQueues:
   \   00000010   0x00000000         DC32 0H, emSerial1RxQueue, 0H, 0H
   \              0x........   
   \              0x00000000   
   \              0x00000000   
    500            { FOR_EACH_PORT( (EmSerialFifoQueue *),EM_SERIAL,_RX_QUEUE_ADDR ) };
    501          

   \                                 In section .rodata, align 4, keep-with-next
    502          int16u PGM emSerialRxQueueSizes[EM_NUM_SERIAL_PORTS] =
   \                     emSerialRxQueueSizes:
   \   00000000   0x0000 0x0080      DC16 0, 128, 0, 0
   \              0x0000 0x0000
    503            { FOR_EACH_PORT( (int16u),EMBER_SERIAL,_RX_QUEUE_SIZE ) };
    504          
    505          // In-flash data structure for determined port mode

   \                                 In section .text, align 4, keep-with-next
    506          int8u PGM emSerialPortModes[EM_NUM_SERIAL_PORTS] =
   \                     emSerialPortModes:
   \   00000000   0x00 0x01          DC8 0, 1, 0, 0
   \              0x00 0x00    
    507            { FOR_EACH_PORT( (int8u),EMBER_SERIAL,_MODE ) };
    508          
    509          //Compatibility code for the AVR Atmega
    510          //If an AVR Atmega is used, then emSerialTx(/Rx)QueueWraps map to
    511          //emSerialTx(/Rx)QueueMasks, otherwise they map to emSerialTx(/Rx)QueueSizes
    512          #ifdef AVR_ATMEGA
    513          int8u PGM emSerialTxQueueWraps[EM_NUM_SERIAL_PORTS] =
    514            { FOR_EACH_PORT( (int8u), EMBER_SERIAL,_TX_QUEUE_SIZE-1 ) };
    515          int8u PGM emSerialRxQueueWraps[EM_NUM_SERIAL_PORTS] =
    516            { FOR_EACH_PORT( (int8u), EMBER_SERIAL,_RX_QUEUE_SIZE-1 ) };
    517          #else

   \                                 In section .text, align 4, keep-with-next
    518          int16u PGM emSerialTxQueueWraps[EM_NUM_SERIAL_PORTS] =
   \                     emSerialTxQueueWraps:
   \   00000000   0x0000 0x0080      DC16 0, 128, 0, 0
   \              0x0000 0x0000
    519            { FOR_EACH_PORT( (int16u), EMBER_SERIAL,_TX_QUEUE_SIZE ) };

   \                                 In section .text, align 4, keep-with-next
    520          int16u PGM emSerialRxQueueWraps[EM_NUM_SERIAL_PORTS] =
   \                     emSerialRxQueueWraps:
   \   00000000   0x0000 0x0080      DC16 0, 128, 0, 0
   \              0x0000 0x0000
    521            { FOR_EACH_PORT( (int16u), EMBER_SERIAL,_RX_QUEUE_SIZE ) };
    522          #endif
    523          
    524          #ifdef EM_ENABLE_SERIAL_BLOCKING
    525          // In-flash data structure for blocking mode

   \                                 In section .text, align 4, keep-with-next
    526          boolean PGM emSerialBlocking[EM_NUM_SERIAL_PORTS] =
   \                     emSerialBlocking:
   \   00000000   0x00 0x01          DC8 0, 1, 0, 0
   \              0x00 0x00    
    527            { FOR_EACH_PORT( (boolean),EM_SERIAL,_BLOCKSTATE ) };
    528          #endif
    529          

   \                                 In section .bss, align 4
    530          int8u emSerialRxError[EM_NUM_SERIAL_PORTS] = {EMBER_SUCCESS,};
   \                     emSerialRxError:
   \   00000000                      DS8 4
    531          int16u emSerialRxErrorIndex[EM_NUM_SERIAL_PORTS] = {0,};
   \                     emSerialRxErrorIndex:
   \   00000004                      DS8 8
    532          #endif //EMBER_SERIAL_USE_STDIO
    533          
    534          
    535          //------------------------------------------------------
    536          // Buffered Serial utility APIs
    537          
    538          #ifdef EM_ENABLE_SERIAL_BUFFER
    539          // always executed in interrupt context
    540          void emSerialBufferNextMessageIsr(EmSerialBufferQueue *q)
    541          {
    542            EmSerialBufferQueueEntry *e = &q->fifo[q->tail];
    543          
    544            q->currentBuffer = e->buffer;
    545            q->nextByte = emberLinkedBufferContents(q->currentBuffer) + e->startIndex;
    546            if((e->length + e->startIndex) > PACKET_BUFFER_SIZE) {
    547              q->lastByte = q->nextByte + ((PACKET_BUFFER_SIZE-1) - e->startIndex);
    548              e->length -= PACKET_BUFFER_SIZE - e->startIndex;
    549            } else {
    550              q->lastByte = q->nextByte + e->length - 1;
    551              e->length = 0;
    552            }
    553          }
    554          #endif
    555          
    556          #ifdef EM_ENABLE_SERIAL_BUFFER
    557          // always executed in interrupt context
    558          void emSerialBufferNextBlockIsr(EmSerialBufferQueue *q, int8u port)
    559          {
    560            EmSerialBufferQueueEntry *e = &q->fifo[q->tail];
    561          
    562            if(e->length != 0) {
    563              q->currentBuffer = emberStackBufferLink(q->currentBuffer);
    564              q->nextByte = emberLinkedBufferContents(q->currentBuffer);
    565              if(e->length > PACKET_BUFFER_SIZE) {
    566                q->lastByte = q->nextByte + 31;
    567                e->length -= PACKET_BUFFER_SIZE;
    568              } else {
    569                q->lastByte = q->nextByte + e->length - 1;
    570                e->length = 0;
    571              }
    572            } else {
    573              #ifdef AVR_ATMEGA
    574                //If we are using an AVR host, non power-of-2 queue sizes are NOT
    575                //supported and therefore we use a mask
    576                q->tail = ((q->tail+1) & emSerialTxQueueMasks[port]);
    577              #else // AVR_ATMEGA
    578                //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
    579                //supported and therefore we use a mod with the queue size
    580                q->tail = ((q->tail+1) % emSerialTxQueueSizes[port]);
    581              #endif // !AVR_ATMEGA
    582              q->dead++;
    583              q->used--;
    584              if(q->used)
    585                emSerialBufferNextMessageIsr(q);
    586              else
    587                q->nextByte = NULL;
    588            }
    589          }
    590          #endif
    591          
    592          //------------------------------------------------------
    593          // Serial initialization
    594          

   \                                 In section .text, align 2, keep-with-next
    595          EmberStatus emberSerialInit(int8u port,
    596                                      SerialBaudRate rate,
    597                                      SerialParity parity,
    598                                      int8u stopBits)
    599          {
   \                     emberSerialInit: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4691             MOV      R9,R2
   \   0000000A   0x469A             MOV      R10,R3
    600          #ifdef EMBER_SERIAL_USE_STDIO
    601            //When using stdio, bypass the serial library initialization
    602            //and just initialize the low level UART driver.
    603            return halInternalUartInit(port, rate, parity, stopBits);
    604          #else //EMBER_SERIAL_USE_STDIO
    605            EmSerialFifoQueue *rq;
    606          
    607            if (emberSerialUnused(port)) return EMBER_SERIAL_INVALID_PORT;
   \   0000000C   0x.... 0x....      BL       emberSerialUnused
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xBF01             ITTTT    EQ 
    608          
    609            switch(emSerialPortModes[port]) {
   \   00000014   0x4625             MOVEQ    R5,R4
   \   00000016   0x.... 0x....      ADREQ.W  R0,emSerialPortModes
   \   0000001A   0x5C28             LDRBEQ   R0,[R5, R0]
   \   0000001C   0x2801             CMPEQ    R0,#+1
   \   0000001E   0xD123             BNE.N    ??emberSerialInit_0
    610          #ifdef EM_ENABLE_SERIAL_FIFO
    611            case EMBER_SERIAL_FIFO: {
    612              EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000020   0x.... 0x....      LDR.W    R6,??DataTable18_1
   \   00000024   0xF856 0x7025      LDR      R7,[R6, R5, LSL #+2]
    613              ATOMIC_LITE(
    614                q->used = 0;
    615                q->head = 0;
    616                q->tail = 0;
    617              )
   \   00000028   0x.... 0x....      BL       _disableBasePri
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x80B9             STRH     R1,[R7, #+4]
   \   00000030   0x8039             STRH     R1,[R7, #+0]
   \   00000032   0x8079             STRH     R1,[R7, #+2]
   \   00000034   0x.... 0x....      BL       _writeBasePri
    618              break; }
    619          #endif
    620          #ifdef EM_ENABLE_SERIAL_BUFFER
    621            case EMBER_SERIAL_BUFFER: {
    622              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
    623              ATOMIC_LITE(
    624                q->used = 0;
    625                q->head = 0;
    626                q->tail = 0;
    627                q->dead = 0;
    628                q->currentBuffer = EMBER_NULL_MESSAGE_BUFFER;
    629                q->nextByte = NULL;
    630                q->lastByte = NULL;
    631              )
    632              break; }
    633          #endif
    634            default:
    635              return EMBER_SERIAL_INVALID_PORT;
    636              //break;  //statement is unreachable
    637            }
    638          
    639            rq = emSerialRxQueues[port];
   \   00000038   0xEB06 0x0085      ADD      R0,R6,R5, LSL #+2
   \   0000003C   0x6906             LDR      R6,[R0, #+16]
    640            ATOMIC_LITE(
    641              rq->used = 0;
    642              rq->head = 0;
    643              rq->tail = 0;
    644              emSerialRxError[port] = EMBER_SUCCESS;
    645            )
   \   0000003E   0x.... 0x....      BL       _disableBasePri
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable18_2
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x80B1             STRH     R1,[R6, #+4]
   \   0000004A   0x8031             STRH     R1,[R6, #+0]
   \   0000004C   0x8071             STRH     R1,[R6, #+2]
   \   0000004E   0x54A9             STRB     R1,[R5, R2]
   \   00000050   0x.... 0x....      BL       _writeBasePri
    646          
    647            halInternalRestartUart();
   \   00000054   0x.... 0x....      BL       halInternalRestartUart
    648          
    649            return halInternalUartInit(port, rate, parity, stopBits);
   \   00000058   0x4653             MOV      R3,R10
   \   0000005A   0x464A             MOV      R2,R9
   \   0000005C   0x4641             MOV      R1,R8
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   00000064   0x.... 0x....      B.W      halInternalUartInit
   \                     ??emberSerialInit_0: (+1)
   \   00000068   0x2021             MOVS     R0,#+33
   \   0000006A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    650          #endif //EMBER_SERIAL_USE_STDIO
    651          }
    652          
    653          //------------------------------------------------------
    654          // Serial Input
    655          
    656          // returns # bytes available for reading

   \                                 In section .text, align 2, keep-with-next
    657          int16u emberSerialReadAvailable(int8u port)
    658          {
   \                     emberSerialReadAvailable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    659          #ifdef EMBER_SERIAL_USE_STDIO
    660            return halInternalPrintfReadAvailable();
    661          #else //EMBER_SERIAL_USE_STDIO
    662            halInternalUartRxPump(port);
   \   00000004   0x.... 0x....      BL       halInternalUartRxPump
    663            return emSerialRxQueues[port]->used;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000000C   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000010   0x6900             LDR      R0,[R0, #+16]
   \   00000012   0x8880             LDRH     R0,[R0, #+4]
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    664          #endif //EMBER_SERIAL_USE_STDIO
    665          }
    666          

   \                                 In section .text, align 2, keep-with-next
    667          EmberStatus emberSerialReadByte(int8u port, int8u *dataByte)
    668          {
   \                     emberSerialReadByte: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
    669          #ifdef EMBER_SERIAL_USE_STDIO
    670            int ch=-1;
    671            ch = getchar();
    672            if(ch<0) {
    673              return EMBER_SERIAL_RX_EMPTY;
    674            }
    675            *dataByte = (int8u)ch;
    676            return EMBER_SUCCESS;
    677          #else //EMBER_SERIAL_USE_STDIO
    678            int8u retval;
    679            EmSerialFifoQueue *q = emSerialRxQueues[port];
   \   00000006   0x464C             MOV      R4,R9
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000000C   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000010   0x4688             MOV      R8,R1
   \   00000012   0x6906             LDR      R6,[R0, #+16]
    680          
    681            if (emberSerialUnused(port)) {
   \   00000014   0x4648             MOV      R0,R9
   \   00000016   0x.... 0x....      BL       emberSerialUnused
   \   0000001A   0xB108             CBZ.N    R0,??emberSerialReadByte_0
    682              return EMBER_ERR_FATAL;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE037             B.N      ??emberSerialReadByte_1
    683            }
    684          
    685            if(emSerialRxError[port] != EMBER_SUCCESS) {
   \                     ??emberSerialReadByte_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R5,??DataTable18_2
   \   00000024   0x5D60             LDRB     R0,[R4, R5]
   \   00000026   0xEB05 0x0744      ADD      R7,R5,R4, LSL #+1
   \   0000002A   0xB160             CBZ.N    R0,??emberSerialReadByte_2
    686              if(emSerialRxErrorIndex[port] == q->tail) {
   \   0000002C   0x88B8             LDRH     R0,[R7, #+4]
   \   0000002E   0x8871             LDRH     R1,[R6, #+2]
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD108             BNE.N    ??emberSerialReadByte_2
    687                ATOMIC_LITE(
    688                  retval = emSerialRxError[port];
    689                  emSerialRxError[port] = EMBER_SUCCESS;
    690                )
   \   00000034   0x.... 0x....      BL       _disableBasePri
   \   00000038   0x5D66             LDRB     R6,[R4, R5]
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x5561             STRB     R1,[R4, R5]
   \   0000003E   0x.... 0x....      BL       _writeBasePri
    691                return retval;
   \   00000042   0x4630             MOV      R0,R6
   \   00000044   0xE024             B.N      ??emberSerialReadByte_1
    692              }
    693            }
    694          
    695            halInternalUartRxPump(port);
   \                     ??emberSerialReadByte_2: (+1)
   \   00000046   0x4648             MOV      R0,R9
   \   00000048   0x.... 0x....      BL       halInternalUartRxPump
    696            halInternalUartFlowControl(port);
    697          
    698            if(q->used > 0) {
   \   0000004C   0x88B0             LDRH     R0,[R6, #+4]
   \   0000004E   0xB1F0             CBZ.N    R0,??emberSerialReadByte_3
    699              ATOMIC_LITE(
    700                *dataByte = FIFO_DEQUEUE(q,emSerialRxQueueWraps[port]);
    701              )
   \   00000050   0x.... 0x....      BL       _disableBasePri
   \   00000054   0x8871             LDRH     R1,[R6, #+2]
   \   00000056   0x.... 0x....      ADR.W    R2,emSerialRxQueueWraps
   \   0000005A   0x1989             ADDS     R1,R1,R6
   \   0000005C   0x7989             LDRB     R1,[R1, #+6]
   \   0000005E   0xF888 0x1000      STRB     R1,[R8, #+0]
   \   00000062   0xF64F 0x78FF      MOVW     R8,#+65535
   \   00000066   0x8871             LDRH     R1,[R6, #+2]
   \   00000068   0xF832 0x2014      LDRH     R2,[R2, R4, LSL #+1]
   \   0000006C   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000070   0x8071             STRH     R1,[R6, #+2]
   \   00000072   0x88B1             LDRH     R1,[R6, #+4]
   \   00000074   0x4441             ADD      R1,R8,R1
   \   00000076   0x80B1             STRH     R1,[R6, #+4]
   \   00000078   0x.... 0x....      BL       _writeBasePri
    702              if(emSerialRxError[port] != EMBER_SUCCESS) {
   \   0000007C   0x5D60             LDRB     R0,[R4, R5]
   \   0000007E   0xB120             CBZ.N    R0,??emberSerialReadByte_4
    703                //This index is used when there is an error when the FIFO is full.
    704                if(emSerialRxErrorIndex[port] == RX_FIFO_FULL) {
   \   00000080   0x88B8             LDRH     R0,[R7, #+4]
   \   00000082   0x4540             CMP      R0,R8
   \   00000084   0xBF04             ITT      EQ 
    705                  //q->tail has advanced by one, we can now mark the head as the error
    706                  emSerialRxErrorIndex[port] = q->head;
   \   00000086   0x8830             LDRHEQ   R0,[R6, #+0]
   \   00000088   0x80B8             STRHEQ   R0,[R7, #+4]
    707                }
    708              }
    709              return EMBER_SUCCESS;
   \                     ??emberSerialReadByte_4: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xE000             B.N      ??emberSerialReadByte_1
    710            } else {
    711              return EMBER_SERIAL_RX_EMPTY;
   \                     ??emberSerialReadByte_3: (+1)
   \   0000008E   0x2026             MOVS     R0,#+38
   \                     ??emberSerialReadByte_1: (+1)
   \   00000090   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    712            }
    713          #endif //EMBER_SERIAL_USE_STDIO
    714          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x1C49             ADDS     R1,R1,#+1
   \   00000002   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \   00000006   0xFB02 0x1113      MLS      R1,R2,R3,R1
   \   0000000A   0x4770             BX       LR
    715          

   \                                 In section .text, align 2, keep-with-next
    716          EmberStatus emberSerialReadData(int8u port,
    717                                          int8u *data,
    718                                          int16u length,
    719                                          int16u *bytesRead)
    720          {
   \                     emberSerialReadData: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461F             MOV      R7,R3
    721            int16u bytesReadInternal = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0xE001             B.N      ??emberSerialReadData_0
    722            EmberStatus status;
    723          
    724            while (bytesReadInternal < length) {
    725              status = emberSerialReadByte(port, data);
    726          
    727              switch (status) {
    728                case EMBER_SUCCESS:
    729                  ++data;
   \                     ??emberSerialReadData_1: (+1)
   \   00000010   0x1C6D             ADDS     R5,R5,#+1
    730                  ++bytesReadInternal;
   \   00000012   0x1C76             ADDS     R6,R6,#+1
    731                  break;
   \                     ??emberSerialReadData_0: (+1)
   \   00000014   0xB2B6             UXTH     R6,R6
   \   00000016   0x4546             CMP      R6,R8
   \   00000018   0xD20A             BCS.N    ??emberSerialReadData_2
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       emberSerialReadByte
   \   00000022   0x0001             MOVS     R1,R0
   \   00000024   0xD0F4             BEQ.N    ??emberSerialReadData_1
   \   00000026   0x2826             CMP      R0,#+38
   \   00000028   0xD0F4             BEQ.N    ??emberSerialReadData_0
    732          
    733                case EMBER_SERIAL_RX_EMPTY:
    734                  // empty queue is not an error for us, we just want to keep waiting
    735                  break;
    736          
    737                default:
    738                  // only store number of bytes read if the caller provided a non-NULL pointer
    739                  if (bytesRead) {
   \   0000002A   0xB127             CBZ.N    R7,??emberSerialReadData_3
    740                    *bytesRead = bytesReadInternal;
   \   0000002C   0x803E             STRH     R6,[R7, #+0]
    741                  }
    742                  return status;
   \   0000002E   0xE002             B.N      ??emberSerialReadData_3
    743              }
    744            }
    745          
    746            // only store number of bytes read if the caller provided a non-NULL pointer
    747            if (bytesRead) {
   \                     ??emberSerialReadData_2: (+1)
   \   00000030   0xB107             CBZ.N    R7,??emberSerialReadData_4
    748              *bytesRead = bytesReadInternal;
   \   00000032   0x803E             STRH     R6,[R7, #+0]
    749            }
    750          
    751            return EMBER_SUCCESS;
   \                     ??emberSerialReadData_4: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??emberSerialReadData_3: (+1)
   \   00000036   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    752          
    753          }
    754          
    755          #ifndef EMBER_TEST

   \                                 In section .text, align 2, keep-with-next
    756          EmberStatus emberSerialReadDataTimeout(int8u port,
    757                                                 int8u *data,
    758                                                 int16u length,
    759                                                 int16u *bytesRead,
    760                                                 int16u firstByteTimeout,
    761                                                 int16u subsequentByteTimeout)
    762          {
   \                     emberSerialReadDataTimeout: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    763            int16u bytesReadInternal = 0;
    764            EmberStatus status;
    765            int16u timeout = firstByteTimeout;
   \   00000004   0x9D0A             LDR      R5,[SP, #+40]
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4692             MOV      R10,R2
   \   0000000C   0x461E             MOV      R6,R3
   \   0000000E   0x2700             MOVS     R7,#+0
    766            int16u startTime = halCommonGetInt16uMillisecondTick();
   \   00000010   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000014   0x9C0B             LDR      R4,[SP, #+44]
   \   00000016   0x4683             MOV      R11,R0
   \   00000018   0xE006             B.N      ??emberSerialReadDataTimeout_0
    767          
    768            // loop until we read the max number of bytes or the timeout elapses
    769            while (bytesReadInternal < length
    770                   && elapsedTimeInt16u(startTime,halCommonGetInt16uMillisecondTick()) < timeout) {
    771              status = emberSerialReadByte(port, data);
    772          
    773              switch (status) {
    774                case EMBER_SUCCESS:
    775                  ++data;
   \                     ??emberSerialReadDataTimeout_1: (+1)
   \   0000001A   0xF109 0x0901      ADD      R9,R9,#+1
    776                  ++bytesReadInternal;
   \   0000001E   0x1C7F             ADDS     R7,R7,#+1
    777                  // reset timer and timeout for next character
    778                  startTime = halCommonGetInt16uMillisecondTick();
   \   00000020   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000024   0x4683             MOV      R11,R0
    779                  timeout = subsequentByteTimeout;
   \   00000026   0x4625             MOV      R5,R4
    780                  break;
   \                     ??emberSerialReadDataTimeout_0: (+1)
   \   00000028   0xB2BF             UXTH     R7,R7
   \   0000002A   0x4557             CMP      R7,R10
   \   0000002C   0xD211             BCS.N    ??emberSerialReadDataTimeout_2
   \   0000002E   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000032   0xEBA0 0x000B      SUB      R0,R0,R11
   \   00000036   0xB280             UXTH     R0,R0
   \   00000038   0x42A8             CMP      R0,R5
   \   0000003A   0xD20A             BCS.N    ??emberSerialReadDataTimeout_2
   \   0000003C   0x4649             MOV      R1,R9
   \   0000003E   0x4640             MOV      R0,R8
   \   00000040   0x.... 0x....      BL       emberSerialReadByte
   \   00000044   0x0001             MOVS     R1,R0
   \   00000046   0xD0E8             BEQ.N    ??emberSerialReadDataTimeout_1
   \   00000048   0x2826             CMP      R0,#+38
   \   0000004A   0xD0ED             BEQ.N    ??emberSerialReadDataTimeout_0
    781          
    782                case EMBER_SERIAL_RX_EMPTY:
    783                  // empty queue is not an error for us, we just want to keep waiting
    784                  break;
    785          
    786                default:
    787                  // only store number of bytes read if the caller provided a non-NULL pointer
    788                  if (bytesRead) {
   \   0000004C   0xB13E             CBZ.N    R6,??emberSerialReadDataTimeout_3
    789                    *bytesRead = bytesReadInternal;
   \   0000004E   0x8037             STRH     R7,[R6, #+0]
    790                  }
    791                  return status;
   \   00000050   0xE005             B.N      ??emberSerialReadDataTimeout_3
    792              }
    793            }
    794          
    795            // only store number of bytes read if the caller provided a non-NULL pointer
    796            if (bytesRead) {
   \                     ??emberSerialReadDataTimeout_2: (+1)
   \   00000052   0xB106             CBZ.N    R6,??emberSerialReadDataTimeout_4
    797              *bytesRead = bytesReadInternal;
   \   00000054   0x8037             STRH     R7,[R6, #+0]
    798            }
    799          
    800            return bytesReadInternal == length ? EMBER_SUCCESS : EMBER_SERIAL_RX_EMPTY;
   \                     ??emberSerialReadDataTimeout_4: (+1)
   \   00000056   0x4557             CMP      R7,R10
   \   00000058   0xBF0C             ITE      EQ 
   \   0000005A   0x2000             MOVEQ    R0,#+0
   \   0000005C   0x2026             MOVNE    R0,#+38
   \                     ??emberSerialReadDataTimeout_3: (+1)
   \   0000005E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    801          }
    802          #endif // EMBER_TEST
    803          

   \                                 In section .text, align 2, keep-with-next
    804          EmberStatus emberSerialReadPartialLine(int8u port, char *data, int8u max, int8u * index)
    805          {
   \                     emberSerialReadPartialLine: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x461F             MOV      R7,R3
   \   00000004   0x4604             MOV      R4,R0
    806            EmberStatus err;
    807            int8u ch;
    808          
    809            if (((*index) == 0) || ((*index) >= max))
   \   00000006   0x7838             LDRB     R0,[R7, #+0]
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0xB108             CBZ.N    R0,??emberSerialReadPartialLine_0
   \   0000000E   0x42B0             CMP      R0,R6
   \   00000010   0xD308             BCC.N    ??emberSerialReadPartialLine_1
    810              data[0] = '\0';
   \                     ??emberSerialReadPartialLine_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7028             STRB     R0,[R5, #+0]
   \   00000016   0xE005             B.N      ??emberSerialReadPartialLine_1
    811          
    812            for (;;) {
    813              err = emberSerialReadByte(port, &ch);
    814          
    815              // no new serial port char?, keep looping
    816              if (err) return err;
    817          
    818              // handle bogus characters
    819              if ( ch > 0x7F ) continue;
    820          
    821              // handle leading newline - fogBUGZ # 584
    822              if (((*index) == 0) &&
    823                  ((ch == '\n') || (ch == 0))) continue;
    824          
    825              // Drop the CR, or NULL that is part of EOL sequence.
    826              if ((*index) >= max) {
    827                *index = 0;
    828                if ((ch == '\r') || (ch == 0)) continue;
    829              }
    830          
    831              // handle backspace
    832              if ( ch == 0x8 || ch == 0x7F ) {
    833                if ( (*index) > 0 ) {
    834                  // delete the last character from our string
    835                  (*index)--;
    836                  data[*index] = '\0';
    837                  // echo backspace
    838                  emberSerialWriteString(port, "\b \b");
    839                }
    840                // don't add or process this character
    841                continue;
    842              }
    843          
    844              //if the string is about to overflow, fake in a CR
    845              if ( (*index) + 2 > max ) {
    846                ch = '\r';
    847              }
    848          
    849              emberSerialWriteByte(port, ch); // term char echo
    850          
    851              //upcase that char
    852              if ( ch>='a' && ch<='z') ch = ch - ('a'-'A');
    853          
    854              // build a string until we press enter
    855              if ( ( ch == '\r' ) || ( ch == '\n' ) ) {
    856                data[*index] = '\0';
    857          
    858                if (ch == '\r') {
    859                  emberSerialWriteByte(port, '\n'); // "append" LF
    860                  *index = 0;                       // Reset for next line; \n next
    861                } else {
    862                  emberSerialWriteByte(port, '\r'); // "append" CR
    863                  *index = max;                     // Reset for next line; \r,\0 next
    864                }
    865          
    866                return EMBER_SUCCESS;
    867              }
    868          
    869              data[(*index)++] = ch;
   \                     ??emberSerialReadPartialLine_2: (+1)
   \   00000018   0x7838             LDRB     R0,[R7, #+0]
   \   0000001A   0x1C41             ADDS     R1,R0,#+1
   \   0000001C   0x7039             STRB     R1,[R7, #+0]
   \   0000001E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000022   0x5541             STRB     R1,[R0, R5]
   \                     ??emberSerialReadPartialLine_1: (+1)
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       emberSerialReadByte
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD155             BNE.N    ??emberSerialReadPartialLine_3
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0x2880             CMP      R0,#+128
   \   00000036   0xDAF5             BGE.N    ??emberSerialReadPartialLine_1
   \   00000038   0x7839             LDRB     R1,[R7, #+0]
   \   0000003A   0xB919             CBNZ.N   R1,??emberSerialReadPartialLine_4
   \   0000003C   0x280A             CMP      R0,#+10
   \   0000003E   0xBF18             IT       NE 
   \   00000040   0x2800             CMPNE    R0,#+0
   \   00000042   0xD0EF             BEQ.N    ??emberSerialReadPartialLine_1
   \                     ??emberSerialReadPartialLine_4: (+1)
   \   00000044   0x42B1             CMP      R1,R6
   \   00000046   0xD307             BCC.N    ??emberSerialReadPartialLine_5
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x7038             STRB     R0,[R7, #+0]
   \   0000004C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000050   0x280D             CMP      R0,#+13
   \   00000052   0xBF18             IT       NE 
   \   00000054   0x2800             CMPNE    R0,#+0
   \   00000056   0xD0E5             BEQ.N    ??emberSerialReadPartialLine_1
   \                     ??emberSerialReadPartialLine_5: (+1)
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0x2808             CMP      R0,#+8
   \   0000005E   0xBF18             IT       NE 
   \   00000060   0x287F             CMPNE    R0,#+127
   \   00000062   0xD10C             BNE.N    ??emberSerialReadPartialLine_6
   \   00000064   0x7838             LDRB     R0,[R7, #+0]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD0DC             BEQ.N    ??emberSerialReadPartialLine_1
   \   0000006A   0x1E40             SUBS     R0,R0,#+1
   \   0000006C   0x7038             STRB     R0,[R7, #+0]
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0xB2C0             UXTB     R0,R0
   \   00000072   0x5541             STRB     R1,[R0, R5]
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x....             ADR.N    R1,??DataTable18  ;; "\b \b"
   \   00000078   0x.... 0x....      BL       emberSerialWriteString
   \   0000007C   0xE7D2             B.N      ??emberSerialReadPartialLine_1
   \                     ??emberSerialReadPartialLine_6: (+1)
   \   0000007E   0x7838             LDRB     R0,[R7, #+0]
   \   00000080   0x1C80             ADDS     R0,R0,#+2
   \   00000082   0x4286             CMP      R6,R0
   \   00000084   0xBFBC             ITT      LT 
   \   00000086   0x200D             MOVLT    R0,#+13
   \   00000088   0xF88D 0x0000      STRBLT   R0,[SP, #+0]
   \   0000008C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       emberSerialWriteByte
   \   00000096   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009A   0x3861             SUBS     R0,R0,#+97
   \   0000009C   0x281A             CMP      R0,#+26
   \   0000009E   0xD204             BCS.N    ??emberSerialReadPartialLine_7
   \   000000A0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A4   0x3820             SUBS     R0,R0,#+32
   \   000000A6   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \                     ??emberSerialReadPartialLine_7: (+1)
   \   000000AA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000AE   0x280D             CMP      R0,#+13
   \   000000B0   0xBF18             IT       NE 
   \   000000B2   0x280A             CMPNE    R0,#+10
   \   000000B4   0xD1B0             BNE.N    ??emberSerialReadPartialLine_2
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x7839             LDRB     R1,[R7, #+0]
   \   000000BA   0x5548             STRB     R0,[R1, R5]
   \   000000BC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000C0   0x280D             CMP      R0,#+13
   \   000000C2   0xD105             BNE.N    ??emberSerialReadPartialLine_8
   \   000000C4   0x210A             MOVS     R1,#+10
   \   000000C6   0x4620             MOV      R0,R4
   \   000000C8   0x.... 0x....      BL       emberSerialWriteByte
   \   000000CC   0x2600             MOVS     R6,#+0
   \   000000CE   0xE003             B.N      ??emberSerialReadPartialLine_9
   \                     ??emberSerialReadPartialLine_8: (+1)
   \   000000D0   0x210D             MOVS     R1,#+13
   \   000000D2   0x4620             MOV      R0,R4
   \   000000D4   0x.... 0x....      BL       emberSerialWriteByte
   \                     ??emberSerialReadPartialLine_9: (+1)
   \   000000D8   0x703E             STRB     R6,[R7, #+0]
   \   000000DA   0x2000             MOVS     R0,#+0
   \                     ??emberSerialReadPartialLine_3: (+1)
   \   000000DC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    870            }
    871          }
    872          

   \                                 In section .text, align 2, keep-with-next
    873          EmberStatus emberSerialReadLine(int8u port, char *data, int8u max)
    874          {
   \                     emberSerialReadLine: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    875            int8u index=0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000010   0xE001             B.N      ??emberSerialReadLine_0
    876          
    877            while(emberSerialReadPartialLine(port, data, max, &index) != EMBER_SUCCESS) {
    878              halResetWatchdog();
   \                     ??emberSerialReadLine_1: (+1)
   \   00000012   0x.... 0x....      BL       halInternalResetWatchDog
    879            }
   \                     ??emberSerialReadLine_0: (+1)
   \   00000016   0xAB00             ADD      R3,SP,#+0
   \   00000018   0x4632             MOV      R2,R6
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       emberSerialReadPartialLine
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1F5             BNE.N    ??emberSerialReadLine_1
    880            return EMBER_SUCCESS;
   \   00000026   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    881          }
    882          
    883          //------------------------------------------------------
    884          // Serial Output
    885          
    886          // returns # bytes (if fifo mode)/messages (if buffer mode) that can be written

   \                                 In section .text, align 2, keep-with-next
    887          int16u emberSerialWriteAvailable(int8u port)
    888          {
    889          #ifdef EMBER_SERIAL_USE_STDIO
    890            return halInternalPrintfWriteAvailable();
    891          #else //EMBER_SERIAL_USE_STDIO
    892            switch(emSerialPortModes[port]) {
   \                     emberSerialWriteAvailable: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,emSerialPortModes
   \   00000004   0x5C41             LDRB     R1,[R0, R1]
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD10A             BNE.N    ??emberSerialWriteAvailable_0
    893          #ifdef EM_ENABLE_SERIAL_FIFO
    894            case EMBER_SERIAL_FIFO:
    895              return emSerialTxQueueSizes[port] -
    896                ((EmSerialFifoQueue*)emSerialTxQueues[port])->used;
   \   0000000A   0x.... 0x....      ADR.W    R1,emSerialTxQueueSizes
   \   0000000E   0x....             LDR.N    R2,??DataTable18_1
   \   00000010   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
   \   00000014   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   00000018   0x8880             LDRH     R0,[R0, #+4]
   \   0000001A   0x1A08             SUBS     R0,R1,R0
   \   0000001C   0xB280             UXTH     R0,R0
   \   0000001E   0x4770             BX       LR
    897          #endif
    898          #ifdef EM_ENABLE_SERIAL_BUFFER
    899            case EMBER_SERIAL_BUFFER: {
    900              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
    901              int8u elementsUsed;
    902              int8u elementsDead;
    903              ATOMIC_LITE( // To clarify the volatile access.
    904                     elementsUsed = q->used;
    905                     elementsDead = q->dead;
    906                     )
    907              return emSerialTxQueueSizes[port] - (elementsUsed + elementsDead);
    908              }
    909          #endif
    910            default: {
    911            }
    912            }
    913            return 0;
   \                     ??emberSerialWriteAvailable_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4770             BX       LR               ;; return
    914          #endif //EMBER_SERIAL_USE_STDIO
    915          }
    916          

   \                                 In section .text, align 2, keep-with-next
    917          int16u emberSerialWriteUsed(int8u port)
    918          {
   \                     emberSerialWriteUsed: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    919          #ifdef EMBER_SERIAL_USE_STDIO
    920            return 0;
    921          #else
    922            return emSerialTxQueueSizes[port] - emberSerialWriteAvailable(port);
   \   00000004   0x.... 0x....      BL       emberSerialWriteAvailable
   \   00000008   0x.... 0x....      ADR.W    R1,emSerialTxQueueSizes
   \   0000000C   0xF831 0x1014      LDRH     R1,[R1, R4, LSL #+1]
   \   00000010   0x1A08             SUBS     R0,R1,R0
   \   00000012   0xB280             UXTH     R0,R0
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    923          #endif //EMBER_SERIAL_USE_STDIO
    924          }
    925          

   \                                 In section .text, align 2, keep-with-next
    926          EmberStatus emberSerialWriteByte(int8u port, int8u dataByte)
    927          {
   \                     emberSerialWriteByte: (+1)
   \   00000000   0xB502             PUSH     {R1,LR}
    928            return emberSerialWriteData(port, &dataByte, 1);
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x.... 0x....      BL       emberSerialWriteData
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    929          }
    930          
    931          #ifndef EMBER_SERIAL_USE_STDIO
    932          #ifdef EM_ENABLE_SERIAL_FIFO

   \                                 In section .text, align 2, keep-with-next
    933          static boolean getOutputFifoSpace(EmSerialFifoQueue *q,
    934                                            int8u port,
    935                                            int16u extraByteCount)
    936          {
    937            return (q->used < emSerialTxQueueSizes[port] - extraByteCount);
   \                     getOutputFifoSpace: (+1)
   \   00000000   0x8880             LDRH     R0,[R0, #+4]
   \   00000002   0x.... 0x....      ADR.W    R3,emSerialTxQueueSizes
   \   00000006   0xF833 0x1011      LDRH     R1,[R3, R1, LSL #+1]
   \   0000000A   0x1A89             SUBS     R1,R1,R2
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xDA01             BGE.N    ??getOutputFifoSpace_0
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
   \                     ??getOutputFifoSpace_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
    938          }
    939          #endif
    940          #endif //EMBER_SERIAL_USE_STDIO
    941          

   \                                 In section .text, align 2, keep-with-next
    942          EmberStatus emberSerialWriteString(int8u port, PGM_P string)
    943          {
   \                     emberSerialWriteString: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4682             MOV      R10,R0
    944          #ifdef EMBER_SERIAL_USE_STDIO
    945            while(*string != '\0') {
    946              putchar(*string);
    947              string++;
    948            }
    949            return EMBER_SUCCESS;
    950          #else //EMBER_SERIAL_USE_STDIO
    951            switch(emSerialPortModes[port]) {
   \   00000006   0x4656             MOV      R6,R10
   \   00000008   0x.... 0x....      ADR.W    R0,emSerialPortModes
   \   0000000C   0x5C30             LDRB     R0,[R6, R0]
   \   0000000E   0x460D             MOV      R5,R1
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD136             BNE.N    ??emberSerialWriteString_0
    952          #ifdef EM_ENABLE_SERIAL_FIFO
    953            case EMBER_SERIAL_FIFO:
    954              {
    955                EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000014   0x....             LDR.N    R0,??DataTable18_1
    956                boolean kickStartTx = FALSE;
   \   00000016   0x.... 0x....      ADR.W    R8,emSerialBlocking
   \   0000001A   0xF850 0x7026      LDR      R7,[R0, R6, LSL #+2]
   \   0000001E   0x.... 0x....      ADR.W    R9,emSerialTxQueueWraps
   \   00000022   0x2400             MOVS     R4,#+0
   \   00000024   0xE014             B.N      ??emberSerialWriteString_1
    957          
    958                while(*string != '\0') {
    959                  while (! getOutputFifoSpace(q, port, 0)) {
    960                    if (kickStartTx) {
    961                      halInternalStartUartTx(port);
    962                      kickStartTx = FALSE;
    963                    }
    964                    #ifdef EM_ENABLE_SERIAL_BLOCKING
    965                      if (emSerialBlocking[port]) {
    966                        simulatedSerialTimePasses();
    967                        // Pet the watchdog here?
    968                        continue;
    969                      }
    970                    #endif
    971                    return EMBER_SERIAL_TX_OVERFLOW;
    972                  }
    973                  ATOMIC_LITE(
    974                    if (q->used == 0) {
    975                      kickStartTx = TRUE;
    976                    }
    977                    FIFO_ENQUEUE(q,*string,emSerialTxQueueWraps[port]);
    978                  )
   \                     ??emberSerialWriteString_2: (+1)
   \   00000026   0x.... 0x....      BL       _disableBasePri
   \   0000002A   0x88B9             LDRH     R1,[R7, #+4]
   \   0000002C   0xB901             CBNZ.N   R1,??emberSerialWriteString_3
   \   0000002E   0x2401             MOVS     R4,#+1
   \                     ??emberSerialWriteString_3: (+1)
   \   00000030   0x883A             LDRH     R2,[R7, #+0]
   \   00000032   0xF815 0x1B01      LDRB     R1,[R5], #+1
   \   00000036   0x19D2             ADDS     R2,R2,R7
   \   00000038   0x7191             STRB     R1,[R2, #+6]
   \   0000003A   0x8839             LDRH     R1,[R7, #+0]
   \   0000003C   0xF839 0x2016      LDRH     R2,[R9, R6, LSL #+1]
   \   00000040   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000044   0x8039             STRH     R1,[R7, #+0]
   \   00000046   0x88B9             LDRH     R1,[R7, #+4]
   \   00000048   0x1C49             ADDS     R1,R1,#+1
   \   0000004A   0x80B9             STRH     R1,[R7, #+4]
   \   0000004C   0x.... 0x....      BL       _writeBasePri
    979                  string++;
   \                     ??emberSerialWriteString_1: (+1)
   \   00000050   0x7828             LDRB     R0,[R5, #+0]
   \   00000052   0xB188             CBZ.N    R0,??emberSerialWriteString_4
   \                     ??emberSerialWriteString_5: (+1)
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x4651             MOV      R1,R10
   \   00000058   0x4638             MOV      R0,R7
   \   0000005A   0x.... 0x....      BL       getOutputFifoSpace
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD1E1             BNE.N    ??emberSerialWriteString_2
   \   00000062   0xB11C             CBZ.N    R4,??emberSerialWriteString_6
   \   00000064   0x4650             MOV      R0,R10
   \   00000066   0x.... 0x....      BL       halInternalStartUartTx
   \   0000006A   0x2400             MOVS     R4,#+0
   \                     ??emberSerialWriteString_6: (+1)
   \   0000006C   0xF816 0x0008      LDRB     R0,[R6, R8]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD1EF             BNE.N    ??emberSerialWriteString_5
   \   00000074   0x2022             MOVS     R0,#+34
   \   00000076   0xE005             B.N      ??emberSerialWriteString_7
    980                }
    981                // make sure the interrupt is enabled so it will be sent
    982                halInternalStartUartTx(port);
   \                     ??emberSerialWriteString_4: (+1)
   \   00000078   0x4650             MOV      R0,R10
   \   0000007A   0x.... 0x....      BL       halInternalStartUartTx
    983                return EMBER_SUCCESS;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE000             B.N      ??emberSerialWriteString_7
    984              }
    985          #endif
    986          #ifdef EM_ENABLE_SERIAL_BUFFER
    987            case EMBER_SERIAL_BUFFER:
    988              {
    989                EmberMessageBuffer buff = emberAllocateStackBuffer();
    990                if(buff != EMBER_NULL_MESSAGE_BUFFER) {
    991                  EmberStatus stat;
    992                  if((stat=emberAppendPgmStringToLinkedBuffers(buff, string))
    993                     == EMBER_SUCCESS) {
    994                    stat = emberSerialWriteBuffer(port, buff, 0, emberMessageBufferLength(buff));
    995                  }
    996                  // Refcounts may be manipulated in ISR if DMA used
    997                  ATOMIC( emberReleaseMessageBuffer(buff); )
    998                  return stat;
    999                }
   1000                return EMBER_NO_BUFFERS;
   1001              }
   1002          #endif
   1003            default:
   1004              return EMBER_ERR_FATAL;
   \                     ??emberSerialWriteString_0: (+1)
   \   00000082   0x2001             MOVS     R0,#+1
   \                     ??emberSerialWriteString_7: (+1)
   \   00000084   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1005            }
   1006          #endif //EMBER_SERIAL_USE_STDIO
   1007          }
   1008          
   1009          

   \                                 In section .text, align 2, keep-with-next
   1010          EmberStatus emberSerialWriteData(int8u port, int8u *data, int8u length)
   1011          {
   \                     emberSerialWriteData: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   1012          #ifdef EMBER_SERIAL_USE_STDIO
   1013            while(length--) {
   1014              putchar(*data);
   1015              data++;
   1016            }
   1017            return EMBER_SUCCESS;
   1018          #else //EMBER_SERIAL_USE_STDIO
   1019            switch(emSerialPortModes[port]) {
   \   00000006   0x4647             MOV      R7,R8
   \   00000008   0x.... 0x....      ADR.W    R0,emSerialPortModes
   \   0000000C   0x5C38             LDRB     R0,[R7, R0]
   \   0000000E   0x468B             MOV      R11,R1
   \   00000010   0x4616             MOV      R6,R2
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD138             BNE.N    ??emberSerialWriteData_0
   1020          #ifdef EM_ENABLE_SERIAL_FIFO
   1021            case EMBER_SERIAL_FIFO:
   1022              {
   1023                EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000016   0x....             LDR.N    R0,??DataTable18_1
   1024                boolean kickStartTx = FALSE;
   \   00000018   0x.... 0x....      ADR.W    R9,emSerialBlocking
   \   0000001C   0xF850 0x4027      LDR      R4,[R0, R7, LSL #+2]
   \   00000020   0x.... 0x....      ADR.W    R10,emSerialTxQueueWraps
   \   00000024   0x2500             MOVS     R5,#+0
   \   00000026   0xE014             B.N      ??emberSerialWriteData_1
   1025          
   1026                while(length--) {
   1027                  while (! getOutputFifoSpace(q, port, 0)) {
   1028                    if (kickStartTx) {
   1029                      halInternalStartUartTx(port);
   1030                      kickStartTx = FALSE;
   1031                    }
   1032                    #ifdef EM_ENABLE_SERIAL_BLOCKING
   1033                      if (emSerialBlocking[port]) {
   1034                        simulatedSerialTimePasses();
   1035                        // Pet the watchdog here?
   1036                        continue;
   1037                      }
   1038                    #endif
   1039                    return EMBER_SERIAL_TX_OVERFLOW;
   1040                  }
   1041                  ATOMIC_LITE(
   1042                    if (q->used == 0) {
   1043                      kickStartTx = TRUE;
   1044                    }
   1045                    FIFO_ENQUEUE(q,*data,emSerialTxQueueWraps[port]);
   1046                  )
   \                     ??emberSerialWriteData_2: (+1)
   \   00000028   0x.... 0x....      BL       _disableBasePri
   \   0000002C   0x88A1             LDRH     R1,[R4, #+4]
   \   0000002E   0xB901             CBNZ.N   R1,??emberSerialWriteData_3
   \   00000030   0x2501             MOVS     R5,#+1
   \                     ??emberSerialWriteData_3: (+1)
   \   00000032   0x8822             LDRH     R2,[R4, #+0]
   \   00000034   0xF81B 0x1B01      LDRB     R1,[R11], #+1
   \   00000038   0x1912             ADDS     R2,R2,R4
   \   0000003A   0x7191             STRB     R1,[R2, #+6]
   \   0000003C   0x8821             LDRH     R1,[R4, #+0]
   \   0000003E   0xF83A 0x2017      LDRH     R2,[R10, R7, LSL #+1]
   \   00000042   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000046   0x8021             STRH     R1,[R4, #+0]
   \   00000048   0x88A1             LDRH     R1,[R4, #+4]
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
   \   0000004C   0x80A1             STRH     R1,[R4, #+4]
   \   0000004E   0x.... 0x....      BL       _writeBasePri
   1047                  data++;
   \                     ??emberSerialWriteData_1: (+1)
   \   00000052   0x4630             MOV      R0,R6
   \   00000054   0x1E46             SUBS     R6,R0,#+1
   \   00000056   0xB2C0             UXTB     R0,R0
   \   00000058   0xB188             CBZ.N    R0,??emberSerialWriteData_4
   \                     ??emberSerialWriteData_5: (+1)
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x4641             MOV      R1,R8
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       getOutputFifoSpace
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD1DF             BNE.N    ??emberSerialWriteData_2
   \   00000068   0xB11D             CBZ.N    R5,??emberSerialWriteData_6
   \   0000006A   0x4640             MOV      R0,R8
   \   0000006C   0x.... 0x....      BL       halInternalStartUartTx
   \   00000070   0x2500             MOVS     R5,#+0
   \                     ??emberSerialWriteData_6: (+1)
   \   00000072   0xF817 0x0009      LDRB     R0,[R7, R9]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD1EF             BNE.N    ??emberSerialWriteData_5
   \   0000007A   0x2022             MOVS     R0,#+34
   \   0000007C   0xE005             B.N      ??emberSerialWriteData_7
   1048                }
   1049                // make sure the interrupt is enabled so it will be sent
   1050                halInternalStartUartTx(port);
   \                     ??emberSerialWriteData_4: (+1)
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0x.... 0x....      BL       halInternalStartUartTx
   1051                return EMBER_SUCCESS;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xE000             B.N      ??emberSerialWriteData_7
   1052              }
   1053          #endif
   1054          #ifdef EM_ENABLE_SERIAL_BUFFER
   1055            case EMBER_SERIAL_BUFFER:
   1056              {
   1057                // Note: We must always copy this, even in buffer mode
   1058                //  since it is ram based data and there are no reference counts
   1059                //  or indication of when it is actually written out the serial
   1060                //  we cannot trust that the data won't be changed after this call
   1061                //  but before it was actually written out.
   1062                EmberMessageBuffer buff = emberFillLinkedBuffers(data,length);
   1063                if(buff != EMBER_NULL_MESSAGE_BUFFER) {
   1064                  EmberStatus stat = emberSerialWriteBuffer(port, buff, 0, emberMessageBufferLength(buff));
   1065                  // Refcounts may be manipulated in ISR if DMA used
   1066                  ATOMIC( emberReleaseMessageBuffer(buff); )
   1067                  return stat;
   1068                } else
   1069                  return EMBER_NO_BUFFERS;
   1070              }
   1071          #endif
   1072            default:
   1073              return EMBER_ERR_FATAL;
   \                     ??emberSerialWriteData_0: (+1)
   \   00000088   0x2001             MOVS     R0,#+1
   \                     ??emberSerialWriteData_7: (+1)
   \   0000008A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1074            }
   1075          #endif //EMBER_SERIAL_USE_STDIO
   1076          }
   1077          
   1078          #ifndef  NO_PACKET_BUFFERS

   \                                 In section .text, align 2, keep-with-next
   1079          EmberStatus emberSerialWriteBuffer(int8u port,
   1080                                             EmberMessageBuffer buffer,
   1081                                             int8u start,
   1082                                             int8u length)
   1083          {
   \                     emberSerialWriteBuffer: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
   1084          //Host processors do not use Ember Message Buffers.
   1085          #if defined(EZSP_HOST) || defined(EMBER_SERIAL_USE_STDIO)
   1086            return EMBER_ERR_FATAL;  //This function is invalid.
   1087          #else // !EZSP_HOST && !EMBER_SERIAL_USE_STDIO
   1088          
   1089            if(buffer == EMBER_NULL_MESSAGE_BUFFER)
   \   0000000C   0x2DFF             CMP      R5,#+255
   \   0000000E   0xD00A             BEQ.N    ??emberSerialWriteBuffer_0
   1090              return EMBER_ERR_FATAL;
   1091            if(length == 0)
   \   00000010   0xB90F             CBNZ.N   R7,??emberSerialWriteBuffer_1
   1092              return EMBER_SUCCESS;
   \                     ??emberSerialWriteBuffer_2: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE008             B.N      ??emberSerialWriteBuffer_3
   1093          
   1094            switch(emSerialPortModes[port]) {
   \                     ??emberSerialWriteBuffer_1: (+1)
   \   00000016   0x.... 0x....      ADR.W    R0,emSerialPortModes
   \   0000001A   0x....             LDR.N    R4,??DataTable18_3
   \   0000001C   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0xD004             BEQ.N    ??emberSerialWriteBuffer_4
   1095          #ifdef   EM_ENABLE_SERIAL_FIFO
   1096            case EMBER_SERIAL_FIFO:
   1097              {
   1098                for(;PACKET_BUFFER_SIZE <= start; start-=PACKET_BUFFER_SIZE)
   1099                  buffer = emberStackBufferLink(buffer);
   1100          
   1101                while (0 < length) {
   1102                  int8u remainingInBuffer = PACKET_BUFFER_SIZE - start;
   1103                  int8u bytes = (length < remainingInBuffer
   1104                                 ? length
   1105                                 : remainingInBuffer);
   1106                  emberSerialWriteData(port,
   1107                                       emberMessageBufferContents(buffer) + start,
   1108                                       bytes);
   1109                  length -= bytes;
   1110                  start = 0;
   1111                  buffer = emberStackBufferLink(buffer);
   1112                }
   1113                // make sure the interrupt is enabled so it will be sent
   1114                halInternalStartUartTx(port);
   1115                break;
   1116              }
   1117          #endif // EM_ENABLE_SERIAL_FIFO
   1118          #ifdef   EM_ENABLE_SERIAL_BUFFER
   1119            case EMBER_SERIAL_BUFFER:
   1120              {
   1121                EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1122                EmSerialBufferQueueEntry *e;
   1123                int8u elementsUsed;
   1124                int8u elementsDead;
   1125          
   1126                ATOMIC_LITE( // To clarify volatile access.
   1127                       elementsUsed = q->used;
   1128                       elementsDead = q->dead;
   1129                       )
   1130          
   1131                #ifdef   EM_ENABLE_SERIAL_BLOCKING
   1132                if(emSerialBlocking[port]) {
   1133                  while((elementsUsed + elementsDead) >= emSerialTxQueueSizes[port]) {
   1134                    emberSerialBufferTick();
   1135                    //re-read the element counters after clocking the serial buffers
   1136                    ATOMIC_LITE( // To clarify volatile access.
   1137                          elementsUsed = q->used;
   1138                          elementsDead = q->dead;
   1139                          )
   1140                  }
   1141                } else
   1142                #endif // EM_ENABLE_SERIAL_BLOCKING
   1143                if((elementsUsed + elementsDead) >= emSerialTxQueueSizes[port]) {
   1144                  if(elementsDead)
   1145                    emberSerialBufferTick();
   1146                  else
   1147                    return EMBER_SERIAL_TX_OVERFLOW;
   1148                }
   1149          
   1150                for(;PACKET_BUFFER_SIZE <= start; start-=PACKET_BUFFER_SIZE) {
   1151                  buffer = emberStackBufferLink(buffer);
   1152                }
   1153                emberHoldMessageBuffer(buffer);
   1154          
   1155                e = &q->fifo[q->head];
   1156                e->length = length;
   1157                e->buffer = buffer;
   1158                e->startIndex = start;
   1159                #ifdef AVR_ATMEGA
   1160                  //If we are using an AVR host, non power-of-2 queue sizes are NOT
   1161                  //supported and therefore we use a mask
   1162                  q->head = ((q->head+1) & emSerialTxQueueMasks[port]);
   1163                #else // AVR_ATMEGA
   1164                  //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
   1165                  //supported and therefore we use a mod with the queue size
   1166                  q->head = ((q->head+1) % emSerialTxQueueSizes[port]);
   1167                #endif // !AVR_ATMEGA
   1168                ATOMIC_LITE(
   1169                  q->used++;
   1170                )
   1171                halInternalStartUartTx(port);
   1172                break;
   1173              }
   1174          #endif // EM_ENABLE_SERIAL_BUFFER
   1175            default:
   1176              return EMBER_ERR_FATAL;
   \                     ??emberSerialWriteBuffer_0: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \                     ??emberSerialWriteBuffer_3: (+1)
   \   00000028   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \                     ??emberSerialWriteBuffer_5: (+1)
   \   0000002C   0x5C2D             LDRB     R5,[R5, R0]
   \   0000002E   0x3E20             SUBS     R6,R6,#+32
   \                     ??emberSerialWriteBuffer_4: (+1)
   \   00000030   0xB2F6             UXTB     R6,R6
   \   00000032   0x2E20             CMP      R6,#+32
   \   00000034   0xDAFA             BGE.N    ??emberSerialWriteBuffer_5
   \                     ??emberSerialWriteBuffer_6: (+1)
   \   00000036   0xF1C6 0x0020      RSB      R0,R6,#+32
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0x46B9             MOV      R9,R7
   \   0000003E   0x4287             CMP      R7,R0
   \   00000040   0xBF88             IT       HI 
   \   00000042   0x4681             MOVHI    R9,R0
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       emberMessageBufferContents
   \   0000004A   0x1831             ADDS     R1,R6,R0
   \   0000004C   0xFA5F 0xF289      UXTB     R2,R9
   \   00000050   0x4640             MOV      R0,R8
   \   00000052   0x.... 0x....      BL       emberSerialWriteData
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x5C2D             LDRB     R5,[R5, R0]
   \   0000005A   0xEBA7 0x0709      SUB      R7,R7,R9
   \   0000005E   0x2600             MOVS     R6,#+0
   \   00000060   0xB2FF             UXTB     R7,R7
   \   00000062   0x2F00             CMP      R7,#+0
   \   00000064   0xD1E7             BNE.N    ??emberSerialWriteBuffer_6
   \   00000066   0x4640             MOV      R0,R8
   \   00000068   0x.... 0x....      BL       halInternalStartUartTx
   1177            }
   1178            return EMBER_SUCCESS;
   \   0000006C   0xE7D1             B.N      ??emberSerialWriteBuffer_2
   1179          #endif // !EZSP_HOST && !EMBER_SERIAL_USE_STDIO
   1180          }
   1181          #endif // NO_PACKET_BUFFERS
   1182          
   1183          

   \                                 In section .text, align 2, keep-with-next
   1184          EmberStatus emberSerialWaitSend(int8u port)  // waits for all byte to be written out of a port
   1185          {
   \                     emberSerialWaitSend: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1186          #ifdef EMBER_SERIAL_USE_STDIO
   1187            fflush(stdout);
   1188          #else //EMBER_SERIAL_USE_STDIO
   1189            switch(emSerialPortModes[port]) {
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0x.... 0x....      ADR.W    R2,emSerialPortModes
   \   00000008   0x5C8A             LDRB     R2,[R1, R2]
   \   0000000A   0x2A01             CMP      R2,#+1
   \   0000000C   0xD105             BNE.N    ??emberSerialWaitSend_0
   1190          #ifdef EM_ENABLE_SERIAL_FIFO
   1191            case EMBER_SERIAL_FIFO: {
   1192              EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   0000000E   0x....             LDR.N    R2,??DataTable18_1
   \   00000010   0xF852 0x1021      LDR      R1,[R2, R1, LSL #+2]
   1193              while(q->used)
   \                     ??emberSerialWaitSend_1: (+1)
   \   00000014   0x888A             LDRH     R2,[R1, #+4]
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD1FC             BNE.N    ??emberSerialWaitSend_1
   1194                simulatedSerialTimePasses();
   1195              break; }
   1196          #endif
   1197          #ifdef EM_ENABLE_SERIAL_BUFFER
   1198            case EMBER_SERIAL_BUFFER: {
   1199              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1200              while(q->used) {
   1201                simulatedSerialTimePasses();
   1202              }
   1203              break; }
   1204          #endif
   1205            default: {
   1206            }
   1207            } // close switch.
   1208            halInternalWaitUartTxComplete(port);
   \                     ??emberSerialWaitSend_0: (+1)
   \   0000001A   0x.... 0x....      BL       halInternalWaitUartTxComplete
   1209          #endif //EMBER_SERIAL_USE_STDIO
   1210            return EMBER_SUCCESS;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
   1211          }
   1212          
   1213          //------------------------------------------------------
   1214          // Guaranteed output
   1215          
   1216          // The _only_ Guaranteed API:  The usage model for this api
   1217          //   Does not require efficiency
   1218          
   1219          #if !defined(EMBER_AF_PLUGIN_STANDARD_PRINTF_SUPPORT)
   1220          

   \                                 In section .text, align 2, keep-with-next
   1221          EmberStatus emberSerialGuaranteedPrintf(int8u port, PGM_P formatString, ...)
   1222          {
   \                     emberSerialGuaranteedPrintf: (+1)
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB538             PUSH     {R3-R5,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1223          #ifdef EMBER_SERIAL_USE_STDIO
   1224            //TODO: This function might have to break stdio abstraction to operate
   1225            //      with interrupts off and guarantee a print.
   1226            //NOTE: The following code is the same code found in emberSerialPrintf
   1227            EmberStatus stat;
   1228            halInternalForcePrintf(TRUE);
   1229            va_list ap;
   1230            va_start (ap, formatString);
   1231            stat = emberSerialPrintfVarArg(port, formatString, ap);
   1232            va_end (ap);
   1233            halInternalForcePrintf(FALSE);
   1234            return stat;
   1235          #else //EMBER_SERIAL_USE_STDIO
   1236            va_list ap;
   1237          
   1238            // prevent interrupt driven transmission from intermixing
   1239            halInternalStopUartTx(port);
   \   00000008   0x.... 0x....      BL       halInternalStopUartTx
   1240            va_start(ap, formatString);
   \   0000000C   0xAB04             ADD      R3,SP,#+16
   1241            emPrintfInternal(halInternalForceWriteUartData, port, formatString, ap);
   \   0000000E   0x462A             MOV      R2,R5
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x....             LDR.N    R0,??DataTable18_4
   \   00000014   0x.... 0x....      BL       emPrintfInternal
   1242            va_end(ap);
   1243          
   1244            // re-enable interrupt driven transmission if needed
   1245            switch(emSerialPortModes[port]) {
   \   00000018   0x.... 0x....      ADR.W    R1,emSerialPortModes
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x5C41             LDRB     R1,[R0, R1]
   \   00000020   0x2901             CMP      R1,#+1
   \   00000022   0xD107             BNE.N    ??emberSerialGuaranteedPrintf_0
   1246          #ifdef EM_ENABLE_SERIAL_FIFO
   1247            case EMBER_SERIAL_FIFO: {
   1248              EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   1249              if(q->used)
   \   00000024   0x....             LDR.N    R1,??DataTable18_1
   \   00000026   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000002A   0x8880             LDRH     R0,[R0, #+4]
   \   0000002C   0xB110             CBZ.N    R0,??emberSerialGuaranteedPrintf_0
   1250                halInternalStartUartTx(port);
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       halInternalStartUartTx
   1251              break; }
   1252          #endif
   1253          #ifdef EM_ENABLE_SERIAL_BUFFER
   1254            case EMBER_SERIAL_BUFFER: {
   1255              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1256              if(q->used)
   1257                halInternalStartUartTx(port);
   1258              break; }
   1259          #endif
   1260            default: {
   1261            }
   1262            } //close switch.
   1263          
   1264            return EMBER_SUCCESS;
   \                     ??emberSerialGuaranteedPrintf_0: (+1)
   \   00000034   0xBC32             POP      {R1,R4,R5}
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
   1265          #endif //EMBER_SERIAL_USE_STDIO
   1266          }
   1267          
   1268          #endif
   1269          
   1270          //------------------------------------------------------
   1271          // Serial buffer maintenance

   \                                 In section .text, align 2, keep-with-next
   1272          void emberSerialFlushRx(int8u port)
   1273          {
   \                     emberSerialFlushRx: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1274          #ifdef EMBER_SERIAL_USE_STDIO
   1275            ATOMIC(
   1276              while(halInternalPrintfReadAvailable()) {
   1277                (int)getchar();
   1278              }
   1279            )
   1280          #else //EMBER_SERIAL_USE_STDIO
   1281            EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialRxQueues[port];
   \   00000002   0x....             LDR.N    R1,??DataTable18_1
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0x6904             LDR      R4,[R0, #+16]
   1282          
   1283            ATOMIC_LITE(
   1284               q->used = 0;
   1285               q->head = 0;
   1286               q->tail = 0;
   1287               )
   \   0000000A   0x.... 0x....      BL       _disableBasePri
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x80A1             STRH     R1,[R4, #+4]
   \   00000012   0x8021             STRH     R1,[R4, #+0]
   \   00000014   0x8061             STRH     R1,[R4, #+2]
   \   00000016   0x.... 0x....      BL       _writeBasePri
   1288          
   1289            halInternalRestartUart();
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x.... 0x....      B.W      halInternalRestartUart
   1290          #endif //EMBER_SERIAL_USE_STDIO
   1291          }
   1292          
   1293          //------------------------------------------------------
   1294          // Serial Buffer Cleanup Tick
   1295          
   1296          #ifdef EM_ENABLE_SERIAL_BUFFER
   1297          //Helper function to calculate deadIndex since ifdefs cannot exist in the
   1298          //ATOMIC_LITE block
   1299          int8u calculateDeadIndex(int8u port, int8u tail, int8u numDead) {
   1300            int8u deadIndex;
   1301          
   1302            #ifdef AVR_ATMEGA
   1303              //If we are using an AVR host, non power-of-2 queue sizes are NOT
   1304              //supported and therefore we use a mask
   1305              deadIndex = (tail - numDead) & emSerialTxQueueMasks[port];
   1306            #else // AVR_ATMEGA
   1307              //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
   1308              //supported and therefore we need to use a conditional to figure
   1309              //out the deadIndex
   1310              if(numDead > tail) {
   1311                //Since subtracting numDead from tail would cause deadIndex to
   1312                //wrap, we add the tail to the queue size and then subtract
   1313                //numDead
   1314                deadIndex = (emSerialTxQueueSizes[port] + tail) - numDead;
   1315              } else {
   1316                deadIndex = tail - numDead;
   1317              }
   1318            #endif // !AVR_ATMEGA
   1319          
   1320            return deadIndex;
   1321          }
   1322          #endif //EM_ENABLE_SERIAL_BUFFER
   1323          

   \                                 In section .text, align 2, keep-with-next
   1324          void emberSerialBufferTick(void)
   1325          {
   1326          #ifdef EM_ENABLE_SERIAL_BUFFER
   1327            int8u port;
   1328            EmSerialBufferQueue *q;
   1329            int8u numDead, deadIndex;
   1330          
   1331            for(port=0; port<EM_NUM_SERIAL_PORTS; port++) {
   1332              if(emSerialPortModes[port] == EMBER_SERIAL_BUFFER) {
   1333                q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1334          
   1335                if(q->dead) {
   1336                  ATOMIC_LITE(
   1337                    numDead = q->dead;
   1338                    q->dead = 0;
   1339                    deadIndex = calculateDeadIndex(port,q->tail,numDead);
   1340                  )
   1341                  for(;numDead;numDead--) {
   1342                    // Refcounts may be manipulated in ISR if DMA used
   1343                    ATOMIC( emberReleaseMessageBuffer(q->fifo[deadIndex].buffer); )
   1344                    #ifdef AVR_ATMEGA
   1345                      //If we are using an AVR host, non power-of-2 queue sizes are NOT
   1346                      //supported and therefore we use a mask
   1347                      deadIndex = (deadIndex + 1) & emSerialTxQueueMasks[port];
   1348                    #else // AVR_ATMEGA
   1349                      //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
   1350                      //supported and therefore we use a mod with the queue size
   1351                      deadIndex = (deadIndex + 1) % emSerialTxQueueSizes[port];
   1352                    #endif // !AVR_ATMEGA
   1353                  }
   1354                }
   1355              }
   1356            }
   1357          
   1358            simulatedSerialTimePasses();
   1359          #endif
   1360          }
   \                     emberSerialBufferTick: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1361          

   \                                 In section .text, align 2, keep-with-next
   1362          boolean emberSerialUnused(int8u port)
   1363          {
   1364          #ifdef EMBER_SERIAL_USE_STDIO
   1365            return FALSE;
   1366          #else //EMBER_SERIAL_USE_STDIO
   1367            return (EM_NUM_SERIAL_PORTS <= port
   1368                    || emSerialPortModes[port] == EMBER_SERIAL_UNUSED);
   \                     emberSerialUnused: (+1)
   \   00000000   0x2804             CMP      R0,#+4
   \   00000002   0xDA06             BGE.N    ??emberSerialUnused_0
   \   00000004   0x.... 0x....      ADR.W    R1,emSerialPortModes
   \   00000008   0x5C41             LDRB     R1,[R0, R1]
   \   0000000A   0x1E48             SUBS     R0,R1,#+1
   \   0000000C   0x4180             SBCS     R0,R0,R0
   \   0000000E   0x0FC0             LSRS     R0,R0,#+31
   \   00000010   0x4770             BX       LR
   \                     ??emberSerialUnused_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x4770             BX       LR               ;; return
   1369          #endif //EMBER_SERIAL_USE_STDIO
   1370          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x08 0x20          DC8      "\b \b"
   \              0x08 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     emSerialTxQueues

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     emSerialRxError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x........         DC32     emPacketBufferLinks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x........         DC32     halInternalForceWriteUartData

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "\\b \\b">`:
   \   00000000   0x08 0x20          DC8 "\010 \010"
   \              0x08 0x00    
   1371          
   1372          #endif //CORTEXM3_EFM32_MICRO

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   emberSerialBufferTick
       8   emberSerialFlushRx
         8   -> _disableBasePri
         8   -> _writeBasePri
         0   -> halInternalRestartUart
      24   emberSerialGuaranteedPrintf
        24   -> emPrintfInternal
        24   -> halInternalStartUartTx
        24   -> halInternalStopUartTx
      32   emberSerialInit
        32   -> _disableBasePri
        32   -> _writeBasePri
        32   -> emberSerialUnused
        32   -> halInternalRestartUart
         0   -> halInternalUartInit
       8   emberSerialReadAvailable
         8   -> halInternalUartRxPump
      32   emberSerialReadByte
        32   -> _disableBasePri
        32   -> _writeBasePri
        32   -> emberSerialUnused
        32   -> halInternalUartRxPump
      24   emberSerialReadData
        24   -> emberSerialReadByte
      40   emberSerialReadDataTimeout
        40   -> emberSerialReadByte
        40   -> halCommonGetInt16uMillisecondTick
      24   emberSerialReadLine
        24   -> emberSerialReadPartialLine
        24   -> halInternalResetWatchDog
      24   emberSerialReadPartialLine
        24   -> emberSerialReadByte
        24   -> emberSerialWriteByte
        24   -> emberSerialWriteString
       0   emberSerialUnused
       8   emberSerialWaitSend
         8   -> halInternalWaitUartTxComplete
       0   emberSerialWriteAvailable
      32   emberSerialWriteBuffer
        32   -> emberMessageBufferContents
        32   -> emberSerialWriteData
        32   -> halInternalStartUartTx
       8   emberSerialWriteByte
         8   -> emberSerialWriteData
      40   emberSerialWriteData
        40   -> _disableBasePri
        40   -> _writeBasePri
        40   -> getOutputFifoSpace
        40   -> halInternalStartUartTx
      32   emberSerialWriteString
        32   -> _disableBasePri
        32   -> _writeBasePri
        32   -> getOutputFifoSpace
        32   -> halInternalStartUartTx
       8   emberSerialWriteUsed
         8   -> emberSerialWriteAvailable
       0   getOutputFifoSpace


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant "\b \b">
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
      12  ?Subroutine0
     136  emSerial1RxQueue
     136  emSerial1TxQueue
       4  emSerialBlocking
       4  emSerialPortModes
      12  emSerialRxError
          emSerialRxErrorIndex
       8  emSerialRxQueueSizes
       8  emSerialRxQueueWraps
       8  emSerialTxQueueMasks
       8  emSerialTxQueueSizes
       8  emSerialTxQueueWraps
      32  emSerialTxQueues
          emSerialRxQueues
       2  emberSerialBufferTick
      34  emberSerialFlushRx
      60  emberSerialGuaranteedPrintf
     110  emberSerialInit
      22  emberSerialReadAvailable
     148  emberSerialReadByte
      58  emberSerialReadData
      98  emberSerialReadDataTimeout
      40  emberSerialReadLine
     222  emberSerialReadPartialLine
      22  emberSerialUnused
      34  emberSerialWaitSend
      36  emberSerialWriteAvailable
     110  emberSerialWriteBuffer
      12  emberSerialWriteByte
     142  emberSerialWriteData
     136  emberSerialWriteString
      22  emberSerialWriteUsed
      24  getOutputFifoSpace

 
   284 bytes in section .bss
    32 bytes in section .data
    20 bytes in section .rodata
 1 396 bytes in section .text
 
 1 396 bytes of CODE  memory
    20 bytes of CONST memory
   316 bytes of DATA  memory

Errors: none
Warnings: none

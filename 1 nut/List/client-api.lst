###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Apr/2016  13:01:20
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\client-api.c
#    Command line =  
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\client-api.c"
#        -D SWITCH_1_BUTTON -D NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D
#        CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"client-api.c\"" -lC "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\List\" --diag_suppress Pa050 -o "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\Obj\" --debug --endian=little --cpu=Cortex-M3
#        --no_path_in_file_macros --separate_cluster_for_initialized_variables
#        -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        "D:\Work Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\"
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\List\client-api.lst
#    Object file  =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\Obj\client-api.o
#
###############################################################################

D:\Work Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\client-api.c
      1          // Copyright 2009 by Ember Corporation. All rights reserved.
      2          //
      3          // This file contains the C portion of the client api.
      4          //
      5          
      6          #include PLATFORM_HEADER
      7          #include "common.h"
      8          #include "util.h"
      9          #include "client-api.h"
     10          

   \                                 In section .bss, align 4
     11          int8u *emAfZclBuffer = NULL;
     12          int16u emAfZclBufferLen = 0;
   \                     emAfZclBufferLen:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \                     emAfZclBuffer:
   \   00000004                      DS8 4
     13          
     14          // Pointer to where this API should put the length
     15          int16u *emAfResponseLengthPtr = NULL;
   \                     emAfResponseLengthPtr:
   \   00000008                      DS8 4
     16          
     17          // Pointer to where the API should put the cluster ID
     18          EmberApsFrame *emAfCommandApsFrame = NULL;
   \                     emAfCommandApsFrame:
   \   0000000C                      DS8 4
     19          
     20          /////////////////
     21          
     22          // Method that fills in the buffer.
     23          // It returns number of bytes filled
     24          // and 0 on error.

   \                                 In section .text, align 2, keep-with-next
     25          static int16u vFillBuffer(int8u *buffer,
     26                                    int16u bufferLen,
     27                                    int8u frameControl,
     28                                    int16u manufacturerCode,
     29                                    int8u commandId,
     30                                    PGM_P format,
     31                                    va_list argPointer)
     32          {
   \                     vFillBuffer: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x2903             CMP      R1,#+3
   \   00000008   0xDB01             BLT.N    ??vFillBuffer_0
   \   0000000A   0xB123             CBZ.N    R3,??vFillBuffer_1
   \   0000000C   0x2905             CMP      R1,#+5
   \                     ??vFillBuffer_0: (+1)
   \   0000000E   0xF2C0 0x808D      BLT.W    ??vFillBuffer_2
     33            int32u value;
     34            int8u valueLen;
     35            int8u *data;
     36            int16u dataLen;
     37            int8u i;
     38            int16u bytes = 0;
     39          
     40            // The destination buffer must be at least large enough to hold the ZCL
     41            // overhead: frame control, manufacturer code (if applicable), sequence
     42            // number, and command id.  If it is, add these in order.
     43            if (bufferLen < EMBER_AF_ZCL_OVERHEAD
     44                || (manufacturerCode != EMBER_AF_NULL_MANUFACTURER_CODE
     45                    && bufferLen < EMBER_AF_ZCL_MANUFACTURER_SPECIFIC_OVERHEAD)) {
     46              emberAfDebugPrintln("ERR: Buffer too short for ZCL header");
     47              return 0;
     48            }
     49            if (manufacturerCode != EMBER_AF_NULL_MANUFACTURER_CODE) {
     50              frameControl |= ZCL_MANUFACTURER_SPECIFIC_MASK;
   \   00000012   0xF042 0x0204      ORR      R2,R2,#0x4
     51            }
     52            buffer[bytes++] = frameControl;
   \                     ??vFillBuffer_1: (+1)
   \   00000016   0x7022             STRB     R2,[R4, #+0]
   \   00000018   0x2501             MOVS     R5,#+1
     53            if (manufacturerCode != EMBER_AF_NULL_MANUFACTURER_CODE) {
   \   0000001A   0xB11B             CBZ.N    R3,??vFillBuffer_3
     54              buffer[bytes++] = LOW_BYTE(manufacturerCode);
   \   0000001C   0x7063             STRB     R3,[R4, #+1]
     55              buffer[bytes++] = HIGH_BYTE(manufacturerCode);
   \   0000001E   0x0A18             LSRS     R0,R3,#+8
   \   00000020   0x70A0             STRB     R0,[R4, #+2]
   \   00000022   0x2503             MOVS     R5,#+3
     56            }
     57            buffer[bytes++] = emberAfNextSequence();
   \                     ??vFillBuffer_3: (+1)
   \   00000024   0x.... 0x....      BL       emberAfNextSequence
   \   00000028   0x5528             STRB     R0,[R5, R4]
   \   0000002A   0x1C69             ADDS     R1,R5,#+1
     58            buffer[bytes++] = commandId;
   \   0000002C   0x980A             LDR      R0,[SP, #+40]
   \   0000002E   0xB289             UXTH     R1,R1
   \   00000030   0x1C4D             ADDS     R5,R1,#+1
   \   00000032   0x5508             STRB     R0,[R1, R4]
     59          
     60            // Each argument comes in as an integer value, a pointer to a buffer, or a
     61            // pointer to a buffer followed by an integer length.
     62            for (i = 0; format[i] != 0; i++) {
   \   00000034   0xF04F 0x0800      MOV      R8,#+0
   \   00000038   0xF8DD 0xA030      LDR      R10,[SP, #+48]
   \   0000003C   0xE007             B.N      ??vFillBuffer_4
     63              char cmd;
     64              value = 0;
     65              valueLen = 0;
     66              data = 0;
     67              cmd = format[i];
     68              if (cmd <= 's') {
     69                //  0--9, A--G, L, S, b, l, and s all have a pointer to a buffer.  The
     70                // length of that buffer is implied by 0--9 and A--G (0 to 16 bytes).
     71                // For L, S, and b, a separate integer specifies the length.  That length
     72                // will precede the data in the destination buffer for L and S, which
     73                // turns them into regular ZigBee strings.  In this case, care must be
     74                // taken to account for invalid strings, which have length 0xFFFF or 0xFF
     75                // for L and S respectively.  In the case of invalid strings, the length
     76                // byte(s) are copied to the destination buffer but the string itself is
     77                // not.  Finally, l and s are just ZigBee strings and the length of the
     78                // string data is contained within the buffer itself and the entire
     79                // buffer is copied as is to the destination buffer.  Note that
     80                // emberAf(Long)StringLength handles invalid strings, but it does not
     81                // include the length byte(s) in the total length, so the overhead
     82                // must be maually accounted for when copying.
     83                data = (int8u *)va_arg(argPointer, int8u *);
     84                valueLen = 0;
     85                if (cmd == 'L' || cmd == 'S' || cmd == 'b') {
     86                  dataLen = (int16u)va_arg(argPointer, int);
     87                  if (cmd == 'L') {
     88                    value = dataLen;
     89                    valueLen = (value == 0xFFFF ? 0 : 2);
     90                  } else if (cmd == 'S') {
     91                    value = (int8u)dataLen;
     92                    valueLen = (value == 0xFF ? 0 : 1);
     93                  }
     94                } else if (cmd == 'l') {
     95                  dataLen = emberAfLongStringLength(data) + 2;
     96                } else if (cmd == 's') {
     97                  dataLen = emberAfStringLength(data) + 1;
     98                } else if ('0' <= cmd && cmd <= '9') {
     99                  dataLen = cmd - '0';
    100                } else if ('A' <= cmd && cmd <= 'G') {
    101                  dataLen = cmd - 'A' + 10;
    102                } else {
    103                  emberAfDebugPrintln("ERR: Unknown format '%c'", cmd);
    104                  return 0;
    105                }
    106              } else {
    107                // u, v, x, and w are one-, two-, three-, or four-byte integers.  u and v
    108                // must be extracted as an int while x and w come through as an int32u.
    109                // In all cases, the value is copied to the destination buffer in little-
    110                // endian format.
    111                dataLen = 0;
    112                if (cmd == 'u') {
    113                  valueLen = 1;
    114                } else if (cmd == 'v') {
    115                  valueLen = 2;
    116                } else if (cmd == 'x') {
    117                  valueLen = 3;
    118                } else if (cmd == 'w') {
    119                  valueLen = 4;
    120                } else {
    121                  emberAfDebugPrintln("ERR: Unknown format '%c'", cmd);
    122                  return 0;
    123                }
    124                value = (int32u)(valueLen <= 2
    125                                 ? va_arg(argPointer, int)
    126                                 : va_arg(argPointer, int32u));
    127              }
    128          
    129              // The destination buffer must be at least as large as the running total
    130              // plus the length of the integer value (if applicable) plus the length of
    131              // the data (if applicable).
    132              if (bufferLen < bytes + dataLen + valueLen) {
    133                emberAfDebugPrintln("ERR: Buffer too short for %d bytes for format '%c'",
    134                                    dataLen + valueLen,
    135                                    cmd);
    136                return 0;
    137              }
    138          
    139              // If there is an integer value, add it to destination buffer in little-
    140              // endian format.
    141              for (; 0 < valueLen; valueLen--) {
    142                buffer[bytes++] = LOW_BYTE(value);
    143                value = value >> 8;
    144              }
    145          
    146              // Finally, if there is data, add it to the destination buffer as is.  If
    147              // the data length is zero, data may actually be NULL.  Even if the length
    148              // argument is zero, passing NULL as either the source or destination to
    149              // MEMCOPY is invalid and the behavior is undefined.  We avoid that with an
    150              // explicit check.
    151              if (dataLen != 0) {
    152                if (data == NULL) {
    153                  emberAfDebugPrintln("ERR: Missing data for %d bytes for format '%c'",
    154                                      dataLen,
    155                                      cmd);
    156                  return 0;
    157                }
    158                MEMCOPY(buffer + bytes, data, dataLen);
   \                     ??vFillBuffer_5: (+1)
   \   0000003E   0x4632             MOV      R2,R6
   \   00000040   0x4649             MOV      R1,R9
   \   00000042   0x1928             ADDS     R0,R5,R4
   \   00000044   0x.... 0x....      BL       halCommonMemMove
    159                bytes += dataLen;
   \   00000048   0x1975             ADDS     R5,R6,R5
   \                     ??vFillBuffer_6: (+1)
   \   0000004A   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??vFillBuffer_4: (+1)
   \   0000004E   0x980B             LDR      R0,[SP, #+44]
   \   00000050   0xFA5F 0xF888      UXTB     R8,R8
   \   00000054   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD069             BEQ.N    ??vFillBuffer_7
   \   0000005C   0x2700             MOVS     R7,#+0
   \   0000005E   0xF04F 0x0B00      MOV      R11,#+0
   \   00000062   0x46B9             MOV      R9,R7
   \   00000064   0x2874             CMP      R0,#+116
   \   00000066   0xDA37             BGE.N    ??vFillBuffer_8
   \   00000068   0xF85A 0x9B04      LDR      R9,[R10], #+4
   \   0000006C   0x284C             CMP      R0,#+76
   \   0000006E   0xBF1C             ITT      NE 
   \   00000070   0x2853             CMPNE    R0,#+83
   \   00000072   0x2862             CMPNE    R0,#+98
   \   00000074   0xD114             BNE.N    ??vFillBuffer_9
   \   00000076   0xF85A 0x6B04      LDR      R6,[R10], #+4
   \   0000007A   0x284C             CMP      R0,#+76
   \   0000007C   0xD107             BNE.N    ??vFillBuffer_10
   \   0000007E   0xB2B6             UXTH     R6,R6
   \   00000080   0x46B3             MOV      R11,R6
   \   00000082   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000086   0x4583             CMP      R11,R0
   \   00000088   0xD038             BEQ.N    ??vFillBuffer_11
   \   0000008A   0x2702             MOVS     R7,#+2
   \   0000008C   0xE036             B.N      ??vFillBuffer_11
   \                     ??vFillBuffer_10: (+1)
   \   0000008E   0x2853             CMP      R0,#+83
   \   00000090   0xD134             BNE.N    ??vFillBuffer_11
   \   00000092   0xFA5F 0xFB86      UXTB     R11,R6
   \   00000096   0xF1BB 0x0FFF      CMP      R11,#+255
   \   0000009A   0xD02F             BEQ.N    ??vFillBuffer_11
   \   0000009C   0x2701             MOVS     R7,#+1
   \   0000009E   0xE02D             B.N      ??vFillBuffer_11
   \                     ??vFillBuffer_9: (+1)
   \   000000A0   0x286C             CMP      R0,#+108
   \   000000A2   0xD104             BNE.N    ??vFillBuffer_12
   \   000000A4   0x4648             MOV      R0,R9
   \   000000A6   0x.... 0x....      BL       emberAfLongStringLength
   \   000000AA   0x1C86             ADDS     R6,R0,#+2
   \   000000AC   0xE026             B.N      ??vFillBuffer_11
   \                     ??vFillBuffer_12: (+1)
   \   000000AE   0x2873             CMP      R0,#+115
   \   000000B0   0xD104             BNE.N    ??vFillBuffer_13
   \   000000B2   0x4648             MOV      R0,R9
   \   000000B4   0x.... 0x....      BL       emberAfStringLength
   \   000000B8   0x1C46             ADDS     R6,R0,#+1
   \   000000BA   0xE01F             B.N      ??vFillBuffer_11
   \                     ??vFillBuffer_13: (+1)
   \   000000BC   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   000000C0   0x290A             CMP      R1,#+10
   \   000000C2   0xBF38             IT       CC 
   \   000000C4   0xF1A0 0x0630      SUBCC    R6,R0,#+48
   \   000000C8   0xD318             BCC.N    ??vFillBuffer_11
   \   000000CA   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   000000CE   0x2907             CMP      R1,#+7
   \   000000D0   0xD22C             BCS.N    ??vFillBuffer_2
   \   000000D2   0xF1A0 0x0637      SUB      R6,R0,#+55
   \   000000D6   0xE011             B.N      ??vFillBuffer_11
   \                     ??vFillBuffer_8: (+1)
   \   000000D8   0x2600             MOVS     R6,#+0
   \   000000DA   0x2875             CMP      R0,#+117
   \   000000DC   0xBF08             IT       EQ 
   \   000000DE   0x2701             MOVEQ    R7,#+1
   \   000000E0   0xD00A             BEQ.N    ??vFillBuffer_14
   \   000000E2   0x2876             CMP      R0,#+118
   \   000000E4   0xBF08             IT       EQ 
   \   000000E6   0x2702             MOVEQ    R7,#+2
   \   000000E8   0xD006             BEQ.N    ??vFillBuffer_14
   \   000000EA   0x2878             CMP      R0,#+120
   \   000000EC   0xBF08             IT       EQ 
   \   000000EE   0x2703             MOVEQ    R7,#+3
   \   000000F0   0xD002             BEQ.N    ??vFillBuffer_14
   \   000000F2   0x2877             CMP      R0,#+119
   \   000000F4   0xD11A             BNE.N    ??vFillBuffer_2
   \   000000F6   0x2704             MOVS     R7,#+4
   \                     ??vFillBuffer_14: (+1)
   \   000000F8   0xF85A 0xBB04      LDR      R11,[R10], #+4
   \                     ??vFillBuffer_11: (+1)
   \   000000FC   0xB2AD             UXTH     R5,R5
   \   000000FE   0xB2B6             UXTH     R6,R6
   \   00000100   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000104   0x1971             ADDS     R1,R6,R5
   \   00000106   0x1879             ADDS     R1,R7,R1
   \   00000108   0x4288             CMP      R0,R1
   \   0000010A   0xDA06             BGE.N    ??vFillBuffer_15
   \   0000010C   0xE00E             B.N      ??vFillBuffer_2
   \                     ??vFillBuffer_16: (+1)
   \   0000010E   0xF805 0xB004      STRB     R11,[R5, R4]
   \   00000112   0x1C6D             ADDS     R5,R5,#+1
   \   00000114   0xEA4F 0x2B1B      LSR      R11,R11,#+8
   \   00000118   0x1E47             SUBS     R7,R0,#+1
   \                     ??vFillBuffer_15: (+1)
   \   0000011A   0xB2F8             UXTB     R0,R7
   \   0000011C   0xB2AD             UXTH     R5,R5
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD1F5             BNE.N    ??vFillBuffer_16
   \   00000122   0x2E00             CMP      R6,#+0
   \   00000124   0xD091             BEQ.N    ??vFillBuffer_6
   \   00000126   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000012A   0xD188             BNE.N    ??vFillBuffer_5
   \                     ??vFillBuffer_2: (+1)
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0xE000             B.N      ??vFillBuffer_17
    160              }
    161            }
    162          
    163            return bytes;
   \                     ??vFillBuffer_7: (+1)
   \   00000130   0xB2A8             UXTH     R0,R5
   \                     ??vFillBuffer_17: (+1)
   \   00000132   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    164          }
    165          
    166          ////////////////////// Public API ////////////////////////
    167          

   \                                 In section .text, align 2, keep-with-next
    168          void emberAfSetExternalBuffer(int8u *buffer,
    169                                        int16u bufferLen,
    170                                        int16u *lenPtr,
    171                                        EmberApsFrame *apsFrame)
    172          {
   \                     emberAfSetExternalBuffer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    173            emAfZclBuffer = buffer;
   \   00000002   0x....             LDR.N    R4,??DataTable7
   \   00000004   0x6060             STR      R0,[R4, #+4]
    174            emAfZclBufferLen = bufferLen;
   \   00000006   0x8021             STRH     R1,[R4, #+0]
    175            emAfResponseLengthPtr = lenPtr;
   \   00000008   0x60A2             STR      R2,[R4, #+8]
    176            emAfCommandApsFrame = apsFrame;
   \   0000000A   0x60E3             STR      R3,[R4, #+12]
    177          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    178          

   \                                 In section .text, align 2, keep-with-next
    179          int16u emberAfFillExternalManufacturerSpecificBuffer(int8u frameControl,
    180                                                               EmberAfClusterId clusterId,
    181                                                               int16u manufacturerCode,
    182                                                               int8u commandId,
    183                                                               PGM_P format,
    184                                                               ...)
    185          {
   \                     emberAfFillExternalManufacturerSpecificBuffer: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    186            int16u returnValue;
    187            va_list argPointer = {0};
    188          
    189            va_start(argPointer, format);
   \   00000004   0xA907             ADD      R1,SP,#+28
    190            returnValue = vFillBuffer(emAfZclBuffer,
    191                                      emAfZclBufferLen,
    192                                      frameControl,
    193                                      manufacturerCode,
    194                                      commandId,
    195                                      format,
    196                                      argPointer);
   \   00000006   0x9102             STR      R1,[SP, #+8]
   \   00000008   0x9300             STR      R3,[SP, #+0]
   \   0000000A   0x4613             MOV      R3,R2
   \   0000000C   0x9906             LDR      R1,[SP, #+24]
   \   0000000E   0x....             LDR.N    R5,??DataTable7
   \   00000010   0x9101             STR      R1,[SP, #+4]
   \   00000012   0x4602             MOV      R2,R0
   \   00000014   0x8829             LDRH     R1,[R5, #+0]
   \   00000016   0x....             B.N      ?Subroutine0
    197            va_end(argPointer);
    198            *emAfResponseLengthPtr = returnValue;
    199            emAfCommandApsFrame->clusterId = clusterId;
    200            emAfCommandApsFrame->options = EMBER_AF_DEFAULT_APS_OPTIONS;
    201            return returnValue;
    202          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6868             LDR      R0,[R5, #+4]
   \   00000002   0x.... 0x....      BL       vFillBuffer
   \   00000006   0x68A9             LDR      R1,[R5, #+8]
   \   00000008   0x8008             STRH     R0,[R1, #+0]
   \   0000000A   0xF44F 0x5288      MOV      R2,#+4352
   \   0000000E   0x68E9             LDR      R1,[R5, #+12]
   \   00000010   0x804C             STRH     R4,[R1, #+2]
   \   00000012   0x80CA             STRH     R2,[R1, #+6]
   \   00000014   0xBD3E             POP      {R1-R5,PC}       ;; return
    203          

   \                                 In section .text, align 2, keep-with-next
    204          int16u emberAfFillExternalBuffer(int8u frameControl,
    205                                           EmberAfClusterId clusterId,
    206                                           int8u commandId,
    207                                           PGM_P format,
    208                                           ...)
    209          {
   \                     emberAfFillExternalBuffer: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    210            int16u returnValue;
    211            va_list argPointer = {0};
    212          
    213            va_start(argPointer, format);
   \   00000004   0xA906             ADD      R1,SP,#+24
    214            returnValue = vFillBuffer(emAfZclBuffer,
    215                                      emAfZclBufferLen,
    216                                      frameControl,
    217                                      EMBER_AF_NULL_MANUFACTURER_CODE,
    218                                      commandId,
    219                                      format,
    220                                      argPointer);
   \   00000006   0x9200             STR      R2,[SP, #+0]
   \   00000008   0x9102             STR      R1,[SP, #+8]
   \   0000000A   0x9301             STR      R3,[SP, #+4]
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x....             LDR.N    R5,??DataTable7
   \   00000010   0x8829             LDRH     R1,[R5, #+0]
   \   00000012   0x4602             MOV      R2,R0
   \   00000014                      REQUIRE ?Subroutine0
   \   00000014                      ;; // Fall through to label ?Subroutine0
    221            va_end(argPointer);
    222            *emAfResponseLengthPtr = returnValue;
    223            emAfCommandApsFrame->clusterId = clusterId;
    224            emAfCommandApsFrame->options = EMBER_AF_DEFAULT_APS_OPTIONS;
    225            return returnValue;
    226          }
    227          

   \                                 In section .text, align 2, keep-with-next
    228          int16u emberAfFillBuffer(int8u *buffer,
    229                                   int16u bufferLen,
    230                                   int8u frameControl,
    231                                   int8u commandId,
    232                                   PGM_P format,
    233                                   ...)
    234          {
   \                     emberAfFillBuffer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    235            int16u returnValue;
    236            va_list argPointer = {0};
    237            va_start(argPointer, format);
   \   00000004   0xAC07             ADD      R4,SP,#+28
    238            returnValue = vFillBuffer(buffer,
    239                                      bufferLen,
    240                                      frameControl,
    241                                      EMBER_AF_NULL_MANUFACTURER_CODE,
    242                                      commandId,
    243                                      format,
    244                                      argPointer);
    245            va_end(argPointer);
    246            return returnValue;
   \   00000006   0x9402             STR      R4,[SP, #+8]
   \   00000008   0x9300             STR      R3,[SP, #+0]
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x9C06             LDR      R4,[SP, #+24]
   \   0000000E   0x9401             STR      R4,[SP, #+4]
   \   00000010   0x.... 0x....      BL       vFillBuffer
   \   00000014   0xB004             ADD      SP,SP,#+16
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    247          }
    248          

   \                                 In section .text, align 2, keep-with-next
    249          EmberStatus emberAfSendCommandUnicastToBindingsWithCallback(EmberAfMessageSentFunction callback)
    250          {
   \                     emberAfSendCommandUnicastToBindingsWithCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    251            return emberAfSendUnicastToBindingsWithCallback(emAfCommandApsFrame,
    252                                                            *emAfResponseLengthPtr,
    253                                                            emAfZclBuffer, 
    254                                                            callback);
   \   00000002   0x....             LDR.N    R4,??DataTable7
   \   00000004   0x6862             LDR      R2,[R4, #+4]
   \   00000006   0x4603             MOV      R3,R0
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
   \   0000000A   0x8801             LDRH     R1,[R0, #+0]
   \   0000000C   0x68E0             LDR      R0,[R4, #+12]
   \   0000000E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000012   0x.... 0x....      B.W      emberAfSendUnicastToBindingsWithCallback
    255          }
    256          

   \                                 In section .text, align 2, keep-with-next
    257          EmberStatus emberAfSendCommandUnicastToBindings(void)
    258          {
    259            return emberAfSendCommandUnicastToBindingsWithCallback(NULL);
   \                     emberAfSendCommandUnicastToBindings: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             B.N      emberAfSendCommandUnicastToBindingsWithCallback
    260          }
    261          

   \                                 In section .text, align 2, keep-with-next
    262          EmberStatus emberAfSendCommandMulticastWithCallback(EmberMulticastId multicastId,
    263                                                              EmberAfMessageSentFunction callback)
    264          {
   \                     emberAfSendCommandMulticastWithCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    265            return emberAfSendMulticastWithCallback(multicastId,
    266                                                    emAfCommandApsFrame,
    267                                                    *emAfResponseLengthPtr,
    268                                                    emAfZclBuffer, 
    269                                                    callback);
   \   00000004   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000008   0x.... 0x....      BL       emberAfSendMulticastWithCallback
   \   0000000C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    270          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x....             LDR.N    R4,??DataTable7
   \   00000002   0x6863             LDR      R3,[R4, #+4]
   \   00000004   0x9100             STR      R1,[SP, #+0]
   \   00000006   0x68A1             LDR      R1,[R4, #+8]
   \   00000008   0x880A             LDRH     R2,[R1, #+0]
   \   0000000A   0x68E1             LDR      R1,[R4, #+12]
   \   0000000C   0x4770             BX       LR
    271          

   \                                 In section .text, align 2, keep-with-next
    272          EmberStatus emberAfSendCommandMulticast(EmberMulticastId multicastId)
    273          {
    274            return emberAfSendCommandMulticastWithCallback(multicastId, NULL);
   \                     emberAfSendCommandMulticast: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      emberAfSendCommandMulticastWithCallback
    275          }
    276          

   \                                 In section .text, align 2, keep-with-next
    277          EmberStatus emberAfSendCommandUnicastWithCallback(EmberOutgoingMessageType type,
    278                                                            int16u indexOrDestination,
    279                                                            EmberAfMessageSentFunction callback)
    280          {
   \                     emberAfSendCommandUnicastWithCallback: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    281            return emberAfSendUnicastWithCallback(type,
    282                                                  indexOrDestination,
    283                                                  emAfCommandApsFrame,
    284                                                  *emAfResponseLengthPtr,
    285                                                  emAfZclBuffer,
    286                                                  callback);
   \   00000002   0x....             LDR.N    R4,??DataTable7
   \   00000004   0x9201             STR      R2,[SP, #+4]
   \   00000006   0x6862             LDR      R2,[R4, #+4]
   \   00000008   0x9200             STR      R2,[SP, #+0]
   \   0000000A   0x68A2             LDR      R2,[R4, #+8]
   \   0000000C   0x8813             LDRH     R3,[R2, #+0]
   \   0000000E   0x68E2             LDR      R2,[R4, #+12]
   \   00000010   0x.... 0x....      BL       emberAfSendUnicastWithCallback
   \   00000014   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    287          }
    288          

   \                                 In section .text, align 2, keep-with-next
    289          EmberStatus emberAfSendCommandUnicast(EmberOutgoingMessageType type,
    290                                                int16u indexOrDestination)
    291          {
    292            return emberAfSendCommandUnicastWithCallback(type, indexOrDestination, NULL);
   \                     emberAfSendCommandUnicast: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x....             B.N      emberAfSendCommandUnicastWithCallback
    293          }
    294          

   \                                 In section .text, align 2, keep-with-next
    295          EmberStatus emberAfSendCommandBroadcastWithCallback(EmberNodeId destination,
    296                                                              EmberAfMessageSentFunction callback)
    297          {
   \                     emberAfSendCommandBroadcastWithCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    298            return emberAfSendBroadcastWithCallback(destination,
    299                                                    emAfCommandApsFrame,
    300                                                    *emAfResponseLengthPtr,
    301                                                    emAfZclBuffer,
    302                                                    callback);
   \   00000004   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000008   0x.... 0x....      BL       emberAfSendBroadcastWithCallback
   \   0000000C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    303          }
    304          

   \                                 In section .text, align 2, keep-with-next
    305          EmberStatus emberAfSendCommandBroadcast(EmberNodeId destination)
    306          {
    307            return emberAfSendCommandBroadcastWithCallback(destination, NULL);
   \                     emberAfSendCommandBroadcast: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      emberAfSendCommandBroadcastWithCallback
    308          }
    309          

   \                                 In section .text, align 2, keep-with-next
    310          EmberStatus emberAfSendCommandInterPan(EmberPanId panId,
    311                                                 const EmberEUI64 destinationLongId,
    312                                                 EmberNodeId destinationShortId,
    313                                                 EmberMulticastId multicastId,
    314                                                 EmberAfProfileId profileId)
    315          {
   \                     emberAfSendCommandInterPan: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    316            return emberAfSendInterPan(panId,
    317                                       destinationLongId,
    318                                       destinationShortId,
    319                                       multicastId,
    320                                       emAfCommandApsFrame->clusterId,
    321                                       profileId,
    322                                       *emAfResponseLengthPtr,
    323                                       emAfZclBuffer);
   \   00000002   0x....             LDR.N    R5,??DataTable7
   \   00000004   0x686C             LDR      R4,[R5, #+4]
   \   00000006   0xB085             SUB      SP,SP,#+20
   \   00000008   0x9403             STR      R4,[SP, #+12]
   \   0000000A   0x68AC             LDR      R4,[R5, #+8]
   \   0000000C   0x8824             LDRH     R4,[R4, #+0]
   \   0000000E   0x9402             STR      R4,[SP, #+8]
   \   00000010   0x9C08             LDR      R4,[SP, #+32]
   \   00000012   0x9401             STR      R4,[SP, #+4]
   \   00000014   0x68EC             LDR      R4,[R5, #+12]
   \   00000016   0x8864             LDRH     R4,[R4, #+2]
   \   00000018   0x9400             STR      R4,[SP, #+0]
   \   0000001A   0x.... 0x....      BL       emberAfSendInterPan
   \   0000001E   0xB005             ADD      SP,SP,#+20
   \   00000020   0xBD30             POP      {R4,R5,PC}       ;; return
    324          }
    325          

   \                                 In section .text, align 2, keep-with-next
    326          EmberApsFrame *emberAfGetCommandApsFrame(void)
    327          {
    328            return emAfCommandApsFrame;
   \                     emberAfGetCommandApsFrame: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7
   \   00000002   0x68C0             LDR      R0,[R0, #+12]
   \   00000004   0x4770             BX       LR               ;; return
    329          }
    330          

   \                                 In section .text, align 2, keep-with-next
    331          void emberAfSetCommandEndpoints(int8u sourceEndpoint, int8u destinationEndpoint)
    332          {
    333            emAfCommandApsFrame->sourceEndpoint = sourceEndpoint;
   \                     emberAfSetCommandEndpoints: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable7
   \   00000002   0x68D3             LDR      R3,[R2, #+12]
   \   00000004   0x7118             STRB     R0,[R3, #+4]
    334            emAfCommandApsFrame->destinationEndpoint = destinationEndpoint;
   \   00000006   0x68D0             LDR      R0,[R2, #+12]
   \   00000008   0x7141             STRB     R1,[R0, #+5]
    335          }
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     emAfZclBufferLen

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   emberAfFillBuffer
        24   -> vFillBuffer
      24   emberAfFillExternalBuffer
        24   -> vFillBuffer
      24   emberAfFillExternalManufacturerSpecificBuffer
        24   -> vFillBuffer
       0   emberAfGetCommandApsFrame
       0   emberAfSendCommandBroadcast
         0   -> emberAfSendCommandBroadcastWithCallback
      16   emberAfSendCommandBroadcastWithCallback
        16   -> emberAfSendBroadcastWithCallback
      32   emberAfSendCommandInterPan
        32   -> emberAfSendInterPan
       0   emberAfSendCommandMulticast
         0   -> emberAfSendCommandMulticastWithCallback
      16   emberAfSendCommandMulticastWithCallback
        16   -> emberAfSendMulticastWithCallback
       0   emberAfSendCommandUnicast
         0   -> emberAfSendCommandUnicastWithCallback
       0   emberAfSendCommandUnicastToBindings
         0   -> emberAfSendCommandUnicastToBindingsWithCallback
       8   emberAfSendCommandUnicastToBindingsWithCallback
         0   -> emberAfSendUnicastToBindingsWithCallback
      16   emberAfSendCommandUnicastWithCallback
        16   -> emberAfSendUnicastWithCallback
       0   emberAfSetCommandEndpoints
       8   emberAfSetExternalBuffer
      40   vFillBuffer
        40   -> emberAfLongStringLength
        40   -> emberAfNextSequence
        40   -> emberAfStringLength
        40   -> halCommonMemMove


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
      22  ?Subroutine0
      14  ?Subroutine1
      16  emAfZclBufferLen
          emAfZclBuffer
          emAfResponseLengthPtr
          emAfCommandApsFrame
      24  emberAfFillBuffer
      20  emberAfFillExternalBuffer
      24  emberAfFillExternalManufacturerSpecificBuffer
       6  emberAfGetCommandApsFrame
       4  emberAfSendCommandBroadcast
      14  emberAfSendCommandBroadcastWithCallback
      34  emberAfSendCommandInterPan
       4  emberAfSendCommandMulticast
      14  emberAfSendCommandMulticastWithCallback
       4  emberAfSendCommandUnicast
       4  emberAfSendCommandUnicastToBindings
      22  emberAfSendCommandUnicastToBindingsWithCallback
      22  emberAfSendCommandUnicastWithCallback
      12  emberAfSetCommandEndpoints
      14  emberAfSetExternalBuffer
     310  vFillBuffer

 
  16 bytes in section .bss
 572 bytes in section .text
 
 572 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none

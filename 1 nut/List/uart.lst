###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Apr/2016  13:01:55
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\hal\micro\cortexm3\uart.c
#    Command line =  
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\hal\micro\cortexm3\uart.c" -D
#        SWITCH_1_BUTTON -D NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D
#        CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"uart.c\"" -lC "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\List\" --diag_suppress Pa050 -o "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\Obj\" --debug --endian=little --cpu=Cortex-M3
#        --no_path_in_file_macros --separate_cluster_for_initialized_variables
#        -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        "D:\Work Space\Silabs\Zigbee\EmberZNet5.6.0-GA\hal\micro\cortexm3\" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\"
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\List\uart.lst
#    Object file  =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\Obj\uart.o
#
###############################################################################

D:\Work Space\Silabs\Zigbee\EmberZNet5.6.0-GA\hal\micro\cortexm3\uart.c
      1          /** @file hal/micro/cortexm3/uart.c
      2           *  @brief EM3XX UART Library.
      3           *
      4           * <!-- Copyright 2014 Silicon Laboratories, Inc.                        *80*-->
      5           */
      6          
      7          #include PLATFORM_HEADER
      8          #include "stack/include/ember.h"
      9          #include "stack/include/error.h"
     10          #include "stack/platform/micro/debug-channel.h"
     11          #include "hal/hal.h"
     12          #include "hal/micro/micro-types.h"
     13          
     14          #if (! defined(EMBER_STACK_IP))
     15          #include "stack/include/packet-buffer.h"
     16          #endif
     17          
     18          #include "app/util/serial/serial.h"
     19          
     20          // Allow some code to be disabled (and flash saved) if
     21          //  a port is unused or in low-level driver mode
     22          // port 0 is VUART
     23          #if (EMBER_SERIAL0_MODE == EMBER_SERIAL_UNUSED)
     24          #define EM_SERIAL0_ENABLED 0
     25          #define EM_SER0_PORT_EN(port) (FALSE)
     26          #else
     27          #define EM_SERIAL0_ENABLED 1
     28          #define EM_SER0_PORT_EN(port) ((port) == 0)
     29          #endif
     30          #if (EMBER_SERIAL0_MODE == EMBER_SERIAL_LOWLEVEL)
     31          #error Serial 0 (Virtual Uart) does not support LOWLEVEL mode
     32          #endif
     33          
     34          // port 1 is SC1
     35          #if !defined(EMBER_MICRO_HAS_SC1) \
     36          		|| (EMBER_SERIAL1_MODE == EMBER_SERIAL_UNUSED) \
     37          		|| (EMBER_SERIAL1_MODE == EMBER_SERIAL_LOWLEVEL)
     38          #define EM_SERIAL1_ENABLED 0
     39          #define EM_SER1_PORT_EN(port)     (FALSE)
     40          #define EM_SER1_PORT_FIFO(port)   (FALSE)
     41          #define EM_SER1_PORT_BUFFER(port) (FALSE)
     42          #else
     43          #define EM_SERIAL1_ENABLED 1
     44          #define EM_SER1_PORT_EN(port) ((port) == 1)
     45          #if     (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
     46          #define EM_SER1_PORT_FIFO(port)   EM_SER1_PORT_EN(port)
     47          #define EM_SER1_PORT_BUFFER(port) (FALSE)
     48          #else //Must be EMBER_SERIAL_BUFFER
     49          #define EM_SER1_PORT_FIFO(port)   (FALSE)
     50          #define EM_SER1_PORT_BUFFER(port) EM_SER1_PORT_EN(port)
     51          #endif
     52          #ifndef SOFTUART
     53          #define EM_PHYSICAL_UART
     54          #endif
     55          #endif
     56          
     57          // port 2 is SC3
     58          #if !defined(EMBER_MICRO_HAS_SC3) \
     59          		|| (EMBER_SERIAL2_MODE == EMBER_SERIAL_UNUSED) \
     60          		|| (EMBER_SERIAL2_MODE == EMBER_SERIAL_LOWLEVEL)
     61          #define EM_SERIAL2_ENABLED 0
     62          #define EM_SER2_PORT_EN(port)     (FALSE)
     63          #define EM_SER2_PORT_FIFO(port)   (FALSE)
     64          #define EM_SER2_PORT_BUFFER(port) (FALSE)
     65          #else
     66          #define EM_SERIAL2_ENABLED 1
     67          #define EM_SER2_PORT_EN(port) ((port) == 2)
     68          #if     (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
     69          #define EM_SER2_PORT_FIFO(port)   EM_SER2_PORT_EN(port)
     70          #define EM_SER2_PORT_BUFFER(port) (FALSE)
     71          #else //Must be EMBER_SERIAL_BUFFER
     72          #define EM_SER2_PORT_FIFO(port)   (FALSE)
     73          #define EM_SER2_PORT_BUFFER(port) EM_SER2_PORT_EN(port)
     74          #endif
     75          #define EM_PHYSICAL_UART
     76          #endif
     77          
     78          // port 3 is USB
     79          #if !defined(CORTEXM3_EM35X_USB) \
     80          		|| (EMBER_SERIAL3_MODE == EMBER_SERIAL_UNUSED) \
     81          		|| defined (USB_MSD) \
     82          		|| defined (USB_HID)
     83          #define EM_SERIAL3_ENABLED 0
     84          #define EM_SER3_PORT_EN(port) (FALSE)
     85          #ifdef USB_HID
     86          #include "hal/micro/cortexm3/usb/em_usb.h"
     87          #include "hal/micro/cortexm3/usb/hid/usbconfig.h"
     88          #include "hal/micro/cortexm3/usb/hid/descriptors.h"
     89          #endif
     90          #define EM_SER3_PORT_FIFO(port)   (FALSE)
     91          #define EM_SER3_PORT_BUFFER(port) (FALSE)
     92          #else
     93          #define EM_SERIAL3_ENABLED 1
     94          #define EM_SER3_PORT_EN(port) ((port) == 3)
     95          #if     (EMBER_SERIAL3_MODE == EMBER_SERIAL_FIFO)
     96          #define EM_SER3_PORT_FIFO(port)   EM_SER3_PORT_EN(port)
     97          #define EM_SER3_PORT_BUFFER(port) (FALSE)
     98          #else //Must be EMBER_SERIAL_BUFFER
     99          #define EM_SER3_PORT_FIFO(port)   (FALSE)
    100          #define EM_SER3_PORT_BUFFER(port) EM_SER3_PORT_EN(port)
    101          #endif
    102          
    103          #include "hal/micro/cortexm3/usb/em_usb.h"
    104          #include "hal/micro/cortexm3/usb/cdc/usbconfig.h"
    105          #include "hal/micro/cortexm3/usb/cdc/descriptors.h"
    106          sernum iSerialNumber =
    107          {
    108          		.len  = 32,
    109          		.type = USB_STRING_DESCRIPTOR,
    110          		.name = {'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'},
    111          		.name[ 16 ] = '\0'
    112          };
    113          #endif
    114          
    115          
    116          
    117          
    118          #if defined(EM_ENABLE_SERIAL_FIFO) && defined(EM_ENABLE_SERIAL_BUFFER)
    119          #define EM_SER_MULTI(expr) (expr)
    120          #else // None/Single/Same UARTs -- no need to runtime check their mode at all
    121          #define EM_SER_MULTI(expr) (TRUE)
    122          #endif
    123          
    124          // TODO
    125          #if EM_SERIAL1_ENABLED && (defined(EMBER_SERIAL1_RTSCTS) || defined(EMBER_SERIAL1_XONXOFF)) && EM_SERIAL2_ENABLED
    126          #error Flow control is not currently supported when using both physical UARTs
    127          #endif
    128          
    129          //State information for RX DMA Buffer operation
    130          typedef struct EmSerialBufferState {
    131          	const int16u fifoSize;
    132          	const int16u rxStartIndexB;
    133          	int16u prevCountA;
    134          	int16u prevCountB;
    135          	boolean waitingForTailA;
    136          	boolean waitingForTailB;
    137          	boolean waitingForInputToB;
    138          	EmberMessageBuffer holdBuf[2];
    139          } EmSerialBufferState;
    140          
    141          // to save flash and speed, if there is only one UART in use, make SCx_REG
    142          // and friends decay into a simple register access
    143          #if EM_SERIAL1_ENABLED && !EM_SERIAL2_ENABLED
    144          // Only Serial 1 is enabled
    145          #define SCx_REG(port, reg) SC1_##reg
    146          #define INT_SCxCFG(port) INT_SC1CFG
    147          #define INT_SCxFLAG(port) INT_SC1FLAG
    148          #define INT_SCx(port) INT_SC1
    149          #elif EM_SERIAL2_ENABLED && !EM_SERIAL1_ENABLED
    150          // Only Serial 2 is enabled
    151          #define SCx_REG(port, reg) SC3_##reg
    152          #define INT_SCxCFG(port) INT_SC3CFG
    153          #define INT_SCxFLAG(port) INT_SC3FLAG
    154          #define INT_SCx(port) INT_SC3
    155          #elif EM_SERIAL2_ENABLED && EM_SERIAL1_ENABLED
    156          // Both Serial 1 and 2 are enabled
    157          const int32u serialControllerBlockAddresses[] = { SC1_RXBEGA_ADDR, SC3_RXBEGA_ADDR };
    158          // index into the above array.
    159          // keep in mind port 1 is SC1 and port 2 is SC3 (this is the tricky one)
    160          #define SCx_REG(port, reg) (*((volatile int32u *)(                          \
    161          		(SC1_##reg##_ADDR - SC1_RXBEGA_ADDR)            \
    162          		+ serialControllerBlockAddresses[(port) - 1])))
    163          
    164          const int32u serialControllerIntCfgAddresses[] = { INT_SC1CFG_ADDR, INT_SC3CFG_ADDR };
    165          #define INT_SCxCFG(port) (*((volatile int32u *)serialControllerIntCfgAddresses[(port) - 1]))
    166          
    167          const int32u serialControllerIntFlagAddresses[]  = { INT_SC1FLAG_ADDR, INT_SC3FLAG_ADDR };
    168          #define INT_SCxFLAG(port) (*((volatile int32u *)serialControllerIntFlagAddresses[(port) - 1]))
    169          
    170          const int32u serialControllerNvecIntValues[] = { INT_SC1, INT_SC3 };
    171          #define INT_SCx(port) serialControllerNvecIntValues[(port) - 1]
    172          #endif
    173          
    174          #if defined(EZSP_UART) && \
    175          		!defined(EMBER_SERIAL1_RTSCTS) && \
    176          		!defined(EMBER_SERIAL1_XONXOFF)&& \
    177          		!defined(EZSP_USB)
    178          #error EZSP-UART requires either RTS/CTS or XON/XOFF flow control!
    179          #endif
    180          
    181          #ifdef EMBER_SERIAL1_RTSCTS
    182          #if EMBER_SERIAL1_MODE != EMBER_SERIAL_BUFFER
    183          #error "Illegal serial port 1 configuration"
    184          #endif
    185          #endif
    186          
    187          #ifdef EMBER_SERIAL2_RTSCTS
    188          #if EMBER_SERIAL2_MODE != EMBER_SERIAL_BUFFER
    189          #error "Illegal serial port 2 configuration"
    190          #endif
    191          #endif
    192          
    193          #ifdef EMBER_SERIAL1_XONXOFF
    194          #if EMBER_SERIAL1_MODE != EMBER_SERIAL_FIFO
    195          #error "Illegal serial port 1 configuration"
    196          #endif
    197          
    198          static void halInternalUart1ForceXon(void); // forward declaration
    199          
    200          static int8s xcmdCount;     // num XONs sent to host, written only by tx isr
    201          //-1 means an XOFF was sent last
    202          // 0 means ready to rx, but no XON has been sent
    203          // n>0 means ready to rx, and n XONs have been sent
    204          static int8u xonXoffTxByte; // if non-zero, an XON or XOFF byte to send ahead
    205          // of tx queue - cleared when byte is sent
    206          static int8u xonTimer;      // time when last data rx'ed from host, or when
    207          // an XON was sent (in 1/4 ticks)
    208          
    209          #define ASCII_XON         0x11  // requests host to pause sending
    210          #define ASCII_XOFF        0x13  // requests host to resume sending
    211          #define XON_REFRESH_TIME  8     // delay between repeat XONs (1/4 sec units)
    212          #define XON_REFRESH_COUNT 3     // max number of repeat XONs to send after 1st
    213          
    214          // Define thresholds for XON/XOFF flow control in terms of queue used values
    215          // Take into account the 4 byte transmit FIFO
    216          #if (EMBER_SERIAL1_RX_QUEUE_SIZE == 128)
    217          #define XON_LIMIT       16    // send an XON
    218          #define XOFF_LIMIT      96    // send an XOFF
    219          #elif (EMBER_SERIAL1_RX_QUEUE_SIZE == 64)
    220          #define XON_LIMIT       8
    221          #define XOFF_LIMIT      36
    222          #elif (EMBER_SERIAL1_RX_QUEUE_SIZE == 32)
    223          #define XON_LIMIT       2
    224          #define XOFF_LIMIT      8
    225          #elif (EMBER_SERIAL1_RX_QUEUE_SIZE > 32)
    226          #define XON_LIMIT       (EMBER_SERIAL1_RX_QUEUE_SIZE/8)
    227          #define XOFF_LIMIT      (EMBER_SERIAL1_RX_QUEUE_SIZE*3/4)
    228          #else
    229          #error "Serial port 1 receive buffer too small!"
    230          #endif
    231          #endif  // EMBER_SERIAL1_XONXOFF
    232          
    233          #ifdef EMBER_SERIAL2_XONXOFF
    234          #error "XON/XOFF is not supported on port 2"
    235          #endif
    236          
    237          #ifdef EMBER_SERIAL3_XONXOFF
    238          #error "XON/XOFF is not supported on port 3"
    239          #endif
    240          
    241          ////////////////////// SOFTUART Pin and Speed definitions //////////////////////
    242          //use a logic analyzer and trial and error to determine these values if
    243          //the SysTick time changes or you want to try a different baud
    244          //These were found using EMU 0x50
    245          #define FULL_BIT_TIME_SCLK  0x9C0UL  //9600 baud with FLKC @ SCLK(24MHz)
    246          #define START_BIT_TIME_SCLK 0x138UL  //9600 baud with FLKC @ SCLK(24MHz)
    247          //USE PB6 (GPIO22) for TXD
    248          #define CONFIG_SOFT_UART_TX_BIT() \
    249          		GPIO_PCCFGH = (GPIO_PCCFGH&(~PC6_CFG_MASK)) | (1 << PC6_CFG_BIT)
    250          #define SOFT_UART_TX_BIT(bit)  GPIO_PCOUT = (GPIO_PCOUT&(~PC6_MASK))|((bit)<<PC6_BIT)
    251          //USE PB7 (GPIO23) for RXD
    252          #define CONFIG_SOFT_UART_RX_BIT() \
    253          		GPIO_PCCFGH = (GPIO_PCCFGH&(~PC7_CFG_MASK)) | (4 << PC7_CFG_BIT)
    254          #define SOFT_UART_RX_BIT  ((GPIO_PCIN&PC7)>>PC7_BIT)
    255          ////////////////////// SOFTUART Pin and Speed definitions //////////////////////
    256          
    257          #if defined(EMBER_SERIAL1_RTSCTS) || defined(EMBER_SERIAL2_RTSCTS)
    258          void halInternalUartRxCheckRts(int8u port);
    259          #else
    260          #define halInternalUartRxCheckRts(x) do {} while(0)
    261          #endif
    262          
    263          #if defined(EMBER_SERIAL1_RTSCTS)
    264          // define this for backwards compatibility
    265          void halInternalUart1RxCheckRts( void )
    266          {
    267          	halInternalUartRxCheckRts(1);
    268          }
    269          #endif
    270          
    271          // Save flash if ports are undefined
    272          #if defined(EM_PHYSICAL_UART)
    273          

   \                                 In section .text, align 4, keep-with-next
    274          const int8u baudSettings[] = {
   \                     baudSettings:
   \   00000000   0x30 0x60          DC8 48, 96, 144, 192, 193, 194, 195, 148, 196, 149, 197, 92, 150, 198
   \              0x90 0xC0    
   \              0xC1 0xC2    
   \              0xC3 0x94    
   \              0xC4 0x95    
   \              0xC5 0x5C    
   \              0x96 0xC6    
   \   0000000E   0xAC 0x97          DC8 172, 151, 152, 153, 13, 0
   \              0x98 0x99    
   \              0x0D 0x00    
    275          		// This table is indexed by the supported BAUD_xxx enum from serial.h.
    276          		// The actual baud rate is encoded in a byte and converted algorithmically
    277          		// into the needed SCx register values based on system clock frequency
    278          		// Here each byte is divided into two 4-bit nibbles 0x<mul><exp> where:
    279          		// baud = <mul> * 100 * 2^<exp> when <exp> is <=10
    280          		//  and = <mul> * 100 * 10^(<exp>-10) when <exp> is >10
    281          		// This allows all supported baud rates (and many others) to be represented.
    282          		0x30, //  0 - BAUD_300    =  3 * 100 * 2^0
    283          		0x60, //  1 - BAUD_600    =  6 * 100 * 2^0
    284          		0x90, //  2 - BAUD_900    =  9 * 100 * 2^0
    285          		0xC0, //  3 - BAUD_1200   = 12 * 100 * 2^0
    286          		0xC1, //  4 - BAUD_2400   = 12 * 100 * 2^1
    287          		0xC2, //  5 - BAUD_4800   = 12 * 100 * 2^2
    288          		0xC3, //  6 - BAUD_9600   = 12 * 100 * 2^3
    289          		0x94, //  7 - BAUD_14400  =  9 * 100 * 2^4
    290          		0xC4, //  8 - BAUD_19200  = 12 * 100 * 2^4
    291          		0x95, //  9 - BAUD_28800  =  9 * 100 * 2^5
    292          		0xC5, // 10 - BAUD_38400  = 12 * 100 * 2^5
    293          		0x5C, // 11 - BAUD_50000  =  5 * 100 * 10^2
    294          		0x96, // 12 - BAUD_57600  =  9 * 100 * 2^6
    295          		0xC6, // 13 - BAUD_76800  = 12 * 100 * 2^6
    296          		0xAC, // 14 - BAUD_100000 = 10 * 100 * 10^2
    297          		0x97, // 15 - BAUD_115200 =  9 * 100 * 2^7
    298          		0x98, // 16 - BAUD_230400 =  9 * 100 * 2^8
    299          		0x99, // 17 - BAUD_460800 =  9 * 100 * 2^9
    300          #ifdef EMBER_SERIAL_BAUD_CUSTOM
    301          		EMBER_SERIAL_BAUD_CUSTOM, //Hook for custom baud rate, see BOARD_HEADER
    302          #else
    303          		0x9A, // 18 - BAUD_921600 =  9 * 100 * 2^10
    304          #endif
    305          };
    306          
    307          #endif // defined(EM_PHYSICAL_UART)
    308          
    309          #if EM_SERIAL1_ENABLED
    310          #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    311          #endif //(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    312          
    313          #if    SLEEPY_IP_MODEM_UART
    314          //This macro is used to manipulate TxD to avoid glitching it across sleep
    315          //which can lead to spurrious data or framing errors seen by peer
    316          #define SC1_TXD_GPIO(gpioCfg, state) do {                                   \
    317          		GPIO_PBCFGL = (GPIO_PBCFGL & ~PB1_CFG_MASK) | ((gpioCfg) << PB1_CFG_BIT); \
    318          		(state) ? (GPIO_PBSET = PB1) : (GPIO_PBCLR = PB1);                        \
    319          } while (0)
    320          #else //!SLEEPY_IP_MODEM_UART
    321          #define SC1_TXD_GPIO(gpioCfg, state) do { } while (0)
    322          #endif //SLEEPY_IP_MODEM_UART
    323          #endif // EM_SERIAL1_ENABLED
    324          
    325          // figure out how many buffer state structs we need
    326          #if (EM_SERIAL1_ENABLED                                                        \
    327          		&& EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)                              \
    328          		&& (EM_SERIAL2_ENABLED                                                     \
    329          				&& EMBER_SERIAL2_MODE == EMBER_SERIAL_BUFFER)                              \
    330          				&& (EM_SERIAL3_ENABLED                                                     \
    331          						&& EMBER_SERIAL3_MODE == EMBER_SERIAL_BUFFER)
    332          static EmSerialBufferState serialBufferStates[] = {
    333          		{ EMBER_SERIAL1_RX_QUEUE_SIZE,
    334          				(EMBER_SERIAL1_RX_QUEUE_SIZE/2),
    335          				0,
    336          				0,
    337          				FALSE,
    338          				FALSE,
    339          				FALSE,
    340          				{ EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    341          		},
    342          		{ EMBER_SERIAL2_RX_QUEUE_SIZE,
    343          				(EMBER_SERIAL2_RX_QUEUE_SIZE/2),
    344          				0,
    345          				0,
    346          				FALSE,
    347          				FALSE,
    348          				FALSE,
    349          				{ EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    350          		},
    351          		{ EMBER_SERIAL3_RX_QUEUE_SIZE,
    352          				(EMBER_SERIAL3_RX_QUEUE_SIZE/2),
    353          				0,
    354          				0,
    355          				FALSE,
    356          				FALSE,
    357          				FALSE,
    358          				{ EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    359          		}
    360          };
    361          
    362          #define BUFSTATE(port) (serialBufferStates + (port) - 1)
    363          #elif (EM_SERIAL1_ENABLED                                          \
    364          		&& EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    365          static EmSerialBufferState serialBufferState = {
    366          		EMBER_SERIAL1_RX_QUEUE_SIZE,
    367          		(EMBER_SERIAL1_RX_QUEUE_SIZE/2),
    368          		0,
    369          		0,
    370          		FALSE,
    371          		FALSE,
    372          		FALSE,
    373          		{ EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    374          };
    375          
    376          #define BUFSTATE(port) (&serialBufferState)
    377          #elif (EM_SERIAL2_ENABLED                                          \
    378          		&& EMBER_SERIAL2_MODE == EMBER_SERIAL_BUFFER)
    379          static EmSerialBufferState serialBufferState = {
    380          		EMBER_SERIAL2_RX_QUEUE_SIZE,
    381          		(EMBER_SERIAL2_RX_QUEUE_SIZE/2),
    382          		0,
    383          		0,
    384          		FALSE,
    385          		FALSE,
    386          		FALSE,
    387          		{ EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    388          };
    389          
    390          #define BUFSTATE(port) (&serialBufferState)
    391          #elif (EM_SERIAL3_ENABLED                                          \
    392          		&& EMBER_SERIAL3_MODE == EMBER_SERIAL_BUFFER)
    393          static EmSerialBufferState serialBufferState = {
    394          		EMBER_SERIAL3_RX_QUEUE_SIZE,
    395          		(EMBER_SERIAL3_RX_QUEUE_SIZE/2),
    396          		0,
    397          		0,
    398          		FALSE,
    399          		FALSE,
    400          		FALSE,
    401          		{ EMBER_NULL_MESSAGE_BUFFER, EMBER_NULL_MESSAGE_BUFFER }
    402          };
    403          
    404          #define BUFSTATE(port) (&serialBufferState)
    405          #endif
    406          
    407          // prototypes
    408          #if defined(EM_PHYSICAL_UART)
    409          static void halInternalUartTxIsr(int8u port);
    410          #endif
    411          static void uartErrorMark(int8u port, int8u errors);
    412          #if defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
    413          static void halInternalRestartUartDma(int8u port);
    414          #endif
    415          
    416          // init function for soft uart
    417          #ifdef SOFTUART
    418          static EmberStatus halInternalInitSoftUart()
    419          {
    420          	//make sure the TX bit starts at idle high
    421          	SOFT_UART_TX_BIT(1);
    422          	CONFIG_SOFT_UART_TX_BIT();
    423          	CONFIG_SOFT_UART_RX_BIT();
    424          
    425          	return EMBER_SUCCESS;
    426          }
    427          #endif
    428          
    429          #ifdef EM_PHYSICAL_UART

   \                                 In section .text, align 2, keep-with-next
    430          static void halInternalInitUartInterrupts(int8u port)
    431          {
    432          #if defined(EM_ENABLE_SERIAL_FIFO)
    433          	if (EM_SER_MULTI(EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port))) {
    434          		// Make the RX Valid interrupt level sensitive (instead of edge)
    435          		// SC1_INTMODE = SC_SPIRXVALMODE;
    436          		// Enable just RX interrupts; TX interrupts are controlled separately
    437          		INT_SCxCFG(port) |= (INT_SCRXVAL   |
    438          				INT_SCRXOVF   |
    439          				INT_SC1FRMERR |
    440          				INT_SC1PARERR);
   \                     halInternalInitUartInterrupts: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable13  ;; 0x4000a808
   \   00000002   0x6C01             LDR      R1,[R0, #+64]
   \   00000004   0xF441 0x41C0      ORR      R1,R1,#0x6000
   \   00000008   0xF041 0x0109      ORR      R1,R1,#0x9
   \   0000000C   0x6401             STR      R1,[R0, #+64]
    441          		INT_SCxFLAG(port) = 0xFFFF; // Clear any stale interrupts
   \   0000000E   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000012   0x6001             STR      R1,[R0, #+0]
    442          		INT_CFGSET = INT_SCx(port);
   \   00000014   0x2020             MOVS     R0,#+32
   \   00000016   0x....             LDR.N    R1,??DataTable13_1  ;; 0xe000e100
   \   00000018   0x6008             STR      R0,[R1, #+0]
    443          	}
    444          #endif
    445          #if defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
    446          	if (EM_SER_MULTI(EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port))) {
    447          		halInternalRestartUartDma(port);
    448          
    449          		// don't do this for port 1 if it's being used for EZSP
    450          #ifdef EZSP_UART
    451          		if (port != 1) {
    452          #endif
    453          			INT_SCxCFG(port) |= (INT_SCRXOVF   |
    454          					INT_SC1FRMERR |
    455          					INT_SC1PARERR);
    456          #ifdef EZSP_UART
    457          		}
    458          #endif
    459          
    460          		// The receive side of buffer mode does not require any interrupts.
    461          		// The transmit side of buffer mode requires interrupts, which
    462          		// will be configured on demand in halInternalStartUartTx(), so just
    463          		// enable the top level interrupt for the transmit side.
    464          		INT_SCxFLAG(port) = 0xFFFF; // Clear any stale interrupts
    465          		INT_CFGSET = INT_SCx(port); // Enable top-level interrupt
    466          
    467          #ifdef EMBER_SERIAL1_RTSCTS
    468          		// TODO refactor this into a variable that can be queried at runtime
    469          		if (EM_SER1_PORT_EN(port)) {
    470          			// Software-based RTS/CTS needs interrupts on DMA buffer unloading.
    471          			INT_SCxCFG(port) |= (INT_SCRXULDA | INT_SCRXULDB);
    472          			SCx_REG(port, UARTCFG) |= (SC_UARTFLOW | SC_UARTRTS);
    473          		}
    474          #endif
    475          #ifdef EMBER_SERIAL2_RTSCTS
    476          		if (EM_SER2_PORT_EN(port)) {
    477          			// Software-based RTS/CTS needs interrupts on DMA buffer unloading.
    478          			INT_SCxCFG(port) |= (INT_SCRXULDA | INT_SCRXULDB);
    479          			SCx_REG(port, UARTCFG) |= (SC_UARTFLOW | SC_UARTRTS);
    480          		}
    481          #endif
    482          	}
    483          #endif //defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
    484          }
   \   0000001A   0x4770             BX       LR               ;; return
    485          
    486          // init function for physical UART
    487          static EmberStatus halInternalInitPhysicalUart(int8u port,
    488          		SerialBaudRate rate,
    489          		SerialParity parity,
    490          		int8u stopBits)
    491          {
    492          	int32u tempcfg;
    493          
    494          	// set baud rate
    495          	// If rate is one of the BAUD_ settings from serial.h then use
    496          	// its baudSetting[] value from above, otherwise interpret it
    497          	// as a custom baudSetting[] encoded value.
    498          	if (rate < sizeof(baudSettings)/sizeof(*baudSettings)) {
    499          		rate = baudSettings[rate];
    500          	}
    501          	// Convert encoded rate into baud by extracting the <mul> and <exp>
    502          	// nibbles.  <mul> is always multiplied by 100.  For <exp> <= 10,
    503          	// that result is multipled by 2^<exp>; for <exp> > 10 that result
    504          	// is multipled by 10^(<exp>-10).
    505          	tempcfg = (int32u)(rate >> 4) * 100; // multiplier
    506          	rate &= 0x0F; // exponent
    507          	if (rate <= 10) {
    508          		tempcfg <<= rate;
    509          	} else {
    510          		while (rate-- > 10) {
    511          			tempcfg *= 10;
    512          		}
    513          	}
    514          	EmberStatus status = halInternalUartSetBaudRate(port, tempcfg);
    515          	if (status != EMBER_SUCCESS) {
    516          		return status;
    517          	}
    518          
    519          	// Default is always 8 data bits irrespective of parity setting,
    520          	// according to Lee, but hack overloads high-order nibble of stopBits to
    521          	// allow user to specify desired number of data bits:  7 or 8 (default).
    522          	if (((stopBits & 0xF0) >> 4) == 7) {
    523          		tempcfg = 0;
    524          	} else {
    525          		tempcfg = SC_UART8BIT;
    526          	}
    527          
    528          	// parity bits
    529          	if (parity == PARITY_ODD) {
    530          		tempcfg |= SC_UARTPAR | SC_UARTODD;
    531          	} else if( parity == PARITY_EVEN ) {
    532          		tempcfg |= SC_UARTPAR;
    533          	}
    534          
    535          	// stop bits
    536          	if ((stopBits & 0x0F) >= 2) {
    537          		tempcfg |= SC_UART2STP;
    538          	}
    539          
    540          	// set all of the above into the config register
    541          	SCx_REG(port, UARTCFG) = tempcfg;
    542          
    543          	// put the peripheral into UART mode
    544          	SCx_REG(port, MODE) = SC1_MODE_UART;
    545          
    546          	if (EM_SER1_PORT_EN(port)) { // port 1 special glitch-free case 
    547          		SC1_TXD_GPIO(GPIOCFG_OUT_ALT, 1); // Can Assign TxD glitch-free to UART now
    548          	}
    549          
    550          	halInternalInitUartInterrupts(port);
    551          
    552          #ifdef EMBER_SERIAL1_XONXOFF
    553          	if (EM_SER1_PORT_EN(port)) { // port 1 XON/XOFF special case
    554          		halInternalUart1ForceXon();
    555          	}
    556          #endif
    557          
    558          	return EMBER_SUCCESS;
    559          }
    560          #endif // EM_PHYSICAL_UART
    561          
    562          // initialize USB Virtual COM Port
    563          #if EM_SERIAL3_ENABLED
    564          static EmberStatus halInternalInitUsbVcp(void)
    565          {
    566          #if defined(CORTEXM3_EM35X_USB)
    567          	halResetWatchdog();
    568          
    569          	tokTypeMfgEui64 tokEui64;
    570          	halCommonGetMfgToken((void *)&tokEui64, TOKEN_MFG_EUI_64);
    571          
    572          	int8u i = 0;
    573          	int8u j = 0;
    574          	for(j = 0; j<8; j++) {
    575          		iSerialNumber.name[i++] = nibble2Ascii((tokEui64[j]>>4)&0xF);
    576          		iSerialNumber.name[i++] = nibble2Ascii((tokEui64[j]>>0)&0xF);
    577          	}
    578          
    579          	USBD_Init(&initstruct);
    580          
    581          	// USBD_Read(EP_OUT, receiveBuffer, 50, dataReceivedCallback);
    582          
    583          	//It is necessary to wait for the COM port on the host to become
    584          	//active before serial port3 can be used.
    585          	int16u startTime = halCommonGetInt16uMillisecondTick();
    586          	while(USBD_GetUsbState()!=USBD_STATE_CONFIGURED) {
    587          #ifdef BOOTLOADER
    588          		halUsbIsr();
    589          #endif
    590          		//Give ourselves a healthy 1 second for a COM port to open.
    591          		if(elapsedTimeInt16u(startTime,
    592          				halCommonGetInt16uMillisecondTick()) > 1000) {
    593          			return EMBER_SERIAL_INVALID_PORT;
    594          		}
    595          	}
    596          
    597          	return EMBER_SUCCESS;
    598          #else
    599          	return EMBER_SERIAL_INVALID_PORT;
    600          #endif
    601          }
    602          #endif
    603          
    604          #if (EM_SERIAL0_ENABLED ||\
    605          		EM_SERIAL1_ENABLED ||\
    606          		EM_SERIAL2_ENABLED ||\
    607          		EM_SERIAL3_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    608          EmberStatus halInternalUartInit(int8u port,
    609          		SerialBaudRate rate,
    610          		SerialParity parity,
    611          		int8u stopBits)
    612          {
   \                     halInternalUartInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4615             MOV      R5,R2
   \   00000004   0x461E             MOV      R6,R3
    613          #if EM_SERIAL0_ENABLED
    614          	if (EM_SER0_PORT_EN(port)) {
    615          		// Initialize the debug channel
    616          		return emDebugInit();
    617          	}
    618          #endif
    619          
    620          #ifdef SOFTUART
    621          	if (EM_SER1_PORT_EN(port)) {
    622          		return halInternalInitSoftUart();
    623          	}
    624          #endif
    625          
    626          #ifdef EM_PHYSICAL_UART
    627          	if (EM_SER1_PORT_EN(port) || EM_SER2_PORT_EN(port)) {
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD135             BNE.N    ??halInternalUartInit_0
    628          		return halInternalInitPhysicalUart(port, rate, parity, stopBits);
   \   0000000A   0x2913             CMP      R1,#+19
   \   0000000C   0xBF3C             ITT      CC 
   \   0000000E   0x.... 0x....      ADRCC.W  R0,baudSettings
   \   00000012   0x5C09             LDRBCC   R1,[R1, R0]
   \   00000014   0x0908             LSRS     R0,R1,#+4
   \   00000016   0x2264             MOVS     R2,#+100
   \   00000018   0x4350             MULS     R0,R2,R0
   \   0000001A   0xF001 0x010F      AND      R1,R1,#0xF
   \   0000001E   0x290B             CMP      R1,#+11
   \   00000020   0xDA03             BGE.N    ??halInternalUartInit_1
   \   00000022   0x4088             LSLS     R0,R0,R1
   \   00000024   0xE006             B.N      ??halInternalUartInit_2
   \                     ??halInternalUartInit_3: (+1)
   \   00000026   0x220A             MOVS     R2,#+10
   \   00000028   0x4350             MULS     R0,R2,R0
   \                     ??halInternalUartInit_1: (+1)
   \   0000002A   0x460A             MOV      R2,R1
   \   0000002C   0x1E51             SUBS     R1,R2,#+1
   \   0000002E   0xB2D2             UXTB     R2,R2
   \   00000030   0x2A0B             CMP      R2,#+11
   \   00000032   0xDAF8             BGE.N    ??halInternalUartInit_3
   \                     ??halInternalUartInit_2: (+1)
   \   00000034   0x4601             MOV      R1,R0
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       halInternalUartSetBaudRate
   \   0000003C   0xB9E0             CBNZ.N   R0,??halInternalUartInit_4
   \   0000003E   0x0930             LSRS     R0,R6,#+4
   \   00000040   0x2807             CMP      R0,#+7
   \   00000042   0xBF0C             ITE      EQ 
   \   00000044   0x2000             MOVEQ    R0,#+0
   \   00000046   0x2002             MOVNE    R0,#+2
   \   00000048   0x2D01             CMP      R5,#+1
   \   0000004A   0xBF08             IT       EQ 
   \   0000004C   0xF040 0x0018      ORREQ    R0,R0,#0x18
   \   00000050   0xD003             BEQ.N    ??halInternalUartInit_5
   \   00000052   0x2D02             CMP      R5,#+2
   \   00000054   0xBF08             IT       EQ 
   \   00000056   0xF040 0x0008      ORREQ    R0,R0,#0x8
   \                     ??halInternalUartInit_5: (+1)
   \   0000005A   0xF006 0x010F      AND      R1,R6,#0xF
   \   0000005E   0x2902             CMP      R1,#+2
   \   00000060   0xBFA8             IT       GE 
   \   00000062   0xF040 0x0004      ORRGE    R0,R0,#0x4
   \   00000066   0x....             LDR.N    R1,??DataTable13_2  ;; 0x4000c854
   \   00000068   0x6088             STR      R0,[R1, #+8]
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x6008             STR      R0,[R1, #+0]
   \   0000006E   0x.... 0x....      BL       halInternalInitUartInterrupts
   \   00000072   0x2000             MOVS     R0,#+0
    629          	}
   \   00000074   0xBD62             POP      {R1,R5,R6,PC}
    630          #endif
    631          
    632          #if EM_SERIAL3_ENABLED && defined(CORTEXM3_EM35X_USB)
    633          	if (EM_SER3_PORT_EN(port)) {
    634          		return halInternalInitUsbVcp();
    635          	}
    636          #endif
    637          
    638          	return EMBER_SERIAL_INVALID_PORT;
   \                     ??halInternalUartInit_0: (+1)
   \   00000076   0x2021             MOVS     R0,#+33
   \                     ??halInternalUartInit_4: (+1)
   \   00000078   0xBD62             POP      {R1,R5,R6,PC}    ;; return
    639          }
    640          #endif //(!defined(EM_SERIAL0_DISABLED) || !defined(EM_SERIAL1_DISABLED))
    641          
    642          #ifdef SOFTUART
    643          //this requires use of the SysTick counter and will destroy interrupt latency!
    644          static void softwareUartTxByte(int8u byte)
    645          {
    646          	int8u i;
    647          	// BIT_TIMEs were determined based on 24 MHz MCU clock.
    648          	// Scale 'em for the actual MCU clock in effect, with rounding.
    649          	// (Because the FCLK might not evenly divide by 1000000 or even 500000, use
    650          	// quad arithmetic dividing it by 250000.)
    651          	int16u fullBitTime = (int16u)(((FULL_BIT_TIME_SCLK
    652          			* (halMcuClockHz() / 250000UL)) + 48) / 96);
    653          
    654          	ATOMIC(
    655          			ST_RVR = fullBitTime; //set the SysTick reload value register
    656          	//enable core clock reference and the counter itself
    657          	ST_CSR = (ST_CSR_CLKSOURCE | ST_CSR_ENABLE);
    658          	while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    659          
    660          	//go low for start bit
    661          	SOFT_UART_TX_BIT(0); //go low for start bit
    662          	while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    663          
    664          	//loop over all 8 data bits transmitting each
    665          	for (i=0;i<8;i++) {
    666          		SOFT_UART_TX_BIT(byte&0x1); //data bit
    667          		while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    668          		byte = (byte>>1);
    669          	}
    670          
    671          	SOFT_UART_TX_BIT(1); //stop bit
    672          	while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    673          
    674          	//disable SysTick
    675          	ST_CSR = 0;
    676          	)
    677          }
    678          #endif //SOFTUART
    679          
    680          #if (EMBER_SERIAL3_MODE == EMBER_SERIAL_BUFFER)
    681          void usbReleaseBuffer( USB_Status_TypeDef status, int32u xferred, int32u remaining )
    682          {
    683          	assert(status == USB_STATUS_OK);
    684          	emberReleaseMessageBuffer(BUFSTATE(3)->holdBuf[0]);
    685          	BUFSTATE(3)->holdBuf[0] = EMBER_NULL_MESSAGE_BUFFER;
    686          }
    687          #endif
    688          

   \                                 In section .text, align 2, keep-with-next
    689          void halInternalStartUartTx(int8u port)
    690          {
    691          #if EM_SERIAL0_ENABLED
    692          	if (EM_SER0_PORT_EN(port)) {
    693          #if EMBER_SERIAL0_MODE == EMBER_SERIAL_FIFO
    694          		EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[0];
    695          		assert(q->tail == 0);
    696          		emDebugSendVuartMessage(q->fifo, q->used);
    697          		q->used = 0;
    698          		q->head = 0;
    699          		return;
    700          #elif EMBER_SERIAL0_MODE == EMBER_SERIAL_BUFFER
    701          		EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[0];
    702          		assert(q->nextByte == NULL);
    703          		emSerialBufferNextMessageIsr(q);
    704          		while (q->nextByte != NULL) {
    705          			emDebugSendVuartMessage(q->nextByte, (q->lastByte-q->nextByte)+1);
    706          			emSerialBufferNextBlockIsr(q,0);
    707          		}
    708          		return;
    709          #endif
    710          	}
    711          #endif //!defined(EM_SERIAL0_DISABLED)
    712          
    713          #if EM_SERIAL1_ENABLED && defined(SOFTUART)
    714          	if (EM_SER1_PORT_EN(port)) {
    715          		EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[1];
    716          		// Always configure the bit because other operations might have
    717          		// tried to compromise it
    718          		SOFT_UART_TX_BIT(1);
    719          		CONFIG_SOFT_UART_TX_BIT();
    720          		while (q->used > 0) {
    721          			int8u byte = FIFO_DEQUEUE(q, emSerialTxQueueWraps[1]);
    722          			softwareUartTxByte(byte);
    723          		}
    724          		return;
    725          	}
    726          #endif
    727          
    728          #if defined(EM_PHYSICAL_UART)
    729          	// If the port is configured, go ahead and start transmit
    730          #if defined(EM_ENABLE_SERIAL_FIFO)
    731          	if ((EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port)) &&
    732          			(SCx_REG(port, MODE) == SC1_MODE_UART)) {
   \                     halInternalStartUartTx: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD000             BEQ.N    ??halInternalStartUartTx_0
   \   00000004   0x4770             BX       LR
   \                     ??halInternalStartUartTx_0: (+1)
   \   00000006   0xB538             PUSH     {R3-R5,LR}
   \   00000008   0x....             LDR.N    R0,??DataTable13_2  ;; 0x4000c854
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD10F             BNE.N    ??halInternalStartUartTx_1
    733          		// Ensure UART TX interrupts are enabled,
    734          		// and call the ISR to send any pending output
    735          		ATOMIC(
    736          				// Enable TX interrupts
    737          				INT_SCxCFG(port) |= (INT_SCTXFREE | INT_SCTXIDLE);
    738          		// Pretend we got a tx interrupt
    739          		halInternalUartTxIsr(port);
    740          		)
   \   00000010   0x.... 0x....      BL       _disableBasePri
   \   00000014   0x4605             MOV      R5,R0
   \   00000016   0x....             LDR.N    R0,??DataTable13_3  ;; 0x4000a848
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0xF041 0x0106      ORR      R1,R1,#0x6
   \   0000001E   0x6001             STR      R1,[R0, #+0]
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       halInternalUartTxIsr
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0xE8BD 0x4026      POP      {R1,R2,R5,LR}
   \   0000002C   0x.... 0x....      B.W      _writeBasePri
    741                  						return;
    742          	}
    743          #endif // defined(EM_ENABLE_SERIAL_FIFO)
    744          #if defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
    745          	if ((EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port)) &&
    746          			(SCx_REG(port, MODE) == SC1_MODE_UART)) {
    747          		// Ensure UART TX interrupts are enabled,
    748          		// and call the ISR to send any pending output
    749          		ATOMIC(
    750          				INT_SCxCFG(port) |= (INT_SCTXULDA | INT_SCTXULDB | INT_SCTXIDLE);
    751          		// Pretend we got a tx interrupt
    752          		halInternalUartTxIsr(port);
    753          		)
    754                  						return;
    755          	}
    756          #endif // defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
    757          #endif // EM_PHYSICAL_UART
    758          
    759          #if EM_SERIAL3_ENABLED
    760          	if (EM_SER3_PORT_EN(port)) {
    761          #if defined(CORTEXM3_EM35X_USB)
    762          #if (EMBER_SERIAL3_MODE == EMBER_SERIAL_FIFO)
    763          		usbTxData();
    764          #else //Must be EMBER_SERIAL_BUFFER
    765          		EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[3];
    766          		assert( !((q->used == 0) && (q->nextByte != NULL)) );
    767          		while ( q->used > 0 ) {
    768          			if ( q->nextByte == NULL ) {
    769          				// new message pending, but nextByte not set up yet
    770          				emSerialBufferNextMessageIsr(q);
    771          			}
    772          			if (!USBD_EpIsBusy(EP_IN))
    773          			{
    774          				USBD_Write( EP_IN, q->nextByte, (int32u)q->lastByte - (int32u)q->nextByte + 1, (USB_XferCompleteCb_TypeDef) &usbReleaseBuffer );
    775          
    776          				if (BUFSTATE(3)->holdBuf[0] != EMBER_NULL_MESSAGE_BUFFER)
    777          					emberReleaseMessageBuffer(BUFSTATE(3)->holdBuf[0]);
    778          				BUFSTATE(3)->holdBuf[0] = q->currentBuffer;
    779          				emberHoldMessageBuffer(BUFSTATE(3)->holdBuf[0]);
    780          				emSerialBufferNextBlockIsr(q, 3);
    781          			}
    782          			else
    783          			{
    784          				break;
    785          			}
    786          		} // while ( q->used > 0 )
    787          #endif
    788          		return;
    789          #endif
    790          	}
    791          #endif // EM_SERIAL3_ENABLED && EMBER_SERIAL3_MODE == EMBER_SERIAL_FIFO
    792          }
   \                     ??halInternalStartUartTx_1: (+1)
   \   00000030   0xBD23             POP      {R0,R1,R5,PC}    ;; return
    793          

   \                                 In section .text, align 2, keep-with-next
    794          void halInternalStopUartTx(int8u port)
    795          {
    796          	// Nothing for port 0 (virtual uart)
    797          
    798          #if defined(EM_PHYSICAL_UART)
    799          #if defined(EM_ENABLE_SERIAL_FIFO)
    800          	if (EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port)) {
   \                     halInternalStopUartTx: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD104             BNE.N    ??halInternalStopUartTx_0
    801          		// Disable TX Interrupts
    802          		INT_SCxCFG(port) &= ~(INT_SCTXFREE | INT_SCTXIDLE);
   \   00000004   0x....             LDR.N    R0,??DataTable13_3  ;; 0x4000a848
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF021 0x0106      BIC      R1,R1,#0x6
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    803          	}
    804          #endif // defined(EM_ENABLE_SERIAL_FIFO)
    805          #if defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
    806          	if (EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port)) {
    807          		// Ensure DMA operations are complete before shutting off interrupts,
    808          		// otherwise we might miss an important interrupt and cause a
    809          		// packet buffer leak, e.g.
    810          		while (SCx_REG(port, DMACTRL) & (SC_TXLODA | SC_TXLODB)) {}
    811          		while ( !(SCx_REG(port, UARTSTAT) & SC_UARTTXIDLE) ) {}
    812          		// Disable TX Interrupts
    813          		INT_SCxCFG(port) &= ~(INT_SCTXULDA | INT_SCTXULDB | INT_SCTXIDLE);
    814          	}
    815          #endif // defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
    816          #endif // defined(EM_PHYSICAL_UART)
    817          }
   \                     ??halInternalStopUartTx_0: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    818          
    819          
    820          //full blocking, no queue overflow issues, can be used in or out of int context
    821          //does not return until character is transmitted.

   \                                 In section .text, align 2, keep-with-next
    822          EmberStatus halInternalForceWriteUartData(int8u port, int8u *data, int8u length)
    823          {
    824          #if EM_SERIAL0_ENABLED
    825          	if (EM_SER0_PORT_EN(port)) {
    826          		emDebugSendVuartMessage(data, length);
    827          		return EMBER_SUCCESS;
    828          	}
    829          #endif
    830          
    831          #ifdef SOFTUART
    832          	if (EM_SER1_PORT_EN(port)) {
    833          		//always configure the bit because other operations might have
    834          		//tried to compromise it
    835          		SOFT_UART_TX_BIT(1);
    836          		CONFIG_SOFT_UART_TX_BIT();
    837          		while (length--) {
    838          			SC1_DATA = *data; // why is the soft UART using the physical UART? --RDM
    839          			softwareUartTxByte(*data);
    840          			data++;
    841          		}
    842          		return EMBER_SUCCESS;
    843          	}
    844          #endif
    845          
    846          #if defined(EM_PHYSICAL_UART)
    847          	//if the port is configured, go ahead and transmit
    848          	if ((EM_SER1_PORT_EN(port) || EM_SER2_PORT_EN(port)) &&
    849          			(SCx_REG(port, MODE) == SC1_MODE_UART)) {
   \                     halInternalForceWriteUartData: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xBF02             ITTT     EQ 
   \   00000004   0x....             LDREQ.N  R0,??DataTable13_4  ;; 0x4000c83c
   \   00000006   0x6983             LDREQ    R3,[R0, #+24]
   \   00000008   0x2B01             CMPEQ    R3,#+1
   \   0000000A   0xD007             BEQ.N    ??halInternalForceWriteUartData_0
    850          		while (length--) {
    851          			//spin until data register has room for more data
    852          			while (!(SCx_REG(port, UARTSTAT) & SC_UARTTXFREE)) {}
    853          			SCx_REG(port, DATA) = *data;
    854          			data++;
    855          		}
    856          
    857          		//spin until TX complete (TX is idle)
    858          		while (!(SCx_REG(port, UARTSTAT) & SC_UARTTXIDLE)) {}
    859          
    860          		return EMBER_SUCCESS;
    861          	}
    862          #endif // defined(EM_PHYSICAL_UART)
    863          
    864          #if EM_SERIAL3_ENABLED
    865          	if (EM_SER3_PORT_EN(port)) {
    866          #if defined(CORTEXM3_EM35X_USB)
    867          		//This function will block until done sending all the data.
    868          		usbForceTxData(data, length);
    869          		return EMBER_SUCCESS;
    870          #endif
    871          	}
    872          #endif // EM_SERIAL3_ENABLED
    873          
    874          	return EMBER_SERIAL_INVALID_PORT;
   \   0000000C   0x2021             MOVS     R0,#+33
   \   0000000E   0x4770             BX       LR               ;; return
   \                     ??halInternalForceWriteUartData_1: (+1)
   \   00000010   0x68C3             LDR      R3,[R0, #+12]
   \   00000012   0x075B             LSLS     R3,R3,#+29
   \   00000014   0xD5FC             BPL.N    ??halInternalForceWriteUartData_1
   \   00000016   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \   0000001A   0x6003             STR      R3,[R0, #+0]
   \                     ??halInternalForceWriteUartData_0: (+1)
   \   0000001C   0x4613             MOV      R3,R2
   \   0000001E   0x1E5A             SUBS     R2,R3,#+1
   \   00000020   0xB2DB             UXTB     R3,R3
   \   00000022   0x2B00             CMP      R3,#+0
   \   00000024   0xD1F4             BNE.N    ??halInternalForceWriteUartData_1
   \                     ??halInternalForceWriteUartData_2: (+1)
   \   00000026   0x68C1             LDR      R1,[R0, #+12]
   \   00000028   0x0649             LSLS     R1,R1,#+25
   \   0000002A   0xD5FC             BPL.N    ??halInternalForceWriteUartData_2
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x4770             BX       LR
    875          }
    876          
    877          // Useful for waiting on serial port characters before interrupts have been
    878          // turned on.

   \                                 In section .text, align 2, keep-with-next
    879          EmberStatus halInternalForceReadUartByte(int8u port, int8u* dataByte)
    880          {
    881          	EmberStatus err = EMBER_SUCCESS;
   \                     halInternalForceReadUartByte: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    882          
    883          #if EM_SERIAL0_ENABLED
    884          	if (EM_SER0_PORT_EN(port)) {
    885          		EmSerialFifoQueue *q = emSerialRxQueues[0];
    886          		ATOMIC(
    887          				if (q->used == 0) {
    888          					WAKE_CORE = WAKE_CORE_FIELD;
    889          				}
    890          		if (q->used > 0) {
    891          			*dataByte = FIFO_DEQUEUE(q, emSerialRxQueueWraps[0]);
    892          		} else {
    893          			err = EMBER_SERIAL_RX_EMPTY;
    894          		}
    895          		)
    896          	}
    897          #endif // EM_SERIAL0_ENABLED
    898          
    899          #if defined(EM_PHYSICAL_UART)
    900          #if defined(EM_ENABLE_SERIAL_FIFO)
    901          	if (EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port)) {
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD106             BNE.N    ??halInternalForceReadUartByte_0
    902          		if (SCx_REG(port, UARTSTAT) & SC_UARTRXVAL) {
   \   00000006   0x....             LDR.N    R0,??DataTable13_4  ;; 0x4000c83c
   \   00000008   0x68C3             LDR      R3,[R0, #+12]
   \   0000000A   0x079B             LSLS     R3,R3,#+30
   \   0000000C   0xBF46             ITTE     MI 
    903          			*dataByte = (int8u) SCx_REG(port, DATA);
   \   0000000E   0x6800             LDRMI    R0,[R0, #+0]
   \   00000010   0x7008             STRBMI   R0,[R1, #+0]
    904          		} else {
    905          			err = EMBER_SERIAL_RX_EMPTY;
   \   00000012   0x2226             MOVPL    R2,#+38
    906          		}
    907          	}
    908          #endif
    909          #if defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
    910          	if (EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port)) {
    911          		//When in buffer mode, the DMA channel is active and the RXVALID bit (as
    912          		//used above in FIFO mode) will never get set.  To maintain the DMA/Buffer
    913          		//model of operation, we need to break the conceptual model in this function
    914          		//and make a function call upwards away from the hardware.  The ReadByte
    915          		//function calls back down into halInternalUartRxPump and forces the
    916          		//sequencing of the serial queues and the DMA buffer, resulting in a forced
    917          		//read byte being returned if it is there.
    918          		if (emberSerialReadByte(port, dataByte) != EMBER_SUCCESS) {
    919          			err = EMBER_SERIAL_RX_EMPTY;
    920          		}
    921          	}
    922          #endif // defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
    923          #endif // defined(EM_PHYSICAL_UART)
    924          
    925          	return err;
   \                     ??halInternalForceReadUartByte_0: (+1)
   \   00000014   0x4610             MOV      R0,R2
   \   00000016   0x4770             BX       LR               ;; return
    926          }
    927          
    928          // blocks until the text actually goes out

   \                                 In section .text, align 2, keep-with-next
    929          void halInternalWaitUartTxComplete(int8u port)
    930          {
   \                     halInternalWaitUartTxComplete: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    931          	halResetWatchdog();
   \   00000004   0x.... 0x....      BL       halInternalResetWatchDog
    932          
    933          	// Nothing to do for port 0 (virtual uart)
    934          
    935          #if defined(EM_PHYSICAL_UART)
    936          	if (EM_SER1_PORT_EN(port) || EM_SER2_PORT_EN(port)) {
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD103             BNE.N    ??halInternalWaitUartTxComplete_0
    937          		while ( !(SCx_REG(port, UARTSTAT) & SC_UARTTXIDLE) ) {}
   \                     ??halInternalWaitUartTxComplete_1: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable13_5  ;; 0x4000c848
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0640             LSLS     R0,R0,#+25
   \   00000012   0xD5FB             BPL.N    ??halInternalWaitUartTxComplete_1
    938          		return;
    939          	}
    940          #endif // defined(EM_PHYSICAL_UART)
    941          }
   \                     ??halInternalWaitUartTxComplete_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    942          
    943          // Debug Channel calls this ISR to push up data it has received

   \                                 In section .text, align 2, keep-with-next
    944          void halStackReceiveVuartMessage(int8u *data, int8u length)
    945          {
    946          #if EM_SERIAL0_ENABLED
    947          	EmSerialFifoQueue *q = emSerialRxQueues[0];
    948          
    949          	while (length--) {
    950          		//Use (emSerialRxQueueSizes - 1) so that the FIFO never completely fills
    951          		//and the head never wraps around to the tail
    952          		if ((q->used < (emSerialRxQueueSizes[0] - 1))) {
    953          			FIFO_ENQUEUE(q,*data++,emSerialRxQueueWraps[0]);
    954          		} else {
    955          			uartErrorMark(0, EMBER_SERIAL_RX_OVERFLOW);
    956          			return;  // no sense in trying to enqueue the rest
    957          		}
    958          	}
    959          #endif // EM_SERIAL0_ENABLED
    960          }
   \                     halStackReceiveVuartMessage: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    961          
    962          #if defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
    963          static void halInternalRestartUartDma(int8u port)
    964          {
    965          	//Reset the DMA software and restart it.
    966          	EmSerialFifoQueue *q = emSerialRxQueues[port];
    967          	int32u startAddress = (int32u)q->fifo;
    968          	int8u head;
    969          	int8u tail;
    970          	int8u loadA = 0;
    971          	int8u loadB = 0;
    972          	BUFSTATE(port)->prevCountA = 0;
    973          	BUFSTATE(port)->prevCountB = 0;
    974          	BUFSTATE(port)->waitingForTailA = FALSE;
    975          	BUFSTATE(port)->waitingForTailB = FALSE;
    976          	BUFSTATE(port)->waitingForInputToB = FALSE;
    977          	//reload all defaults addresses - they will be adjusted below if needed
    978          	SCx_REG(port, DMACTRL) = SC_RXDMARST;
    979          	SCx_REG(port, RXBEGA) =  startAddress;
    980          	SCx_REG(port, RXENDA) = (startAddress + BUFSTATE(port)->fifoSize/2 - 1);
    981          	SCx_REG(port, RXBEGB) =  (startAddress + BUFSTATE(port)->fifoSize/2);
    982          	SCx_REG(port, RXENDB) = (startAddress + BUFSTATE(port)->fifoSize - 1);
    983          
    984          	//adjust buffer addresses as needed and reload available buffers
    985          	if ( q->used != BUFSTATE(port)->fifoSize ) {
    986          		//we can only reload if the FIFO isn't full!
    987          		//the FIFO is not empty or full, figure out what to do:
    988          		//at this point we know we always have to adjust ST_ADDR to the head
    989          		//we need to know which buffer the head is in, and always load that buff
    990          		if ((q->head) < BUFSTATE(port)->rxStartIndexB) {
    991          			SCx_REG(port, RXBEGA) = startAddress + (q->head);
    992          			loadA++;
    993          		} else {
    994          			SCx_REG(port, RXBEGB) = startAddress + (q->head);
    995          			loadB++;
    996          		}
    997          		//check to see if the head and the tail are not in the same buffer
    998          		if((q->tail)/(BUFSTATE(port)->rxStartIndexB)) {
    999          			tail = TRUE;  //Tail in B buffer
   1000          		} else {
   1001          			tail = FALSE; //Tail in A buffer
   1002          		}
   1003          
   1004          		if((q->head)/(BUFSTATE(port)->rxStartIndexB)) {
   1005          			head = TRUE;  //Head in B buffer
   1006          		} else {
   1007          			head = FALSE; //Head in A buffer
   1008          		}
   1009          
   1010          		if ( tail != head ) {
   1011          			//the head and the tail are in different buffers
   1012          			//we need to flag the buffer the tail is in so the Pump function does
   1013          			//not try to reenable it until it has been drained like normal.
   1014          			if ((q->tail)<BUFSTATE(port)->rxStartIndexB) {
   1015          				BUFSTATE(port)->waitingForTailA = TRUE;
   1016          			} else {
   1017          				BUFSTATE(port)->waitingForTailB = TRUE;
   1018          			}
   1019          		} else {
   1020          			//the head and the tail are in the same buffers
   1021          			if (q->used <= BUFSTATE(port)->rxStartIndexB) {
   1022          				//The serial FIFO is less no more than half full!
   1023          				if (!loadB) {
   1024          					//the head is in B, and we're capable of loading A
   1025          					//BUT: we can't activate A because the DMA defaults to A first,
   1026          					//  and it needs to start using B first to fill from the head
   1027          					//  SO, only load A if B hasn't been marked yet for loading.
   1028          					loadA++;
   1029          				} else {
   1030          					//B is loaded and waiting for data, A is being supressed until
   1031          					//B receives at least one byte so A doesn't prematurely load and
   1032          					//steal bytes meant for B first.
   1033          					BUFSTATE(port)->waitingForTailA = TRUE;
   1034          					BUFSTATE(port)->waitingForInputToB = TRUE;
   1035          				}
   1036          				//We can always loadB at this point thanks to our waiting* flags.
   1037          				loadB++;
   1038          			} else {
   1039          				//The serial FIFO is more than half full!
   1040          				//Since this case requires moving an end address of a buffer, which
   1041          				//severely breaks DMA'ing into a FIFO, we cannot do anything.
   1042          				//Doing nothing is ok because we are more than half full anyways,
   1043          				//and under normal operation we would only load a buffer when our
   1044          				//used count is less than half full.
   1045          				//Configure so the Pump function takes over when the serial FIFO drains
   1046          				SCx_REG(port, RXBEGA) =  startAddress;
   1047          				SCx_REG(port, RXBEGB) =  (startAddress + BUFSTATE(port)->fifoSize/2);
   1048          				loadA = 0;
   1049          				loadB = 0;
   1050          				BUFSTATE(port)->waitingForTailA = TRUE;
   1051          				BUFSTATE(port)->waitingForTailB = TRUE;
   1052          			}
   1053          		}
   1054          
   1055          		//Address are set, flags are set, DMA is ready, so now we load buffers
   1056          		if (loadA) {
   1057          			SCx_REG(port, DMACTRL) = SC_RXLODA;
   1058          		}
   1059          		if (loadB) {
   1060          			SCx_REG(port, DMACTRL) = SC_RXLODB;
   1061          		}
   1062          	} else {
   1063          		//we're full!!  doh!  have to wait for the FIFO to drain
   1064          		BUFSTATE(port)->waitingForTailA = TRUE;
   1065          		BUFSTATE(port)->waitingForTailB = TRUE;
   1066          	}
   1067          }
   1068          #endif // defined(EM_ENABLE_SERIAL_BUFFER)
   1069          
   1070          #ifdef EM_PHYSICAL_UART

   \                                 In section .text, align 2, keep-with-next
   1071          void halInternalUartRxIsr(int8u port, int16u causes)
   1072          {
   \                     halInternalUartRxIsr: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   1073          #if defined(EM_ENABLE_SERIAL_FIFO)
   1074          	if (EM_SER_MULTI(EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port))) {
   1075          		EmSerialFifoQueue *q = emSerialRxQueues[port];
   \   00000004   0x....             LDR.N    R1,??DataTable13_6
   \   00000006   0x....             LDR.N    R3,??DataTable13_7
   \   00000008   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   0000000C   0x....             LDR.N    R4,??DataTable13_8
   \   0000000E   0x....             LDR.N    R5,??DataTable13_9
   \   00000010   0x....             LDR.N    R6,??DataTable13_10
   \   00000012   0x.... 0x....      LDR.W    R8,??DataTable13_4  ;; 0x4000c83c
   \   00000016   0xE019             B.N      ??halInternalUartRxIsr_0
   1076          
   1077          		// At present we really don't care which interrupt(s)
   1078          		// occurred, just that one did.  Loop reading RXVALID
   1079          		// data (loop is necessary for bursty data otherwise
   1080          		// we could leave with RXVALID and not get another
   1081          		// RXVALID interrupt), processing any errors noted
   1082          		// along the way.
   1083          		while ( SCx_REG(port, UARTSTAT) & SC_UARTRXVAL ) {
   1084          			int8u errors = SCx_REG(port, UARTSTAT) & (SC_UARTFRMERR |
   1085          					SC_UARTRXOVF  |
   1086          					SC_UARTPARERR );
   1087          			int8u incoming = (int8u) SCx_REG(port, DATA);
   1088          #if     (CORTEXM3_EM35X_GEN3 && defined(ENABLE_OSC24M) && (ENABLE_OSC24M != 24) \
   1089          		&& (ENABLE_OSC24M != 24000) && (ENABLE_OSC24M != 24000000))
   1090          			// Hack workaround for EMLIPARI-101 UART HW bug on non-24 MHz SysClk
   1091          			static boolean uartFixTried = FALSE;
   1092          			if ( (errors & SC_UARTFRMERR) && (incoming != 0 /* a BRK */) ) {
   1093          				if (!uartFixTried) {
   1094          					// Try to correct for this HW bug by inverting fraction bit
   1095          					SCx_REG(port, UARTFRAC) = !SCx_REG(port, UARTFRAC);
   1096          					uartFixTried = TRUE;
   1097          				}
   1098          				incoming >>= 1;
   1099          				errors &= ~SC_UARTFRMERR;
   1100          			}
   1101          #endif //(CORTEXM3_EM35X_GEN3 && defined(ENABLE_OSC24M) && ...)
   1102          
   1103          			if ( (errors == 0) && (q->used < (emSerialRxQueueSizes[port]-1)) ) {
   \                     ??halInternalUartRxIsr_1: (+1)
   \   00000018   0xF8B2 0xE004      LDRH     LR,[R2, #+4]
   \   0000001C   0xF836 0x7010      LDRH     R7,[R6, R0, LSL #+1]
   \   00000020   0x1E7F             SUBS     R7,R7,#+1
   \   00000022   0x45BE             CMP      LR,R7
   \   00000024   0xDA26             BGE.N    ??halInternalUartRxIsr_2
   1104          #ifdef EMBER_SERIAL1_XONXOFF
   1105          				if (EM_SER1_PORT_FIFO(port)) {
   1106          					// Discard any XON or XOFF bytes received
   1107          					if ( (incoming != ASCII_XON) && (incoming != ASCII_XOFF) ) {
   1108          						FIFO_ENQUEUE(q, incoming, emSerialRxQueueWraps[port]);
   1109          					}
   1110          				} else {
   1111          					FIFO_ENQUEUE(q, incoming, emSerialRxQueueWraps[port]);
   1112          				}
   1113          #else
   1114          				FIFO_ENQUEUE(q, incoming, emSerialRxQueueWraps[port]);
   \   00000026   0xF8B2 0xE000      LDRH     LR,[R2, #+0]
   \   0000002A   0x4496             ADD      LR,LR,R2
   \   0000002C   0xF88E 0xC006      STRB     R12,[LR, #+6]
   \   00000030   0x8817             LDRH     R7,[R2, #+0]
   \   00000032   0xF835 0xE010      LDRH     LR,[R5, R0, LSL #+1]
   \   00000036   0xF107 0x0C01      ADD      R12,R7,#+1
   \   0000003A   0xFB9C 0xF7FE      SDIV     R7,R12,LR
   \   0000003E   0xFB0E 0xCC17      MLS      R12,LR,R7,R12
   \   00000042   0xF8A2 0xC000      STRH     R12,[R2, #+0]
   \   00000046   0x8897             LDRH     R7,[R2, #+4]
   \   00000048   0x1C7F             ADDS     R7,R7,#+1
   \   0000004A   0x8097             STRH     R7,[R2, #+4]
   1115          #endif
   1116          			} else {
   \                     ??halInternalUartRxIsr_0: (+1)
   \   0000004C   0xF8D8 0x700C      LDR      R7,[R8, #+12]
   \   00000050   0x07BF             LSLS     R7,R7,#+30
   \   00000052   0xD53C             BPL.N    ??halInternalUartRxIsr_3
   \   00000054   0xF8D8 0x700C      LDR      R7,[R8, #+12]
   \   00000058   0xF8D8 0xC000      LDR      R12,[R8, #+0]
   \   0000005C   0xF017 0x0738      ANDS     R7,R7,#0x38
   \   00000060   0xD0DA             BEQ.N    ??halInternalUartRxIsr_1
   1117          				// Translate error code
   1118          				if ( errors == 0 ) {
   1119          					errors = EMBER_SERIAL_RX_OVERFLOW;
   1120          					HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_OVERFLOW_ERROR);
   1121          				} else if ( errors & SC_UARTRXOVF ) {
   \   00000062   0xEA5F 0x7C07      LSLS     R12,R7,#+28
   \   00000066   0xD408             BMI.N    ??halInternalUartRxIsr_4
   1122          					errors = EMBER_SERIAL_RX_OVERRUN_ERROR;
   1123          					HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_OVERRUN_ERROR);
   1124          				} else if ( errors & SC_UARTFRMERR ) {
   \   00000068   0xEA5F 0x6CC7      LSLS     R12,R7,#+27
   \   0000006C   0xD508             BPL.N    ??halInternalUartRxIsr_5
   1125          					errors = EMBER_SERIAL_RX_FRAME_ERROR;
   \   0000006E   0xF04F 0x0E24      MOV      LR,#+36
   \   00000072   0xE00B             B.N      ??halInternalUartRxIsr_6
   1126          					HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_FRAMING_ERROR);
   1127          				} else if ( errors & SC_UARTPARERR ) {
   \                     ??halInternalUartRxIsr_2: (+1)
   \   00000074   0xF04F 0x0E23      MOV      LR,#+35
   \   00000078   0xE008             B.N      ??halInternalUartRxIsr_6
   \                     ??halInternalUartRxIsr_4: (+1)
   \   0000007A   0xF04F 0x0E27      MOV      LR,#+39
   \   0000007E   0xE005             B.N      ??halInternalUartRxIsr_6
   \                     ??halInternalUartRxIsr_5: (+1)
   \   00000080   0x06BF             LSLS     R7,R7,#+26
   \   00000082   0xBF4C             ITE      MI 
   1128          					errors = EMBER_SERIAL_RX_PARITY_ERROR;
   \   00000084   0xF04F 0x0E25      MOVMI    LR,#+37
   1129          				} else { // unknown
   1130          					errors = EMBER_ERR_FATAL;
   \   00000088   0xF04F 0x0E01      MOVPL    LR,#+1
   1131          				}
   1132          				uartErrorMark(port, errors);
   \                     ??halInternalUartRxIsr_6: (+1)
   \   0000008C   0xF851 0xC020      LDR      R12,[R1, R0, LSL #+2]
   \   00000090   0x5D07             LDRB     R7,[R0, R4]
   \   00000092   0xB937             CBNZ.N   R7,??halInternalUartRxIsr_7
   \   00000094   0xF8BC 0x7000      LDRH     R7,[R12, #+0]
   \   00000098   0xF823 0x7010      STRH     R7,[R3, R0, LSL #+1]
   \   0000009C   0xF800 0xE004      STRB     LR,[R0, R4]
   \   000000A0   0xE7D4             B.N      ??halInternalUartRxIsr_0
   \                     ??halInternalUartRxIsr_7: (+1)
   \   000000A2   0xF833 0x7010      LDRH     R7,[R3, R0, LSL #+1]
   \   000000A6   0xF8AC 0x7000      STRH     R7,[R12, #+0]
   \   000000AA   0xF800 0xE004      STRB     LR,[R0, R4]
   \   000000AE   0xF8BC 0x7000      LDRH     R7,[R12, #+0]
   \   000000B2   0xF8BC 0xE002      LDRH     LR,[R12, #+2]
   \   000000B6   0x4577             CMP      R7,LR
   \   000000B8   0xBF2F             ITEEE    CS 
   \   000000BA   0xEBA7 0x0E0E      SUBCS    LR,R7,LR
   \   000000BE   0xF836 0x9010      LDRHCC   R9,[R6, R0, LSL #+1]
   \   000000C2   0xEBA9 0x0E0E      SUBCC    LR,R9,LR
   \   000000C6   0x44BE             ADDCC    LR,R7,LR
   \   000000C8   0xF8AC 0xE004      STRH     LR,[R12, #+4]
   \   000000CC   0xE7BE             B.N      ??halInternalUartRxIsr_0
   1133          			}
   1134          #ifdef EMBER_SERIAL1_XONXOFF
   1135          			if (EM_SER1_PORT_FIFO(port) &&
   1136          					(q->used >= XOFF_LIMIT) && (xcmdCount >= 0))  {
   1137          				xonXoffTxByte = ASCII_XOFF;
   1138          				halInternalStartUartTx(1);
   1139          			}
   1140          #endif
   1141          		} // end of while ( SC1_UARTSTAT & SC1_UARTRXVAL )
   1142          	}
   1143          #endif
   1144          
   1145          #if defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
   1146          	if (EM_SER_MULTI(EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port))) {
   1147          #ifdef EMBER_SERIAL1_RTSCTS
   1148          		// TODO this flow control will fail if port 2 is active
   1149          		// If RTS is controlled by sw, this ISR is called when a buffer unloads.
   1150          		if (causes & (INT_SCRXULDA | INT_SCRXULDB)) {
   1151          			// Deassert RTS if the rx queue tail is not in an active DMA buffer:
   1152          			// if it is, then there's at least one empty DMA buffer
   1153          			if ( !( (emSerialRxQueues[port]->tail < emSerialRxQueueSizes[port]/2) &&
   1154          					(SCx_REG(port, DMASTAT) & SC_RXACTA) ) &&
   1155          					!( (emSerialRxQueues[port]->tail >= emSerialRxQueueSizes[port]/2)
   1156          							&& (SCx_REG(port, DMASTAT) & SC_RXACTB) ) ) {
   1157          				SCx_REG(port, UARTCFG) &= ~SC_UARTRTS;        // deassert RTS
   1158          			}
   1159          #ifdef EZSP_UART
   1160          			// TODO fix EZSP_UART
   1161          			if ( ( (causes & INT_SCRXULDA) && (SC1_DMASTAT & SC_RXOVFA) ) ||
   1162          					( (causes & INT_SCRXULDB) && (SC1_DMASTAT & SC_RXOVFB) ) ) {
   1163          				HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_OVERFLOW_ERROR);
   1164          			}
   1165          			if ( ( (causes & INT_SCRXULDA) && (SC1_DMASTAT & SC_RXFRMA) ) ||
   1166          					( (causes & INT_SCRXULDB) && (SC1_DMASTAT & SC_RXFRMB) ) ) {
   1167          				HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_FRAMING_ERROR);
   1168          			}
   1169          #else //!EZSP_UART
   1170          			causes &= ~(INT_SCRXULDA | INT_SCRXULDB);
   1171          			if (causes == 0) { // if no errors in addition, all done
   1172          				return;
   1173          			}
   1174          #endif //EZSP_UART
   1175          		}
   1176          #endif  //#ifdef EMBER_SERIAL1_RTSCTS
   1177          #ifndef EZSP_UART
   1178          		//Load all of the hardware status, then immediately reset so we can process
   1179          		//what happened without worrying about new data changing these values.
   1180          		//We're in an error condition anyways, so it is ok to have the DMA disabled
   1181          		//for a while (less than 80us, while 4 bytes @ 115.2kbps is 350us)
   1182          		{
   1183          			EmSerialFifoQueue *q = emSerialRxQueues[port];
   1184          			int16u status  = SCx_REG(port, DMASTAT);
   1185          			int16u errCntA = SCx_REG(port, RXERRA);
   1186          			int16u errCntB = SCx_REG(port, RXERRB);
   1187          			int32u errorIdx = emSerialRxQueueSizes[port]*2;
   1188          			int32u tempIdx;
   1189          			int32u startAddress = (int32u)q->fifo;
   1190          
   1191          			//interrupts acknowledged at the start of the master SC1 ISR
   1192          			int16u intSrc  = causes;
   1193          			int8u errorType = EMBER_SUCCESS;
   1194          
   1195          			SCx_REG(port, DMACTRL) = SC_RXDMARST;  //to clear error
   1196          			//state fully captured, DMA reset, now we process error and restart
   1197          
   1198          			if ( intSrc & INT_SCRXOVF ) {
   1199          				//Read the data register four times to clear
   1200          				//the RXOVERRUN condition and empty the FIFO, giving us 4 bytes
   1201          				//worth of time (from this point) to reenable the DMA.
   1202          				(void) SCx_REG(port, DATA);
   1203          				(void) SCx_REG(port, DATA);
   1204          				(void) SCx_REG(port, DATA);
   1205          				(void) SCx_REG(port, DATA);
   1206          
   1207          				if ( status & ( SC_RXFRMA
   1208          						| SC_RXFRMB
   1209          						| SC_RXPARA
   1210          						| SC_RXPARB ) ) {
   1211          					//We just emptied hardware FIFO so the overrun condition is cleared.
   1212          					//Byte errors require special handling to roll back the serial FIFO.
   1213          					goto dealWithByteError;
   1214          				}
   1215          
   1216          				//record the error type
   1217          				emSerialRxError[port] = EMBER_SERIAL_RX_OVERRUN_ERROR;
   1218          
   1219          				//check for a retriggering of the Rx overflow, don't advance FIFO if so
   1220          				if ( !(BUFSTATE(port)->waitingForTailA && BUFSTATE(port)->waitingForTailB) ) {
   1221          					//first, move head to end of buffer head is in
   1222          					//second, move head to end of other buffer if tail is not in other buffer
   1223          					if ((q->head)<BUFSTATE(port)->rxStartIndexB) {
   1224          						//head inside A
   1225          						q->used += (BUFSTATE(port)->rxStartIndexB - q->head);
   1226          						q->head = (BUFSTATE(port)->rxStartIndexB);
   1227          						if ((q->tail)<BUFSTATE(port)->rxStartIndexB) {
   1228          							//tail not inside of B
   1229          							q->used += BUFSTATE(port)->rxStartIndexB;
   1230          							q->head = 0;
   1231          						}
   1232          					} else {
   1233          						//head inside B
   1234          						q->used += (BUFSTATE(port)->fifoSize - q->head);
   1235          						q->head = 0;
   1236          						if ((q->tail)>=BUFSTATE(port)->rxStartIndexB) {
   1237          							//tail is not inside of A
   1238          							q->used += BUFSTATE(port)->rxStartIndexB;
   1239          							q->head = BUFSTATE(port)->rxStartIndexB;
   1240          						}
   1241          					}
   1242          				}
   1243          
   1244          				//Record the error position in the serial FIFO
   1245          				if (q->used != BUFSTATE(port)->fifoSize) {
   1246          					//mark the byte at q->head as the error
   1247          					emSerialRxErrorIndex[port] = q->head;
   1248          				} else {
   1249          					//Since the FIFO is full, the error index needs special handling
   1250          					//so there is no conflict between the head and tail looking at the same
   1251          					//index which needs to be marked as an error.
   1252          					emSerialRxErrorIndex[port] = RX_FIFO_FULL;
   1253          				}
   1254          
   1255          				//By now the error is accounted for and the DMA hardware is reset.
   1256          				//By definition, the overrun error means we have no room left, therefore
   1257          				//we can't reenable the DMA.  Reset the previous counter states, and set
   1258          				//the waitingForTail flags to TRUE - this tells the Pump function we have
   1259          				//data to process.  The Pump function will reenable the buffers as they
   1260          				//become available, just like normal.
   1261          				BUFSTATE(port)->prevCountA = 0;
   1262          				BUFSTATE(port)->prevCountB = 0;
   1263          				BUFSTATE(port)->waitingForInputToB = FALSE;
   1264          				BUFSTATE(port)->waitingForTailA = TRUE;
   1265          				BUFSTATE(port)->waitingForTailB = TRUE;
   1266          				//from this point we fall through to the end of the Isr and return.
   1267          
   1268          			} else {
   1269          				dealWithByteError:
   1270          				//We have a byte error to deal with and possibly more than one byte error,
   1271          				//of different types in different DMA buffers, so check each error flag.
   1272          				//All four error checks translate the DMA buffer's error position to their
   1273          				//position in the serial FIFO, and compares the error locations to find
   1274          				//the first error to occur after the head of the FIFO.  This error is the
   1275          				//error condition that is stored and operated on.
   1276          				if ( status & SC_RXFRMA ) {
   1277          					tempIdx = errCntA;
   1278          					if (tempIdx < q->head) {
   1279          						tempIdx += BUFSTATE(port)->fifoSize;
   1280          					}
   1281          					if (tempIdx<errorIdx) {
   1282          						errorIdx = tempIdx;
   1283          					}
   1284          					errorType = EMBER_SERIAL_RX_FRAME_ERROR;
   1285          				}
   1286          				if ( status & SC_RXFRMB ) {
   1287          					tempIdx = (errCntB + SCx_REG(port, RXBEGB)) - startAddress;
   1288          					if (tempIdx < q->head) {
   1289          						tempIdx += BUFSTATE(port)->fifoSize;
   1290          					}
   1291          					if (tempIdx<errorIdx) {
   1292          						errorIdx = tempIdx;
   1293          					}
   1294          					errorType = EMBER_SERIAL_RX_FRAME_ERROR;
   1295          				}
   1296          				if ( status & SC_RXPARA ) {
   1297          					tempIdx = errCntA;
   1298          					if (tempIdx < q->head) {
   1299          						tempIdx += BUFSTATE(port)->fifoSize;
   1300          					}
   1301          					if (tempIdx<errorIdx) {
   1302          						errorIdx = tempIdx;
   1303          					}
   1304          					errorType = EMBER_SERIAL_RX_PARITY_ERROR;
   1305          				}
   1306          				if ( status & SC_RXPARB ) {
   1307          					tempIdx = (errCntB + SCx_REG(port, RXBEGB)) - startAddress;
   1308          					if (tempIdx < q->head) {
   1309          						tempIdx += BUFSTATE(port)->fifoSize;
   1310          					}
   1311          					if (tempIdx<errorIdx) {
   1312          						errorIdx = tempIdx;
   1313          					}
   1314          					errorType = EMBER_SERIAL_RX_PARITY_ERROR;
   1315          				}
   1316          
   1317          				//We now know the type and location of the first error.
   1318          				//Move up to the error location and increase the used count.
   1319          				q->head = (errorIdx % BUFSTATE(port)->fifoSize);
   1320          				if (q->head < q->tail) {
   1321          					q->used = ((q->head + BUFSTATE(port)->fifoSize) - q->tail);
   1322          				} else {
   1323          					q->used = (q->head - q->tail);
   1324          				}
   1325          
   1326          				//Mark the byte at q->head as the error
   1327          				emSerialRxError[port] = errorType;
   1328          				if (q->used != BUFSTATE(port)->fifoSize) {
   1329          					//mark the byte at q->head as the error
   1330          					emSerialRxErrorIndex[port] = q->head;
   1331          				} else {
   1332          					//Since the FIFO is full, the error index needs special handling
   1333          					//so there is no conflict between the head and tail looking at the same
   1334          					//index which needs to be marked as an error.
   1335          					emSerialRxErrorIndex[port] = RX_FIFO_FULL;
   1336          				}
   1337          
   1338          				//By now the error is accounted for and the DMA hardware is reset.
   1339          				halInternalRestartUartDma(port);
   1340          			}
   1341          		}
   1342          #endif // #ifndef EZSP_UART
   1343          	}
   1344          #endif // defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
   1345          }
   \                     ??halInternalUartRxIsr_3: (+1)
   \   000000CE   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1346          #endif //!defined(EM_SERIAL1_DISABLED)
   1347          
   1348          
   1349          #if EM_SERIAL3_ENABLED
   1350          void halInternalUart3RxIsr(int8u *rxData, int8u length)
   1351          {
   1352          	EmSerialFifoQueue *q = emSerialRxQueues[3];
   1353          
   1354          	while(length--) {
   1355          		if(q->used < (EMBER_SERIAL3_RX_QUEUE_SIZE-1)) {
   1356          			FIFO_ENQUEUE(q, *rxData, emSerialRxQueueWraps[3]);
   1357          			rxData++;
   1358          		} else {
   1359          			uartErrorMark(3, EMBER_SERIAL_RX_OVERFLOW);
   1360          			return;
   1361          		}
   1362          	}
   1363          }
   1364          #endif
   1365          
   1366          
   1367          #ifdef SOFTUART
   1368          //this requires use of the SysTick counter and will destroy interrupt latency!
   1369          static int8u softwareUartRxByte(void)
   1370          {
   1371          	int8u i;
   1372          	int8u bit;
   1373          	int8u byte = 0;
   1374          	// BIT_TIMEs were determined based on 24 MHz MCU clock.
   1375          	// Scale 'em for the actual MCU clock in effect, with rounding.
   1376          	// (Because the FCLK might not evenly divide by 1000000 or even 500000, use
   1377          	// quad arithmetic dividing it by 250000.)
   1378          	int16u fullBitTime  = (int16u)((( FULL_BIT_TIME_SCLK
   1379          			* (halMcuClockHz() / 250000)) + 48) / 96);
   1380          	int16u startBitTime = (int16u)(((START_BIT_TIME_SCLK
   1381          			* (halMcuClockHz() / 250000)) + 48) / 96);
   1382          	ATOMIC(
   1383          			INTERRUPTS_ON();
   1384          	//we can only begin receiveing if the input is idle high
   1385          	while (SOFT_UART_RX_BIT != 1) {}
   1386          	//now wait for our start bit
   1387          	while (SOFT_UART_RX_BIT != 0) {}
   1388          	INTERRUPTS_OFF();
   1389          
   1390          	//set reload value such that move to the center of an incoming bit
   1391          	ST_RVR = startBitTime;
   1392          	ST_CVR = 0; //writing the current value will cause it to reset to zero
   1393          	//enable core clock reference and the counter itself
   1394          	ST_CSR = (ST_CSR_CLKSOURCE | ST_CSR_ENABLE);
   1395          	while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 0.5bit time
   1396          	//set reload value such that move 1bit time
   1397          	ST_RVR = fullBitTime;
   1398          	ST_CVR = 0; //writing the current value will cause it to reset to zero
   1399          
   1400          	//loop 8 times recieving all 8 bits and building up the byte
   1401          	for (i=0;i<8;i++) {
   1402          		while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
   1403          		bit = SOFT_UART_RX_BIT; //get the data bit
   1404          		bit = ((bit&0x1)<<7);
   1405          		byte = (byte>>1)|(bit);
   1406          	}
   1407          
   1408          	//disable SysTick
   1409          	ST_CSR = 0;
   1410          	)
   1411          	return byte;
   1412          }
   1413          #endif //SOFTUART
   1414          

   \                                 In section .text, align 2, keep-with-next
   1415          void halInternalUartRxPump(int8u port)
   1416          {
   1417          #ifdef SOFTUART
   1418          	if (EM_SER1_PORT_EN(port)) {
   1419          		EmSerialFifoQueue *q = emSerialRxQueues[1];
   1420          		int8u errors;
   1421          		int8u byte;
   1422          
   1423          		//always configure the bit because other operations might have
   1424          		//tried to compromise it
   1425          		CONFIG_SOFT_UART_RX_BIT();
   1426          
   1427          		//this will block waiting for a start bit!
   1428          		byte = softwareUartRxByte();
   1429          
   1430          		if (q->used < (EMBER_SERIAL1_RX_QUEUE_SIZE-1)) {
   1431          			FIFO_ENQUEUE(q, byte, emSerialRxQueueWraps[1]);
   1432          		} else {
   1433          			errors = EMBER_SERIAL_RX_OVERFLOW;
   1434          			uartErrorMark(1, errors);
   1435          		}
   1436          		return;
   1437          	}
   1438          #endif
   1439          
   1440          #if defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
   1441          	if (EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port)) {
   1442          		EmSerialFifoQueue *q = emSerialRxQueues[port];
   1443          		int8u tail,head;
   1444          		int16u count=0;
   1445          		int8u loadA;
   1446          		int8u loadB;
   1447          		//Load all of the hardware status, so we can process what happened
   1448          		//without worrying about new data changing these values.
   1449          		int8u dmaStatus = SCx_REG(port, DMACTRL);
   1450          		int16u currCountA = SCx_REG(port, RXCNTA);
   1451          		int16u currCountB = SCx_REG(port, RXCNTB);
   1452          
   1453          		//Normal check to see if A has any data
   1454          		if (BUFSTATE(port)->prevCountA != currCountA) {
   1455          			//Update the counters and head location for the new data
   1456          			count = (currCountA - BUFSTATE(port)->prevCountA);
   1457          			q->used += count;
   1458          			q->head = (q->head + count) % emSerialRxQueueSizes[port];
   1459          			BUFSTATE(port)->prevCountA = currCountA;
   1460          			BUFSTATE(port)->waitingForTailA = TRUE;
   1461          		}
   1462          		//Normal check to see if B has any data at all
   1463          		if (BUFSTATE(port)->prevCountB != currCountB) {
   1464          			//Update the counters and head location for the new data
   1465          			count = (currCountB - BUFSTATE(port)->prevCountB);
   1466          			q->used += count;
   1467          			q->head = (q->head + count) % emSerialRxQueueSizes[port];
   1468          			BUFSTATE(port)->prevCountB = currCountB;
   1469          			BUFSTATE(port)->waitingForTailB = TRUE;
   1470          			BUFSTATE(port)->waitingForInputToB = FALSE;
   1471          		}
   1472          
   1473          
   1474          		//if the used count is greater than half the buffer size, nothing can be done
   1475          		if (q->used > BUFSTATE(port)->rxStartIndexB) {
   1476          			return;
   1477          		}
   1478          		//if nothing is in the FIFO, we can reload both if needed
   1479          		if (q->used == 0) {
   1480          			loadA = TRUE;
   1481          			loadB = TRUE;
   1482          			goto reloadBuffers;
   1483          		}
   1484          		//0 < used < bufferSize, so figure out where tail and head are
   1485          		if((q->tail)/(BUFSTATE(port)->rxStartIndexB)) {
   1486          			tail = TRUE;  //Tail in B buffer
   1487          		} else {
   1488          			tail = FALSE; //Tail in A buffer
   1489          		}
   1490          
   1491          		if(((int16u)(q->head - 1))/(BUFSTATE(port)->rxStartIndexB)) {
   1492          			head = TRUE;  //Head in B buffer
   1493          		} else {
   1494          			head = FALSE; //Head in A buffer
   1495          		}
   1496          
   1497          		//To load, the tail must be in the same buffer as the head so we don't
   1498          		//overwrite any bytes that haven't drained from the serial FIFO yet.
   1499          		if (tail!=head) {
   1500          			halInternalUartRxCheckRts(port);
   1501          			return;
   1502          		}
   1503          		// Recall tail TRUE means data is inside B
   1504          		loadA = tail;
   1505          		loadB = !tail;
   1506          		reloadBuffers:
   1507          		//check if the buffers need to be reloaded
   1508          		if ( (loadA) && (!BUFSTATE(port)->waitingForInputToB) ) {
   1509          			if ( (dmaStatus&SC_RXLODA)
   1510          					!= SC_RXLODA) {
   1511          				//An error interrupt can move the addresses of the buffer
   1512          				//during the flush/reset/reload operation.  At this point the
   1513          				//buffer is clear of any usage, so we can reset the addresses
   1514          				SCx_REG(port, RXBEGA) = (int32u)q->fifo;
   1515          				SCx_REG(port, RXENDA) = (int32u)(q->fifo + BUFSTATE(port)->fifoSize/2 - 1);
   1516          				BUFSTATE(port)->prevCountA = 0;
   1517          				BUFSTATE(port)->waitingForTailA = FALSE;
   1518          				SCx_REG(port, DMACTRL) = SC_RXLODA;
   1519          			}
   1520          		}
   1521          		if (loadB) {
   1522          			if ( (dmaStatus&SC_RXLODB)
   1523          					!= SC_RXLODB) {
   1524          				//An error interrupt can move the addresses of the buffer
   1525          				//during the flush/reset/reload operation.  At this point the
   1526          				//buffer is clear of any usage, so we can reset the addresses
   1527          				SCx_REG(port, RXBEGB) = (int32u)(q->fifo + BUFSTATE(port)->fifoSize/2);
   1528          				SCx_REG(port, RXENDB) = (int32u)(q->fifo + BUFSTATE(port)->fifoSize - 1);
   1529          				BUFSTATE(port)->prevCountB = 0;
   1530          				BUFSTATE(port)->waitingForTailB = FALSE;
   1531          				SCx_REG(port, DMACTRL) = SC_RXLODB;
   1532          			}
   1533          		}
   1534          		halInternalUartRxCheckRts(port);
   1535          	}
   1536          #endif // defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
   1537          }
   \                     halInternalUartRxPump: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1538          
   1539          #if defined(EMBER_SERIAL1_RTSCTS) || defined(EMBER_SERIAL2_RTSCTS)
   1540          void halInternalUartRxCheckRts(int8u port)
   1541          {
   1542          	// Verify RTS is controlled by SW (not AUTO mode), and isn't already asserted.
   1543          	// (The logic to deassert RTS is in halInternalUart1RxIsr().)
   1544          	if ((SCx_REG(port, UARTCFG) & (SC_UARTFLOW | SC_UARTAUTO | SC_UARTRTS)) == SC_UARTFLOW) {
   1545          		// Assert RTS if the rx queue tail is in an active (or pending) DMA buffer,
   1546          		// because this means the other DMA buffer is empty.
   1547          		ATOMIC (
   1548          				if ( ( (emSerialRxQueues[port]->tail < emSerialRxQueueSizes[port]/2) &&
   1549          						(SCx_REG(port, DMACTRL) & SC_RXLODA) ) ||
   1550          						( (emSerialRxQueues[port]->tail >= emSerialRxQueueSizes[port]/2)
   1551          								&& (SCx_REG(port, DMACTRL) & SC_RXLODB) ) ) {
   1552          					SCx_REG(port, UARTCFG) |= SC_UARTRTS;          // assert RTS
   1553          				}
   1554          		)
   1555          	}
   1556          }
   1557          #endif
   1558          
   1559          #ifdef EMBER_SERIAL1_RTSCTS
   1560          boolean halInternalUartFlowControlRxIsEnabled(int8u port)
   1561          {
   1562          	return ( (SCx_REG(port, UARTCFG) & (SC_UARTFLOW | SC_UARTAUTO | SC_UARTRTS)) ==
   1563          			(SC_UARTFLOW | SC_UARTRTS) );
   1564          }
   1565          #endif
   1566          #ifdef EMBER_SERIAL1_XONXOFF
   1567          boolean halInternalUartFlowControlRxIsEnabled(int8u port)
   1568          {
   1569          	xonTimer = halCommonGetInt16uQuarterSecondTick(); //FIXME move into new func?
   1570          	return ( (xonXoffTxByte == 0) && (xcmdCount > 0) );
   1571          }
   1572          
   1573          boolean halInternalUartXonRefreshDone(int8u port)
   1574          {
   1575          	return (xcmdCount == XON_REFRESH_COUNT);
   1576          }
   1577          #endif
   1578          

   \                                 In section .text, align 2, keep-with-next
   1579          boolean halInternalUartTxIsIdle(int8u port)
   1580          {
   1581          	// TODO how do we determine idle for the VUART or USB?
   1582          #if defined(EM_PHYSICAL_UART)
   1583          	if (EM_SER1_PORT_EN(port) || EM_SER2_PORT_EN(port)) {
   \                     halInternalUartTxIsIdle: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD10A             BNE.N    ??halInternalUartTxIsIdle_0
   1584          		return ( (SCx_REG(port, MODE) == SC1_MODE_UART) &&
   1585          				((SCx_REG(port, UARTSTAT) & SC_UARTTXIDLE) != 0) );
   \   00000004   0x....             LDR.N    R0,??DataTable13_5  ;; 0x4000c848
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD104             BNE.N    ??halInternalUartTxIsIdle_1
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0980             LSRS     R0,R0,#+6
   \   00000010   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000014   0x4770             BX       LR
   \                     ??halInternalUartTxIsIdle_1: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR
   1586          	}
   1587          #endif
   1588          
   1589          	return TRUE;
   \                     ??halInternalUartTxIsIdle_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x4770             BX       LR               ;; return
   1590          }
   1591          
   1592          #if defined(EM_PHYSICAL_UART)
   1593          // If called outside of an ISR, it should be from within an ATOMIC block.

   \                                 In section .text, align 2, keep-with-next
   1594          static void halInternalUartTxIsr(int8u port)
   1595          {
   \                     halInternalUartTxIsr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1596          #if defined(EM_ENABLE_SERIAL_FIFO)
   1597          	if (EM_SER_MULTI(EM_SER1_PORT_FIFO(port) || EM_SER2_PORT_FIFO(port))) {
   1598          		EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000002   0x....             LDR.N    R1,??DataTable13_11
   \   00000004   0x....             LDR.N    R2,??DataTable13_12
   \   00000006   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \   0000000A   0x....             LDR.N    R3,??DataTable13_4  ;; 0x4000c83c
   \   0000000C   0xE00F             B.N      ??halInternalUartTxIsr_0
   1599          
   1600          		// At present we really don't care which interrupt(s)
   1601          		// occurred, just that one did.  Loop while there is
   1602          		// room to send more data and we've got more data to
   1603          		// send.  For UART there is no error detection.
   1604          
   1605          #ifdef EMBER_SERIAL1_XONXOFF
   1606          		// Sending an XON or XOFF takes priority over data in the tx queue.
   1607          		if (xonXoffTxByte && (SCx_REG(port, UARTSTAT) & SC_UARTTXFREE) ) {
   1608          			SCx_REG(port, DATA) = xonXoffTxByte;
   1609          			if (xonXoffTxByte == ASCII_XOFF) {
   1610          				xcmdCount = -1;
   1611          				HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_XOFF);
   1612          			} else {
   1613          				xcmdCount = (xcmdCount < 0) ? 1: xcmdCount + 1;
   1614          			}
   1615          			xonXoffTxByte = 0;    // clear to indicate XON/XOFF was sent
   1616          		}
   1617          #endif
   1618          		while ( (q->used > 0) && (SCx_REG(port, UARTSTAT) & SC_UARTTXFREE) ) {
   1619          			SCx_REG(port, DATA) = FIFO_DEQUEUE(q, emSerialTxQueueWraps[port]);
   \                     ??halInternalUartTxIsr_1: (+1)
   \   0000000E   0x884C             LDRH     R4,[R1, #+2]
   \   00000010   0x1864             ADDS     R4,R4,R1
   \   00000012   0x79A4             LDRB     R4,[R4, #+6]
   \   00000014   0x601C             STR      R4,[R3, #+0]
   \   00000016   0x884C             LDRH     R4,[R1, #+2]
   \   00000018   0xF832 0x5010      LDRH     R5,[R2, R0, LSL #+1]
   \   0000001C   0x1C64             ADDS     R4,R4,#+1
   \   0000001E   0xFB94 0xF6F5      SDIV     R6,R4,R5
   \   00000022   0xFB05 0x4416      MLS      R4,R5,R6,R4
   \   00000026   0x804C             STRH     R4,[R1, #+2]
   \   00000028   0x888C             LDRH     R4,[R1, #+4]
   \   0000002A   0x1E64             SUBS     R4,R4,#+1
   \   0000002C   0x808C             STRH     R4,[R1, #+4]
   1620          		}
   \                     ??halInternalUartTxIsr_0: (+1)
   \   0000002E   0x888C             LDRH     R4,[R1, #+4]
   \   00000030   0xB114             CBZ.N    R4,??halInternalUartTxIsr_2
   \   00000032   0x68DC             LDR      R4,[R3, #+12]
   \   00000034   0x0764             LSLS     R4,R4,#+29
   \   00000036   0xD4EA             BMI.N    ??halInternalUartTxIsr_1
   1621          	}
   1622          #endif
   1623          #if defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
   1624          	if (EM_SER_MULTI(EM_SER1_PORT_BUFFER(port) || EM_SER2_PORT_BUFFER(port))) {
   1625          		EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1626          
   1627          		// The only interrupts we care about here are UNLOAD's and IDLE.
   1628          		// Our algorithm doesn't really care which interrupt occurred,
   1629          		// or even if one really didn't.  If there is data to send and
   1630          		// a DMA channel available to send it, then out it goes.
   1631          
   1632          		assert( !((q->used == 0) && (q->nextByte != NULL)) );
   1633          		while ( q->used > 0 ) {
   1634          			if ( q->nextByte == NULL ) {
   1635          				// new message pending, but nextByte not set up yet
   1636          				emSerialBufferNextMessageIsr(q);
   1637          			}
   1638          
   1639          			// Something to send: do we have a DMA channel to send it on?
   1640          			// Probe for an available channel by checking the channel's
   1641          			// SC1_DMACTRL.TX_LOAD   == 0 (channel unloaded) &&
   1642          			// SC1_DMASTAT.TX_ACTIVE == 0 (channel not active)
   1643          			// The latter check should be superfluous but is a safety mechanism.
   1644          			if ( !(SCx_REG(port, DMACTRL) & SC_TXLODA) &&
   1645          					!(SCx_REG(port, DMASTAT) & SC_TXACTA) ) {
   1646          				// Channel A is available
   1647          				SCx_REG(port, TXBEGA)  = (int32u)q->nextByte;
   1648          				SCx_REG(port, TXENDA) = (int32u)q->lastByte;
   1649          				INT_SCxFLAG(port) = INT_SCTXULDA; // Ack if pending
   1650          				SCx_REG(port, DMACTRL) = SC_TXLODA;
   1651          				// Release previously held buffer and hold the newly-loaded one
   1652          				// so we can safely use emSerialBufferNextBlockIsr() to check for
   1653          				// more data to send without the risk of reusing a buffer we're
   1654          				// in the process of DMA-ing.
   1655          				if (BUFSTATE(port)->holdBuf[0] != EMBER_NULL_MESSAGE_BUFFER)
   1656          					emberReleaseMessageBuffer(BUFSTATE(port)->holdBuf[0]);
   1657          				BUFSTATE(port)->holdBuf[0] = q->currentBuffer;
   1658          				emberHoldMessageBuffer(BUFSTATE(port)->holdBuf[0]);
   1659          				emSerialBufferNextBlockIsr(q, port);
   1660          			} else
   1661          				if ( !(SCx_REG(port, DMACTRL) & SC_TXLODB) &&
   1662          						!(SCx_REG(port, DMASTAT) & SC_TXACTB) ) {
   1663          					// Channel B is available
   1664          					SCx_REG(port, TXBEGB)  = (int32u)q->nextByte;
   1665          					SCx_REG(port, TXENDB) = (int32u)q->lastByte;
   1666          					INT_SCxFLAG(port) = INT_SCTXULDB; // Ack if pending
   1667          					SCx_REG(port, DMACTRL) = SC_TXLODB;
   1668          					// Release previously held buffer and hold the newly-loaded one
   1669          					// so we can safely use emSerialBufferNextBlockIsr() to check for
   1670          					// more data to send without the risk of reusing a buffer we're
   1671          					// in the process of DMA-ing.
   1672          					if (BUFSTATE(port)->holdBuf[1] != EMBER_NULL_MESSAGE_BUFFER)
   1673          						emberReleaseMessageBuffer(BUFSTATE(port)->holdBuf[1]);
   1674          					BUFSTATE(port)->holdBuf[1] = q->currentBuffer;
   1675          					emberHoldMessageBuffer(BUFSTATE(port)->holdBuf[1]);
   1676          					emSerialBufferNextBlockIsr(q, port);
   1677          				} else {
   1678          					// No channels available; can't send anything now so break out of loop
   1679          					break;
   1680          				}
   1681          
   1682          		} // while ( q->used > 0 )
   1683          
   1684          		// Release previously-held buffer(s) from an earlier DMA operation
   1685          		// if that channel is now free (i.e. it's completed the DMA and we
   1686          		// didn't need to use that channel for more output in this call).
   1687          		if ( (BUFSTATE(port)->holdBuf[0] != EMBER_NULL_MESSAGE_BUFFER) &&
   1688          				!(SCx_REG(port, DMACTRL) & SC_TXLODA) &&
   1689          				!(SCx_REG(port, DMASTAT) & SC_TXACTA) ) {
   1690          			emberReleaseMessageBuffer(BUFSTATE(port)->holdBuf[0]);
   1691          			BUFSTATE(port)->holdBuf[0] = EMBER_NULL_MESSAGE_BUFFER;
   1692          		}
   1693          		if ( (BUFSTATE(port)->holdBuf[1] != EMBER_NULL_MESSAGE_BUFFER) &&
   1694          				!(SCx_REG(port, DMACTRL) & SC_TXLODB) &&
   1695          				!(SCx_REG(port, DMASTAT) & SC_TXACTB) ) {
   1696          			emberReleaseMessageBuffer(BUFSTATE(port)->holdBuf[1]);
   1697          			BUFSTATE(port)->holdBuf[1] = EMBER_NULL_MESSAGE_BUFFER;
   1698          		}
   1699          	}
   1700          #endif // defined(EM_ENABLE_SERIAL_BUFFER) && (EM_SERIAL1_ENABLED || EM_SERIAL2_ENABLED)
   1701          }
   \                     ??halInternalUartTxIsr_2: (+1)
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
   1702          #endif // defined(EM_PHYSICAL_UART)
   1703          
   1704          
   1705          #if EM_SERIAL1_ENABLED
   1706          //The following registers are the only SC1-UART registers that need to be
   1707          //saved across deep sleep cycles.  All other SC1-UART registers are
   1708          //reenabled or restarted using more complex init or restart algorithms.

   \                                 In section .bss, align 4
   1709          static int32u  SC1_UARTPER_SAVED;
   \                     SC1_UARTPER_SAVED:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4
   1710          static int32u  SC1_UARTFRAC_SAVED;
   1711          static int32u  SC1_UARTCFG_SAVED;
   1712          #endif // EM_SERIAL1_ENABLED
   1713          #if EM_SERIAL2_ENABLED
   1714          //The following registers are the only SC3-UART registers that need to be
   1715          //saved across deep sleep cycles.  All other SC3-UART registers are
   1716          //reenabled or restarted using more complex init or restart algorithms.
   1717          static int32u  SC3_UARTPER_SAVED;
   1718          static int32u  SC3_UARTFRAC_SAVED;
   1719          static int32u  SC3_UARTCFG_SAVED;
   1720          #endif // EM_SERIAL2_ENABLED
   1721          

   \                                 In section .text, align 2, keep-with-next
   1722          void halInternalPowerDownUart(void)
   1723          {
   1724          #if EM_SERIAL1_ENABLED
   1725          	SC1_UARTPER_SAVED = SC1_UARTPER;
   \                     halInternalPowerDownUart: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable13_13  ;; 0x4000c85c
   \   00000002   0x....             LDR.N    R1,??DataTable13_14
   \   00000004   0x68C2             LDR      R2,[R0, #+12]
   \   00000006   0x600A             STR      R2,[R1, #+0]
   1726          	SC1_UARTFRAC_SAVED = SC1_UARTFRAC;
   \   00000008   0x6902             LDR      R2,[R0, #+16]
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   1727          	SC1_UARTCFG_SAVED = SC1_UARTCFG;
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6088             STR      R0,[R1, #+8]
   1728          	SC1_TXD_GPIO(GPIOCFG_OUT, 1); // Avoid gitching TxD going down
   1729          #endif // EM_SERIAL1_ENABLED
   1730          #if EM_SERIAL2_ENABLED
   1731          	SC3_UARTPER_SAVED = SC3_UARTPER;
   1732          	SC3_UARTFRAC_SAVED = SC3_UARTFRAC;
   1733          	SC3_UARTCFG_SAVED = SC3_UARTCFG;
   1734          	// TODO SC3_TXD_GPIO(GPIOCFG_OUT, 1); // Avoid gitching TxD going down
   1735          #endif // EM_SERIAL1_ENABLED
   1736          }
   \   00000010   0x4770             BX       LR               ;; return
   1737          

   \                                 In section .text, align 2, keep-with-next
   1738          void halInternalPowerUpUart(void)
   1739          {
   1740          #if EM_SERIAL1_ENABLED
   1741          	SC1_UARTPER = SC1_UARTPER_SAVED;
   \                     halInternalPowerUpUart: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable13_14
   \   00000002   0x....             LDR.N    R0,??DataTable13_2  ;; 0x4000c854
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x6142             STR      R2,[R0, #+20]
   1742          	SC1_UARTFRAC = SC1_UARTFRAC_SAVED;
   \   00000008   0x684A             LDR      R2,[R1, #+4]
   \   0000000A   0x6182             STR      R2,[R0, #+24]
   1743          	SC1_UARTCFG = SC1_UARTCFG_SAVED;
   \   0000000C   0x6889             LDR      R1,[R1, #+8]
   \   0000000E   0x6081             STR      R1,[R0, #+8]
   1744          
   1745          	SC1_MODE = SC1_MODE_UART;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x6001             STR      R1,[R0, #+0]
   1746          	SC1_TXD_GPIO(GPIOCFG_OUT_ALT, 1); // Can Assign TxD glitch-free to UART now
   1747          
   1748          	halInternalInitUartInterrupts(1);
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x....             B.N      halInternalInitUartInterrupts
   1749          #endif
   1750          
   1751          #if EM_SERIAL2_ENABLED
   1752          	SC3_UARTPER = SC3_UARTPER_SAVED;
   1753          	SC3_UARTFRAC = SC3_UARTFRAC_SAVED;
   1754          	SC3_UARTCFG = SC3_UARTCFG_SAVED;
   1755          
   1756          	SC3_MODE = SC3_MODE_UART;
   1757          	//SC3_TXD_GPIO(GPIOCFG_OUT_ALT, 1); // Can Assign TxD glitch-free to UART now
   1758          
   1759          	halInternalInitUartInterrupts(2);
   1760          #endif
   1761          
   1762          #if EM_SERIAL3_ENABLED || defined (USB_MSD) || defined (USB_HID)
   1763          	//Remember, halInternalPowerUpUart does not return anything.  Powering
   1764          	//up the USB requires going through its normal configuration and
   1765          	//enumeration process.
   1766          #if defined(CORTEXM3_EM35X_USB)
   1767          	USBD_Init(&initstruct);
   1768          #endif
   1769          #endif
   1770          }
   1771          
   1772          

   \                                 In section .text, align 2, keep-with-next
   1773          void halInternalRestartUart(void)
   1774          {
   1775          	// This is no longer needed and should be removed as a dinosaur --DMM
   1776          }
   \                     halInternalRestartUart: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1777          
   1778          #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO) && defined(EMBER_SERIAL1_XONXOFF)
   1779          // TODO XON/XOFF on port 2
   1780          void halInternalUartFlowControl(int8u port)
   1781          {
   1782          	if (EM_SER1_PORT_EN(port)) {
   1783          		int16u used = emSerialRxQueues[1]->used;
   1784          		int8u time = halCommonGetInt16uQuarterSecondTick();
   1785          
   1786          		if (used) {
   1787          			xonTimer = time;
   1788          		}
   1789          		// Send an XON if the rx queue is below the XON threshold
   1790          		// and an XOFF had been sent that needs to be reversed
   1791          		ATOMIC(
   1792          				if ( (xcmdCount == -1) && (used <= XON_LIMIT) ) {
   1793          					halInternalUart1ForceXon();
   1794          				} else if ( (used == 0) &&
   1795          						((int8u)(time - xonTimer) >= XON_REFRESH_TIME) &&
   1796          						(xcmdCount < XON_REFRESH_COUNT) ) {
   1797          					halInternalUart1ForceXon();
   1798          				}
   1799          		)
   1800          	}
   1801          }
   1802          #endif
   1803          
   1804          #ifdef EMBER_SERIAL1_XONXOFF
   1805          // Must be called from within an ATOMIC block.
   1806          static void halInternalUart1ForceXon(void)
   1807          {
   1808          	if (xonXoffTxByte == ASCII_XOFF) {  // if XOFF waiting to be sent, cancel it
   1809          		xonXoffTxByte = 0;
   1810          		xcmdCount = 0;
   1811          	} else {                            // else, send XON and record the time
   1812          		xonXoffTxByte = ASCII_XON;
   1813          		halInternalStartUartTx(1);
   1814          	}
   1815          	xonTimer = halCommonGetInt16uQuarterSecondTick();
   1816          }
   1817          #endif
   1818          
   1819          #if EM_SERIAL1_ENABLED

   \                                 In section .text, align 2, keep-with-next
   1820          void halSc1Isr(void)
   1821          {
   \                     halSc1Isr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1822          	int32u interrupt;
   1823          
   1824          	//this read and mask is performed in two steps otherwise the compiler
   1825          	//will complain about undefined order of volatile access
   1826          	interrupt = INT_SC1FLAG;
   \   00000002   0x....             LDR.N    R4,??DataTable13  ;; 0x4000a808
   \   00000004   0xE00F             B.N      ??halSc1Isr_0
   1827          	interrupt &= INT_SC1CFG;
   1828          
   1829          #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1830          	while (interrupt != 0) {
   \                     ??halSc1Isr_1: (+1)
   \   00000006   0xF246 0x7029      MOVW     R0,#+26409
   1831          #endif // (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1832          
   1833          		INT_SC1FLAG = interrupt; // acknowledge the interrupts early
   \   0000000A   0x6025             STR      R5,[R4, #+0]
   1834          
   1835          		// RX events
   1836          		if ( interrupt & (INT_SCRXVAL   | // RX has data
   1837          				INT_SCRXOVF   | // RX Overrun error
   1838          				INT_SCRXFIN   | // RX done [TWI]
   1839          				INT_SCNAK     | // RX Nack [TWI]
   1840          				INT_SCRXULDA  | // RX DMA A has data
   1841          				INT_SCRXULDB  | // RX DMA B has data
   1842          				INT_SC1FRMERR | // RX Frame error
   1843          				INT_SC1PARERR ) // RX Parity error
   1844          		) {
   \   0000000C   0x4205             TST      R5,R0
   \   0000000E   0xD003             BEQ.N    ??halSc1Isr_2
   1845          			halInternalUartRxIsr(1, interrupt);
   \   00000010   0xB2A9             UXTH     R1,R5
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       halInternalUartRxIsr
   1846          		}
   1847          
   1848          		// TX events
   1849          		if ( interrupt & (INT_SCTXFREE | // TX has room
   1850          				INT_SCTXIDLE | // TX idle (more room)
   1851          				INT_SCTXUND  | // TX Underrun [SPI/TWI]
   1852          				INT_SCTXFIN  | // TX complete [TWI]
   1853          				INT_SCCMDFIN | // TX Start/Stop done [TWI]
   1854          				INT_SCTXULDA | // TX DMA A has room
   1855          				INT_SCTXULDB ) // TX DMA B has room
   1856          		) {
   \                     ??halSc1Isr_2: (+1)
   \   00000018   0xF641 0x00D6      MOVW     R0,#+6358
   \   0000001C   0x4205             TST      R5,R0
   \   0000001E   0xBF1C             ITT      NE 
   1857          			halInternalUartTxIsr(1);
   \   00000020   0x2001             MOVNE    R0,#+1
   \   00000022   0x.... 0x....      BLNE     halInternalUartTxIsr
   1858          		}
   1859          
   1860          #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1861          		interrupt = INT_SC1FLAG;
   \                     ??halSc1Isr_0: (+1)
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   1862          		interrupt &= INT_SC1CFG;
   \   00000028   0x6C21             LDR      R1,[R4, #+64]
   \   0000002A   0xEA11 0x0500      ANDS     R5,R1,R0
   1863          	}
   \   0000002E   0xD1EA             BNE.N    ??halSc1Isr_1
   1864          #endif // (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1865          }
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x4000A808         DC32     0x4000a808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x4000C854         DC32     0x4000c854

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x4000A848         DC32     0x4000a848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x4000C83C         DC32     0x4000c83c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x4000C848         DC32     0x4000c848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x........         DC32     emSerialRxQueues

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x........         DC32     emSerialRxErrorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x........         DC32     emSerialRxError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x........         DC32     emSerialRxQueueWraps

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x........         DC32     emSerialRxQueueSizes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x........         DC32     emSerialTxQueues

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x........         DC32     emSerialTxQueueWraps

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \   00000000   0x4000C85C         DC32     0x4000c85c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \   00000000   0x........         DC32     SC1_UARTPER_SAVED
   1866          #endif // EM_SERIAL1_ENABLED
   1867          
   1868          #if EM_SERIAL2_ENABLED
   1869          void halSc3Isr(void)
   1870          {
   1871          	int32u interrupt;
   1872          
   1873          	//this read and mask is performed in two steps otherwise the compiler
   1874          	//will complain about undefined order of volatile access
   1875          	interrupt = INT_SC3FLAG;
   1876          	interrupt &= INT_SC3CFG;
   1877          
   1878          #if (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
   1879          	while (interrupt != 0) {
   1880          #endif // (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
   1881          
   1882          		INT_SC3FLAG = interrupt; // acknowledge the interrupts early
   1883          
   1884          		// RX events
   1885          		if ( interrupt & (INT_SCRXVAL   | // RX has data
   1886          				INT_SCRXOVF   | // RX Overrun error
   1887          				INT_SCRXFIN   | // RX done [TWI]
   1888          				INT_SCNAK     | // RX Nack [TWI]
   1889          				INT_SCRXULDA  | // RX DMA A has data
   1890          				INT_SCRXULDB  | // RX DMA B has data
   1891          				INT_SC1FRMERR | // RX Frame error
   1892          				INT_SC1PARERR ) // RX Parity error
   1893          		) {
   1894          			halInternalUartRxIsr(2, interrupt);
   1895          		}
   1896          
   1897          		// TX events
   1898          		if ( interrupt & (INT_SCTXFREE | // TX has room
   1899          				INT_SCTXIDLE | // TX idle (more room)
   1900          				INT_SCTXUND  | // TX Underrun [SPI/TWI]
   1901          				INT_SCTXFIN  | // TX complete [TWI]
   1902          				INT_SCCMDFIN | // TX Start/Stop done [TWI]
   1903          				INT_SCTXULDA | // TX DMA A has room
   1904          				INT_SCTXULDB ) // TX DMA B has room
   1905          		) {
   1906          			halInternalUartTxIsr(2);
   1907          		}
   1908          
   1909          #if (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
   1910          		interrupt = INT_SC3FLAG;
   1911          		interrupt &= INT_SC3CFG;
   1912          	}
   1913          #endif // (EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO)
   1914          }
   1915          #endif // EM_SERIAL2_ENABLED
   1916          
   1917          static void uartErrorMark(int8u port, int8u errors)
   1918          {
   1919          	EmSerialFifoQueue *q = emSerialRxQueues[port];
   1920          
   1921          	// save error code & location in queue
   1922          	if ( emSerialRxError[port] == EMBER_SUCCESS ) {
   1923          		emSerialRxErrorIndex[port] = q->head;
   1924          		emSerialRxError[port] = errors;
   1925          	} else {
   1926          		// Flush back to previous error location & update value
   1927          		q->head = emSerialRxErrorIndex[port];
   1928          		emSerialRxError[port] = errors;
   1929          		if(q->head < q->tail) {
   1930          			q->used = (emSerialRxQueueSizes[port] - q->tail) + q->head;
   1931          		} else {
   1932          			q->used = q->head - q->tail;
   1933          		}
   1934          	}
   1935          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   halInternalForceReadUartByte
       0   halInternalForceWriteUartData
       0   halInternalInitUartInterrupts
       0   halInternalPowerDownUart
       0   halInternalPowerUpUart
         0   -> halInternalInitUartInterrupts
       0   halInternalRestartUart
      16   halInternalStartUartTx
        16   -> _disableBasePri
         0   -> _writeBasePri
        16   -> halInternalUartTxIsr
       0   halInternalStopUartTx
      16   halInternalUartInit
        16   -> halInternalInitUartInterrupts
        16   -> halInternalUartSetBaudRate
      28   halInternalUartRxIsr
       0   halInternalUartRxPump
       0   halInternalUartTxIsIdle
      16   halInternalUartTxIsr
       8   halInternalWaitUartTxComplete
         8   -> halInternalResetWatchDog
      16   halSc1Isr
        16   -> halInternalUartRxIsr
        16   -> halInternalUartTxIsr
       0   halStackReceiveVuartMessage


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      12  SC1_UARTPER_SAVED
          SC1_UARTFRAC_SAVED
          SC1_UARTCFG_SAVED
      20  baudSettings
      24  halInternalForceReadUartByte
      48  halInternalForceWriteUartData
      28  halInternalInitUartInterrupts
      18  halInternalPowerDownUart
      24  halInternalPowerUpUart
       2  halInternalRestartUart
      50  halInternalStartUartTx
      16  halInternalStopUartTx
     122  halInternalUartInit
     210  halInternalUartRxIsr
       2  halInternalUartRxPump
      30  halInternalUartTxIsIdle
      58  halInternalUartTxIsr
      22  halInternalWaitUartTxComplete
      50  halSc1Isr
       2  halStackReceiveVuartMessage

 
  12 bytes in section .bss
 786 bytes in section .text
 
 786 bytes of CODE memory
  12 bytes of DATA memory

Errors: none
Warnings: none

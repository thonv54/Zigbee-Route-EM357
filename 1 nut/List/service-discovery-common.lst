###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Apr/2016  13:01:49
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\service-discovery-common.c
#    Command line =  
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\service-discovery-common.c"
#        -D SWITCH_1_BUTTON -D NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D
#        CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"service-discovery-common.c\"" -lC "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\List\" --diag_suppress Pa050 -o "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\Obj\" --debug --endian=little --cpu=Cortex-M3
#        --no_path_in_file_macros --separate_cluster_for_initialized_variables
#        -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        "D:\Work Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\"
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\List\service-discovery-common.lst
#    Object file  =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\1
#        nut\Obj\service-discovery-common.o
#
###############################################################################

D:\Work Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\service-discovery-common.c
      1          // *****************************************************************************
      2          // * service-discovery-common.c
      3          // *
      4          // * Service discovery code that is common to different types of service
      5          // * discovery, e.g. match descriptor, NWK address lookup, and IEEE address
      6          // * lookup.
      7          // *
      8          // * Copyright 2010 by Ember Corporation. All rights reserved.              *80*
      9          // *****************************************************************************
     10          
     11          #include "app/framework/include/af.h"
     12          #include "app/util/zigbee-framework/zigbee-device-common.h"
     13          #ifdef EZSP_HOST
     14            #include "app/util/zigbee-framework/zigbee-device-host.h"
     15          #endif
     16          #include "service-discovery.h"
     17          
     18          #if EMBER_SUPPORTED_NETWORKS > 4
     19            #error "Service discovery is limited to four networks."
     20          #endif
     21          
     22          #define MAX_SIMPLE_DESCRIPTOR_RESPONSE_PAYLOAD \
     23            (128   /* 802.15.4 MTU */ \
     24             - 1   /* PHY length byte */ \
     25             - 11  /* MAC header 9 + 2 byte CRC */  \
     26             - 8   /* NWK header */ \
     27             - 18  /* NWK security header + 4-byte MIC */ \
     28             - 8   /* APS header */ \
     29             - EMBER_AF_ZDO_RESPONSE_OVERHEAD \
     30             - 3   /* Active Endpoint Response overhead: Address(2), length(1) */ \
     31            )
     32          
     33          #define SIMPLE_DESCRIPTOR_RESPONSE_ENDPOINT_OFFSET \
     34           (EMBER_AF_ZDO_RESPONSE_OVERHEAD \
     35            + 2  /* address of interest */ \
     36            + 1  /* length value */ \
     37            )
     38          
     39          #define SIMPLE_DESCRIPTOR_RESPONSE_PROFILE_ID_OFFSET \
     40           (SIMPLE_DESCRIPTOR_RESPONSE_ENDPOINT_OFFSET \
     41            + 1  /* endpoint */ \
     42            )
     43          
     44          #define SIMPLE_DESCRIPTOR_RESPONSE_DEVICE_ID_OFFSET \
     45            (SIMPLE_DESCRIPTOR_RESPONSE_PROFILE_ID_OFFSET + 2) 
     46          
     47          #define SIMPLE_DESCRIPTOR_RESPONSE_INPUT_CLUSTER_LIST_COUNT_INDEX \
     48            (SIMPLE_DESCRIPTOR_RESPONSE_DEVICE_ID_OFFSET \
     49             + 2  /* device ID length */ \
     50             + 1  /* version (4-bits), reserved (4-bits) */ \
     51           )
     52          
     53          #define SIMPLE_DESCRIPTOR_RESPONSE_INPUT_CLUSTER_LIST_INDEX \
     54           (SIMPLE_DESCRIPTOR_RESPONSE_INPUT_CLUSTER_LIST_COUNT_INDEX + 1)
     55          
     56          #define MAX_CLUSTERS_IN_ACTIVE_ENDPOINT_RESPONSE (MAX_SIMPLE_DESCRIPTOR_RESPONSE_PAYLOAD >> 1)
     57          
     58          #define ACTIVE_ENDPOINT_RESPONSE_COUNT_OFFSET \
     59           (EMBER_AF_ZDO_RESPONSE_OVERHEAD \
     60            + 2)  // Address of Interest
     61          
     62          //==============================================================================
     63          // Service discovery state machine
     64          //
     65          //   This code handles initiating a limited set of ZDO, receiving
     66          //   the response and sending it back to the cluster or code element that
     67          //   requested it.  Unfortunately the ZDO message does not have any distinct
     68          //   identifiers that would allow us to determine what cluster/endpoint on our
     69          //   local device initiated the request.  Therefore we can only allow one
     70          //    outstanding request at a time.
     71          

   \                                 In section .bss, align 4
     72          EmberEventControl emAfServiceDiscoveryEventControls[EMBER_SUPPORTED_NETWORKS];
   \                     emAfServiceDiscoveryEventControls:
   \   00000000                      DS8 8
   \   00000008                      DS8 12
     73          
     74          typedef struct {
     75            boolean active;
     76            EmberAfServiceDiscoveryCallback *callback;
     77            // This will contain the target type: broadcast or unicast (high bit)
     78            // and the ZDO cluster ID of the request.  Since ZDO requests
     79            // clear the high bit (only repsonses use it), we can use that leftover bit
     80            // for something else.
     81            int16u requestData;
     82          } State;
     83          static State states[EMBER_SUPPORTED_NETWORKS];
     84          
     85          #define UNICAST_QUERY_BIT (0x8000)
     86          #define isUnicastQuery(state) (UNICAST_QUERY_BIT == (state->requestData & UNICAST_QUERY_BIT))
     87          #define setUnicastQuery(state) (state->requestData |= UNICAST_QUERY_BIT)
     88          #define getRequestCluster(state) (state->requestData & ~UNICAST_QUERY_BIT)
     89          #define serviceDiscoveryInProgress(state) (state->active)
     90          
     91          #ifndef EMBER_AF_DISCOVERY_TIMEOUT_QS
     92            #define EMBER_AF_DISCOVERY_TIMEOUT_QS (2 * 4)
     93          #endif
     94          
     95          // seq. number (1), status (1), address (2), length (1)
     96          #define MATCH_DESCRIPTOR_OVERHEAD               5
     97          #define MINIMUM_MATCH_DESCRIPTOR_SUCCESS_LENGTH MATCH_DESCRIPTOR_OVERHEAD
     98          
     99          // seq. number (1), status (1)
    100          #define EMBER_AF_ZDO_RESPONSE_OVERHEAD 2
    101          // EUI64 (8), node ID (2),
    102          #define MINIMUM_ADDRESS_REQEUST_SUCCESS (EMBER_AF_ZDO_RESPONSE_OVERHEAD + 10)
    103          #define ADDRESS_RESPONSE_NODE_ID_OFFSET (EMBER_AF_ZDO_RESPONSE_OVERHEAD + EUI64_SIZE)
    104          
    105          // Address (2), EP Count (1)
    106          #define MINIMUM_ACTIVE_ENDPOINT_RESPONSE (EMBER_AF_ZDO_RESPONSE_OVERHEAD + 3)
    107          #define ACTIVE_ENDPOINT_RESPONSE_NODE_ID_OFFSET (EMBER_AF_ZDO_RESPONSE_OVERHEAD + 1)
    108          #define ACTIVE_ENDPOINT_RESPONSE_LIST_OFFSET (ACTIVE_ENDPOINT_RESPONSE_NODE_ID_OFFSET + 2)
    109          
    110          #define PREFIX "Svc Disc: "
    111          
    112          //==============================================================================
    113          // Forward Declarations
    114          
    115          static void setupDiscoveryData(State *state,
    116                                         EmberNodeId messageDest,
    117                                         EmberAfServiceDiscoveryCallback *callback,
    118                                         int16u zdoClusterId);
    119          
    120          //==============================================================================
    121          

   \                                 In section .text, align 2, keep-with-next
    122          EmberStatus emberAfFindDevicesByProfileAndCluster(EmberNodeId target,
    123                                                            EmberAfProfileId profileId,
    124                                                            EmberAfClusterId clusterId,
    125                                                            boolean serverCluster,
    126                                                            EmberAfServiceDiscoveryCallback *callback)
    127          {
   \                     emberAfFindDevicesByProfileAndCluster: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x4698             MOV      R8,R3
    128            State *state = &states[emberGetCurrentNetwork()];
   \   0000000C   0x.... 0x....      BL       emberGetCurrentNetwork
   \   00000010   0x210C             MOVS     R1,#+12
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable7
   \   00000016   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000001A   0xF100 0x0708      ADD      R7,R0,#+8
    129            EmberStatus status;
    130          
    131            if (serviceDiscoveryInProgress(state)) {
   \   0000001E   0x7838             LDRB     R0,[R7, #+0]
   \   00000020   0xB108             CBZ.N    R0,??emberAfFindDevicesByProfileAndCluster_0
    132              emberAfServiceDiscoveryPrintln("%pDiscovery already in progress", PREFIX);
    133              return EMBER_INVALID_CALL;
   \   00000022   0x2070             MOVS     R0,#+112
   \   00000024   0xE016             B.N      ??emberAfFindDevicesByProfileAndCluster_1
    134            }
    135          
    136            if (EMBER_BROADCAST_ADDRESS <= target
    137                && target != EMBER_RX_ON_WHEN_IDLE_BROADCAST_ADDRESS) {
   \                     ??emberAfFindDevicesByProfileAndCluster_0: (+1)
   \   00000026   0xF64F 0x71FC      MOVW     R1,#+65532
   \   0000002A   0x428C             CMP      R4,R1
   \   0000002C   0xDB04             BLT.N    ??emberAfFindDevicesByProfileAndCluster_2
   \   0000002E   0xF64F 0x71FD      MOVW     R1,#+65533
   \   00000032   0x428C             CMP      R4,R1
   \   00000034   0xBF18             IT       NE 
    138              // Note:  The core spec. only allows a Match Descriptor broadcast to
    139              // the 'rx on when idle' address.  No other broadcast addresses are allowed.
    140              // The Ember stack will silently discard broadcast match descriptors
    141              // to invalid broadcast addresses.
    142              emberAfServiceDiscoveryPrintln("%pIllegal broadcast address, remapping to valid one.",
    143                                             PREFIX);
    144              target = EMBER_RX_ON_WHEN_IDLE_BROADCAST_ADDRESS;
   \   00000036   0x460C             MOVNE    R4,R1
    145            }
    146          
    147            status = emAfSendMatchDescriptor(target, profileId, clusterId, serverCluster);
   \                     ??emberAfFindDevicesByProfileAndCluster_2: (+1)
   \   00000038   0x4643             MOV      R3,R8
   \   0000003A   0x4632             MOV      R2,R6
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       emAfSendMatchDescriptor
    148            if (status != EMBER_SUCCESS) {
   \   00000044   0xB930             CBNZ.N   R0,??emberAfFindDevicesByProfileAndCluster_1
    149              emberAfServiceDiscoveryPrintln("%pFailed to send match discovery: 0x%x",
    150                                             PREFIX,
    151                                             status);
    152              return status;
    153            }
    154          
    155            emberAfServiceDiscoveryPrintln("%pStarting discovery for cluster 0x%2x",
    156                                           PREFIX,
    157                                           clusterId);
    158          
    159            setupDiscoveryData(state, target, callback, MATCH_DESCRIPTORS_REQUEST);
   \   00000046   0x9A06             LDR      R2,[SP, #+24]
   \   00000048   0x2306             MOVS     R3,#+6
   \   0000004A   0x4621             MOV      R1,R4
   \   0000004C   0x4638             MOV      R0,R7
   \   0000004E   0x.... 0x....      BL       setupDiscoveryData
    160          
    161            return EMBER_SUCCESS;
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??emberAfFindDevicesByProfileAndCluster_1: (+1)
   \   00000054   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    162          }
    163          

   \                                 In section .text, align 2, keep-with-next
    164          EmberStatus emberAfFindActiveEndpoints(EmberNodeId target,
    165                                                 EmberAfServiceDiscoveryCallback *callback)
    166          {
   \                     emberAfFindActiveEndpoints: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine0
    167            State *state = &states[emberGetCurrentNetwork()];
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000006   0x210C             MOVS     R1,#+12
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable7
   \   0000000C   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000010   0xF100 0x0608      ADD      R6,R0,#+8
    168            EmberStatus status;
    169            
    170            if (serviceDiscoveryInProgress(state)) {
   \   00000014   0x7830             LDRB     R0,[R6, #+0]
   \   00000016   0xB108             CBZ.N    R0,??emberAfFindActiveEndpoints_0
    171              return EMBER_INVALID_CALL;
   \   00000018   0x2070             MOVS     R0,#+112
   \   0000001A   0xBD70             POP      {R4-R6,PC}
    172            }
    173          
    174            status = emberActiveEndpointsRequest(target, EMBER_AF_DEFAULT_APS_OPTIONS);
   \                     ??emberAfFindActiveEndpoints_0: (+1)
   \   0000001C   0xF44F 0x5288      MOV      R2,#+4352
   \   00000020   0x2105             MOVS     R1,#+5
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       emberSendZigDevRequestTarget
    175            if (status != EMBER_SUCCESS) {
   \   00000028   0xB918             CBNZ.N   R0,??emberAfFindActiveEndpoints_1
    176              emberAfServiceDiscoveryPrintln("%pFailed to send active endpoint request: 0x%x",
    177                                             PREFIX,
    178                                             status);    
    179              return status;
    180            }
    181            setupDiscoveryData(state, target, callback, ACTIVE_ENDPOINTS_REQUEST);
   \   0000002A   0x2305             MOVS     R3,#+5
   \   0000002C   0x.... 0x....      BL       ?Subroutine2
    182            return status;
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??emberAfFindActiveEndpoints_1: (+1)
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    183          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x462A             MOV      R2,R5
   \   00000002   0x4621             MOV      R1,R4
   \   00000004   0x4630             MOV      R0,R6
   \   00000006   0x....             B.N      setupDiscoveryData

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x.... 0x....      B.W      emberGetCurrentNetwork
    184          

   \                                 In section .text, align 2, keep-with-next
    185          EmberStatus emberAfFindClustersByDeviceAndEndpoint(EmberNodeId target,
    186                                                             int8u targetEndpoint,
    187                                                             EmberAfServiceDiscoveryCallback *callback) {
   \                     emberAfFindClustersByDeviceAndEndpoint: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    188            
    189            State *state = &states[emberGetCurrentNetwork()];
   \   00000008   0x.... 0x....      BL       emberGetCurrentNetwork
   \   0000000C   0x210C             MOVS     R1,#+12
   \   0000000E   0x....             LDR.N    R2,??DataTable7
   \   00000010   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000014   0xF100 0x0708      ADD      R7,R0,#+8
    190            EmberStatus status;
    191            
    192            if (serviceDiscoveryInProgress(state)) {
   \   00000018   0x7838             LDRB     R0,[R7, #+0]
   \   0000001A   0xB108             CBZ.N    R0,??emberAfFindClustersByDeviceAndEndpoint_0
    193              return EMBER_INVALID_CALL;
   \   0000001C   0x2070             MOVS     R0,#+112
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}
    194            }
    195          
    196            status = emberSimpleDescriptorRequest(target,
    197                                                  targetEndpoint,
    198                                                  EMBER_AF_DEFAULT_APS_OPTIONS);
   \                     ??emberAfFindClustersByDeviceAndEndpoint_0: (+1)
   \   00000020   0xF44F 0x5288      MOV      R2,#+4352
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       emberSimpleDescriptorRequest
    199            
    200            if (status != EMBER_SUCCESS) {
   \   0000002C   0xB930             CBNZ.N   R0,??emberAfFindClustersByDeviceAndEndpoint_1
    201              emberAfServiceDiscoveryPrintln("%pFailed to send simple descriptor request: 0x%x",
    202                                             PREFIX,
    203                                             status);
    204              return status;
    205            }
    206            
    207            setupDiscoveryData(state, target, callback, SIMPLE_DESCRIPTOR_REQUEST);
   \   0000002E   0x2304             MOVS     R3,#+4
   \   00000030   0x4632             MOV      R2,R6
   \   00000032   0x4621             MOV      R1,R4
   \   00000034   0x4638             MOV      R0,R7
   \   00000036   0x.... 0x....      BL       setupDiscoveryData
    208            
    209            return status;
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??emberAfFindClustersByDeviceAndEndpoint_1: (+1)
   \   0000003C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    210          }
    211          

   \                                 In section .text, align 2, keep-with-next
    212          EmberStatus emberAfFindIeeeAddress(EmberNodeId shortAddress,
    213                                             EmberAfServiceDiscoveryCallback *callback)
    214          {
   \                     emberAfFindIeeeAddress: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine0
    215            State *state = &states[emberGetCurrentNetwork()];
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000006   0x210C             MOVS     R1,#+12
   \   00000008   0x....             LDR.N    R2,??DataTable7
   \   0000000A   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000000E   0xF100 0x0608      ADD      R6,R0,#+8
    216            EmberStatus status;
    217          
    218            if (serviceDiscoveryInProgress(state)) {
   \   00000012   0x7830             LDRB     R0,[R6, #+0]
   \   00000014   0xB108             CBZ.N    R0,??emberAfFindIeeeAddress_0
    219              return EMBER_INVALID_CALL;
   \   00000016   0x2070             MOVS     R0,#+112
   \   00000018   0xBD70             POP      {R4-R6,PC}
    220            }
    221          
    222            status = emberIeeeAddressRequest(shortAddress,
    223                                             FALSE,         // report kids?
    224                                             0,             // child start index
    225                                             EMBER_APS_OPTION_RETRY);
   \                     ??emberAfFindIeeeAddress_0: (+1)
   \   0000001A   0x2340             MOVS     R3,#+64
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       emberIeeeAddressRequest
    226          
    227            if (status != EMBER_SUCCESS) {
   \   00000026   0xB918             CBNZ.N   R0,??emberAfFindIeeeAddress_1
    228              emberAfServiceDiscoveryPrintln("%pFailed to send IEEE address request: 0x%x",
    229                                             PREFIX,
    230                                             status);
    231              return status;
    232            }
    233          
    234            setupDiscoveryData(state, shortAddress, callback, IEEE_ADDRESS_REQUEST);
   \   00000028   0x2301             MOVS     R3,#+1
   \   0000002A   0x.... 0x....      BL       ?Subroutine2
    235          
    236            return status;
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??emberAfFindIeeeAddress_1: (+1)
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    237          }
    238          

   \                                 In section .text, align 2, keep-with-next
    239          EmberStatus emberAfFindNodeId(EmberEUI64 longAddress,
    240                                        EmberAfServiceDiscoveryCallback *callback)
    241          {
   \                     emberAfFindNodeId: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine0
    242            State *state = &states[emberGetCurrentNetwork()];
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000006   0x210C             MOVS     R1,#+12
   \   00000008   0x....             LDR.N    R2,??DataTable7
   \   0000000A   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000000E   0xF100 0x0608      ADD      R6,R0,#+8
    243            EmberStatus status;
    244          
    245            if (serviceDiscoveryInProgress(state)) {
   \   00000012   0x7830             LDRB     R0,[R6, #+0]
   \   00000014   0xB108             CBZ.N    R0,??emberAfFindNodeId_0
    246              return EMBER_INVALID_CALL;
   \   00000016   0x2070             MOVS     R0,#+112
   \   00000018   0xBD70             POP      {R4-R6,PC}
    247            }
    248          
    249            status = emberNetworkAddressRequest(longAddress,
    250                                                FALSE,         // report kids?
    251                                                0);            // child start index
   \                     ??emberAfFindNodeId_0: (+1)
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       emberNetworkAddressRequest
    252          
    253            if (status != EMBER_SUCCESS) {
   \   00000024   0xB938             CBNZ.N   R0,??emberAfFindNodeId_1
    254              emberAfServiceDiscoveryPrintln("%pFailed to send NWK address request: 0x%x",
    255                                             PREFIX,
    256                                             status);
    257              return status;
    258            }
    259          
    260            setupDiscoveryData(state,
    261                               EMBER_BROADCAST_ADDRESS,
    262                               callback,
    263                               NETWORK_ADDRESS_REQUEST);
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0x462A             MOV      R2,R5
   \   0000002A   0xF64F 0x71FC      MOVW     R1,#+65532
   \   0000002E   0x4630             MOV      R0,R6
   \   00000030   0x.... 0x....      BL       setupDiscoveryData
    264          
    265            return status;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??emberAfFindNodeId_1: (+1)
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    266          }
    267          

   \                                 In section .text, align 2, keep-with-next
    268          static void setupDiscoveryData(State *state,
    269                                         EmberNodeId messageDest,
    270                                         EmberAfServiceDiscoveryCallback *callback,
    271                                         int16u zdoClusterRequest)
    272          {
   \                     setupDiscoveryData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    273            state->active = TRUE;
   \   00000002   0x2401             MOVS     R4,#+1
   \   00000004   0x7004             STRB     R4,[R0, #+0]
    274            state->requestData = zdoClusterRequest;
    275            if (messageDest < EMBER_BROADCAST_ADDRESS) {
   \   00000006   0xF64F 0x74FC      MOVW     R4,#+65532
   \   0000000A   0x42A1             CMP      R1,R4
   \   0000000C   0xBFB8             IT       LT 
    276              setUnicastQuery(state);
   \   0000000E   0xF443 0x4300      ORRLT    R3,R3,#0x8000
   \   00000012   0x8103             STRH     R3,[R0, #+8]
    277            }
    278            state->callback = callback;
   \   00000014   0x6042             STR      R2,[R0, #+4]
    279            emberAfServiceDiscoveryPrintln("%pWaiting %d sec for discovery to complete",
    280                                           PREFIX,
    281                                           EMBER_AF_DISCOVERY_TIMEOUT_QS >> 2);
    282            emberAfNetworkEventControlSetDelayQS(emAfServiceDiscoveryEventControls,
    283                                                 EMBER_AF_DISCOVERY_TIMEOUT_QS);
   \   00000016   0x2108             MOVS     R1,#+8
   \   00000018   0x....             LDR.N    R0,??DataTable7
   \   0000001A   0x.... 0x....      BL       emberAfNetworkEventControlSetDelayQS
    284          
    285            // keep sleepy end devices out of hibernation until
    286            // service discovery is complete
    287            emberAfAddToCurrentAppTasks(EMBER_AF_WAITING_FOR_SERVICE_DISCOVERY);
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0x.... 0x....      B.W      emberAfAddToCurrentAppTasksCallback
    288          }
    289          

   \                                 In section .text, align 2, keep-with-next
    290          static void serviceDiscoveryComplete(int8u networkIndex)
    291          {
   \                     serviceDiscoveryComplete: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
    292            State *state = &states[networkIndex];
   \   00000002   0x....             LDR.N    R4,??DataTable7
   \   00000004   0x210C             MOVS     R1,#+12
   \   00000006   0xFB01 0x4100      MLA      R1,R1,R0,R4
   \   0000000A   0xF101 0x0508      ADD      R5,R1,#+8
    293          
    294            emberAfPushNetworkIndex(networkIndex);
   \   0000000E   0x.... 0x....      BL       emberAfPushNetworkIndex
    295          
    296            state->active = FALSE;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7028             STRB     R0,[R5, #+0]
    297            emberAfServiceDiscoveryPrintln("%pcomplete.", PREFIX);
    298            emberAfNetworkEventControlSetInactive(emAfServiceDiscoveryEventControls);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       emberAfNetworkEventControlSetInactive
    299          
    300            // allow sleepy end devices to go into hibernation now.
    301            emberAfRemoveFromCurrentAppTasks(EMBER_AF_WAITING_FOR_SERVICE_DISCOVERY);
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0x.... 0x....      BL       emberAfRemoveFromCurrentAppTasksCallback
    302          
    303            if (state->callback != NULL) {
   \   00000022   0x6869             LDR      R1,[R5, #+4]
   \   00000024   0x0008             MOVS     R0,R1
   \   00000026   0xD010             BEQ.N    ??serviceDiscoveryComplete_0
    304              EmberAfServiceDiscoveryResult result;
    305              result.status = (isUnicastQuery(state)
    306                               ? EMBER_AF_UNICAST_SERVICE_DISCOVERY_TIMEOUT
    307                               : EMBER_AF_BROADCAST_SERVICE_DISCOVERY_COMPLETE);
   \   00000028   0x8928             LDRH     R0,[R5, #+8]
   \   0000002A   0x0402             LSLS     R2,R0,#+16
   \   0000002C   0xBF4C             ITE      MI 
   \   0000002E   0x2202             MOVMI    R2,#+2
   \   00000030   0x2200             MOVPL    R2,#+0
    308              result.zdoRequestClusterId = getRequestCluster(state);
   \   00000032   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000036   0xF88D 0x2000      STRB     R2,[SP, #+0]
    309              result.matchAddress = EMBER_NULL_NODE_ID;
   \   0000003A   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000003E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    310              result.responseData = NULL;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x9002             STR      R0,[SP, #+8]
    311              (*state->callback)(&result);
   \   00000046   0xA800             ADD      R0,SP,#+0
   \   00000048   0x4788             BLX      R1
    312            }
    313          
    314            emberAfPopNetworkIndex();
   \                     ??serviceDiscoveryComplete_0: (+1)
   \   0000004A   0x.... 0x....      BL       emberAfPopNetworkIndex
    315          }
   \   0000004E   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x0440             LSLS     R0,R0,#+17
   \   00000002   0x0C40             LSRS     R0,R0,#+17
   \   00000004   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \   00000008   0x4770             BX       LR
    316          

   \                                 In section .text, align 2, keep-with-next
    317          void emAfServiceDiscoveryComplete0(void)
    318          {
    319            serviceDiscoveryComplete(0);
   \                     emAfServiceDiscoveryComplete0: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             B.N      serviceDiscoveryComplete
    320          }
    321          

   \                                 In section .text, align 2, keep-with-next
    322          void emAfServiceDiscoveryComplete1(void)
    323          {
    324            serviceDiscoveryComplete(1);
   \                     emAfServiceDiscoveryComplete1: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             B.N      serviceDiscoveryComplete
    325          }
    326          

   \                                 In section .text, align 2, keep-with-next
    327          void emAfServiceDiscoveryComplete2(void)
    328          {
    329            serviceDiscoveryComplete(2);
   \                     emAfServiceDiscoveryComplete2: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0x....             B.N      serviceDiscoveryComplete
    330          }
    331          

   \                                 In section .text, align 2, keep-with-next
    332          void emAfServiceDiscoveryComplete3(void)
    333          {
    334            serviceDiscoveryComplete(3);
   \                     emAfServiceDiscoveryComplete3: (+1)
   \   00000000   0x2003             MOVS     R0,#+3
   \   00000002   0x....             B.N      serviceDiscoveryComplete
    335          }
    336          

   \                                 In section .text, align 2, keep-with-next
    337          static void executeCallback(State *state,
    338                                      const EmberAfServiceDiscoveryResult *result)
    339          {
   \                     executeCallback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    340            (*state->callback)(result);
   \   00000006   0x6861             LDR      R1,[R4, #+4]
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x4788             BLX      R1
    341            if (isUnicastQuery(state)
    342                || result->status == EMBER_AF_BROADCAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE) {
   \   0000000C   0x8920             LDRH     R0,[R4, #+8]
   \   0000000E   0x0400             LSLS     R0,R0,#+16
   \   00000010   0xD402             BMI.N    ??executeCallback_0
   \   00000012   0x7828             LDRB     R0,[R5, #+0]
   \   00000014   0x2804             CMP      R0,#+4
   \   00000016   0xD106             BNE.N    ??executeCallback_1
    343              // If the request was unicast and we received a response then we are done.
    344              // No need to wait for the timer to expire.
    345              // Alternatively certain broadcast requests are only expected to get 1 response,
    346              // or we only care about the 1st response.
    347          
    348              // We NULL the callback as a way of indicating we already fired it.
    349              // For timeouts, the callback will not be NULL and still fire.
    350              state->callback = NULL;
   \                     ??executeCallback_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6060             STR      R0,[R4, #+4]
    351              serviceDiscoveryComplete(emberGetCurrentNetwork());
   \   0000001C   0x.... 0x....      BL       emberGetCurrentNetwork
   \   00000020   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000024   0x....             B.N      serviceDiscoveryComplete
    352            }
    353          }
   \                     ??executeCallback_1: (+1)
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    354          
    355          static boolean processMatchDescriptorResponse(State *state,
    356                                                        const int8u *message,
    357                                                        int16u length)
    358          {
    359            EmberNodeId matchId;
    360            int8u listLength;
    361          
    362            if (length < MINIMUM_MATCH_DESCRIPTOR_SUCCESS_LENGTH) {
    363              emberAfServiceDiscoveryPrintln("%pMessage too short", PREFIX);
    364              return TRUE;
    365            }
    366          
    367            // This will now be used as the length of the match list.
    368            length -= MATCH_DESCRIPTOR_OVERHEAD;
    369          
    370            // If the parent of a sleepy device supports caching its descriptor
    371            // information then the sender of the response may not be the device
    372            // that actually matches the request.  The device id that matches
    373            // is included in the message.
    374            matchId = message[2] + (message[3] << 8);
    375            listLength = message[4];
    376          
    377            if (listLength != length) {
    378              emberAfServiceDiscoveryPrintln("%pMessage too short for num. endpoints",
    379                                             PREFIX);
    380              return TRUE;
    381            }
    382          
    383            emberAfServiceDiscoveryPrintln("%pMatch%p found from 0x%2x.",
    384                                           PREFIX,
    385                                           (listLength > 0
    386                                            ? ""
    387                                            : " NOT"),
    388                                           matchId);
    389          
    390            // If we got an active response with an empty list then ignore it.
    391            if (listLength != 0) {
    392              EmberAfServiceDiscoveryResult result;
    393              EmberAfEndpointList endpointList;
    394              endpointList.count = length;
    395              endpointList.list = &(message[MATCH_DESCRIPTOR_OVERHEAD]);
    396              result.status = (isUnicastQuery(state)
    397                               ? EMBER_AF_UNICAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE
    398                               : EMBER_AF_BROADCAST_SERVICE_DISCOVERY_RESPONSE_RECEIVED);
    399              result.zdoRequestClusterId = getRequestCluster(state);
    400              result.matchAddress = matchId;
    401              result.responseData = &endpointList;
    402              executeCallback(state, &result);
    403            }
    404            return TRUE;
    405          }
    406          

   \                                 In section .text, align 2, keep-with-next
    407          static boolean processSimpleDescriptorResponse(State *state,
    408                                                         const int8u *message,
    409                                                         int16u length) 
    410          {
   \                     processSimpleDescriptorResponse: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB09C             SUB      SP,SP,#+112
    411            EmberAfServiceDiscoveryResult result;
    412            EmberAfClusterList clusterList;
    413          
    414            clusterList.profileId = message[SIMPLE_DESCRIPTOR_RESPONSE_PROFILE_ID_OFFSET]
    415                                    + (message[SIMPLE_DESCRIPTOR_RESPONSE_PROFILE_ID_OFFSET + 1] << 8);
   \   00000006   0x798B             LDRB     R3,[R1, #+6]
   \   00000008   0x79CC             LDRB     R4,[R1, #+7]
   \   0000000A   0xEB03 0x2304      ADD      R3,R3,R4, LSL #+8
   \   0000000E   0xF8AD 0x301C      STRH     R3,[SP, #+28]
    416            clusterList.deviceId = message[SIMPLE_DESCRIPTOR_RESPONSE_DEVICE_ID_OFFSET]
    417                                   + (message[SIMPLE_DESCRIPTOR_RESPONSE_DEVICE_ID_OFFSET + 1] << 8);
    418            clusterList.endpoint = message[SIMPLE_DESCRIPTOR_RESPONSE_ENDPOINT_OFFSET];
    419          
    420            // Copying the cluster list to a separate array
    421            // is primarily necessary on Big endian CPUs where
    422            // the over-the-air Zigbee messages are all little-endian
    423            // and we cannot just cast the message pointer into an int16u* array.
    424            // However we also do it for the little endian CPUs because the 
    425            // message can actually be truncated due to bad Zigbee stacks.
    426            int16u clusters[MAX_CLUSTERS_IN_ACTIVE_ENDPOINT_RESPONSE];
    427            int8u index = SIMPLE_DESCRIPTOR_RESPONSE_INPUT_CLUSTER_LIST_INDEX;
    428            clusterList.inClusterCount = message[SIMPLE_DESCRIPTOR_RESPONSE_INPUT_CLUSTER_LIST_COUNT_INDEX];
    429            // The +1 is for the input cluster count length.
    430            clusterList.outClusterCount = message[SIMPLE_DESCRIPTOR_RESPONSE_INPUT_CLUSTER_LIST_COUNT_INDEX
    431                                                  + 1 + (clusterList.inClusterCount * 2)];
    432          
    433            if ((length - index - 1) % 2 != 0) {  // subtract 1 for the output cluster count.
   \   00000012   0x3A0D             SUBS     R2,R2,#+13
   \   00000014   0x7A0B             LDRB     R3,[R1, #+8]
   \   00000016   0x7A4C             LDRB     R4,[R1, #+9]
   \   00000018   0xEB03 0x2304      ADD      R3,R3,R4, LSL #+8
   \   0000001C   0xF8AD 0x301E      STRH     R3,[SP, #+30]
   \   00000020   0xEB02 0x75D2      ADD      R5,R2,R2, LSR #+31
   \   00000024   0x794B             LDRB     R3,[R1, #+5]
   \   00000026   0xF88D 0x3020      STRB     R3,[SP, #+32]
   \   0000002A   0x230C             MOVS     R3,#+12
   \   0000002C   0x7ACC             LDRB     R4,[R1, #+11]
   \   0000002E   0xF88D 0x400C      STRB     R4,[SP, #+12]
   \   00000032   0x106D             ASRS     R5,R5,#+1
   \   00000034   0xEB01 0x0444      ADD      R4,R1,R4, LSL #+1
   \   00000038   0xEBB2 0x0245      SUBS     R2,R2,R5, LSL #+1
   \   0000003C   0x7B24             LDRB     R4,[R4, #+12]
   \   0000003E   0xF88D 0x4014      STRB     R4,[SP, #+20]
   \   00000042   0xD142             BNE.N    ??processSimpleDescriptorResponse_0
    434              emberAfServiceDiscoveryPrintln("Error: %p bad simple descriptor length.", PREFIX);
    435              // Return true because we still tried to process the message.
    436              return TRUE;
    437            }
    438            int8u loop;
    439            int8u clusterIndex = 0;
    440            for (loop = 0; loop < 2; loop++) {
   \   00000044   0x2500             MOVS     R5,#+0
   \   00000046   0xE000             B.N      ??processSimpleDescriptorResponse_1
    441              int8u count;
    442              int8u i;
    443              if (loop == 0) {
   \                     ??processSimpleDescriptorResponse_2: (+1)
   \   00000048   0xB935             CBNZ.N   R5,??processSimpleDescriptorResponse_3
    444                clusterList.inClusterList = &(clusters[clusterIndex]);
   \                     ??processSimpleDescriptorResponse_1: (+1)
   \   0000004A   0xAE09             ADD      R6,SP,#+36
   \   0000004C   0xEB06 0x0642      ADD      R6,R6,R2, LSL #+1
    445                count = clusterList.inClusterCount;
   \   00000050   0xF89D 0x800C      LDRB     R8,[SP, #+12]
   \   00000054   0x9604             STR      R6,[SP, #+16]
   \   00000056   0xE004             B.N      ??processSimpleDescriptorResponse_4
    446              } else {
    447                clusterList.outClusterList = &(clusters[clusterIndex]);
   \                     ??processSimpleDescriptorResponse_3: (+1)
   \   00000058   0xAF09             ADD      R7,SP,#+36
   \   0000005A   0xEB07 0x0646      ADD      R6,R7,R6, LSL #+1
   \   0000005E   0x9606             STR      R6,[SP, #+24]
    448                count = clusterList.outClusterCount;
   \   00000060   0x46A0             MOV      R8,R4
    449              }
    450              for (i = 0; i < count; i++) {
   \                     ??processSimpleDescriptorResponse_4: (+1)
   \   00000062   0xF04F 0x0C00      MOV      R12,#+0
   \   00000066   0xE00D             B.N      ??processSimpleDescriptorResponse_5
    451                clusters[clusterIndex] = message[index] + (message[index+1] << 8);
   \                     ??processSimpleDescriptorResponse_6: (+1)
   \   00000068   0x185F             ADDS     R7,R3,R1
   \   0000006A   0xF813 0xE001      LDRB     LR,[R3, R1]
   \   0000006E   0x787F             LDRB     R7,[R7, #+1]
   \   00000070   0xEB0E 0x2E07      ADD      LR,LR,R7, LSL #+8
   \   00000074   0xAF09             ADD      R7,SP,#+36
    452                clusterIndex++;
    453                index += 2;
   \   00000076   0x1C9B             ADDS     R3,R3,#+2
   \   00000078   0xF827 0xE016      STRH     LR,[R7, R6, LSL #+1]
   \   0000007C   0x1C52             ADDS     R2,R2,#+1
   \   0000007E   0xB2DB             UXTB     R3,R3
    454              }
   \   00000080   0xF10C 0x0C01      ADD      R12,R12,#+1
   \                     ??processSimpleDescriptorResponse_5: (+1)
   \   00000084   0xB2D2             UXTB     R2,R2
   \   00000086   0xFA5F 0xFC8C      UXTB     R12,R12
   \   0000008A   0x4616             MOV      R6,R2
   \   0000008C   0x45C4             CMP      R12,R8
   \   0000008E   0xDBEB             BLT.N    ??processSimpleDescriptorResponse_6
    455              if (loop == 0) {
   \   00000090   0xB90D             CBNZ.N   R5,??processSimpleDescriptorResponse_7
    456                // This is the output cluster count
    457                index++;
   \   00000092   0x1C5B             ADDS     R3,R3,#+1
   \   00000094   0xB2DB             UXTB     R3,R3
    458              }
    459            }
   \                     ??processSimpleDescriptorResponse_7: (+1)
   \   00000096   0x1C6D             ADDS     R5,R5,#+1
   \   00000098   0x2D02             CMP      R5,#+2
   \   0000009A   0xDBD5             BLT.N    ??processSimpleDescriptorResponse_2
    460          
    461            result.status = (isUnicastQuery(state)
    462                             ? EMBER_AF_UNICAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE
    463                             : EMBER_AF_BROADCAST_SERVICE_DISCOVERY_RESPONSE_RECEIVED);
   \   0000009C   0x8902             LDRH     R2,[R0, #+8]
   \   0000009E   0x0412             LSLS     R2,R2,#+16
   \   000000A0   0xBF4C             ITE      MI 
   \   000000A2   0x2203             MOVMI    R2,#+3
   \   000000A4   0x2201             MOVPL    R2,#+1
   \   000000A6   0xF88D 0x2000      STRB     R2,[SP, #+0]
    464            result.matchAddress = message[2] + (message[3] << 8);
   \   000000AA   0x788A             LDRB     R2,[R1, #+2]
   \   000000AC   0x78C9             LDRB     R1,[R1, #+3]
   \   000000AE   0xEB02 0x2101      ADD      R1,R2,R1, LSL #+8
   \   000000B2   0xF8AD 0x1004      STRH     R1,[SP, #+4]
    465            result.zdoRequestClusterId = getRequestCluster(state);
   \   000000B6   0x8901             LDRH     R1,[R0, #+8]
   \   000000B8   0x0449             LSLS     R1,R1,#+17
   \   000000BA   0x0C49             LSRS     R1,R1,#+17
   \   000000BC   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    466            result.responseData = &clusterList;
   \   000000C0   0xA903             ADD      R1,SP,#+12
   \   000000C2   0x9102             STR      R1,[SP, #+8]
    467          
    468            executeCallback(state, &result);
   \   000000C4   0xA900             ADD      R1,SP,#+0
   \   000000C6   0x.... 0x....      BL       executeCallback
    469            return TRUE;
   \                     ??processSimpleDescriptorResponse_0: (+1)
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0xB01C             ADD      SP,SP,#+112
   \   000000CE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    470          }
    471          
    472          // Both NWK and IEEE responses have the same exact format.
    473          static boolean processAddressResponse(State *state,
    474                                                const int8u *message,
    475                                                int16u length)
    476          {
    477            EmberAfServiceDiscoveryResult result;
    478            EmberEUI64 eui64LittleEndian;
    479          
    480            if (length < MINIMUM_ADDRESS_REQEUST_SUCCESS) {
    481              emberAfServiceDiscoveryPrintln("%pMessage too short", PREFIX);
    482              return TRUE;
    483            }
    484            MEMMOVE(eui64LittleEndian, message + EMBER_AF_ZDO_RESPONSE_OVERHEAD, EUI64_SIZE);
    485            // Given that we only expect one response, we set the status to complete even
    486            // though the request was broadcast.
    487            result.status = (isUnicastQuery(state)
    488                             ? EMBER_AF_UNICAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE
    489                             : EMBER_AF_BROADCAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE);
    490            result.matchAddress = (message[ADDRESS_RESPONSE_NODE_ID_OFFSET]
    491                                   + (message[ADDRESS_RESPONSE_NODE_ID_OFFSET+1] << 8));
    492            result.zdoRequestClusterId = getRequestCluster(state);
    493            result.responseData = eui64LittleEndian;
    494          
    495            executeCallback(state, &result);
    496            return TRUE;
    497          }
    498          
    499          static boolean processActiveEndpointResponse(State* state,
    500                                                       const int8u* message,
    501                                                       int16u length)
    502          {
    503            EmberAfServiceDiscoveryResult result;
    504            EmberAfEndpointList listStruct;
    505            if (length < MINIMUM_ACTIVE_ENDPOINT_RESPONSE) {
    506              emberAfServiceDiscoveryPrintln("%pMessage too short", PREFIX);
    507              return TRUE;    
    508            }
    509            result.matchAddress = (message[ACTIVE_ENDPOINT_RESPONSE_NODE_ID_OFFSET]
    510                                   + (message[ACTIVE_ENDPOINT_RESPONSE_NODE_ID_OFFSET + 1] << 8));
    511            int8u count = message[ACTIVE_ENDPOINT_RESPONSE_COUNT_OFFSET];
    512          
    513            // +1 for count value iteslf, +2 for node ID
    514            int8u expectedLength = EMBER_AF_ZDO_RESPONSE_OVERHEAD + 1 + 2 + count;  
    515          
    516            if (expectedLength != length) {
    517              emberAfServiceDiscoveryPrintln("Error: %p invalid length (%d != %d) for Active Endpoint response", 
    518                                             PREFIX,
    519                                             expectedLength,
    520                                             length);
    521              return TRUE;
    522            }
    523            emberAfServiceDiscoveryPrintln("%pgot active EP response", PREFIX);
    524            result.status = (isUnicastQuery(state)
    525                             ? EMBER_AF_UNICAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE
    526                             : EMBER_AF_BROADCAST_SERVICE_DISCOVERY_RESPONSE_RECEIVED);
    527            result.zdoRequestClusterId = getRequestCluster(state);
    528            result.responseData = &listStruct;
    529            listStruct.list = &(message[ACTIVE_ENDPOINT_RESPONSE_LIST_OFFSET]);
    530            listStruct.count = message[ACTIVE_ENDPOINT_RESPONSE_COUNT_OFFSET];
    531            executeCallback(state, &result);
    532            return TRUE;
    533          }
    534          

   \                                 In section .text, align 2, keep-with-next
    535          boolean emAfServiceDiscoveryIncoming(EmberNodeId sender,
    536                                               EmberApsFrame *apsFrame,
    537                                               const int8u *message,
    538                                               int16u length)
    539          {
   \                     emAfServiceDiscoveryIncoming: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4614             MOV      R4,R2
   \   00000008   0x461E             MOV      R6,R3
    540            State *state = &states[emberGetCurrentNetwork()];
   \   0000000A   0x.... 0x....      BL       emberGetCurrentNetwork
   \   0000000E   0x210C             MOVS     R1,#+12
   \   00000010   0x....             LDR.N    R2,??DataTable7
   \   00000012   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000016   0xF100 0x0508      ADD      R5,R0,#+8
    541            if (!(serviceDiscoveryInProgress(state)
    542                  && (apsFrame->profileId == EMBER_ZDO_PROFILE_ID
    543                      // ZDO Responses set the high bit on the request cluster ID
    544                      && (apsFrame->clusterId == (CLUSTER_ID_RESPONSE_MINIMUM
    545                                                  | getRequestCluster(state)))))) {
   \   0000001A   0x7828             LDRB     R0,[R5, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD016             BEQ.N    ??emAfServiceDiscoveryIncoming_0
   \   00000020   0x8838             LDRH     R0,[R7, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xBF01             ITTTT    EQ 
   \   00000026   0x8878             LDRHEQ   R0,[R7, #+2]
   \   00000028   0x8929             LDRHEQ   R1,[R5, #+8]
   \   0000002A   0xF441 0x4100      ORREQ    R1,R1,#0x8000
   \   0000002E   0x4288             CMPEQ    R0,R1
   \   00000030   0xD176             BNE.N    ??emAfServiceDiscoveryIncoming_1
    546              return FALSE;
    547            }
    548          
    549            // The second byte is the status code
    550            if (message[1] != EMBER_ZDP_SUCCESS) {
   \   00000032   0x7861             LDRB     R1,[R4, #+1]
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD171             BNE.N    ??emAfServiceDiscoveryIncoming_2
    551              return TRUE;
    552            }
    553          
    554            switch (apsFrame->clusterId) {
   \   00000038   0xF44F 0x4200      MOV      R2,#+32768
   \   0000003C   0x1A80             SUBS     R0,R0,R2
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD92F             BLS.N    ??emAfServiceDiscoveryIncoming_3
   \   00000042   0x1F00             SUBS     R0,R0,#+4
   \   00000044   0xD004             BEQ.N    ??emAfServiceDiscoveryIncoming_4
   \   00000046   0x1E40             SUBS     R0,R0,#+1
   \   00000048   0xD046             BEQ.N    ??emAfServiceDiscoveryIncoming_5
   \   0000004A   0x1E40             SUBS     R0,R0,#+1
   \   0000004C   0xD006             BEQ.N    ??emAfServiceDiscoveryIncoming_6
   \                     ??emAfServiceDiscoveryIncoming_0: (+1)
   \   0000004E   0xE067             B.N      ??emAfServiceDiscoveryIncoming_1
    555            case SIMPLE_DESCRIPTOR_RESPONSE:
    556              return processSimpleDescriptorResponse(state, message, length);
   \                     ??emAfServiceDiscoveryIncoming_4: (+1)
   \   00000050   0x4632             MOV      R2,R6
   \   00000052   0x4621             MOV      R1,R4
   \   00000054   0x4628             MOV      R0,R5
   \   00000056   0x.... 0x....      BL       processSimpleDescriptorResponse
   \   0000005A   0xE062             B.N      ??emAfServiceDiscoveryIncoming_7
    557            case MATCH_DESCRIPTORS_RESPONSE:
    558              return processMatchDescriptorResponse(state, message, length);
   \                     ??emAfServiceDiscoveryIncoming_6: (+1)
   \   0000005C   0x2E05             CMP      R6,#+5
   \   0000005E   0xDB5D             BLT.N    ??emAfServiceDiscoveryIncoming_2
   \   00000060   0x78A0             LDRB     R0,[R4, #+2]
   \   00000062   0x78E2             LDRB     R2,[R4, #+3]
   \   00000064   0xEB00 0x2002      ADD      R0,R0,R2, LSL #+8
   \   00000068   0x1F71             SUBS     R1,R6,#+5
   \   0000006A   0x7922             LDRB     R2,[R4, #+4]
   \   0000006C   0xB289             UXTH     R1,R1
   \   0000006E   0x428A             CMP      R2,R1
   \   00000070   0xD154             BNE.N    ??emAfServiceDiscoveryIncoming_2
   \   00000072   0x2A00             CMP      R2,#+0
   \   00000074   0xD052             BEQ.N    ??emAfServiceDiscoveryIncoming_2
   \   00000076   0xF88D 0x100C      STRB     R1,[SP, #+12]
   \   0000007A   0xF204 0x0105      ADDW     R1,R4,#+5
   \   0000007E   0x9104             STR      R1,[SP, #+16]
   \   00000080   0x8929             LDRH     R1,[R5, #+8]
   \   00000082   0x040A             LSLS     R2,R1,#+16
   \   00000084   0xBF4C             ITE      MI 
   \   00000086   0x2203             MOVMI    R2,#+3
   \   00000088   0x2201             MOVPL    R2,#+1
   \   0000008A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   0000008E   0x0449             LSLS     R1,R1,#+17
   \   00000090   0x0C49             LSRS     R1,R1,#+17
   \   00000092   0xA803             ADD      R0,SP,#+12
   \   00000094   0xF8AD 0x1002      STRH     R1,[SP, #+2]
   \   00000098   0x9002             STR      R0,[SP, #+8]
   \   0000009A   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \   0000009E   0xA900             ADD      R1,SP,#+0
   \   000000A0   0xE039             B.N      ??emAfServiceDiscoveryIncoming_8
    559          
    560            case NETWORK_ADDRESS_RESPONSE:
    561            case IEEE_ADDRESS_RESPONSE:
    562              return processAddressResponse(state, message, length);
   \                     ??emAfServiceDiscoveryIncoming_3: (+1)
   \   000000A2   0x2E0C             CMP      R6,#+12
   \   000000A4   0xDB3A             BLT.N    ??emAfServiceDiscoveryIncoming_2
   \   000000A6   0x2208             MOVS     R2,#+8
   \   000000A8   0x1CA1             ADDS     R1,R4,#+2
   \   000000AA   0xA803             ADD      R0,SP,#+12
   \   000000AC   0x.... 0x....      BL       halCommonMemMove
   \   000000B0   0x8928             LDRH     R0,[R5, #+8]
   \   000000B2   0x0400             LSLS     R0,R0,#+16
   \   000000B4   0xBF4C             ITE      MI 
   \   000000B6   0x2003             MOVMI    R0,#+3
   \   000000B8   0x2004             MOVPL    R0,#+4
   \   000000BA   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   000000BE   0x7AE1             LDRB     R1,[R4, #+11]
   \   000000C0   0x7AA0             LDRB     R0,[R4, #+10]
   \   000000C2   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \   000000C6   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   000000CA   0xA900             ADD      R1,SP,#+0
   \   000000CC   0x8928             LDRH     R0,[R5, #+8]
   \   000000CE   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4: (+1)
   \   000000D2   0xA803             ADD      R0,SP,#+12
   \   000000D4   0x9002             STR      R0,[SP, #+8]
   \   000000D6   0xE01E             B.N      ??emAfServiceDiscoveryIncoming_8
    563          
    564            case ACTIVE_ENDPOINTS_RESPONSE:
    565              return processActiveEndpointResponse(state, message, length);
   \                     ??emAfServiceDiscoveryIncoming_5: (+1)
   \   000000D8   0x2E05             CMP      R6,#+5
   \   000000DA   0xDB1F             BLT.N    ??emAfServiceDiscoveryIncoming_2
   \   000000DC   0x78E0             LDRB     R0,[R4, #+3]
   \   000000DE   0x7921             LDRB     R1,[R4, #+4]
   \   000000E0   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \   000000E4   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \   000000E8   0x7920             LDRB     R0,[R4, #+4]
   \   000000EA   0x1D40             ADDS     R0,R0,#+5
   \   000000EC   0xB2C0             UXTB     R0,R0
   \   000000EE   0x42B0             CMP      R0,R6
   \   000000F0   0xD114             BNE.N    ??emAfServiceDiscoveryIncoming_2
   \   000000F2   0x8928             LDRH     R0,[R5, #+8]
   \   000000F4   0x0401             LSLS     R1,R0,#+16
   \   000000F6   0xBF4C             ITE      MI 
   \   000000F8   0x2103             MOVMI    R1,#+3
   \   000000FA   0x2101             MOVPL    R1,#+1
   \   000000FC   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000100   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \   00000104   0xA803             ADD      R0,SP,#+12
   \   00000106   0x9002             STR      R0,[SP, #+8]
   \   00000108   0xA900             ADD      R1,SP,#+0
   \   0000010A   0xF204 0x0005      ADDW     R0,R4,#+5
   \   0000010E   0x9004             STR      R0,[SP, #+16]
   \   00000110   0x7920             LDRB     R0,[R4, #+4]
   \   00000112   0xF88D 0x000C      STRB     R0,[SP, #+12]
   \                     ??emAfServiceDiscoveryIncoming_8: (+1)
   \   00000116   0x4628             MOV      R0,R5
   \   00000118   0x.... 0x....      BL       executeCallback
   \                     ??emAfServiceDiscoveryIncoming_2: (+1)
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0xE000             B.N      ??emAfServiceDiscoveryIncoming_7
    566          
    567            default:
    568              // Some ZDO request we don't care about.
    569              break;
    570            }
    571          
    572            return FALSE;
   \                     ??emAfServiceDiscoveryIncoming_1: (+1)
   \   00000120   0x2000             MOVS     R0,#+0
   \                     ??emAfServiceDiscoveryIncoming_7: (+1)
   \   00000122   0xB005             ADD      SP,SP,#+20
   \   00000124   0xBDF0             POP      {R4-R7,PC}       ;; return
    573          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     emAfServiceDiscoveryEventControls

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   emAfServiceDiscoveryComplete0
         0   -> serviceDiscoveryComplete
       0   emAfServiceDiscoveryComplete1
         0   -> serviceDiscoveryComplete
       0   emAfServiceDiscoveryComplete2
         0   -> serviceDiscoveryComplete
       0   emAfServiceDiscoveryComplete3
         0   -> serviceDiscoveryComplete
      40   emAfServiceDiscoveryIncoming
        40   -> emberGetCurrentNetwork
        40   -> executeCallback
        40   -> halCommonMemMove
        40   -> processSimpleDescriptorResponse
      16   emberAfFindActiveEndpoints
        16   -> emberGetCurrentNetwork
        16   -> emberSendZigDevRequestTarget
        16   -> setupDiscoveryData
      24   emberAfFindClustersByDeviceAndEndpoint
        24   -> emberGetCurrentNetwork
        24   -> emberSimpleDescriptorRequest
        24   -> setupDiscoveryData
      24   emberAfFindDevicesByProfileAndCluster
        24   -> emAfSendMatchDescriptor
        24   -> emberGetCurrentNetwork
        24   -> setupDiscoveryData
      16   emberAfFindIeeeAddress
        16   -> emberGetCurrentNetwork
        16   -> emberIeeeAddressRequest
        16   -> setupDiscoveryData
      16   emberAfFindNodeId
        16   -> emberGetCurrentNetwork
        16   -> emberNetworkAddressRequest
        16   -> setupDiscoveryData
      16   executeCallback
        16   -- Indirect call
        16   -> emberGetCurrentNetwork
         0   -> serviceDiscoveryComplete
     136   processSimpleDescriptorResponse
       136   -> executeCallback
      24   serviceDiscoveryComplete
        24   -- Indirect call
        24   -> emberAfNetworkEventControlSetInactive
        24   -> emberAfPopNetworkIndex
        24   -> emberAfPushNetworkIndex
        24   -> emberAfRemoveFromCurrentAppTasksCallback
       8   setupDiscoveryData
         0   -> emberAfAddToCurrentAppTasksCallback
         8   -> emberAfNetworkEventControlSetDelayQS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       8  ?Subroutine0
      10  ?Subroutine1
       8  ?Subroutine2
       4  emAfServiceDiscoveryComplete0
       4  emAfServiceDiscoveryComplete1
       4  emAfServiceDiscoveryComplete2
       4  emAfServiceDiscoveryComplete3
      20  emAfServiceDiscoveryEventControls
          states
     294  emAfServiceDiscoveryIncoming
      52  emberAfFindActiveEndpoints
      62  emberAfFindClustersByDeviceAndEndpoint
      88  emberAfFindDevicesByProfileAndCluster
      50  emberAfFindIeeeAddress
      56  emberAfFindNodeId
      40  executeCallback
     210  processSimpleDescriptorResponse
      80  serviceDiscoveryComplete
      40  setupDiscoveryData

 
    20 bytes in section .bss
 1 018 bytes in section .text
 
 1 018 bytes of CODE memory
    20 bytes of DATA memory

Errors: none
Warnings: none

// This file is generated by Ember Desktop.  Please do not edit manually.
//
//

// This is a set of generated functions that parse the
// the incomming message, and call appropriate command handler.

#include PLATFORM_HEADER
#ifdef EZSP_HOST
// Includes needed for ember related functions for the EZSP host
#include "stack/include/error.h"
#include "stack/include/ember-types.h"
#include "app/util/ezsp/ezsp-protocol.h"
#include "app/util/ezsp/ezsp.h"
#include "app/util/ezsp/ezsp-utils.h"
#include "app/util/ezsp/serial-interface.h"
#else
// Includes needed for ember related functions for the EM250
#include "stack/include/ember.h"
#endif // EZSP_HOST
#include "app/framework/util/util.h"
#include "af-structs.h"
#include "call-command-handler.h"
#include "command-id.h"
#include "callback.h"
#include "UART_task.h"
#include "ButtonExe.h"
#include "Task.h"
#include "ConfigDevice.h"

static EmberAfStatus status(boolean wasHandled, boolean mfgSpecific) {
	if (wasHandled) {
		return EMBER_ZCL_STATUS_SUCCESS;
	} else if (mfgSpecific) {
		return EMBER_ZCL_STATUS_UNSUP_MANUF_CLUSTER_COMMAND;
	} else {
		return EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
	}
}

// Main command parsing controller.
EmberAfStatus emberAfClusterSpecificCommandParse(EmberAfClusterCommand *cmd) {
	if (cmd->direction == ZCL_DIRECTION_SERVER_TO_CLIENT
			&& emberAfContainsClient(cmd->apsFrame->destinationEndpoint,
					cmd->apsFrame->clusterId)) {
		switch (cmd->apsFrame->clusterId) {
		case ZCL_IDENTIFY_CLUSTER_ID:
			return emberAfIdentifyClusterClientCommandParse(cmd);
		}
	} else if (cmd->direction == ZCL_DIRECTION_CLIENT_TO_SERVER
			&& emberAfContainsServer(cmd->apsFrame->destinationEndpoint,
					cmd->apsFrame->clusterId)) {
		switch (cmd->apsFrame->clusterId) {
		case ZCL_BASIC_CLUSTER_ID:
			return emberAfBasicClusterServerCommandParse(cmd);
		case ZCL_IDENTIFY_CLUSTER_ID:
			return emberAfIdentifyClusterServerCommandParse(cmd);
		case ZCL_GROUPS_CLUSTER_ID:
			return emberAfGroupsClusterServerCommandParse(cmd);
		case ZCL_SCENES_CLUSTER_ID:
			return emberAfScenesClusterServerCommandParse(cmd);
		case ZCL_ON_OFF_CLUSTER_ID:
			return emberAfOnOffClusterServerCommandParse(cmd);
#ifdef DIMMER
		case ZCL_LEVEL_CONTROL_CLUSTER_ID:
			return emberAfLevelControlClusterServerCommandParse(cmd);
#endif
		}
	}
	return status(FALSE, cmd->mfgSpecific);
}

// Cluster: Basic, server
EmberAfStatus emberAfBasicClusterServerCommandParse(EmberAfClusterCommand *cmd) {
	boolean wasHandled = FALSE;
	if (!cmd->mfgSpecific) {
		switch (cmd->commandId) {
		case ZCL_RESET_TO_FACTORY_DEFAULTS_COMMAND_ID: {
			// Command is fixed length: 0
			wasHandled = emberAfBasicClusterResetToFactoryDefaultsCallback();
			break;
		}
		}
	}
	return status(wasHandled, cmd->mfgSpecific);
}

// Cluster: Identify, client
EmberAfStatus emberAfIdentifyClusterClientCommandParse(
		EmberAfClusterCommand *cmd) {
	boolean wasHandled = FALSE;
	if (!cmd->mfgSpecific) {
		switch (cmd->commandId) {
		case ZCL_IDENTIFY_QUERY_RESPONSE_COMMAND_ID: {
			int16u payloadOffset = cmd->payloadStartIndex;
			int16u timeout;  // Ver.: always
			// Command is fixed length: 2
			if (cmd->bufLen < payloadOffset + 2)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			timeout = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfIdentifyClusterIdentifyQueryResponseCallback(
					timeout);

			break;
		}
		}
	}
	return status(wasHandled, cmd->mfgSpecific);
}

// Cluster: Identify, server
EmberAfStatus emberAfIdentifyClusterServerCommandParse(
		EmberAfClusterCommand *cmd) {
	boolean wasHandled = FALSE;
	if (!cmd->mfgSpecific) {
		switch (cmd->commandId) {
		case ZCL_IDENTIFY_COMMAND_ID: {
			int16u payloadOffset = cmd->payloadStartIndex;
			int16u identifyTime;  // Ver.: always
			// Command is fixed length: 2
			if (cmd->bufLen < payloadOffset + 2)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			identifyTime = emberAfGetInt16u(cmd->buffer, payloadOffset,
					cmd->bufLen);
			wasHandled = emberAfIdentifyClusterIdentifyCallback(identifyTime);
			break;
		}
		case ZCL_IDENTIFY_QUERY_COMMAND_ID: {
			// Command is fixed length: 0
			wasHandled = emberAfIdentifyClusterIdentifyQueryCallback();
			break;
		}
		}
	}
	return status(wasHandled, cmd->mfgSpecific);
}

// Cluster: Groups, server
EmberAfStatus emberAfGroupsClusterServerCommandParse(EmberAfClusterCommand *cmd) {
	boolean wasHandled = FALSE;
	if (!cmd->mfgSpecific) {
		switch (cmd->commandId) {
		case ZCL_ADD_GROUP_COMMAND_ID: {
			int16u payloadOffset = cmd->payloadStartIndex;
			int16u groupId;  // Ver.: always
			int8u* groupName;  // Ver.: always
			// Command is not a fixed length
			if (cmd->bufLen < payloadOffset + 2)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 2;
			if (cmd->bufLen
					< payloadOffset
					+ emberAfStringLength(cmd->buffer + payloadOffset)
					+ 1)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			groupName = emberAfGetString(cmd->buffer, payloadOffset,
					cmd->bufLen);
			wasHandled = emberAfGroupsClusterAddGroupCallback(groupId,
					groupName);
			break;
		}
		case ZCL_VIEW_GROUP_COMMAND_ID: {
			int16u payloadOffset = cmd->payloadStartIndex;
			int16u groupId;  // Ver.: always
			// Command is fixed length: 2
			if (cmd->bufLen < payloadOffset + 2)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfGroupsClusterViewGroupCallback(groupId);
			break;
		}
		case ZCL_GET_GROUP_MEMBERSHIP_COMMAND_ID: {
			int16u payloadOffset = cmd->payloadStartIndex;
			int8u groupCount;  // Ver.: always
			int8u* groupList;  // Ver.: always
			// Command is fixed length: 1
			if (cmd->bufLen < payloadOffset + 1)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			groupCount = emberAfGetInt8u(cmd->buffer, payloadOffset,
					cmd->bufLen);
			payloadOffset += 1;
			groupList = cmd->buffer + payloadOffset;
			wasHandled = emberAfGroupsClusterGetGroupMembershipCallback(
					groupCount, groupList);
			break;
		}
		case ZCL_REMOVE_GROUP_COMMAND_ID: {
			int16u payloadOffset = cmd->payloadStartIndex;
			int16u groupId;  // Ver.: always
			// Command is fixed length: 2
			if (cmd->bufLen < payloadOffset + 2)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfGroupsClusterRemoveGroupCallback(groupId);
			break;
		}
		case ZCL_REMOVE_ALL_GROUPS_COMMAND_ID: {
			// Command is fixed length: 0
			wasHandled = emberAfGroupsClusterRemoveAllGroupsCallback();
			break;
		}
		case ZCL_ADD_GROUP_IF_IDENTIFYING_COMMAND_ID: {
			int16u payloadOffset = cmd->payloadStartIndex;
			int16u groupId;  // Ver.: always
			int8u* groupName;  // Ver.: always
			// Command is not a fixed length
			if (cmd->bufLen < payloadOffset + 2)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 2;
			if (cmd->bufLen
					< payloadOffset
					+ emberAfStringLength(cmd->buffer + payloadOffset)
					+ 1)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			groupName = emberAfGetString(cmd->buffer, payloadOffset,
					cmd->bufLen);
			wasHandled = emberAfGroupsClusterAddGroupIfIdentifyingCallback(
					groupId, groupName);
			break;
		}
		}
	}
	return status(wasHandled, cmd->mfgSpecific);
}

// Cluster: Scenes, server
EmberAfStatus emberAfScenesClusterServerCommandParse(EmberAfClusterCommand *cmd) {
	boolean wasHandled = FALSE;
	if (!cmd->mfgSpecific) {
		switch (cmd->commandId) {
		case ZCL_ADD_SCENE_COMMAND_ID: {
			int16u payloadOffset = cmd->payloadStartIndex;
			int16u groupId;  // Ver.: always
			int8u sceneId;  // Ver.: always
			int16u transitionTime;  // Ver.: always
			int8u* sceneName;  // Ver.: always
			int8u* extensionFieldSets;  // Ver.: always
			// Command is not a fixed length
			if (cmd->bufLen < payloadOffset + 2)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 2;
			if (cmd->bufLen < payloadOffset + 1)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			sceneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 1;
			if (cmd->bufLen < payloadOffset + 2)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset,
					cmd->bufLen);
			payloadOffset += 2;
			if (cmd->bufLen
					< payloadOffset
					+ emberAfStringLength(cmd->buffer + payloadOffset)
					+ 1)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			sceneName = emberAfGetString(cmd->buffer, payloadOffset,
					cmd->bufLen);
			payloadOffset += emberAfStringLength(cmd->buffer + payloadOffset)
							+ 1;
			extensionFieldSets = cmd->buffer + payloadOffset;
			wasHandled = emberAfScenesClusterAddSceneCallback(groupId, sceneId,
					transitionTime, sceneName, extensionFieldSets);
			break;
		}
		case ZCL_VIEW_SCENE_COMMAND_ID: {
			int16u payloadOffset = cmd->payloadStartIndex;
			int16u groupId;  // Ver.: always
			int8u sceneId;  // Ver.: always
			// Command is fixed length: 3
			if (cmd->bufLen < payloadOffset + 3)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 2;
			sceneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfScenesClusterViewSceneCallback(groupId,
					sceneId);
			break;
		}
		case ZCL_REMOVE_SCENE_COMMAND_ID: {
			int16u payloadOffset = cmd->payloadStartIndex;
			int16u groupId;  // Ver.: always
			int8u sceneId;  // Ver.: always
			// Command is fixed length: 3
			if (cmd->bufLen < payloadOffset + 3)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 2;
			sceneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfScenesClusterRemoveSceneCallback(groupId,
					sceneId);
			break;
		}
		case ZCL_REMOVE_ALL_SCENES_COMMAND_ID: {
			int16u payloadOffset = cmd->payloadStartIndex;
			int16u groupId;  // Ver.: always
			// Command is fixed length: 2
			if (cmd->bufLen < payloadOffset + 2)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfScenesClusterRemoveAllScenesCallback(groupId);
			break;
		}
		case ZCL_STORE_SCENE_COMMAND_ID: {
			int16u payloadOffset = cmd->payloadStartIndex;
			int16u groupId;  // Ver.: always
			int8u sceneId;  // Ver.: always
			// Command is fixed length: 3
			if (cmd->bufLen < payloadOffset + 3)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 2;
			sceneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfScenesClusterStoreSceneCallback(groupId,
					sceneId);
			break;
		}
		case ZCL_RECALL_SCENE_COMMAND_ID: {
			int16u payloadOffset = cmd->payloadStartIndex;
			int16u groupId;  // Ver.: always
			int8u sceneId;  // Ver.: always
			// Command is fixed length: 3
			if (cmd->bufLen < payloadOffset + 3)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 2;
			sceneId = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfScenesClusterRecallSceneCallback(groupId,
					sceneId);
			break;
		}
		case ZCL_GET_SCENE_MEMBERSHIP_COMMAND_ID: {
			int16u payloadOffset = cmd->payloadStartIndex;
			int16u groupId;  // Ver.: always
			// Command is fixed length: 2
			if (cmd->bufLen < payloadOffset + 2)
				return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			groupId = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfScenesClusterGetSceneMembershipCallback(
					groupId);
			break;
		}
		}
	}
	return status(wasHandled, cmd->mfgSpecific);
}
int16u OnOffCmdBeforeTimer[5] = {0};
// Cluster: On/off, server
EmberAfStatus emberAfOnOffClusterServerCommandParse(EmberAfClusterCommand *cmd) {
	boolean wasHandled = FALSE;
	int8u OnOfffCmdBeforeNumber;
	if (!cmd->mfgSpecific) {
		switch (cmd->apsFrame->destinationEndpoint){
			case 1 : OnOfffCmdBeforeNumber = 1;
			break;
			case 3 : OnOfffCmdBeforeNumber = 2;
			break;
			case 5 : OnOfffCmdBeforeNumber = 3;
			break;
			case 7 : OnOfffCmdBeforeNumber = 4;
			break;
			case LedLightOptionEndpoint:
					 OnOfffCmdBeforeNumber = 5;
			break;
		}
		if (CommonGetDurationTime(OnOffCmdBeforeTimer[OnOfffCmdBeforeNumber]) > 1000){
			OnOffCmdBeforeTimer[OnOfffCmdBeforeNumber] = (int16u)halCommonGetInt32uMillisecondTick();
			switch (cmd->commandId) {
				case ZCL_OFF_COMMAND_ID: {
					// Command is fixed length: 0
					wasHandled = emberAfOnOffClusterOffCallback();
					break;
				}
				case ZCL_ON_COMMAND_ID: {
					// Command is fixed length: 0
					wasHandled = emberAfOnOffClusterOnCallback();
					break;
				}
				case ZCL_TOGGLE_COMMAND_ID: {
					// Command is fixed length: 0
					wasHandled = emberAfOnOffClusterToggleCallback();
					break;
				}
			}



		//	User Controller Command
			int8u CurrentState;
			emberAfReadServerAttribute(cmd->apsFrame->destinationEndpoint,
						ZCL_ON_OFF_CLUSTER_ID, ZCL_ON_OFF_ATTRIBUTE_ID, &CurrentState,
						sizeof(CurrentState));
			if (status(wasHandled, cmd->mfgSpecific) == EMBER_ZCL_STATUS_SUCCESS) {
				if (cmd->apsFrame->destinationEndpoint == LedLightOptionEndpoint) {
					if (CurrentState == 1) {
						halClearLed(LED_LIGHT);
					}
					else{
						halSetLed(LED_LIGHT);
					}
				}
				else {
					if (CurrentState == 1) {
						UartSendSwitchControlNumber(
								(((cmd->apsFrame->destinationEndpoint) >> 1) + 1),
								OnRelay);
					} else {
						UartSendSwitchControlNumber(
								(((cmd->apsFrame->destinationEndpoint) >> 1) + 1),
								OffRelay);
					}

					//	 	Send to Bind Device

					SendViaBindingTable(cmd->apsFrame->destinationEndpoint,
							CurrentState, OnOffType);

					//		Send On-Off AttributeResponse, Zipato stupid update :D-----------------------------//
					SendOnOffControlReadAttribute(cmd->apsFrame->destinationEndpoint,
							CurrentState);

					// on-off led

					if (CurrentState == 1) {
						CommonSetLed(cmd->apsFrame->destinationEndpoint >> 1);
					} else {
						CommonClearLed(cmd->apsFrame->destinationEndpoint >> 1);
					}
				}
			}
		}
	}
	return status(wasHandled, cmd->mfgSpecific);
}

#ifdef DIMMER

// Cluster: Level Control, server
EmberAfStatus emberAfLevelControlClusterServerCommandParse(EmberAfClusterCommand *cmd)
{
	boolean wasHandled = FALSE;
	if (!cmd->mfgSpecific) {
		switch (cmd->commandId) {
		case ZCL_MOVE_TO_LEVEL_COMMAND_ID:
		{
			int16u payloadOffset = cmd->payloadStartIndex;
			int8u level;  // Ver.: always
			int16u transitionTime;// Ver.: always
			// Command is fixed length: 3
			if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			level = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 1;
			transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfLevelControlClusterMoveToLevelCallback(level,
					transitionTime);
			// 			user controller

			//		 	Send to Bind Device
			SendViaBindingTable(DimmerInClusterEndpoint,level, LevelType);
			//			Send Level AttributeResponse, Zipato stupid update :D-----------------------------//
			SendLevelControlReadAttribute(DimmerInClusterEndpoint,level);
#ifdef CURTAIN
			//			Send to Level Change to MC
			int8u OnOffState;
			emberAfReadServerAttribute(DimmerInClusterEndpoint,
					ZCL_ON_OFF_CLUSTER_ID,
					ZCL_ON_OFF_ATTRIBUTE_ID,
					&OnOffState,
					sizeof (OnOffState));
			if(OnOffState == 1) {
				UartSendDimLevel(level);
			}
#endif
			// 			end user controller

			break;
		}
		case ZCL_MOVE_COMMAND_ID:
		{
			int16u payloadOffset = cmd->payloadStartIndex;
			int8u moveMode;  // Ver.: always
			int8u rate;// Ver.: always
			// Command is fixed length: 2
			if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			moveMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 1;
			rate = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfLevelControlClusterMoveCallback(moveMode,
					rate);
			//			user controller
			int8u level;
			if(moveMode == EMBER_ZCL_MOVE_MODE_UP) {
				level = 0xFF;
			}
			else {
				level = 0x00;
			}
			//		 	Send to Bind Device
			SendViaBindingTable(DimmerInClusterEndpoint,level,LevelType);

			//			Send Level AttributeResponse, Zipato stupid update :D-----------------------------//
			SendLevelControlReadAttribute(DimmerInClusterEndpoint,level);

#ifdef CURTAIN
			//			Send to Level Change to MC
			int8u OnOffState;
			emberAfReadServerAttribute(DimmerInClusterEndpoint,
					ZCL_ON_OFF_CLUSTER_ID,
					ZCL_ON_OFF_ATTRIBUTE_ID,
					&OnOffState,
					sizeof (OnOffState));
			if(OnOffState == 1) {
				UartSendDimLevel(level);
			}
#endif
			// end user controller

			break;
		}
		case ZCL_STEP_COMMAND_ID:
		{
			int16u payloadOffset = cmd->payloadStartIndex;
			int8u stepMode;  // Ver.: always
			int8u stepSize;// Ver.: always
			int16u transitionTime;// Ver.: always
			// Command is fixed length: 4
			if (cmd->bufLen < payloadOffset + 4) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			stepMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 1;
			stepSize = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 1;
			transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfLevelControlClusterStepCallback(stepMode,
					stepSize,
					transitionTime);
			int8u Level;
			// get Current Level
			int8u currentLevel;
			emberAfReadServerAttribute(DimmerInClusterEndpoint,
					ZCL_LEVEL_CONTROL_CLUSTER_ID,
					ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
					(int8u *)&currentLevel,
					sizeof(currentLevel));
			// Get Level
			if(stepMode == EMBER_ZCL_STEP_MODE_UP) {
				if(currentLevel + stepSize > EMBER_AF_PLUGIN_LEVEL_CONTROL_MAXIMUM_LEVEL) {
					Level = EMBER_AF_PLUGIN_LEVEL_CONTROL_MAXIMUM_LEVEL;
				}
				else {
					Level = currentLevel + stepSize;
				}
			}
			else {
				if(currentLevel - stepSize < EMBER_AF_PLUGIN_LEVEL_CONTROL_MINIMUM_LEVEL) {
					Level = EMBER_AF_PLUGIN_LEVEL_CONTROL_MINIMUM_LEVEL;
				}
				else {
					Level = currentLevel - stepSize;
				}
			}
			//	 	Send to Bind Device
			SendViaBindingTable(DimmerInClusterEndpoint,Level, LevelType);

			//		Send Level AttributeResponse, Zipato stupid update :D-----------------------------//
			SendLevelControlReadAttribute(DimmerInClusterEndpoint,Level);
#ifdef CURTAIN
			//			Send to Level Change to MC
			int8u OnOffState;
			emberAfReadServerAttribute(DimmerInClusterEndpoint,
					ZCL_ON_OFF_CLUSTER_ID,
					ZCL_ON_OFF_ATTRIBUTE_ID,
					&OnOffState,
					sizeof (OnOffState));
			if(OnOffState == 1) {
				UartSendDimLevel(Level);
			}
#endif
			// end user controller
			break;
		}
		case ZCL_STOP_COMMAND_ID:
		{
			// Command is fixed length: 0
			wasHandled = emberAfLevelControlClusterStopCallback();
			// get Current Level
			int8u currentLevel;
			emberAfReadServerAttribute(DimmerInClusterEndpoint,
					ZCL_LEVEL_CONTROL_CLUSTER_ID,
					ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
					(int8u *)&currentLevel,
					sizeof(currentLevel));
			//	 			Send to Bind Device
			SendViaBindingTable(DimmerInClusterEndpoint,currentLevel,LevelType);

			//				Send Level AttributeResponse, Zipato stupid update :D-----------------------------//
			SendLevelControlReadAttribute(DimmerInClusterEndpoint,currentLevel);
#ifdef CURTAIN
			//			Send to Level Change to MC
			int8u OnOffState;
			emberAfReadServerAttribute(DimmerInClusterEndpoint,
					ZCL_ON_OFF_CLUSTER_ID,
					ZCL_ON_OFF_ATTRIBUTE_ID,
					&OnOffState,
					sizeof (OnOffState));
			if(OnOffState == 1) {
				UartSendDimLevel(currentLevel);
			}
#endif
			// end user controller
			break;
		}
		case ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID:
		{
			int16u payloadOffset = cmd->payloadStartIndex;
			int8u level;  // Ver.: always
			int16u transitionTime;// Ver.: always
			// Command is fixed length: 3
			if (cmd->bufLen < payloadOffset + 3) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			level = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 1;
			transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfLevelControlClusterMoveToLevelWithOnOffCallback(level,
					transitionTime);

			// user controller

			//	 	Send to Bind Device
			SendViaBindingTable(DimmerInClusterEndpoint,level,LevelWithOnOffType);
			//		Send Level AttributeResponse, Zipato stupid update :D-----------------------------//
			SendLevelControlReadAttribute(DimmerInClusterEndpoint,level);
			//		Send On-Off AttributeResponse, Zipato stupid update :D-----------------------------//
			if(level == 0) {
				SendOnOffControlReadAttribute(DimmerInClusterEndpoint,0);
			}
			else {
				SendOnOffControlReadAttribute(DimmerInClusterEndpoint,1);
			}
			//		Send to Level Change to MC
#ifdef CURTAIN

			UartSendDimLevel(level);
#endif
			// end user controller
			break;
		}
		case ZCL_MOVE_WITH_ON_OFF_COMMAND_ID:
		{
			int16u payloadOffset = cmd->payloadStartIndex;
			int8u moveMode;  // Ver.: always
			int8u rate;// Ver.: always
			// Command is fixed length: 2
			if (cmd->bufLen < payloadOffset + 2) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			moveMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 1;
			rate = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfLevelControlClusterMoveWithOnOffCallback(moveMode,
					rate);
			// user controller
			int8u Level;
			if(moveMode == EMBER_ZCL_MOVE_MODE_UP) {
				Level = 0xFF;
			}
			else {
				Level = 0x00;
			}

			//	 	Send to Bind Device
			SendViaBindingTable(DimmerInClusterEndpoint,Level,LevelWithOnOffType);
			//		Send Level AttributeResponse, Zipato stupid update :D-----------------------------//
			SendLevelControlReadAttribute(DimmerInClusterEndpoint,Level);
			//		Send On-Off AttributeResponse, Zipato stupid update :D-----------------------------//
			if(Level == 0) {
				SendOnOffControlReadAttribute(DimmerInClusterEndpoint,0);
			}
			else {
				SendOnOffControlReadAttribute(DimmerInClusterEndpoint,1);
			}
			//		Send to Level Change to MC
#ifdef CURTAIN
			UartSendDimLevel(Level);
#endif
			// end user controller

			break;
		}
		case ZCL_STEP_WITH_ON_OFF_COMMAND_ID:
		{
			int16u payloadOffset = cmd->payloadStartIndex;
			int8u stepMode;  // Ver.: always
			int8u stepSize;// Ver.: always
			int16u transitionTime;// Ver.: always
			// Command is fixed length: 4
			if (cmd->bufLen < payloadOffset + 4) return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
			stepMode = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 1;
			stepSize = emberAfGetInt8u(cmd->buffer, payloadOffset, cmd->bufLen);
			payloadOffset += 1;
			transitionTime = emberAfGetInt16u(cmd->buffer, payloadOffset, cmd->bufLen);
			wasHandled = emberAfLevelControlClusterStepWithOnOffCallback(stepMode,
					stepSize,
					transitionTime);
			// 		user controller
			int8u Level;
			// 		get Current Level
			int8u currentLevel;
			emberAfReadServerAttribute(DimmerInClusterEndpoint,
					ZCL_LEVEL_CONTROL_CLUSTER_ID,
					ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
					(int8u *)&currentLevel,
					sizeof(currentLevel));
			// 		Get Level
			if(stepMode == EMBER_ZCL_STEP_MODE_UP) {
				if(currentLevel + stepSize > EMBER_AF_PLUGIN_LEVEL_CONTROL_MAXIMUM_LEVEL) {
					Level = EMBER_AF_PLUGIN_LEVEL_CONTROL_MAXIMUM_LEVEL;
				}
				else {
					Level = currentLevel + stepSize;
				}
			}
			else {
				if(currentLevel - stepSize < EMBER_AF_PLUGIN_LEVEL_CONTROL_MINIMUM_LEVEL) {
					Level = EMBER_AF_PLUGIN_LEVEL_CONTROL_MINIMUM_LEVEL;
				}
				else {
					Level = currentLevel - stepSize;
				}
			}
			//	 	Send to Bind Device
			SendViaBindingTable(DimmerInClusterEndpoint,Level,LevelWithOnOffType);
			//		Send Level AttributeResponse, Zipato stupid update :D-----------------------------//
			SendLevelControlReadAttribute(DimmerInClusterEndpoint,Level);
			//		Send On-Off AttributeResponse, Zipato stupid update :D-----------------------------//
			if(Level == 0) {
				SendOnOffControlReadAttribute(DimmerInClusterEndpoint,0);
			}
			else {
				SendOnOffControlReadAttribute(DimmerInClusterEndpoint,1);
			}
			//		Send to Level Change to MC
#ifdef CURTAIN
			UartSendDimLevel(Level);
#endif
			// end user controller

			break;
		}
		case ZCL_STOP_WITH_ON_OFF_COMMAND_ID:
		{
			// Command is fixed length: 0
			wasHandled = emberAfLevelControlClusterStopWithOnOffCallback();

			//		user control
			// 		get Current Level
			int8u currentLevel;
			emberAfReadServerAttribute(DimmerInClusterEndpoint,
					ZCL_LEVEL_CONTROL_CLUSTER_ID,
					ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
					(int8u *)&currentLevel,
					sizeof(currentLevel));
			//	 	Send to Bind Device
			SendViaBindingTable(DimmerInClusterEndpoint,currentLevel,LevelWithOnOffType);
			//		Send Level AttributeResponse, Zipato stupid update :D-----------------------------//
			SendLevelControlReadAttribute(DimmerInClusterEndpoint,currentLevel);
			//		Send On-Off AttributeResponse, Zipato stupid update :D-----------------------------//
			if(currentLevel == 0) {
				SendOnOffControlReadAttribute(DimmerInClusterEndpoint,0);
			}
			else {
				SendOnOffControlReadAttribute(DimmerInClusterEndpoint,1);
			}
			//		Send to Level Change to MC

			int16u ClosedLimit;
			emberAfReadServerAttribute(DimmerInClusterEndpoint,
									   ZCL_SHADE_CONFIG_CLUSTER_ID,
									   ZCL_SHADE_CONFIG_CLOSED_LIMIT_ATTRIBUTE_ID,
									   (int8u *)&ClosedLimit,
										sizeof(ClosedLimit));
#ifdef CURTAIN
			UartSendDimLevel((ClosedLimit * currentLevel)/255);
#endif
			// end user controller

			break;
		}
		}
	}
	return status(wasHandled, cmd->mfgSpecific);
}
#endif

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Apr/2016  12:59:54
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\util.c
#    Command line =  
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\util.c" -D
#        SWITCH_4_BUTTON -D NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D
#        CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"util.c\"" -lC "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\4
#        nut\List\" --diag_suppress Pa050 -o "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\4
#        nut\Obj\" --debug --endian=little --cpu=Cortex-M3
#        --no_path_in_file_macros --separate_cluster_for_initialized_variables
#        -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        "D:\Work Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\"
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\4
#        nut\List\util.lst
#    Object file  =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\4
#        nut\Obj\util.o
#
###############################################################################

D:\Work Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\util.c
      1          // *******************************************************************
      2          // * util.c
      3          // *
      4          // * This file contains all of the common ZCL command and attribute handling
      5          // * code for Ember's ZCL implementation
      6          // *
      7          // * The actual compiled version of this code will vary depending on
      8          // * #defines for clusters included in the built application.
      9          // *
     10          // * Copyright 2014 Silicon Laboratories, Inc.                              *80*
     11          // *******************************************************************
     12          
     13          
     14          #include "../include/af.h"
     15          #include "af-main.h"
     16          #include "common.h"
     17          #include "../security/crypto-state.h"
     18          #include "../plugin/time-server/time-server.h"
     19          #include "../../util/source-route-common.h"
     20          #include "app/framework/util/af-event.h"
     21          #include "app/framework/util/time-util.h"
     22          
     23          //------------------------------------------------------------------------------
     24          // Forward Declarations
     25          
     26          static void platformTick(void);
     27          
     28          #ifdef EMBER_AF_HEARTBEAT_ENABLE
     29            #define blinkHeartbeat() halToggleLed(EMBER_AF_HEARTBEAT_LED)
     30          #else
     31            #define blinkHeartbeat()
     32          #endif
     33          
     34          //------------------------------------------------------------------------------
     35          // Globals
     36          
     37          // Storage and functions for turning on and off devices

   \                                 In section .bss, align 4
     38          boolean afDeviceEnabled[MAX_ENDPOINT_COUNT];
   \                     afDeviceEnabled:
   \   00000000                      DS8 12
     39          
     40          #ifdef EMBER_AF_ENABLE_STATISTICS
     41          // a variable containing the number of messages send from the utilities
     42          // since emberAfInit was called.
     43          int32u afNumPktsSent;
     44          #endif
     45          

   \                                 In section .text, align 4, keep-with-next
     46          PGM EmberAfClusterName zclClusterNames[] = {
   \                     zclClusterNames:
   \   00000000   0x0000             DC16 0
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x........         DC32 `?<Constant "Basic">`
   \   00000008   0x0003             DC16 3
   \   0000000A   0x00 0x00          DC8 0, 0
   \   0000000C   0x........         DC32 `?<Constant "Identify">`
   \   00000010   0x0004             DC16 4
   \   00000012   0x00 0x00          DC8 0, 0
   \   00000014   0x........         DC32 `?<Constant "Groups">`
   \   00000018   0x0005             DC16 5
   \   0000001A   0x00 0x00          DC8 0, 0
   \   0000001C   0x........         DC32 `?<Constant "Scenes">`
   \   00000020   0x0006             DC16 6
   \   00000022   0x00 0x00          DC8 0, 0
   \   00000024   0x........         DC32 `?<Constant "On/off">`
   \   00000028   0xFFFF             DC16 65535
   \   0000002A   0x00 0x00          DC8 0, 0
   \   0000002C   0x00000000         DC32 0H
     47            CLUSTER_IDS_TO_NAMES                 // defined in print-cluster.h
     48            { ZCL_NULL_CLUSTER_ID, NULL },  // terminator
     49          };
     50          
     51          // A pointer to the current command being processed
     52          // This struct is allocated on the stack inside
     53          // emberAfProcessMessage. The pointer below is set
     54          // to NULL when the function exits.
     55          EmberAfClusterCommand *emAfCurrentCommand;
     56          
     57          // variable used for toggling Aps Link security. Set by the CLI

   \                                 In section .data, align 1
     58          int8u emAfTestApsSecurityOverride = APS_TEST_SECURITY_DEFAULT;
   \                     emAfTestApsSecurityOverride:
   \   00000000   0x02               DC8 2
     59          
     60          // DEPRECATED.

   \                                 In section .data, align 1
     61          int8u emberAfIncomingZclSequenceNumber = 0xFF;
   \                     emberAfIncomingZclSequenceNumber:
   \   00000000   0xFF               DC8 255
     62          
     63          static boolean afNoSecurityForDefaultResponse = FALSE;
     64          
     65          // Sequence used for outgoing messages if they are
     66          // not responses.
     67          int8u emberAfSequenceNumber = 0xFF;
     68          
     69          // A boolean value so we know when the device is performing
     70          // key establishment.
     71          boolean emAfDeviceIsPerformingKeyEstablishment = FALSE;
     72          
     73          int8u emberAfApsRetryOverride = EMBER_AF_RETRY_OVERRIDE_UNSET;
   \                     emberAfApsRetryOverride:
   \   00000001   0x02               DC8 2

   \                                 In section .data, align 1
   \                     emberAfSequenceNumber:
   \   00000000   0xFF               DC8 255

   \                                 In section .bss, align 4
   \                     afNoSecurityForDefaultResponse:
   \   00000000                      DS8 1
     74          
     75          // Holds the response type
     76          int8u emberAfResponseType = ZCL_UTIL_RESP_NORMAL;
   \                     emberAfResponseType:
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \   00000004                      DS8 24
   \                     emAfCurrentCommand:
   \   0000001C                      DS8 4

   \                                 In section .bss, align 1
   \                     emAfDeviceIsPerformingKeyEstablishment:
   \   00000000                      DS8 1
     77          
     78          static EmberAfInterpanHeader interpanResponseHeader;
     79          
     80          #if EMBER_AF_PLUGIN_ADDRESS_TABLE_SIZE != 0

   \                                 In section .bss, align 4
     81            static int8u addressTableReferenceCounts[EMBER_AF_PLUGIN_ADDRESS_TABLE_SIZE];
   \                     addressTableReferenceCounts:
   \   00000000                      DS8 8
     82          #endif
     83          
     84          
     85          #if 0
     86          // Moving to time-util.c
     87          #define SECONDS_IN_DAY 86400L
     88          #define SECONDS_IN_HOUR 3600
     89          PGM int8u emberAfDaysInMonth[] =
     90            { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
     91          #endif
     92          

   \                                 In section .text, align 4, keep-with-next
     93          static PGM int8u emberAfAnalogDiscreteThresholds[] = {
   \                     emberAfAnalogDiscreteThresholds:
   \   00000000   0x07 0x02          DC8 7, 2, 31, 1, 47, 0, 55, 1, 63, 0, 87, 1, 223, 2, 231, 0, 255, 2
   \              0x1F 0x01    
   \              0x2F 0x00    
   \              0x37 0x01    
   \              0x3F 0x00    
   \              0x57 0x01    
   \              0xDF 0x02    
   \              0xE7 0x00    
   \              0xFF 0x02    
   \   00000012   0x00 0x00          DC8 0, 0
     94            0x07, EMBER_AF_DATA_TYPE_NONE,
     95            0x1F, EMBER_AF_DATA_TYPE_DISCRETE,
     96            0x2F, EMBER_AF_DATA_TYPE_ANALOG,
     97            0x37, EMBER_AF_DATA_TYPE_DISCRETE,
     98            0x3F, EMBER_AF_DATA_TYPE_ANALOG,
     99            0x57, EMBER_AF_DATA_TYPE_DISCRETE,
    100            0xDF, EMBER_AF_DATA_TYPE_NONE,
    101            0xE7, EMBER_AF_DATA_TYPE_ANALOG,
    102            0xFF, EMBER_AF_DATA_TYPE_NONE
    103          };
    104          
    105          typedef void (TickFunction)(void);
    106          

   \                                 In section .text, align 4, keep-with-next
    107          static TickFunction* PGM internalTickFunctions[] = {
   \                     internalTickFunctions:
   \   00000000   0x........         DC32 emberAfMainTickCallback, platformTick, 0H
   \              0x........   
   \              0x00000000   
    108            // This is the main customer tick
    109            emberAfMainTickCallback,
    110          
    111            platformTick,
    112          
    113            NULL            // terminator, must be last
    114          };
    115          
    116          #ifdef EMBER_AF_GENERATED_PLUGIN_INIT_FUNCTION_DECLARATIONS
    117            EMBER_AF_GENERATED_PLUGIN_INIT_FUNCTION_DECLARATIONS
    118          #endif
    119          #ifdef EMBER_AF_GENERATED_PLUGIN_TICK_FUNCTION_DECLARATIONS
    120            EMBER_AF_GENERATED_PLUGIN_TICK_FUNCTION_DECLARATIONS
    121          #endif
    122          
    123          //------------------------------------------------------------------------------
    124          

   \                                 In section .text, align 2, keep-with-next
    125          static void platformTick(void)
    126          {
   \                     platformTick: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    127            static int16u lastBlinkTime = 0;
    128            int16u time;
    129          
    130            emberAfSchedulePollEventCallback();
   \   00000002   0x.... 0x....      BL       emberAfSchedulePollEventCallback
    131            emberAfCheckForSleepCallback();
   \   00000006   0x.... 0x....      BL       emberAfCheckForSleepCallback
    132          
    133            time = halCommonGetInt16uMillisecondTick();
   \   0000000A   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
    134          
    135            if (elapsedTimeInt16u(lastBlinkTime, time) > 200 /*ms*/) {
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable27
   \   00000012   0x880A             LDRH     R2,[R1, #+0]
   \   00000014   0x1A82             SUBS     R2,R0,R2
   \   00000016   0xB292             UXTH     R2,R2
   \   00000018   0x2AC9             CMP      R2,#+201
   \   0000001A   0xBFA8             IT       GE 
    136              blinkHeartbeat();
    137              lastBlinkTime = time;
   \   0000001C   0x8008             STRHGE   R0,[R1, #+0]
    138            }
    139          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 2
   \                     ??lastBlinkTime:
   \   00000000                      DS8 2
    140          
    141          // Device enabled/disabled functions

   \                                 In section .text, align 2, keep-with-next
    142          boolean emberAfIsDeviceEnabled(int8u endpoint)
    143          {
   \                     emberAfIsDeviceEnabled: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    144            int8u index;
    145          #ifdef ZCL_USING_BASIC_CLUSTER_DEVICE_ENABLED_ATTRIBUTE
    146            boolean deviceEnabled;
    147            if (emberAfReadServerAttribute(endpoint,
    148                                           ZCL_BASIC_CLUSTER_ID,
    149                                           ZCL_DEVICE_ENABLED_ATTRIBUTE_ID,
    150                                           (int8u *)&deviceEnabled,
    151                                           sizeof(deviceEnabled))
    152                == EMBER_ZCL_STATUS_SUCCESS) {
    153              return deviceEnabled;
    154            }
    155          #endif
    156            index = emberAfIndexFromEndpoint(endpoint);
   \   00000002   0x.... 0x....      BL       emberAfIndexFromEndpoint
    157            if (index != 0xFF && index < sizeof(afDeviceEnabled)) {
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD005             BEQ.N    ??emberAfIsDeviceEnabled_0
   \   0000000A   0x2809             CMP      R0,#+9
   \   0000000C   0xD203             BCS.N    ??emberAfIsDeviceEnabled_0
    158              return afDeviceEnabled[index];
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   00000012   0x5C40             LDRB     R0,[R0, R1]
   \   00000014   0xBD02             POP      {R1,PC}
    159            }
    160            return FALSE;
   \                     ??emberAfIsDeviceEnabled_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    161          }
    162          

   \                                 In section .text, align 2, keep-with-next
    163          void emberAfSetDeviceEnabled(int8u endpoint, boolean enabled)
    164          {
   \                     emberAfSetDeviceEnabled: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    165            int8u index = emberAfIndexFromEndpoint(endpoint);
   \   00000004   0x.... 0x....      BL       emberAfIndexFromEndpoint
    166            if (index != 0xFF && index < sizeof(afDeviceEnabled)) {
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xD004             BEQ.N    ??emberAfSetDeviceEnabled_0
   \   0000000C   0x2809             CMP      R0,#+9
   \   0000000E   0xBF3C             ITT      CC 
    167              afDeviceEnabled[index] = enabled;
   \   00000010   0x.... 0x....      LDRCC.W  R1,??DataTable27_1
   \   00000014   0x5444             STRBCC   R4,[R0, R1]
    168            }
    169          #ifdef ZCL_USING_BASIC_CLUSTER_DEVICE_ENABLED_ATTRIBUTE
    170            emberAfWriteServerAttribute(endpoint,
    171                                        ZCL_BASIC_CLUSTER_ID,
    172                                        ZCL_DEVICE_ENABLED_ATTRIBUTE_ID,
    173                                        (int8u *)&enabled,
    174                                        ZCL_BOOLEAN_ATTRIBUTE_TYPE);
    175          #endif
    176          }
   \                     ??emberAfSetDeviceEnabled_0: (+1)
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    177          
    178          // Is the device identifying?

   \                                 In section .text, align 2, keep-with-next
    179          boolean emberAfIsDeviceIdentifying(int8u endpoint)
    180          {
   \                     emberAfIsDeviceIdentifying: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    181          #ifdef ZCL_USING_IDENTIFY_CLUSTER_SERVER
    182            int16u identifyTime;
    183            EmberAfStatus status = emberAfReadServerAttribute(endpoint,
    184                                                              ZCL_IDENTIFY_CLUSTER_ID,
    185                                                              ZCL_IDENTIFY_TIME_ATTRIBUTE_ID,
    186                                                              (int8u *)&identifyTime,
    187                                                              sizeof(identifyTime));
    188            return (status == EMBER_ZCL_STATUS_SUCCESS && 0 < identifyTime);
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0x9100             STR      R1,[SP, #+0]
   \   00000008   0xAB01             ADD      R3,SP,#+4
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x2103             MOVS     R1,#+3
   \   0000000E   0x.... 0x....      BL       emberAfReadServerAttribute
   \   00000012   0xB920             CBNZ.N   R0,??emberAfIsDeviceIdentifying_0
   \   00000014   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000018   0xB110             CBZ.N    R0,??emberAfIsDeviceIdentifying_1
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE000             B.N      ??emberAfIsDeviceIdentifying_1
   \                     ??emberAfIsDeviceIdentifying_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \                     ??emberAfIsDeviceIdentifying_1: (+1)
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0xBD0E             POP      {R1-R3,PC}       ;; return
    189          #else
    190            return FALSE;
    191          #endif
    192          }
    193          
    194          
    195          // Calculates difference. Works only for dataSizes of 4 or less.

   \                                 In section .text, align 2, keep-with-next
    196          int32u emberAfGetDifference(int8u *pData, int32u value, int8u dataSize)
    197          {
   \                     emberAfGetDifference: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    198            int32u value2 = 0, diff;
   \   00000002   0x2300             MOVS     R3,#+0
    199            int8u i;
    200          
    201            // only support data types up to 4 bytes
    202            if (dataSize > 4) {
   \   00000004   0x2A05             CMP      R2,#+5
   \   00000006   0xDB01             BLT.N    ??emberAfGetDifference_0
    203              return 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xBD62             POP      {R1,R5,R6,PC}
    204            }
    205          
    206            // get the 32-bit value
    207            for (i = 0; i < dataSize; i++) {
   \                     ??emberAfGetDifference_0: (+1)
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0xE006             B.N      ??emberAfGetDifference_1
    208              value2 = value2 << 8;
    209          #if (BIGENDIAN_CPU)
    210              value2 += pData[i];
    211          #else //BIGENDIAN
    212              value2 += pData[dataSize - i - 1];
   \                     ??emberAfGetDifference_2: (+1)
   \   00000010   0x1B56             SUBS     R6,R2,R5
   \   00000012   0x1836             ADDS     R6,R6,R0
    213          #endif //BIGENDIAN
    214            }
   \   00000014   0x1C6D             ADDS     R5,R5,#+1
   \   00000016   0xF816 0x6C01      LDRB     R6,[R6, #-1]
   \   0000001A   0xEB06 0x2303      ADD      R3,R6,R3, LSL #+8
   \                     ??emberAfGetDifference_1: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5
   \   00000020   0x4295             CMP      R5,R2
   \   00000022   0xD3F5             BCC.N    ??emberAfGetDifference_2
    215          
    216            if (value > value2) {
   \   00000024   0x428B             CMP      R3,R1
   \   00000026   0xD201             BCS.N    ??emberAfGetDifference_3
    217              diff = value - value2;
   \   00000028   0x1AC8             SUBS     R0,R1,R3
   \   0000002A   0xBD62             POP      {R1,R5,R6,PC}
    218            } else {
    219              diff = value2 - value;
   \                     ??emberAfGetDifference_3: (+1)
   \   0000002C   0x1A58             SUBS     R0,R3,R1
    220            }
    221          
    222            //emberAfDebugPrintln("comparing 0x%4x and 0x%4x, diff is 0x%4x",
    223            //                    value, value2, diff);
    224          
    225            return diff;
   \   0000002E   0xBD62             POP      {R1,R5,R6,PC}    ;; return
    226          }
    227          
    228          // --------------------------------------------------
    229          

   \                                 In section .text, align 2, keep-with-next
    230          static void prepareForResponse(const EmberAfClusterCommand *cmd)
    231          {
   \                     prepareForResponse: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    232            emberAfResponseApsFrame.profileId           = cmd->apsFrame->profileId;
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   00000008   0x8813             LDRH     R3,[R2, #+0]
   \   0000000A   0x800B             STRH     R3,[R1, #+0]
    233            emberAfResponseApsFrame.clusterId           = cmd->apsFrame->clusterId;
   \   0000000C   0x8853             LDRH     R3,[R2, #+2]
   \   0000000E   0x804B             STRH     R3,[R1, #+2]
    234            emberAfResponseApsFrame.sourceEndpoint      = cmd->apsFrame->destinationEndpoint;
   \   00000010   0x7952             LDRB     R2,[R2, #+5]
   \   00000012   0x710A             STRB     R2,[R1, #+4]
    235            emberAfResponseApsFrame.destinationEndpoint = cmd->apsFrame->sourceEndpoint;
   \   00000014   0x6802             LDR      R2,[R0, #+0]
   \   00000016   0x7912             LDRB     R2,[R2, #+4]
   \   00000018   0x714A             STRB     R2,[R1, #+5]
    236          
    237            // Use the default APS options for the response, but also use encryption and
    238            // retries if the incoming message used them.  The rationale is that the
    239            // sender of the request cares about some aspects of the delivery, so we as
    240            // the receiver should make equal effort for the response.
    241            emberAfResponseApsFrame.options = EMBER_AF_DEFAULT_APS_OPTIONS;
   \   0000001A   0xF44F 0x5288      MOV      R2,#+4352
   \   0000001E   0x80CA             STRH     R2,[R1, #+6]
    242            if (cmd->apsFrame->options & EMBER_APS_OPTION_ENCRYPTION) {
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x7993             LDRB     R3,[R2, #+6]
   \   00000024   0x069B             LSLS     R3,R3,#+26
   \   00000026   0xBF44             ITT      MI 
    243              emberAfResponseApsFrame.options |= EMBER_APS_OPTION_ENCRYPTION;
   \   00000028   0xF44F 0x5389      MOVMI    R3,#+4384
   \   0000002C   0x80CB             STRHMI   R3,[R1, #+6]
    244            }
    245            if (cmd->apsFrame->options & EMBER_APS_OPTION_RETRY) {
   \   0000002E   0x7992             LDRB     R2,[R2, #+6]
   \   00000030   0x0652             LSLS     R2,R2,#+25
   \   00000032   0xD503             BPL.N    ??prepareForResponse_0
    246              emberAfResponseApsFrame.options |= EMBER_APS_OPTION_RETRY;
   \   00000034   0x88CA             LDRH     R2,[R1, #+6]
   \   00000036   0xF042 0x0240      ORR      R2,R2,#0x40
   \   0000003A   0x80CA             STRH     R2,[R1, #+6]
    247            }
    248          
    249            if (cmd->interPanHeader == NULL) {
   \                     ??prepareForResponse_0: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R4,??DataTable27_3
   \   00000040   0x6982             LDR      R2,[R0, #+24]
   \   00000042   0x7861             LDRB     R1,[R4, #+1]
   \   00000044   0xB93A             CBNZ.N   R2,??prepareForResponse_1
    250              emberAfResponseDestination = cmd->source;
   \   00000046   0x88C0             LDRH     R0,[R0, #+6]
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable27_4
   \   0000004C   0x8010             STRH     R0,[R2, #+0]
    251              emberAfResponseType &= ~ZCL_UTIL_RESP_INTERPAN;
   \   0000004E   0xF001 0x00FD      AND      R0,R1,#0xFD
   \   00000052   0x7060             STRB     R0,[R4, #+1]
   \   00000054   0xBD10             POP      {R4,PC}
    252            } else {
    253              emberAfResponseType |= ZCL_UTIL_RESP_INTERPAN;
   \                     ??prepareForResponse_1: (+1)
   \   00000056   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000005A   0x7061             STRB     R1,[R4, #+1]
    254              MEMMOVE(&interpanResponseHeader,
    255                      cmd->interPanHeader,
    256                      sizeof(EmberAfInterpanHeader));
   \   0000005C   0x2216             MOVS     R2,#+22
   \   0000005E   0x6981             LDR      R1,[R0, #+24]
   \   00000060   0x1D20             ADDS     R0,R4,#+4
   \   00000062   0x.... 0x....      BL       halCommonMemMove
    257              // Always send responses as unicast
    258              interpanResponseHeader.messageType = EMBER_AF_INTER_PAN_UNICAST;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x7120             STRB     R0,[R4, #+4]
    259            }
    260          }
   \   0000006A   0xBD10             POP      {R4,PC}          ;; return
    261          
    262          // ****************************************
    263          // Initialize Clusters
    264          // ****************************************

   \                                 In section .text, align 2, keep-with-next
    265          void emberAfInit(void)
    266          {
   \                     emberAfInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    267            int8u i;
    268          #ifdef EMBER_AF_ENABLE_STATISTICS
    269            afNumPktsSent = 0;
    270          #endif
    271          
    272            for (i = 0; i < EMBER_SUPPORTED_NETWORKS; i++) {
    273              emberAfPushNetworkIndex(i);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       emberAfPushNetworkIndex
    274              emberAfInitializeAttributes(EMBER_BROADCAST_ENDPOINT);
   \   00000008   0x20FF             MOVS     R0,#+255
   \   0000000A   0x.... 0x....      BL       emberAfInitializeAttributes
    275              emberAfPopNetworkIndex();
   \   0000000E   0x.... 0x....      BL       emberAfPopNetworkIndex
    276            }
    277          
    278            MEMSET(afDeviceEnabled, TRUE, emberAfEndpointCount());
   \   00000012   0x.... 0x....      BL       emberAfEndpointCount
   \   00000016   0x4602             MOV      R2,R0
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   0000001E   0x.... 0x....      BL       halCommonMemSet
    279          
    280            // Set up client API buffer.
    281            emberAfSetExternalBuffer(appResponseData,
    282                                     EMBER_AF_RESPONSE_BUFFER_LEN,
    283                                     &appResponseLength,
    284                                     &emberAfResponseApsFrame);
   \   00000022   0x.... 0x....      LDR.W    R3,??DataTable27_2
   \   00000026   0x.... 0x....      LDR.W    R2,??DataTable27_5
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable27_6
   \   0000002E   0x2152             MOVS     R1,#+82
   \   00000030   0x.... 0x....      BL       emberAfSetExternalBuffer
    285          
    286           // initialize event management system
    287           emAfInitEvents();
   \   00000034   0x.... 0x....      BL       emAfInitEvents
    288          
    289          #ifdef EMBER_AF_GENERATED_PLUGIN_INIT_FUNCTION_CALLS
    290            EMBER_AF_GENERATED_PLUGIN_INIT_FUNCTION_CALLS
   \   00000038   0x.... 0x....      BL       emberAfPluginAddressTableInitCallback
   \   0000003C   0x.... 0x....      BL       emberAfPluginCountersInitCallback
   \   00000040   0x.... 0x....      BL       emberAfPluginNetworkFindInitCallback
   \   00000044   0x.... 0x....      BL       emberAfPluginReportingInitCallback
    291          #endif
    292          
    293            emAfCallInits();
   \   00000048   0xE8BD 0x4001      POP      {R0,LR}
   \   0000004C   0x.... 0x....      B.W      emAfCallInits
    294          }
    295          

   \                                 In section .text, align 2, keep-with-next
    296          void emberAfTick(void)
    297          {
   \                     emberAfTick: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    298            int8u i = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x.... 0x....      ADR.W    R5,internalTickFunctions
   \   00000008   0xE001             B.N      ??emberAfTick_0
    299          
    300            while (internalTickFunctions[i] != NULL) {
    301              if (emAfIsCryptoOperationInProgress()) {
    302                // Wait until ECC operations are done.  Don't allow
    303                // any of the clusters to send messages.  This is necessary
    304                // on host or SOC application.
    305                return;
    306              }
    307          
    308              (internalTickFunctions[i])();
   \                     ??emberAfTick_1: (+1)
   \   0000000A   0x47B0             BLX      R6
    309              i++;
   \   0000000C   0x1C64             ADDS     R4,R4,#+1
   \                     ??emberAfTick_0: (+1)
   \   0000000E   0xB2E4             UXTB     R4,R4
   \   00000010   0xF855 0x6024      LDR      R6,[R5, R4, LSL #+2]
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0xD004             BEQ.N    ??emberAfTick_2
   \   00000018   0x.... 0x....      BL       emAfGetCryptoStatus
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD1F4             BNE.N    ??emberAfTick_1
   \   00000020   0xBD70             POP      {R4-R6,PC}
    310            }
    311          
    312          #ifdef EMBER_AF_GENERATED_PLUGIN_TICK_FUNCTION_CALLS
    313            EMBER_AF_GENERATED_PLUGIN_TICK_FUNCTION_CALLS
   \                     ??emberAfTick_2: (+1)
   \   00000022   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000026   0x.... 0x....      B.W      emberAfPluginIdleSleepTickCallback
    314          #endif
    315          }
    316          
    317          // ****************************************
    318          // This function is called by the application when the stack goes down,
    319          // such as after a leave network. This allows zcl utils to clear state
    320          // that should not be kept when changing networks
    321          // ****************************************

   \                                 In section .text, align 2, keep-with-next
    322          void emberAfStackDown(void)
    323          {
   \                     emberAfStackDown: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    324            // (Case 14696) Clearing the report table is only necessary if the stack is
    325            // going down for good; if we're rejoining, leave the table intact since we'll
    326            // be right back, hopefully.
    327            // (Issue 77101) Also don't clear the table if the stack has gone down as a
    328            // a result of losing its parent or some other transient state where a future
    329            // rejoin is expected to get us back online.
    330            if (emberStackIsPerformingRejoin() == FALSE
    331              && emberNetworkState() == EMBER_NO_NETWORK) {
   \   00000002   0x.... 0x....      BL       emberStackIsPerformingRejoin
   \   00000006   0xB920             CBNZ.N   R0,??emberAfStackDown_0
   \   00000008   0x.... 0x....      BL       emberNetworkState
   \   0000000C   0xB908             CBNZ.N   R0,??emberAfStackDown_0
    332              // the report table should be cleared when the stack comes down.
    333              // going to a new network means new report devices should be discovered.
    334              // if the table isnt cleared the device keeps trying to send messages.
    335              emberAfClearReportTableCallback();
   \   0000000E   0x.... 0x....      BL       emberAfClearReportTableCallback
    336            }
    337          
    338            emberAfRegistrationAbortCallback();
   \                     ??emberAfStackDown_0: (+1)
   \   00000012   0x.... 0x....      BL       emberAfRegistrationAbortCallback
    339            emberAfTrustCenterKeepaliveAbortCallback();
   \   00000016   0xE8BD 0x4001      POP      {R0,LR}
   \   0000001A   0x.... 0x....      B.W      emberAfTrustCenterKeepaliveAbortCallback
    340          }
    341          
    342          // ****************************************
    343          // Print out information about each cluster
    344          // ****************************************
    345          

   \                                 In section .text, align 2, keep-with-next
    346          int16u emberAfFindClusterNameIndex(int16u cluster)
    347          {
   \                     emberAfFindClusterNameIndex: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    348            int16u index = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000008   0x.... 0x....      ADR.W    R3,zclClusterNames
   \   0000000C   0xE000             B.N      ??emberAfFindClusterNameIndex_0
    349            while (zclClusterNames[index].id != ZCL_NULL_CLUSTER_ID) {
    350              if (zclClusterNames[index].id == cluster) {
    351                return index;
    352              }
    353              index++;
   \                     ??emberAfFindClusterNameIndex_1: (+1)
   \   0000000E   0x1C52             ADDS     R2,R2,#+1
   \                     ??emberAfFindClusterNameIndex_0: (+1)
   \   00000010   0xB292             UXTH     R2,R2
   \   00000012   0xF833 0x4032      LDRH     R4,[R3, R2, LSL #+3]
   \   00000016   0x428C             CMP      R4,R1
   \   00000018   0xD003             BEQ.N    ??emberAfFindClusterNameIndex_2
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD1F7             BNE.N    ??emberAfFindClusterNameIndex_1
   \   0000001E   0x4610             MOV      R0,R2
   \   00000020   0xBD10             POP      {R4,PC}
    354            }
    355            return 0xFFFF;
   \                     ??emberAfFindClusterNameIndex_2: (+1)
   \   00000022   0x4608             MOV      R0,R1
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    356          }
    357          

   \                                 In section .text, align 2, keep-with-next
    358          void emberAfDecodeAndPrintCluster(int16u cluster)
    359          {
   \                     emberAfDecodeAndPrintCluster: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    360            int16u index = emberAfFindClusterNameIndex(cluster);
   \   00000004   0x.... 0x....      BL       emberAfFindClusterNameIndex
    361            if (index == 0xFFFF) {
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable27_7
   \   0000000C   0x4601             MOV      R1,R0
   \   0000000E   0x8828             LDRH     R0,[R5, #+0]
   \   00000010   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000014   0x4291             CMP      R1,R2
   \   00000016   0xD103             BNE.N    ??emberAfDecodeAndPrintCluster_0
    362              emberAfPrint(emberAfPrintActiveArea,
    363                           "(Unknown clus. [0x%2x])",
    364                           cluster);
   \   00000018   0x4622             MOV      R2,R4
   \   0000001A   0x.... 0x....      ADR.W    R1,`?<Constant "(Unknown clus. [0x%2x])">`
   \   0000001E   0xE006             B.N      ??emberAfDecodeAndPrintCluster_1
    365            } else {
    366              emberAfPrint(emberAfPrintActiveArea,
    367                           "(%p)",
    368                           zclClusterNames[index].name);
   \                     ??emberAfDecodeAndPrintCluster_0: (+1)
   \   00000020   0x.... 0x....      ADR.W    R2,zclClusterNames
   \   00000024   0xEB02 0x01C1      ADD      R1,R2,R1, LSL #+3
   \   00000028   0x684A             LDR      R2,[R1, #+4]
   \   0000002A   0x.... 0x....      ADR.W    R1,`?<Constant "(%p)">`
   \                     ??emberAfDecodeAndPrintCluster_1: (+1)
   \   0000002E   0x.... 0x....      BL       emberAfPrint
    369            }
    370            emberAfFlush(emberAfPrintActiveArea);
   \   00000032   0x8828             LDRH     R0,[R5, #+0]
   \   00000034   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000038   0x.... 0x....      B.W      emberAfFlush
    371          }
    372          
    373          static void printIncomingZclMessage(const EmberAfClusterCommand *cmd)
    374          {
    375          #if defined(EMBER_AF_PRINT_ENABLE) && defined(EMBER_AF_PRINT_APP)
    376            if (emberAfPrintReceivedMessages) {
    377              emberAfAppPrint("\r\nT%4x:", emberAfGetCurrentTime());
    378              emberAfAppPrint("RX len %d, ep %x, clus 0x%2x ",
    379                              cmd->bufLen,
    380                              cmd->apsFrame->destinationEndpoint,
    381                              cmd->apsFrame->clusterId);
    382              emberAfAppDebugExec(emberAfDecodeAndPrintCluster(cmd->apsFrame->clusterId));
    383              if (cmd->mfgSpecific) {
    384                emberAfAppPrint(" mfgId %2x", cmd->mfgCode);
    385              }
    386              emberAfAppPrint(" FC %x seq %x cmd %x payload[",
    387                              cmd->buffer[0], // frame control
    388                              cmd->seqNum,
    389                              cmd->commandId);
    390              emberAfAppFlush();
    391              emberAfAppPrintBuffer(cmd->buffer + cmd->payloadStartIndex, // message
    392                                    cmd->bufLen - cmd->payloadStartIndex, // length
    393                                    TRUE);                                // spaces?
    394              emberAfAppFlush();
    395              emberAfAppPrintln("]");
    396            }
    397          #endif
    398          }
    399          

   \                                 In section .text, align 2, keep-with-next
    400          static boolean dispatchZclMessage(EmberAfClusterCommand *cmd)
    401          {
   \                     dispatchZclMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    402            int8u index = emberAfIndexFromEndpoint(cmd->apsFrame->destinationEndpoint);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x7940             LDRB     R0,[R0, #+5]
   \   00000008   0x.... 0x....      BL       emberAfIndexFromEndpoint
    403            if (index == 0xFF) {
   \   0000000C   0x28FF             CMP      R0,#+255
   \   0000000E   0xD01D             BEQ.N    ??dispatchZclMessage_0
    404              emberAfDebugPrint("Drop cluster 0x%2x command 0x%x",
    405                                cmd->apsFrame->clusterId,
    406                                cmd->commandId);
    407              emberAfDebugPrint(" due to invalid endpoint: ");
    408              emberAfDebugPrintln("0x%x", cmd->apsFrame->destinationEndpoint);
    409              return FALSE;
    410            } else if (emberAfNetworkIndexFromEndpointIndex(index) != cmd->networkIndex) {
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable27_8
   \   00000014   0x7F22             LDRB     R2,[R4, #+28]
   \   00000016   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   0000001A   0x7B01             LDRB     R1,[R0, #+12]
   \   0000001C   0x4291             CMP      R1,R2
   \   0000001E   0xD115             BNE.N    ??dispatchZclMessage_0
    411              emberAfDebugPrint("Drop cluster 0x%2x command 0x%x",
    412                                cmd->apsFrame->clusterId,
    413                                cmd->commandId);
    414              emberAfDebugPrint(" for endpoint 0x%x due to wrong %p: ",
    415                                cmd->apsFrame->destinationEndpoint,
    416                                "network");
    417              emberAfDebugPrintln("%d", cmd->networkIndex);
    418              return FALSE;
    419            } else if (emberAfProfileIdFromIndex(index) != cmd->apsFrame->profileId
    420                       && (cmd->apsFrame->profileId != EMBER_WILDCARD_PROFILE_ID
    421                           || (EMBER_MAXIMUM_STANDARD_PROFILE_ID
    422                               < emberAfProfileIdFromIndex(index)))) {
   \   00000020   0x6822             LDR      R2,[R4, #+0]
   \   00000022   0x8840             LDRH     R0,[R0, #+2]
   \   00000024   0x8811             LDRH     R1,[R2, #+0]
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD006             BEQ.N    ??dispatchZclMessage_1
   \   0000002A   0xF64F 0x73FF      MOVW     R3,#+65535
   \   0000002E   0x4299             CMP      R1,R3
   \   00000030   0xD10C             BNE.N    ??dispatchZclMessage_0
   \   00000032   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000036   0xDA09             BGE.N    ??dispatchZclMessage_0
    423              emberAfDebugPrint("Drop cluster 0x%2x command 0x%x",
    424                                cmd->apsFrame->clusterId,
    425                                cmd->commandId);
    426              emberAfDebugPrint(" for endpoint 0x%x due to wrong %p: ",
    427                                cmd->apsFrame->destinationEndpoint,
    428                                "profile");
    429              emberAfDebugPrintln("0x%2x", cmd->apsFrame->profileId);
    430              return FALSE;
    431            } else if ((cmd->type == EMBER_INCOMING_MULTICAST
    432                        || cmd->type == EMBER_INCOMING_MULTICAST_LOOPBACK)
    433                       && !emberAfGroupsClusterEndpointInGroupCallback(cmd->apsFrame->destinationEndpoint,
    434                                                                       cmd->apsFrame->groupId)) {
   \                     ??dispatchZclMessage_1: (+1)
   \   00000038   0x7920             LDRB     R0,[R4, #+4]
   \   0000003A   0x2802             CMP      R0,#+2
   \   0000003C   0xBF18             IT       NE 
   \   0000003E   0x2803             CMPNE    R0,#+3
   \   00000040   0xD106             BNE.N    ??dispatchZclMessage_2
   \   00000042   0x8911             LDRH     R1,[R2, #+8]
   \   00000044   0x7950             LDRB     R0,[R2, #+5]
   \   00000046   0x.... 0x....      BL       emberAfGroupsClusterEndpointInGroupCallback
   \   0000004A   0xB908             CBNZ.N   R0,??dispatchZclMessage_2
    435              emberAfDebugPrint("Drop cluster 0x%2x command 0x%x",
    436                                cmd->apsFrame->clusterId,
    437                                cmd->commandId);
    438              emberAfDebugPrint(" for endpoint 0x%x due to wrong %p: ",
    439                                cmd->apsFrame->destinationEndpoint,
    440                                "group");
    441              emberAfDebugPrintln("0x%2x", cmd->apsFrame->groupId);
    442              return FALSE;
   \                     ??dispatchZclMessage_0: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBD10             POP      {R4,PC}
    443            } else {
    444              return (cmd->clusterSpecific
    445                      ? emAfProcessClusterSpecificCommand(cmd)
    446                      : emAfProcessGlobalCommand(cmd));
   \                     ??dispatchZclMessage_2: (+1)
   \   00000050   0x7BA0             LDRB     R0,[R4, #+14]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0xBF1C             ITT      NE 
   \   00000058   0xE8BD 0x4010      POPNE    {R4,LR}
   \   0000005C   0x.... 0x....      BNE.W    emAfProcessClusterSpecificCommand
   \   00000060   0xE8BD 0x4010      POP      {R4,LR}
   \   00000064   0x.... 0x....      B.W      emAfProcessGlobalCommand
    447            }
    448          }
    449          

   \                                 In section .text, align 2, keep-with-next
    450          boolean emberAfProcessMessageIntoZclCmd(EmberApsFrame* apsFrame,
    451                                                  EmberIncomingMessageType type,
    452                                                  int8u* message,
    453                                                  int16u messageLength,
    454                                                  EmberNodeId source,
    455                                                  InterPanHeader* interPanHeader,
    456                                                  EmberAfClusterCommand* returnCmd)
    457          {
   \                     emberAfProcessMessageIntoZclCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4614             MOV      R4,R2
   \   00000004   0x461A             MOV      R2,R3
    458            int8u minLength = (message[0] & ZCL_MANUFACTURER_SPECIFIC_MASK
    459                               ? EMBER_AF_ZCL_MANUFACTURER_SPECIFIC_OVERHEAD
    460                               : EMBER_AF_ZCL_OVERHEAD);
   \   00000006   0x7823             LDRB     R3,[R4, #+0]
   \   00000008   0x075B             LSLS     R3,R3,#+29
   \   0000000A   0xBF4C             ITE      MI 
   \   0000000C   0x2305             MOVMI    R3,#+5
   \   0000000E   0x2303             MOVPL    R3,#+3
    461          
    462            if (messageLength < minLength) {
   \   00000010   0x429A             CMP      R2,R3
   \   00000012   0xD201             BCS.N    ??emberAfProcessMessageIntoZclCmd_0
    463              emberAfAppPrintln("%pRX pkt too short: %d < %d", "ERROR: ", messageLength, minLength);
    464              return FALSE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}
    465            }
   \                     ??emberAfProcessMessageIntoZclCmd_0: (+1)
   \   00000018   0x9D06             LDR      R5,[SP, #+24]
    466          
    467            // Populate the cluster command struct for processing.
    468            returnCmd->apsFrame        = apsFrame;
   \   0000001A   0x6028             STR      R0,[R5, #+0]
    469            returnCmd->type            = type;
   \   0000001C   0x7129             STRB     R1,[R5, #+4]
    470            returnCmd->source          = source;
   \   0000001E   0x9804             LDR      R0,[SP, #+16]
   \   00000020   0x80E8             STRH     R0,[R5, #+6]
    471            returnCmd->buffer          = message;
   \   00000022   0x60AC             STR      R4,[R5, #+8]
    472            returnCmd->bufLen          = messageLength;
   \   00000024   0x81AA             STRH     R2,[R5, #+12]
    473            returnCmd->clusterSpecific = (message[0] & ZCL_CLUSTER_SPECIFIC_COMMAND);
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000002C   0x73A8             STRB     R0,[R5, #+14]
    474            returnCmd->mfgSpecific     = (message[0] & ZCL_MANUFACTURER_SPECIFIC_MASK);
   \   0000002E   0x7820             LDRB     R0,[R4, #+0]
   \   00000030   0xF000 0x0004      AND      R0,R0,#0x4
   \   00000034   0x73E8             STRB     R0,[R5, #+15]
    475            returnCmd->direction       = ((message[0] & ZCL_FRAME_CONTROL_DIRECTION_MASK)
    476                                           ? ZCL_DIRECTION_SERVER_TO_CLIENT
    477                                           : ZCL_DIRECTION_CLIENT_TO_SERVER);
   \   00000036   0x7820             LDRB     R0,[R4, #+0]
   \   00000038   0x08C0             LSRS     R0,R0,#+3
   \   0000003A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000003E   0x7568             STRB     R0,[R5, #+21]
    478            returnCmd->payloadStartIndex = 1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x7528             STRB     R0,[R5, #+20]
    479            if (returnCmd->mfgSpecific) {
   \   00000044   0x7BE8             LDRB     R0,[R5, #+15]
   \   00000046   0xB130             CBZ.N    R0,??emberAfProcessMessageIntoZclCmd_1
    480              returnCmd->mfgCode = emberAfGetInt16u(message, returnCmd->payloadStartIndex, messageLength);
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       emberAfGetInt16u
    481              returnCmd->payloadStartIndex += 2;
   \   00000050   0x7D29             LDRB     R1,[R5, #+20]
   \   00000052   0x1C89             ADDS     R1,R1,#+2
   \   00000054   0x7529             STRB     R1,[R5, #+20]
    482            } else {
    483              returnCmd->mfgCode = EMBER_AF_NULL_MANUFACTURER_CODE;
   \                     ??emberAfProcessMessageIntoZclCmd_1: (+1)
   \   00000056   0x8228             STRH     R0,[R5, #+16]
    484            }
    485            returnCmd->seqNum         = message[returnCmd->payloadStartIndex++];
   \   00000058   0x7D28             LDRB     R0,[R5, #+20]
   \   0000005A   0x1C41             ADDS     R1,R0,#+1
   \   0000005C   0x7529             STRB     R1,[R5, #+20]
   \   0000005E   0x5D00             LDRB     R0,[R0, R4]
   \   00000060   0x74A8             STRB     R0,[R5, #+18]
    486            returnCmd->commandId      = message[returnCmd->payloadStartIndex++];
   \   00000062   0x1C48             ADDS     R0,R1,#+1
   \   00000064   0x7528             STRB     R0,[R5, #+20]
   \   00000066   0xB2C9             UXTB     R1,R1
   \   00000068   0x5D08             LDRB     R0,[R1, R4]
   \   0000006A   0x74E8             STRB     R0,[R5, #+19]
    487            returnCmd->interPanHeader = interPanHeader;
   \   0000006C   0x9805             LDR      R0,[SP, #+20]
   \   0000006E   0x61A8             STR      R0,[R5, #+24]
    488            returnCmd->networkIndex   = emberGetCurrentNetwork();
   \   00000070   0x.... 0x....      BL       emberGetCurrentNetwork
   \   00000074   0x7728             STRB     R0,[R5, #+28]
    489            return TRUE;
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    490          }
    491          
    492          // a single call to process global and cluster-specific messages and callbacks.

   \                                 In section .text, align 2, keep-with-next
    493          boolean emberAfProcessMessage(EmberApsFrame *apsFrame,
    494                                        EmberIncomingMessageType type,
    495                                        int8u *message,
    496                                        int16u msgLen,
    497                                        EmberNodeId source,
    498                                        InterPanHeader *interPanHeader)
    499          {
   \                     emberAfProcessMessage: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x460E             MOV      R6,R1
    500            EmberAfClusterCommand cmd;
    501            boolean msgHandled = FALSE;
    502          
    503            if (!emberAfProcessMessageIntoZclCmd(apsFrame,
    504                                                 type,
    505                                                 message,
    506                                                 msgLen,
    507                                                 source,
    508                                                 interPanHeader,
    509                                                 &cmd)) {
   \   00000006   0xA903             ADD      R1,SP,#+12
   \   00000008   0x9102             STR      R1,[SP, #+8]
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0x9910             LDR      R1,[SP, #+64]
   \   0000000E   0x9F11             LDR      R7,[SP, #+68]
   \   00000010   0x.... 0x....      LDR.W    R4,??DataTable27_3
   \   00000014   0x9100             STR      R1,[SP, #+0]
   \   00000016   0x9701             STR      R7,[SP, #+4]
   \   00000018   0x4631             MOV      R1,R6
   \   0000001A   0x.... 0x....      BL       emberAfProcessMessageIntoZclCmd
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD05E             BEQ.N    ??emberAfProcessMessage_0
    510              goto kickout;
    511            }
    512            emAfCurrentCommand = &cmd;
   \   00000022   0xA803             ADD      R0,SP,#+12
   \   00000024   0x61E0             STR      R0,[R4, #+28]
    513          
    514            // All of these should be covered by the EmberAfClusterCommand but are
    515            // still here until all the code is moved over to use the cmd. -WEH
    516            emberAfIncomingZclSequenceNumber = cmd.seqNum;
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable27_9
   \   0000002A   0xF89D 0x001E      LDRB     R0,[SP, #+30]
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    517          
    518            printIncomingZclMessage(&cmd);
    519            prepareForResponse(&cmd);
   \   00000030   0xA803             ADD      R0,SP,#+12
   \   00000032   0x.... 0x....      BL       prepareForResponse
    520          
    521            if (emberAfPreCommandReceivedCallback(&cmd)) {
   \   00000036   0xA803             ADD      R0,SP,#+12
   \   00000038   0x.... 0x....      BL       emberAfPreCommandReceivedCallback
   \   0000003C   0xBB20             CBNZ.N   R0,??emberAfProcessMessage_1
    522              msgHandled = TRUE;
    523              goto kickout;
    524            }
    525          
    526            if (interPanHeader == NULL) {
   \   0000003E   0xBB2F             CBNZ.N   R7,??emberAfProcessMessage_2
    527              boolean broadcast = (type == EMBER_INCOMING_BROADCAST
    528                                   || type == EMBER_INCOMING_BROADCAST_LOOPBACK
    529                                   || type == EMBER_INCOMING_MULTICAST
    530                                   || type == EMBER_INCOMING_MULTICAST_LOOPBACK);
   \   00000040   0x2E04             CMP      R6,#+4
   \   00000042   0xBF18             IT       NE 
   \   00000044   0x2E05             CMPNE    R6,#+5
   \   00000046   0xD003             BEQ.N    ??emberAfProcessMessage_3
   \   00000048   0x2E02             CMP      R6,#+2
   \   0000004A   0xBF18             IT       NE 
   \   0000004C   0x2E03             CMPNE    R6,#+3
   \   0000004E   0xD101             BNE.N    ??emberAfProcessMessage_4
   \                     ??emberAfProcessMessage_3: (+1)
   \   00000050   0x2201             MOVS     R2,#+1
   \   00000052   0xE000             B.N      ??emberAfProcessMessage_5
   \                     ??emberAfProcessMessage_4: (+1)
   \   00000054   0x2200             MOVS     R2,#+0
    531          
    532              // if the cluster for the incoming message requires security and
    533              // doesnt have it return default response STATUS_FAILURE
    534              if (emberAfDetermineIfLinkSecurityIsRequired(cmd.commandId,
    535                                                           TRUE, // incoming
    536                                                           broadcast,
    537                                                           cmd.apsFrame->profileId,
    538                                                           cmd.apsFrame->clusterId,
    539                                                           cmd.source)
    540                  && (!(cmd.apsFrame->options & EMBER_APS_OPTION_ENCRYPTION))) {
   \                     ??emberAfProcessMessage_5: (+1)
   \   00000056   0xF8BD 0x0012      LDRH     R0,[SP, #+18]
   \   0000005A   0x9001             STR      R0,[SP, #+4]
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x9803             LDR      R0,[SP, #+12]
   \   00000060   0x8840             LDRH     R0,[R0, #+2]
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0x9803             LDR      R0,[SP, #+12]
   \   00000066   0x8803             LDRH     R3,[R0, #+0]
   \   00000068   0xF89D 0x001F      LDRB     R0,[SP, #+31]
   \   0000006C   0x.... 0x....      BL       emberAfDetermineIfLinkSecurityIsRequired
   \   00000070   0xB178             CBZ.N    R0,??emberAfProcessMessage_6
   \   00000072   0x9803             LDR      R0,[SP, #+12]
   \   00000074   0x7980             LDRB     R0,[R0, #+6]
   \   00000076   0x0680             LSLS     R0,R0,#+26
   \   00000078   0xD40B             BMI.N    ??emberAfProcessMessage_6
    541                emberAfDebugPrintln("Drop clus %2x due to no aps security",
    542                                    cmd.apsFrame->clusterId);
    543                afNoSecurityForDefaultResponse = TRUE;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x7020             STRB     R0,[R4, #+0]
    544                emberAfSendDefaultResponse(&cmd, EMBER_ZCL_STATUS_FAILURE);
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0xA803             ADD      R0,SP,#+12
   \   00000082   0x.... 0x....      BL       emberAfSendDefaultResponse
    545                afNoSecurityForDefaultResponse = FALSE;
   \   00000086   0x7025             STRB     R5,[R4, #+0]
    546          
    547                // Mark the message as processed.  It failed security processing, so no
    548                // other parts of the code act should upon it.
    549                msgHandled = TRUE;
   \                     ??emberAfProcessMessage_1: (+1)
   \   00000088   0x2501             MOVS     R5,#+1
    550                goto kickout;
   \   0000008A   0xE029             B.N      ??emberAfProcessMessage_0
    551              }
    552            } else if (!(interPanHeader->options
    553                         & EMBER_AF_INTERPAN_OPTION_MAC_HAS_LONG_ADDRESS)) {
   \                     ??emberAfProcessMessage_2: (+1)
   \   0000008C   0x7D38             LDRB     R0,[R7, #+20]
   \   0000008E   0x0780             LSLS     R0,R0,#+30
   \   00000090   0xD526             BPL.N    ??emberAfProcessMessage_0
    554              // For safety, dump all interpan messages that don't have a long
    555              // source in the MAC layer.  In theory they should not get past
    556              // the MAC filters but this is insures they will not get processed.
    557              goto kickout;
    558            }
    559          
    560            if (cmd.apsFrame->destinationEndpoint == EMBER_BROADCAST_ENDPOINT) {
   \                     ??emberAfProcessMessage_6: (+1)
   \   00000092   0x9803             LDR      R0,[SP, #+12]
   \   00000094   0x7940             LDRB     R0,[R0, #+5]
   \   00000096   0x28FF             CMP      R0,#+255
   \   00000098   0xD11E             BNE.N    ??emberAfProcessMessage_7
    561              int8u i;
    562              for (i = 0; i < emberAfEndpointCount(); i++) {
   \   0000009A   0x2600             MOVS     R6,#+0
   \   0000009C   0x.... 0x....      LDR.W    R7,??DataTable27_2
   \                     ??emberAfProcessMessage_8: (+1)
   \   000000A0   0x.... 0x....      BL       emberAfEndpointCount
   \   000000A4   0xB2F6             UXTB     R6,R6
   \   000000A6   0x4286             CMP      R6,R0
   \   000000A8   0xD21A             BCS.N    ??emberAfProcessMessage_0
    563                if (!emberAfEndpointIndexIsEnabled(i)) {
   \   000000AA   0x4630             MOV      R0,R6
   \   000000AC   0x.... 0x....      BL       emberAfEndpointIndexIsEnabled
   \   000000B0   0xB180             CBZ.N    R0,??emberAfProcessMessage_9
    564                  continue;
    565                }
    566                // Since the APS frame is cleared after each sending,
    567                // we must reinitialize it.  It is cleared to prevent
    568                // data from leaking out and being sent inadvertently.
    569                prepareForResponse(&cmd);
   \   000000B2   0xA803             ADD      R0,SP,#+12
   \   000000B4   0x.... 0x....      BL       prepareForResponse
    570          
    571                // Change the destination endpoint of the incoming command and the source
    572                // source endpoint of the response so they both reflect the endpoint the
    573                // message is actually being passed to in this iteration of the loop.
    574                cmd.apsFrame->destinationEndpoint      = emberAfEndpointFromIndex(i);
   \   000000B8   0x4630             MOV      R0,R6
   \   000000BA   0x.... 0x....      BL       emberAfEndpointFromIndex
   \   000000BE   0x9903             LDR      R1,[SP, #+12]
   \   000000C0   0x7148             STRB     R0,[R1, #+5]
    575                emberAfResponseApsFrame.sourceEndpoint = emberAfEndpointFromIndex(i);
   \   000000C2   0x4630             MOV      R0,R6
   \   000000C4   0x.... 0x....      BL       emberAfEndpointFromIndex
   \   000000C8   0x7138             STRB     R0,[R7, #+4]
    576                if (dispatchZclMessage(&cmd)) {
   \   000000CA   0xA803             ADD      R0,SP,#+12
   \   000000CC   0x.... 0x....      BL       dispatchZclMessage
   \   000000D0   0xB100             CBZ.N    R0,??emberAfProcessMessage_9
    577                  msgHandled = TRUE;
   \   000000D2   0x2501             MOVS     R5,#+1
    578                }
    579              }
   \                     ??emberAfProcessMessage_9: (+1)
   \   000000D4   0x1C76             ADDS     R6,R6,#+1
   \   000000D6   0xE7E3             B.N      ??emberAfProcessMessage_8
    580            } else {
    581              msgHandled = dispatchZclMessage(&cmd);
   \                     ??emberAfProcessMessage_7: (+1)
   \   000000D8   0xA803             ADD      R0,SP,#+12
   \   000000DA   0x.... 0x....      BL       dispatchZclMessage
   \   000000DE   0x4605             MOV      R5,R0
    582            }
    583          
    584          kickout:
    585            emberAfClearResponseData();
   \                     ??emberAfProcessMessage_0: (+1)
   \   000000E0   0x.... 0x....      BL       emberAfClearResponseData
    586            MEMSET(&interpanResponseHeader,
    587                   0,
    588                   sizeof(EmberAfInterpanHeader));
   \   000000E4   0x2216             MOVS     R2,#+22
   \   000000E6   0x2100             MOVS     R1,#+0
   \   000000E8   0x1D20             ADDS     R0,R4,#+4
   \   000000EA   0x.... 0x....      BL       halCommonMemSet
    589            emAfCurrentCommand = NULL;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x61E0             STR      R0,[R4, #+28]
    590            return msgHandled;
   \   000000F2   0xB00B             ADD      SP,SP,#+44
   \   000000F4   0x4628             MOV      R0,R5
   \   000000F6   0xBDF0             POP      {R4-R7,PC}       ;; return
    591          }
    592          

   \                                 In section .text, align 2, keep-with-next
    593          int8u emberAfNextSequence(void)
    594          {
    595            return ((++emberAfSequenceNumber) & EMBER_AF_ZCL_SEQUENCE_MASK);
   \                     emberAfNextSequence: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable27_10
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0x7001             STRB     R1,[R0, #+0]
   \   0000000A   0xF001 0x007F      AND      R0,R1,#0x7F
   \   0000000E   0x4770             BX       LR               ;; return
    596          }
    597          

   \                                 In section .text, align 2, keep-with-next
    598          int8u emberAfGetLastSequenceNumber(void)
    599          {
    600            return (emberAfSequenceNumber & EMBER_AF_ZCL_SEQUENCE_MASK);
   \                     emberAfGetLastSequenceNumber: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable27_10
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xF000 0x007F      AND      R0,R0,#0x7F
   \   0000000A   0x4770             BX       LR               ;; return
    601          }
    602          
    603          // the caller to the library can set a flag to say do not respond to the
    604          // next ZCL message passed in to the library. Passing TRUE means disable
    605          // the reply for the next ZCL message. Setting to FALSE re-enables the
    606          // reply (in the case where the app disables it and then doesnt send a
    607          // message that gets parsed).

   \                                 In section .text, align 2, keep-with-next
    608          void emberAfSetNoReplyForNextMessage(boolean set)
    609          {
    610            if (set) {
   \                     emberAfSetNoReplyForNextMessage: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable27_3
   \   00000004   0x784A             LDRB     R2,[R1, #+1]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xBF14             ITE      NE 
    611              emberAfResponseType |= ZCL_UTIL_RESP_NONE;
   \   0000000A   0xF042 0x0001      ORRNE    R0,R2,#0x1
    612            } else {
    613              emberAfResponseType &= ~ZCL_UTIL_RESP_NONE;
   \   0000000E   0xF002 0x00FE      ANDEQ    R0,R2,#0xFE
   \   00000012   0x7048             STRB     R0,[R1, #+1]
    614            }
    615          }
   \   00000014   0x4770             BX       LR               ;; return
    616          

   \                                 In section .text, align 2, keep-with-next
    617          EmberStatus emberAfSendResponseWithCallback(EmberAfMessageSentFunction callback)
    618          {
   \                     emberAfSendResponseWithCallback: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
    619            EmberStatus status;
    620            int8u label;
    621          
    622            // If the no-response flag is set, dont send anything.
    623            if (emberAfResponseType & ZCL_UTIL_RESP_NONE) {
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable27_3
   \   00000006   0x7863             LDRB     R3,[R4, #+1]
   \   00000008   0x07D9             LSLS     R1,R3,#+31
   \   0000000A   0xD501             BPL.N    ??emberAfSendResponseWithCallback_0
    624              emberAfDebugPrintln("ZCL Util: no response at user request");
    625              return EMBER_SUCCESS;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD76             POP      {R1,R2,R4-R6,PC}
    626            }
    627          
    628            if (emberAfApsRetryOverride == EMBER_AF_RETRY_OVERRIDE_SET) {
   \                     ??emberAfSendResponseWithCallback_0: (+1)
   \   00000010   0x.... 0x....      LDR.W    R2,??DataTable27_9
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable27_2
   \   00000018   0x7855             LDRB     R5,[R2, #+1]
   \   0000001A   0x2D01             CMP      R5,#+1
   \   0000001C   0xD103             BNE.N    ??emberAfSendResponseWithCallback_1
    629              emberAfResponseApsFrame.options |= EMBER_APS_OPTION_RETRY;
   \   0000001E   0x88CD             LDRH     R5,[R1, #+6]
   \   00000020   0xF045 0x0540      ORR      R5,R5,#0x40
   \   00000024   0xE005             B.N      ??emberAfSendResponseWithCallback_2
    630            } else if (emberAfApsRetryOverride == EMBER_AF_RETRY_OVERRIDE_UNSET) {
   \                     ??emberAfSendResponseWithCallback_1: (+1)
   \   00000026   0x2D02             CMP      R5,#+2
   \   00000028   0xD104             BNE.N    ??emberAfSendResponseWithCallback_3
    631              emberAfResponseApsFrame.options &= ~EMBER_APS_OPTION_RETRY;
   \   0000002A   0x88CD             LDRH     R5,[R1, #+6]
   \   0000002C   0xF64F 0x76BF      MOVW     R6,#+65471
   \   00000030   0x4035             ANDS     R5,R6,R5
   \                     ??emberAfSendResponseWithCallback_2: (+1)
   \   00000032   0x80CD             STRH     R5,[R1, #+6]
    632            }
    633          
    634            // Fill commands may increase the sequence.  For responses, we want to make
    635            // sure the sequence is reset to that of the request.
    636            if (appResponseData[0] & ZCL_MANUFACTURER_SPECIFIC_MASK) {
   \                     ??emberAfSendResponseWithCallback_3: (+1)
   \   00000034   0x7815             LDRB     R5,[R2, #+0]
   \   00000036   0x.... 0x....      LDR.W    R2,??DataTable27_6
   \   0000003A   0x7816             LDRB     R6,[R2, #+0]
   \   0000003C   0x0776             LSLS     R6,R6,#+29
   \   0000003E   0xBF4C             ITE      MI 
    637              appResponseData[3] = emberAfIncomingZclSequenceNumber;
   \   00000040   0x70D5             STRBMI   R5,[R2, #+3]
    638            } else {
    639              appResponseData[1] = emberAfIncomingZclSequenceNumber;
   \   00000042   0x7055             STRBPL   R5,[R2, #+1]
    640            }
    641          
    642            // The manner in which the message is sent depends on the response flags and
    643            // the destination of the message.
    644            if (emberAfResponseType & ZCL_UTIL_RESP_INTERPAN) {
   \   00000044   0x.... 0x....      LDR.W    R5,??DataTable27_5
   \   00000048   0x882D             LDRH     R5,[R5, #+0]
   \   0000004A   0x079B             LSLS     R3,R3,#+30
   \   0000004C   0xD508             BPL.N    ??emberAfSendResponseWithCallback_4
    645              label = 'I';
    646              status = emberAfInterpanSendMessageCallback(&interpanResponseHeader,
    647                                                          appResponseLength,
    648                                                          appResponseData);
   \   0000004E   0x4629             MOV      R1,R5
   \   00000050   0x1D20             ADDS     R0,R4,#+4
   \   00000052   0x.... 0x....      BL       emberAfInterpanSendMessageCallback
    649              emberAfResponseType &= ~ZCL_UTIL_RESP_INTERPAN;
   \   00000056   0x7861             LDRB     R1,[R4, #+1]
   \   00000058   0xF001 0x01FD      AND      R1,R1,#0xFD
   \   0000005C   0x7061             STRB     R1,[R4, #+1]
   \   0000005E   0xBD76             POP      {R1,R2,R4-R6,PC}
    650            } else if (emberAfResponseDestination < EMBER_BROADCAST_ADDRESS) {
   \                     ??emberAfSendResponseWithCallback_4: (+1)
   \   00000060   0x.... 0x....      LDR.W    R3,??DataTable27_4
   \   00000064   0x881C             LDRH     R4,[R3, #+0]
   \   00000066   0xF64F 0x73FC      MOVW     R3,#+65532
   \   0000006A   0x429C             CMP      R4,R3
   \   0000006C   0xDA08             BGE.N    ??emberAfSendResponseWithCallback_5
    651              label = 'U';
    652              status = emberAfSendUnicastWithCallback(EMBER_OUTGOING_DIRECT,
    653                                                      emberAfResponseDestination,
    654                                                      &emberAfResponseApsFrame,
    655                                                      appResponseLength,
    656                                                      appResponseData,
    657                                                      callback);
   \   0000006E   0x9200             STR      R2,[SP, #+0]
   \   00000070   0x9001             STR      R0,[SP, #+4]
   \   00000072   0x460A             MOV      R2,R1
   \   00000074   0x462B             MOV      R3,R5
   \   00000076   0x4621             MOV      R1,R4
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x.... 0x....      BL       emberAfSendUnicastWithCallback
   \   0000007E   0xBD76             POP      {R1,R2,R4-R6,PC}
    658            } else {
    659              label = 'B';
    660              status = emberAfSendBroadcastWithCallback(emberAfResponseDestination,
    661                                                        &emberAfResponseApsFrame,
    662                                                        appResponseLength,
    663                                                        appResponseData,
    664                                                        callback);
   \                     ??emberAfSendResponseWithCallback_5: (+1)
   \   00000080   0x9000             STR      R0,[SP, #+0]
   \   00000082   0x4613             MOV      R3,R2
   \   00000084   0x462A             MOV      R2,R5
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       emberAfSendBroadcastWithCallback
    665            }
    666            UNUSED_VAR(label);
    667            emberAfDebugPrintln("T%4x:TX (%p) %ccast 0x%x%p",
    668                                emberAfGetCurrentTime(),
    669                                "resp",
    670                                label,
    671                                status,
    672                                ((emberAfResponseApsFrame.options
    673                                  & EMBER_APS_OPTION_ENCRYPTION)
    674                                 ? " w/ link key" : ""));
    675            emberAfDebugPrint("TX buffer: [");
    676            emberAfDebugFlush();
    677            emberAfDebugPrintBuffer(appResponseData, appResponseLength, TRUE);
    678            emberAfDebugPrintln("]");
    679            emberAfDebugFlush();
    680          
    681          #ifdef EMBER_AF_ENABLE_STATISTICS
    682            if (status == EMBER_SUCCESS) {
    683              afNumPktsSent++;
    684            }
    685          #endif
    686          
    687            return status;
   \   0000008C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    688          }
    689          

   \                                 In section .text, align 2, keep-with-next
    690          EmberStatus emberAfSendResponse(void)
    691          {
    692            return emberAfSendResponseWithCallback(NULL);
   \                     emberAfSendResponse: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             B.N      emberAfSendResponseWithCallback
    693          }
    694          

   \                                 In section .text, align 2, keep-with-next
    695          EmberStatus emberAfSendImmediateDefaultResponseWithCallback(EmberAfStatus status,
    696                                                                      EmberAfMessageSentFunction callback)
    697          {
    698            return emberAfSendDefaultResponseWithCallback(emberAfCurrentCommand(), status, callback);
   \                     emberAfSendImmediateDefaultResponseWithCallback: (+1)
   \   00000000   0x460A             MOV      R2,R1
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable27_3
   \   00000008   0x69C0             LDR      R0,[R0, #+28]
   \   0000000A   0x....             B.N      emberAfSendDefaultResponseWithCallback
    699          }
    700          

   \                                 In section .text, align 2, keep-with-next
    701          EmberStatus emberAfSendImmediateDefaultResponse(EmberAfStatus status)
    702          {
    703            return emberAfSendImmediateDefaultResponseWithCallback(status, NULL);
   \                     emberAfSendImmediateDefaultResponse: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      emberAfSendImmediateDefaultResponseWithCallback
    704          }
    705          

   \                                 In section .text, align 2, keep-with-next
    706          EmberStatus emberAfSendDefaultResponseWithCallback(const EmberAfClusterCommand *cmd,
    707                                                             EmberAfStatus status,
    708                                                             EmberAfMessageSentFunction callback)
    709          {
   \                     emberAfSendDefaultResponseWithCallback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    710            int8u frameControl;
    711          
    712            // Default Response commands are only sent in response to unicast commands.
    713            if (cmd->type != EMBER_INCOMING_UNICAST
    714                && cmd->type != EMBER_INCOMING_UNICAST_REPLY) {
   \   00000006   0x7920             LDRB     R0,[R4, #+4]
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xBF18             IT       NE 
   \   0000000E   0x2801             CMPNE    R0,#+1
   \   00000010   0xD10A             BNE.N    ??emberAfSendDefaultResponseWithCallback_0
    715              return EMBER_SUCCESS;
    716            }
    717          
    718            // If the Disable Default Response sub-field is set, Default Response commands
    719            // are only sent if there was an error.
    720            if ((cmd->buffer[0] & ZCL_DISABLE_DEFAULT_RESPONSE_MASK)
    721                && status == EMBER_ZCL_STATUS_SUCCESS) {
   \   00000012   0x68A0             LDR      R0,[R4, #+8]
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x06C0             LSLS     R0,R0,#+27
   \   00000018   0xD500             BPL.N    ??emberAfSendDefaultResponseWithCallback_1
   \   0000001A   0xB12D             CBZ.N    R5,??emberAfSendDefaultResponseWithCallback_0
    722              return EMBER_SUCCESS;
    723            }
    724          
    725            // Default Response commands are never sent in response to other Default
    726            // Response commands.
    727            if (!cmd->clusterSpecific
    728                && cmd->commandId == ZCL_DEFAULT_RESPONSE_COMMAND_ID) {
   \                     ??emberAfSendDefaultResponseWithCallback_1: (+1)
   \   0000001C   0x7BA0             LDRB     R0,[R4, #+14]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xBF04             ITT      EQ 
   \   00000022   0x7CE0             LDRBEQ   R0,[R4, #+19]
   \   00000024   0x280B             CMPEQ    R0,#+11
   \   00000026   0xD101             BNE.N    ??emberAfSendDefaultResponseWithCallback_2
    729              return EMBER_SUCCESS;
   \                     ??emberAfSendDefaultResponseWithCallback_0: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD70             POP      {R4-R6,PC}
    730            }
    731          
    732            appResponseLength = 0;
   \                     ??emberAfSendDefaultResponseWithCallback_2: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable27_5
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x8008             STRH     R0,[R1, #+0]
    733            frameControl = (ZCL_PROFILE_WIDE_COMMAND
    734                            | (cmd->direction == ZCL_DIRECTION_CLIENT_TO_SERVER
    735                               ? ZCL_FRAME_CONTROL_SERVER_TO_CLIENT
    736                               : ZCL_FRAME_CONTROL_CLIENT_TO_SERVER));
   \   00000034   0x7D60             LDRB     R0,[R4, #+21]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xBF0C             ITE      EQ 
   \   0000003A   0x2008             MOVEQ    R0,#+8
   \   0000003C   0x2000             MOVNE    R0,#+0
    737          
    738            if (!cmd->mfgSpecific) {
   \   0000003E   0x7BE1             LDRB     R1,[R4, #+15]
   \   00000040   0xB911             CBNZ.N   R1,??emberAfSendDefaultResponseWithCallback_3
    739              emberAfPutInt8uInResp(frameControl & ~ZCL_MANUFACTURER_SPECIFIC_MASK);
   \   00000042   0x.... 0x....      BL       emberAfPutInt8uInResp
   \   00000046   0xE006             B.N      ??emberAfSendDefaultResponseWithCallback_4
    740            } else {
    741              emberAfPutInt8uInResp(frameControl | ZCL_MANUFACTURER_SPECIFIC_MASK);
   \                     ??emberAfSendDefaultResponseWithCallback_3: (+1)
   \   00000048   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000004C   0x.... 0x....      BL       emberAfPutInt8uInResp
    742              emberAfPutInt16uInResp(cmd->mfgCode);
   \   00000050   0x8A20             LDRH     R0,[R4, #+16]
   \   00000052   0x.... 0x....      BL       emberAfPutInt16uInResp
    743            }
    744            emberAfPutInt8uInResp(cmd->seqNum);
   \                     ??emberAfSendDefaultResponseWithCallback_4: (+1)
   \   00000056   0x7CA0             LDRB     R0,[R4, #+18]
   \   00000058   0x.... 0x....      BL       emberAfPutInt8uInResp
    745            emberAfPutInt8uInResp(ZCL_DEFAULT_RESPONSE_COMMAND_ID);
   \   0000005C   0x200B             MOVS     R0,#+11
   \   0000005E   0x.... 0x....      BL       emberAfPutInt8uInResp
    746            emberAfPutInt8uInResp(cmd->commandId);
   \   00000062   0x7CE0             LDRB     R0,[R4, #+19]
   \   00000064   0x.... 0x....      BL       emberAfPutInt8uInResp
    747            emberAfPutInt8uInResp(status);
   \   00000068   0x4628             MOV      R0,R5
   \   0000006A   0x.... 0x....      BL       emberAfPutInt8uInResp
    748          
    749            prepareForResponse(cmd);
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       prepareForResponse
    750            return emberAfSendResponseWithCallback(callback);
   \   00000074   0x4630             MOV      R0,R6
   \   00000076   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000007A   0x....             B.N      emberAfSendResponseWithCallback
    751          }
    752          

   \                                 In section .text, align 2, keep-with-next
    753          EmberStatus emberAfSendDefaultResponse(const EmberAfClusterCommand *cmd,
    754                                                 EmberAfStatus status)
    755          {
    756            return emberAfSendDefaultResponseWithCallback(cmd, status, NULL);
   \                     emberAfSendDefaultResponse: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x....             B.N      emberAfSendDefaultResponseWithCallback
    757          }
    758          

   \                                 In section .text, align 2, keep-with-next
    759          boolean emberAfDetermineIfLinkSecurityIsRequired(int8u commandId,
    760                                                           boolean incoming,
    761                                                           boolean broadcast,
    762                                                           EmberAfProfileId profileId,
    763                                                           EmberAfClusterId clusterId,
    764                                                           EmberNodeId remoteNodeId)
    765          {
   \                     emberAfDetermineIfLinkSecurityIsRequired: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4618             MOV      R0,R3
    766            (void)afNoSecurityForDefaultResponse; // remove warning if not used
    767          
    768            // If we have turned off all APS security (needed for testing), then just
    769            // always return false.
    770            if ((emAfTestApsSecurityOverride == APS_TEST_SECURITY_DISABLED) || afNoSecurityForDefaultResponse) {
   \   00000006   0x.... 0x....      LDR.W    R3,??DataTable27_11
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable27_3
   \   0000000E   0x781B             LDRB     R3,[R3, #+0]
   \   00000010   0x2B01             CMP      R3,#+1
   \   00000012   0xD001             BEQ.N    ??emberAfDetermineIfLinkSecurityIsRequired_0
   \   00000014   0x782E             LDRB     R6,[R5, #+0]
   \   00000016   0xB116             CBZ.N    R6,??emberAfDetermineIfLinkSecurityIsRequired_1
    771              afNoSecurityForDefaultResponse = FALSE;
   \                     ??emberAfDetermineIfLinkSecurityIsRequired_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x7028             STRB     R0,[R5, #+0]
    772              return FALSE;
   \   0000001C   0xBD70             POP      {R4-R6,PC}
    773            }
    774          
    775            // NOTE: In general if it is a unicast, and one of the SE clusters, it
    776            // requires APS encryption.  A few special cases exists that we allow for
    777            // but those must be explicitly spelled out here.
    778          
    779            // Assume that if the local device is broadcasting, even if it is using one
    780            // of the SE clusters, this is okay.
    781            if (!incoming && broadcast) {
   \                     ??emberAfDetermineIfLinkSecurityIsRequired_1: (+1)
   \   0000001E   0xB911             CBNZ.N   R1,??emberAfDetermineIfLinkSecurityIsRequired_2
   \   00000020   0xB10A             CBZ.N    R2,??emberAfDetermineIfLinkSecurityIsRequired_2
    782              return FALSE;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD70             POP      {R4-R6,PC}
    783            }
    784          
    785            // At this point if the CLI command has been issued, it's safe to over any other settings
    786            // and return.
    787            // This change allows HA applications to use the CLI option to enable APS security.
    788            if(emAfTestApsSecurityOverride == APS_TEST_SECURITY_ENABLED) {
   \                     ??emberAfDetermineIfLinkSecurityIsRequired_2: (+1)
   \   00000026   0xB12B             CBZ.N    R3,??emberAfDetermineIfLinkSecurityIsRequired_3
    789              return TRUE;
    790            } else if (emAfTestApsSecurityOverride == APS_TEST_SECURITY_DISABLED) {
    791              //The default return value before this change.
    792              return FALSE;
    793            }
    794          
    795          
    796          
    797          #ifdef EMBER_AF_HAS_SECURITY_PROFILE_SE
    798            if (emberAfIsCurrentSecurityProfileSmartEnergy()) {
    799          
    800              // Check against profile IDs that use APS security on these clusters.
    801              if (profileId != SE_PROFILE_ID && profileId != EMBER_WILDCARD_PROFILE_ID) {
    802                return FALSE;
    803              }
    804          
    805              // Loopback packets do not require security
    806              if (emberGetNodeId() == remoteNodeId) {
    807                return FALSE;
    808              }
    809          
    810              // This list comes from Section 5.4.6 of the SE spec.
    811              switch (clusterId) {
    812              case ZCL_TIME_CLUSTER_ID:
    813              case ZCL_COMMISSIONING_CLUSTER_ID:
    814              case ZCL_PRICE_CLUSTER_ID:
    815              case ZCL_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_ID:
    816              case ZCL_SIMPLE_METERING_CLUSTER_ID:
    817              case ZCL_MESSAGING_CLUSTER_ID:
    818              case ZCL_TUNNELING_CLUSTER_ID:
    819              case ZCL_GENERIC_TUNNEL_CLUSTER_ID:
    820              case ZCL_PREPAYMENT_CLUSTER_ID:
    821              case ZCL_CALENDAR_CLUSTER_ID:
    822              case ZCL_DEVICE_MANAGEMENT_CLUSTER_ID:
    823              case ZCL_EVENTS_CLUSTER_ID:
    824              case ZCL_MDU_PAIRING_CLUSTER_ID:
    825              case ZCL_ENERGY_MANAGEMENT_CLUSTER_ID:
    826                return TRUE;
    827              case ZCL_OTA_BOOTLOAD_CLUSTER_ID:
    828                if (commandId == ZCL_IMAGE_NOTIFY_COMMAND_ID && broadcast) {
    829                  return FALSE;
    830                } else {
    831                  return TRUE;
    832                }
    833              default:
    834                break;
    835              }
    836            }
    837          #endif //EMBER_AF_HAS_SECURITY_PROFILE_SE
    838          
    839            if (emberAfClusterSecurityCustomCallback(profileId,
    840                                                     clusterId,
    841                                                     incoming,
    842                                                     commandId)) {
   \   00000028   0x460A             MOV      R2,R1
   \   0000002A   0x9904             LDR      R1,[SP, #+16]
   \   0000002C   0x4623             MOV      R3,R4
   \   0000002E   0x.... 0x....      BL       emberAfClusterSecurityCustomCallback
   \   00000032   0xB100             CBZ.N    R0,??emberAfDetermineIfLinkSecurityIsRequired_4
    843              return TRUE;
   \                     ??emberAfDetermineIfLinkSecurityIsRequired_3: (+1)
   \   00000034   0x2001             MOVS     R0,#+1
    844            }
    845          
    846          //APS_TEST_SECURITY_DEFAULT at this point returns FALSE.
    847          return FALSE;
   \                     ??emberAfDetermineIfLinkSecurityIsRequired_4: (+1)
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    848          
    849          }
    850          

   \                                 In section .text, align 2, keep-with-next
    851          int8u emberAfMaximumApsPayloadLength(EmberOutgoingMessageType type,
    852                                               int16u indexOrDestination,
    853                                               EmberApsFrame *apsFrame)
    854          {
   \                     emberAfMaximumApsPayloadLength: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    855            EmberNodeId destination = EMBER_UNKNOWN_NODE_ID;
    856            int8u max = EMBER_AF_MAXIMUM_APS_PAYLOAD_LENGTH;
    857          
    858            if (apsFrame->options & EMBER_APS_OPTION_ENCRYPTION) {
   \   00000002   0x88D2             LDRH     R2,[R2, #+6]
   \   00000004   0x2452             MOVS     R4,#+82
   \   00000006   0xF64F 0x73FD      MOVW     R3,#+65533
   \   0000000A   0x0695             LSLS     R5,R2,#+26
   \   0000000C   0xBF48             IT       MI 
    859              max -= EMBER_AF_APS_ENCRYPTION_OVERHEAD;
   \   0000000E   0x2449             MOVMI    R4,#+73
    860            }
    861            if (apsFrame->options & EMBER_APS_OPTION_SOURCE_EUI64) {
   \   00000010   0x0555             LSLS     R5,R2,#+21
   \   00000012   0xBF44             ITT      MI 
    862              max -= EUI64_SIZE;
   \   00000014   0x3C08             SUBMI    R4,R4,#+8
   \   00000016   0xB2E4             UXTBMI   R4,R4
    863            }
    864            if (apsFrame->options & EMBER_APS_OPTION_DESTINATION_EUI64) {
   \   00000018   0x0515             LSLS     R5,R2,#+20
   \   0000001A   0xBF44             ITT      MI 
    865              max -= EUI64_SIZE;
   \   0000001C   0x3C08             SUBMI    R4,R4,#+8
   \   0000001E   0xB2E4             UXTBMI   R4,R4
    866            }
    867            if (apsFrame->options & EMBER_APS_OPTION_FRAGMENT) {
   \   00000020   0x0412             LSLS     R2,R2,#+16
   \   00000022   0xBF44             ITT      MI 
    868              max -= EMBER_AF_APS_FRAGMENTATION_OVERHEAD;
   \   00000024   0x1EA4             SUBMI    R4,R4,#+2
   \   00000026   0xB2E4             UXTBMI   R4,R4
    869            }
    870          
    871            switch (type) {
   \   00000028   0xB138             CBZ.N    R0,??emberAfMaximumApsPayloadLength_0
   \   0000002A   0x2802             CMP      R0,#+2
   \   0000002C   0xD00B             BEQ.N    ??emberAfMaximumApsPayloadLength_1
   \   0000002E   0xD306             BCC.N    ??emberAfMaximumApsPayloadLength_2
   \   00000030   0x2803             CMP      R0,#+3
   \   00000032   0xBF04             ITT      EQ 
    872            case EMBER_OUTGOING_DIRECT:
    873              destination = indexOrDestination;
    874              break;
    875            case EMBER_OUTGOING_VIA_ADDRESS_TABLE:
    876              destination = emberGetAddressTableRemoteNodeId(indexOrDestination);
    877              break;
    878            case EMBER_OUTGOING_VIA_BINDING:
    879              destination = emberGetBindingRemoteNodeId(indexOrDestination);
    880              break;
    881            case EMBER_OUTGOING_MULTICAST:
    882              // APS multicast messages include the two-byte group id and exclude the
    883              // one-byte destination endpoint, for a net loss of an extra byte.
    884              max--;
   \   00000034   0x1E64             SUBEQ    R4,R4,#+1
   \   00000036   0xB2E4             UXTBEQ   R4,R4
   \   00000038   0xE009             B.N      ??emberAfMaximumApsPayloadLength_3
   \                     ??emberAfMaximumApsPayloadLength_0: (+1)
   \   0000003A   0x460B             MOV      R3,R1
   \   0000003C   0xE007             B.N      ??emberAfMaximumApsPayloadLength_3
   \                     ??emberAfMaximumApsPayloadLength_2: (+1)
   \   0000003E   0xB2C8             UXTB     R0,R1
   \   00000040   0x.... 0x....      BL       emberGetAddressTableRemoteNodeId
   \   00000044   0xE002             B.N      ??emberAfMaximumApsPayloadLength_4
   \                     ??emberAfMaximumApsPayloadLength_1: (+1)
   \   00000046   0xB2C8             UXTB     R0,R1
   \   00000048   0x.... 0x....      BL       emberGetBindingRemoteNodeId
   \                     ??emberAfMaximumApsPayloadLength_4: (+1)
   \   0000004C   0x4603             MOV      R3,R0
    885              break;
    886            case EMBER_OUTGOING_BROADCAST:
    887              break;
    888            }
    889          
    890            max -= emberAfGetSourceRouteOverheadCallback(destination);
    891          
    892            return max;
   \                     ??emberAfMaximumApsPayloadLength_3: (+1)
   \   0000004E   0x4618             MOV      R0,R3
   \   00000050   0x.... 0x....      BL       emberAfGetSourceRouteOverheadCallback
   \   00000054   0x1A20             SUBS     R0,R4,R0
   \   00000056   0xB2C0             UXTB     R0,R0
   \   00000058   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    893          }
    894          

   \                                 In section .text, align 2, keep-with-next
    895          void emberAfCopyInt16u(int8u *data, int16u index, int16u x) {
    896            data[index]   = (int8u) ( ((x)    ) & 0xFF);
   \                     emberAfCopyInt16u: (+1)
   \   00000000   0x540A             STRB     R2,[R1, R0]
    897            data[index+1] = (int8u) ( ((x)>> 8) & 0xFF);
   \   00000002   0x1808             ADDS     R0,R1,R0
   \   00000004   0x0A12             LSRS     R2,R2,#+8
   \   00000006   0x7042             STRB     R2,[R0, #+1]
    898          }
   \   00000008   0x4770             BX       LR               ;; return
    899          

   \                                 In section .text, align 2, keep-with-next
    900          void emberAfCopyInt24u(int8u *data, int16u index, int32u x) {
    901            data[index]   = (int8u) ( ((x)    ) & 0xFF );
   \                     emberAfCopyInt24u: (+1)
   \   00000000   0x540A             STRB     R2,[R1, R0]
    902            data[index+1] = (int8u) ( ((x)>> 8) & 0xFF );
   \   00000002   0x1808             ADDS     R0,R1,R0
   \   00000004   0x0A11             LSRS     R1,R2,#+8
   \   00000006   0x7041             STRB     R1,[R0, #+1]
    903            data[index+2] = (int8u) ( ((x)>>16) & 0xFF );
   \   00000008   0x0C11             LSRS     R1,R2,#+16
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
    904          }
   \   0000000C   0x4770             BX       LR               ;; return
    905          

   \                                 In section .text, align 2, keep-with-next
    906          void emberAfCopyInt32u(int8u *data, int16u index, int32u x) {
    907            data[index]   = (int8u) ( ((x)    ) & 0xFF );
   \                     emberAfCopyInt32u: (+1)
   \   00000000   0x540A             STRB     R2,[R1, R0]
    908            data[index+1] = (int8u) ( ((x)>> 8) & 0xFF );
   \   00000002   0x1808             ADDS     R0,R1,R0
   \   00000004   0x0A11             LSRS     R1,R2,#+8
   \   00000006   0x7041             STRB     R1,[R0, #+1]
    909            data[index+2] = (int8u) ( ((x)>>16) & 0xFF );
   \   00000008   0x0C11             LSRS     R1,R2,#+16
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
    910            data[index+3] = (int8u) ( ((x)>>24) & 0xFF );
   \   0000000C   0x0E11             LSRS     R1,R2,#+24
   \   0000000E   0x70C1             STRB     R1,[R0, #+3]
    911          }
   \   00000010   0x4770             BX       LR               ;; return
    912          

   \                                 In section .text, align 2, keep-with-next
    913          void emberAfCopyString(int8u *dest, int8u *src, int8u size)
    914          {
   \                     emberAfCopyString: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x4616             MOV      R6,R2
    915            if ( src == NULL ) {
   \   00000008   0xBF0E             ITEE     EQ 
    916              dest[0] = 0; // Zero out the length of string
   \   0000000A   0x2000             MOVEQ    R0,#+0
    917            } else if (src[0] == 0xFF){
   \   0000000C   0x7828             LDRBNE   R0,[R5, #+0]
   \   0000000E   0x28FF             CMPNE    R0,#+255
   \   00000010   0xD101             BNE.N    ??emberAfCopyString_0
    918              dest[0] = src[0];
   \   00000012   0x7020             STRB     R0,[R4, #+0]
   \   00000014   0xBD70             POP      {R4-R6,PC}
    919            } else {
    920              int8u length = emberAfStringLength(src);
   \                     ??emberAfCopyString_0: (+1)
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       emberAfStringLength
    921              if (size < length) {
   \   0000001C   0x4286             CMP      R6,R0
   \   0000001E   0xBF88             IT       HI 
   \   00000020   0x4606             MOVHI    R6,R0
    922                length = size;
    923              }
    924              MEMMOVE(dest + 1, src + 1, length);
   \   00000022   0x4632             MOV      R2,R6
   \   00000024   0x1C69             ADDS     R1,R5,#+1
   \   00000026   0x1C60             ADDS     R0,R4,#+1
   \   00000028   0x.... 0x....      BL       halCommonMemMove
    925              dest[0] = length;
   \   0000002C   0x7026             STRB     R6,[R4, #+0]
    926            }
    927          }
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    928          

   \                                 In section .text, align 2, keep-with-next
    929          void emberAfCopyLongString(int8u *dest, int8u *src, int16u size)
    930          {
   \                     emberAfCopyLongString: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x4616             MOV      R6,R2
    931            if ( src == NULL ) {
   \   00000008   0xD103             BNE.N    ??emberAfCopyLongString_0
    932              dest[0] = dest[1] = 0; // Zero out the length of string
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x7060             STRB     R0,[R4, #+1]
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
   \   00000010   0xBD70             POP      {R4-R6,PC}
    933            } else if ((src[0] == 0xFF)
    934                       && (src[1] == 0xFF)){
   \                     ??emberAfCopyLongString_0: (+1)
   \   00000012   0x7828             LDRB     R0,[R5, #+0]
   \   00000014   0x28FF             CMP      R0,#+255
   \   00000016   0xBF02             ITTT     EQ 
   \   00000018   0x7868             LDRBEQ   R0,[R5, #+1]
   \   0000001A   0x28FF             CMPEQ    R0,#+255
    935              dest[0] = 0xFF;
   \   0000001C   0x7020             STRBEQ   R0,[R4, #+0]
    936              dest[1] = 0xFF;
   \   0000001E   0xD00C             BEQ.N    ??emberAfCopyLongString_1
    937            } else {
    938              int16u length = emberAfLongStringLength(src);
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       emberAfLongStringLength
    939              if (size < length) {
   \   00000026   0x4286             CMP      R6,R0
   \   00000028   0xBF88             IT       HI 
   \   0000002A   0x4606             MOVHI    R6,R0
    940                length = size;
    941              }
    942              MEMMOVE(dest + 2, src + 2, length);
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x1CA9             ADDS     R1,R5,#+2
   \   00000030   0x1CA0             ADDS     R0,R4,#+2
   \   00000032   0x.... 0x....      BL       halCommonMemMove
    943              dest[0] = LOW_BYTE(length);
   \   00000036   0x7026             STRB     R6,[R4, #+0]
    944              dest[1] = HIGH_BYTE(length);
   \   00000038   0x0A30             LSRS     R0,R6,#+8
   \                     ??emberAfCopyLongString_1: (+1)
   \   0000003A   0x7060             STRB     R0,[R4, #+1]
    945            }
    946          }
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    947          
    948          #if 0
    949          // Moving to time-util.c
    950          void emberAfCopyDate(int8u *data, int16u index, EmberAfDate *src)
    951          {
    952            data[index]   = src->year;
    953            data[index+1] = src->month;
    954            data[index+2] = src->dayOfMonth;
    955            data[index+3] = src->dayOfWeek;
    956          }
    957          #endif
    958          
    959          
    960          #if (BIGENDIAN_CPU)
    961            #define EM_BIG_ENDIAN TRUE
    962          #else
    963            #define EM_BIG_ENDIAN FALSE
    964          #endif
    965          
    966          // You can pass in val1 as NULL, which will assume that it is
    967          // pointing to an array of all zeroes. This is used so that
    968          // default value of NULL is treated as all zeroes.

   \                                 In section .text, align 2, keep-with-next
    969          int8s emberAfCompareValues(int8u* val1,
    970                                     int8u* val2,
    971                                     int8u len,
    972                                     boolean signedNumber)
    973          {
   \                     emberAfCompareValues: (+1)
   \   00000000   0xE92D 0x4178      PUSH     {R3-R6,R8,LR}
    974            int8u i, j, k;
    975            if (signedNumber){ // signed number comparison
   \   00000004   0x1E54             SUBS     R4,R2,#+1
   \   00000006   0x2B00             CMP      R3,#+0
   \   00000008   0xD038             BEQ.N    ??emberAfCompareValues_0
    976              if (len <= 4){ // only number with 32-bits or less is supported
   \   0000000A   0x2A05             CMP      R2,#+5
   \   0000000C   0xDA48             BGE.N    ??emberAfCompareValues_1
    977                int32s accum1 = 0x0;
    978                int32s accum2 = 0x0;
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0x2600             MOVS     R6,#+0
    979                int32s all1s = -1;
    980          
    981                for (i = 0; i < len; i++) {
   \   00000012   0x462B             MOV      R3,R5
   \   00000014   0xE00E             B.N      ??emberAfCompareValues_2
    982                  j = ( val1 == NULL
    983                      ? 0
    984                      : (EM_BIG_ENDIAN ? val1[i] : val1[(len-1)-i])
    985                      );
    986                  accum1 |= j << (8*(len-i));
   \                     ??emberAfCompareValues_3: (+1)
   \   00000016   0xEBA2 0x0803      SUB      R8,R2,R3
   \   0000001A   0xEA4F 0x08C8      LSL      R8,R8,#+3
   \   0000001E   0xFA0C 0xFC08      LSL      R12,R12,R8
   \   00000022   0xEA4C 0x0606      ORR      R6,R12,R6
    987          
    988                  k = (EM_BIG_ENDIAN
    989                      ? val2[i]
    990                      : val2[(len-1)-i]);
    991                  accum2 |= k << (8*(len-i));
   \   00000026   0xF81E 0xC001      LDRB     R12,[LR, R1]
   \   0000002A   0xFA0C 0xFC08      LSL      R12,R12,R8
   \   0000002E   0xEA4C 0x0505      ORR      R5,R12,R5
   \   00000032   0x1C5B             ADDS     R3,R3,#+1
   \                     ??emberAfCompareValues_2: (+1)
   \   00000034   0xB2DB             UXTB     R3,R3
   \   00000036   0x4293             CMP      R3,R2
   \   00000038   0xD208             BCS.N    ??emberAfCompareValues_4
   \   0000003A   0xEBA4 0x0E03      SUB      LR,R4,R3
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xBF0C             ITE      EQ 
   \   00000042   0xF04F 0x0C00      MOVEQ    R12,#+0
   \   00000046   0xF81E 0xC000      LDRBNE   R12,[LR, R0]
   \   0000004A   0xE7E4             B.N      ??emberAfCompareValues_3
    992                }
    993          
    994                // sign extending, no need for 32-bits numbers
    995                if (len < 4){
   \                     ??emberAfCompareValues_4: (+1)
   \   0000004C   0x2A04             CMP      R2,#+4
   \   0000004E   0xDA0F             BGE.N    ??emberAfCompareValues_5
    996                  if (accum1 & (1<<(8*len - 1))){ // check sign
   \   00000050   0x00D0             LSLS     R0,R2,#+3
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x00D2             LSLS     R2,R2,#+3
   \   00000056   0x1E40             SUBS     R0,R0,#+1
   \   00000058   0x4091             LSLS     R1,R1,R2
   \   0000005A   0x4249             RSBS     R1,R1,#+0
   \   0000005C   0xFA46 0xF200      ASR      R2,R6,R0
   \   00000060   0x07D2             LSLS     R2,R2,#+31
   \   00000062   0xBF48             IT       MI 
    997                    accum1 |= all1s - ((1 << (len*8)) - 1);
   \   00000064   0x430E             ORRMI    R6,R1,R6
    998                  }
    999                  if (accum2 & (1<<(8*len - 1))){ // check sign
   \   00000066   0xFA45 0xF000      ASR      R0,R5,R0
   \   0000006A   0x07C0             LSLS     R0,R0,#+31
   \   0000006C   0xBF48             IT       MI 
   1000                    accum2 |= all1s - ((1 << (len*8)) - 1);
   \   0000006E   0x430D             ORRMI    R5,R1,R5
   1001                  }
   1002                }
   1003          
   1004                if (accum1 > accum2) {
   \                     ??emberAfCompareValues_5: (+1)
   \   00000070   0x42B5             CMP      R5,R6
   \   00000072   0xDB0E             BLT.N    ??emberAfCompareValues_6
   1005                  return 1;
   1006                } else if (accum1 < accum2) {
   \   00000074   0x42AE             CMP      R6,R5
   \   00000076   0xDA13             BGE.N    ??emberAfCompareValues_1
   1007                  return -1;
   \   00000078   0xE00F             B.N      ??emberAfCompareValues_7
   1008                } else {
   1009                  return 0;
   1010                }
   1011              } else { // not supported
   1012                return 0;
   1013              }
   1014            } else { // regular unsigned number comparison
   1015              for (i = 0; i < len; i++) {
   \                     ??emberAfCompareValues_8: (+1)
   \   0000007A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??emberAfCompareValues_0: (+1)
   \   0000007C   0xB2DB             UXTB     R3,R3
   \   0000007E   0x4293             CMP      R3,R2
   \   00000080   0xD20E             BCS.N    ??emberAfCompareValues_1
   1016                j = ( val1 == NULL
   1017                    ? 0
   1018                    : (EM_BIG_ENDIAN ? val1[i] : val1[(len-1)-i])
   1019                    );
   \   00000082   0x1AE5             SUBS     R5,R4,R3
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xBF0C             ITE      EQ 
   \   00000088   0x2600             MOVEQ    R6,#+0
   \   0000008A   0x5C2E             LDRBNE   R6,[R5, R0]
   1020                k = (EM_BIG_ENDIAN
   1021                    ? val2[i]
   1022                    : val2[(len-1)-i]);
   \   0000008C   0x5C6D             LDRB     R5,[R5, R1]
   1023          
   1024                if (j > k) {
   \   0000008E   0x42B5             CMP      R5,R6
   \   00000090   0xDA01             BGE.N    ??emberAfCompareValues_9
   1025                  return 1;
   \                     ??emberAfCompareValues_6: (+1)
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0xE005             B.N      ??emberAfCompareValues_10
   1026                } else if (k > j) {
   \                     ??emberAfCompareValues_9: (+1)
   \   00000096   0x42AE             CMP      R6,R5
   \   00000098   0xDAEF             BGE.N    ??emberAfCompareValues_8
   1027                  return -1;
   \                     ??emberAfCompareValues_7: (+1)
   \   0000009A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000009E   0xE000             B.N      ??emberAfCompareValues_10
   1028                }
   1029              }
   1030              return 0;
   \                     ??emberAfCompareValues_1: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \                     ??emberAfCompareValues_10: (+1)
   \   000000A2   0xE8BD 0x8172      POP      {R1,R4-R6,R8,PC}  ;; return
   1031            }
   1032          }
   1033          
   1034          #if 0
   1035          // Moving to time-util.c
   1036          int8s emberAfCompareDates(EmberAfDate* date1, EmberAfDate* date2)
   1037          {
   1038            int32u val1 = emberAfEncodeDate(date1);
   1039            int32u val2 = emberAfEncodeDate(date2);
   1040            return (val1 == val2) ? 0 : ((val1 < val2) ? -1 : 1);
   1041          }
   1042          #endif
   1043          
   1044          // returns the type that the attribute is, either EMBER_AF_DATA_TYPE_ANALOG,
   1045          // EMBER_AF_DATA_TYPE_DISCRETE, or EMBER_AF_DATA_TYPE_NONE. This is based on table
   1046          // 2.15 from the ZCL spec 075123r02

   \                                 In section .text, align 2, keep-with-next
   1047          int8u emberAfGetAttributeAnalogOrDiscreteType(int8u dataType)
   1048          {
   1049            int8u index = 0;
   \                     emberAfGetAttributeAnalogOrDiscreteType: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      ADR.W    R2,emberAfAnalogDiscreteThresholds
   \   00000006   0xE001             B.N      ??emberAfGetAttributeAnalogOrDiscreteType_0
   1050          
   1051            while ( emberAfAnalogDiscreteThresholds[index] < dataType ) {
   1052              index += 2;
   \                     ??emberAfGetAttributeAnalogOrDiscreteType_1: (+1)
   \   00000008   0x1C89             ADDS     R1,R1,#+2
   \   0000000A   0xB2C9             UXTB     R1,R1
   1053            }
   \                     ??emberAfGetAttributeAnalogOrDiscreteType_0: (+1)
   \   0000000C   0x5C8B             LDRB     R3,[R1, R2]
   \   0000000E   0x4283             CMP      R3,R0
   \   00000010   0xD3FA             BCC.N    ??emberAfGetAttributeAnalogOrDiscreteType_1
   1054            return emberAfAnalogDiscreteThresholds[index+1];
   \   00000012   0x1888             ADDS     R0,R1,R2
   \   00000014   0x7840             LDRB     R0,[R0, #+1]
   \   00000016   0x4770             BX       LR               ;; return
   1055          }
   1056          
   1057          // Zigbee spec says types between signed 8 bit and signed 64 bit

   \                                 In section .text, align 2, keep-with-next
   1058          boolean emberAfIsTypeSigned(EmberAfAttributeType dataType) {
   1059            return (dataType >= ZCL_INT8S_ATTRIBUTE_TYPE &&
   1060              dataType <= ZCL_INT64S_ATTRIBUTE_TYPE);
   \                     emberAfIsTypeSigned: (+1)
   \   00000000   0x3828             SUBS     R0,R0,#+40
   \   00000002   0x2808             CMP      R0,#+8
   \   00000004   0x4180             SBCS     R0,R0,R0
   \   00000006   0x0FC0             LSRS     R0,R0,#+31
   \   00000008   0x4770             BX       LR               ;; return
   1061          }
   1062          

   \                                 In section .text, align 2, keep-with-next
   1063          EmberStatus emberAfEndpointEventControlSetInactive(EmberEventControl *controls,
   1064                                                             int8u endpoint)
   1065          {
   \                     emberAfEndpointEventControlSetInactive: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine1
   1066            int8u index = emberAfIndexFromEndpoint(endpoint);
   1067            if (index == 0xFF) {
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD101             BNE.N    ??emberAfEndpointEventControlSetInactive_0
   1068              return EMBER_INVALID_ENDPOINT;
   \   0000000A   0x20A3             MOVS     R0,#+163
   \   0000000C   0xBD10             POP      {R4,PC}
   1069            }
   1070            emberEventControlSetInactive(controls[index]);
   \                     ??emberAfEndpointEventControlSetInactive_0: (+1)
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0xF804 0x1030      STRB     R1,[R4, R0, LSL #+3]
   1071            return EMBER_SUCCESS;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   1072          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x4608             MOV      R0,R1
   \   00000004   0x.... 0x....      B.W      emberAfIndexFromEndpoint
   1073          

   \                                 In section .text, align 2, keep-with-next
   1074          boolean emberAfEndpointEventControlGetActive(EmberEventControl *controls,
   1075                                                       int8u endpoint)
   1076          {
   \                     emberAfEndpointEventControlGetActive: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine1
   1077            int8u index = emberAfIndexFromEndpoint(endpoint);
   1078            return (index != 0xFF && emberEventControlGetActive(controls[index]));
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD004             BEQ.N    ??emberAfEndpointEventControlGetActive_0
   \   0000000A   0xF814 0x0030      LDRB     R0,[R4, R0, LSL #+3]
   \   0000000E   0xB110             CBZ.N    R0,??emberAfEndpointEventControlGetActive_1
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xBD10             POP      {R4,PC}
   \                     ??emberAfEndpointEventControlGetActive_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??emberAfEndpointEventControlGetActive_1: (+1)
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   1079          }
   1080          

   \                                 In section .text, align 2, keep-with-next
   1081          EmberStatus emberAfEndpointEventControlSetActive(EmberEventControl *controls,
   1082                                                           int8u endpoint)
   1083          {
   \                     emberAfEndpointEventControlSetActive: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine1
   1084            int8u index = emberAfIndexFromEndpoint(endpoint);
   1085            if (index == 0xFF) {
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD101             BNE.N    ??emberAfEndpointEventControlSetActive_0
   1086              return EMBER_INVALID_ENDPOINT;
   \   0000000A   0x20A3             MOVS     R0,#+163
   \   0000000C   0xBD10             POP      {R4,PC}
   1087            }
   1088            emberEventControlSetActive(controls[index]);
   \                     ??emberAfEndpointEventControlSetActive_0: (+1)
   \   0000000E   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   00000012   0x.... 0x....      BL       emEventControlSetActive
   1089            return EMBER_SUCCESS;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1090          }
   1091          

   \                                 In section .text, align 2, keep-with-next
   1092          EmberStatus emberAfEndpointEventControlSetDelayMS(EmberEventControl *controls,
   1093                                                            int8u endpoint,
   1094                                                            int32u delayMs)
   1095          {
   \                     emberAfEndpointEventControlSetDelayMS: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine0
   1096            int8u index = emberAfIndexFromEndpoint(endpoint);
   1097            if (index == 0xFF) {
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD101             BNE.N    ??emberAfEndpointEventControlSetDelayMS_0
   1098              return EMBER_INVALID_ENDPOINT;
   \   0000000A   0x20A3             MOVS     R0,#+163
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
   1099            }
   1100            return emberAfEventControlSetDelayMS(&controls[index], delayMs);
   \                     ??emberAfEndpointEventControlSetDelayMS_0: (+1)
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   00000014   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000018   0x.... 0x....      B.W      emberAfEventControlSetDelayMS
   1101          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x4608             MOV      R0,R1
   \   00000004   0x4615             MOV      R5,R2
   \   00000006   0x.... 0x....      B.W      emberAfIndexFromEndpoint
   1102          

   \                                 In section .text, align 2, keep-with-next
   1103          EmberStatus emberAfEndpointEventControlSetDelayQS(EmberEventControl *controls,
   1104                                                            int8u endpoint,
   1105                                                            int32u delayQs)
   1106          {
   \                     emberAfEndpointEventControlSetDelayQS: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine0
   1107            int8u index = emberAfIndexFromEndpoint(endpoint);
   1108            if (index == 0xFF) {
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD101             BNE.N    ??emberAfEndpointEventControlSetDelayQS_0
   1109              return EMBER_INVALID_ENDPOINT;
   \   0000000A   0x20A3             MOVS     R0,#+163
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
   1110            }
   1111            return emberAfEventControlSetDelayQS(&controls[index], delayQs);
   \                     ??emberAfEndpointEventControlSetDelayQS_0: (+1)
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   00000014   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000018   0x.... 0x....      B.W      emberAfEventControlSetDelayQS
   1112          }
   1113          

   \                                 In section .text, align 2, keep-with-next
   1114          EmberStatus emberAfEndpointEventControlSetDelayMinutes(EmberEventControl *controls,
   1115                                                                 int8u endpoint,
   1116                                                                 int16u delayM)
   1117          {
   \                     emberAfEndpointEventControlSetDelayMinutes: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine0
   1118            int8u index = emberAfIndexFromEndpoint(endpoint);
   1119            if (index == 0xFF) {
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD101             BNE.N    ??emberAfEndpointEventControlSetDelayMinutes_0
   1120              return EMBER_INVALID_ENDPOINT;
   \   0000000A   0x20A3             MOVS     R0,#+163
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
   1121            }
   1122            return emberAfEventControlSetDelayMinutes(&controls[index], delayM);
   \                     ??emberAfEndpointEventControlSetDelayMinutes_0: (+1)
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0xEB04 0x00C0      ADD      R0,R4,R0, LSL #+3
   \   00000014   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000018   0x.... 0x....      B.W      emberAfEventControlSetDelayMinutes
   1123          }
   1124          

   \                                 In section .text, align 2, keep-with-next
   1125          boolean emberAfIsThisMyEui64(EmberEUI64 eui64)
   1126          {
   \                     emberAfIsThisMyEui64: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1127            EmberEUI64 myEui64;
   1128            emberAfGetEui64(myEui64);
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      BL       emberAfGetEui64
   1129            return (0 == MEMCOMPARE(eui64, myEui64, EUI64_SIZE)
   1130                    ? TRUE
   1131                    : FALSE);
   \   0000000A   0x2208             MOVS     R2,#+8
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       halCommonMemCompare
   \   00000014   0x1E40             SUBS     R0,R0,#+1
   \   00000016   0x4180             SBCS     R0,R0,R0
   \   00000018   0x0FC0             LSRS     R0,R0,#+31
   \   0000001A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1132          }
   1133          
   1134          #if EMBER_AF_PLUGIN_ADDRESS_TABLE_SIZE == 0
   1135          int8u emberAfAddAddressTableEntry(EmberEUI64 longId, EmberNodeId shortId)
   1136          {
   1137            return EMBER_NULL_ADDRESS_TABLE_INDEX;
   1138          }
   1139          
   1140          EmberStatus emberAfSetAddressTableEntry(int8u index,
   1141                                                  EmberEUI64 longId,
   1142                                                  EmberNodeId shortId)
   1143          {
   1144            return EMBER_ADDRESS_TABLE_INDEX_OUT_OF_RANGE;
   1145          }
   1146          
   1147          EmberStatus emberAfRemoveAddressTableEntry(int8u index)
   1148          {
   1149            return EMBER_ADDRESS_TABLE_INDEX_OUT_OF_RANGE;
   1150          }
   1151          
   1152          #else
   1153          

   \                                 In section .text, align 2, keep-with-next
   1154          int8u emberAfAddAddressTableEntry(EmberEUI64 longId, EmberNodeId shortId)
   1155          {
   \                     emberAfAddAddressTableEntry: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   1156            int8u i, index = EMBER_NULL_ADDRESS_TABLE_INDEX;
   \   00000008   0x24FF             MOVS     R4,#+255
   1157            for (i = 0; i < EMBER_AF_PLUGIN_ADDRESS_TABLE_SIZE; i++) {
   \   0000000A   0x2700             MOVS     R7,#+0
   1158              if (emberGetAddressTableRemoteNodeId(i)
   1159                  != EMBER_TABLE_ENTRY_UNUSED_NODE_ID) {
   \                     ??emberAfAddAddressTableEntry_0: (+1)
   \   0000000C   0x4638             MOV      R0,R7
   \   0000000E   0x.... 0x....      BL       emberGetAddressTableRemoteNodeId
   \   00000012   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD00B             BEQ.N    ??emberAfAddAddressTableEntry_1
   1160                EmberEUI64 eui64;
   1161                emberGetAddressTableRemoteEui64(i, eui64);
   \   0000001A   0xA900             ADD      R1,SP,#+0
   \   0000001C   0x4638             MOV      R0,R7
   \   0000001E   0x.... 0x....      BL       emberGetAddressTableRemoteEui64
   1162                if (MEMCOMPARE(longId, eui64, EUI64_SIZE) == 0) {
   \   00000022   0x2208             MOVS     R2,#+8
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       halCommonMemCompare
   \   0000002C   0xB920             CBNZ.N   R0,??emberAfAddAddressTableEntry_2
   1163                  index = i;
   \   0000002E   0x463C             MOV      R4,R7
   1164                  goto kickout;
   \   00000030   0xE00C             B.N      ??emberAfAddAddressTableEntry_3
   1165                }
   1166              } else if (index == EMBER_NULL_ADDRESS_TABLE_INDEX) {
   \                     ??emberAfAddAddressTableEntry_1: (+1)
   \   00000032   0x2CFF             CMP      R4,#+255
   \   00000034   0xBF08             IT       EQ 
   1167                index = i;
   \   00000036   0x463C             MOVEQ    R4,R7
   1168              }
   1169            }
   \                     ??emberAfAddAddressTableEntry_2: (+1)
   \   00000038   0x1C7F             ADDS     R7,R7,#+1
   \   0000003A   0xB2FF             UXTB     R7,R7
   \   0000003C   0x2F05             CMP      R7,#+5
   \   0000003E   0xDBE5             BLT.N    ??emberAfAddAddressTableEntry_0
   1170            if (index != EMBER_NULL_ADDRESS_TABLE_INDEX) {
   \   00000040   0x2CFF             CMP      R4,#+255
   \   00000042   0xD00F             BEQ.N    ??emberAfAddAddressTableEntry_4
   1171              emberSetAddressTableRemoteEui64(index, longId);
   \   00000044   0x4629             MOV      R1,R5
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       emberSetAddressTableRemoteEui64
   1172          kickout:
   1173              if (shortId != EMBER_UNKNOWN_NODE_ID) {
   \                     ??emberAfAddAddressTableEntry_3: (+1)
   \   0000004C   0xF64F 0x70FD      MOVW     R0,#+65533
   \   00000050   0x4286             CMP      R6,R0
   \   00000052   0xD003             BEQ.N    ??emberAfAddAddressTableEntry_5
   1174                emberSetAddressTableRemoteNodeId(index, shortId);
   \   00000054   0x4631             MOV      R1,R6
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       emberSetAddressTableRemoteNodeId
   1175              }
   1176              addressTableReferenceCounts[index]++;
   \                     ??emberAfAddAddressTableEntry_5: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable27_12
   \   0000005E   0x5C21             LDRB     R1,[R4, R0]
   \   00000060   0x1C49             ADDS     R1,R1,#+1
   \   00000062   0x5421             STRB     R1,[R4, R0]
   1177            }
   1178            return index;
   \                     ??emberAfAddAddressTableEntry_4: (+1)
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0xBDFE             POP      {R1-R7,PC}       ;; return
   1179          }
   1180          

   \                                 In section .text, align 2, keep-with-next
   1181          EmberStatus emberAfSetAddressTableEntry(int8u index,
   1182                                                  EmberEUI64 longId,
   1183                                                  EmberNodeId shortId)
   1184          {
   \                     emberAfSetAddressTableEntry: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   1185            EmberStatus status = EMBER_ADDRESS_TABLE_INDEX_OUT_OF_RANGE;
   \   00000004   0x266A             MOVS     R6,#+106
   \   00000006   0x4615             MOV      R5,R2
   1186            if (index < EMBER_AF_PLUGIN_ADDRESS_TABLE_SIZE) {
   \   00000008   0x2C05             CMP      R4,#+5
   \   0000000A   0xDA13             BGE.N    ??emberAfSetAddressTableEntry_0
   1187              if (addressTableReferenceCounts[index] == 0) {
   \   0000000C   0x....             LDR.N    R7,??DataTable27_12
   \   0000000E   0x5DE0             LDRB     R0,[R4, R7]
   \   00000010   0xB978             CBNZ.N   R0,??emberAfSetAddressTableEntry_1
   1188                status = emberSetAddressTableRemoteEui64(index, longId);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       emberSetAddressTableRemoteEui64
   \   00000018   0x0006             MOVS     R6,R0
   1189                if (status == EMBER_SUCCESS && shortId != EMBER_UNKNOWN_NODE_ID) {
   \   0000001A   0xD107             BNE.N    ??emberAfSetAddressTableEntry_2
   \   0000001C   0xF64F 0x70FD      MOVW     R0,#+65533
   \   00000020   0x4285             CMP      R5,R0
   \   00000022   0xD003             BEQ.N    ??emberAfSetAddressTableEntry_2
   1190                  emberSetAddressTableRemoteNodeId(index, shortId);
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       emberSetAddressTableRemoteNodeId
   1191                }
   1192                addressTableReferenceCounts[index] = 1;
   \                     ??emberAfSetAddressTableEntry_2: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x55E0             STRB     R0,[R4, R7]
   \   00000030   0xE000             B.N      ??emberAfSetAddressTableEntry_0
   1193              } else {
   1194                status = EMBER_ADDRESS_TABLE_ENTRY_IS_ACTIVE;
   \                     ??emberAfSetAddressTableEntry_1: (+1)
   \   00000032   0x2676             MOVS     R6,#+118
   1195              }
   1196            }
   1197            return status;
   \                     ??emberAfSetAddressTableEntry_0: (+1)
   \   00000034   0x4630             MOV      R0,R6
   \   00000036   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1198          }
   1199          

   \                                 In section .text, align 2, keep-with-next
   1200          EmberStatus emberAfRemoveAddressTableEntry(int8u index)
   1201          {
   \                     emberAfRemoveAddressTableEntry: (+1)
   \   00000000   0x4602             MOV      R2,R0
   1202            EmberStatus status = EMBER_ADDRESS_TABLE_INDEX_OUT_OF_RANGE;
   \   00000002   0x206A             MOVS     R0,#+106
   1203            if (index < EMBER_AF_PLUGIN_ADDRESS_TABLE_SIZE) {
   \   00000004   0x2A05             CMP      R2,#+5
   \   00000006   0xDB00             BLT.N    ??emberAfRemoveAddressTableEntry_0
   \   00000008   0x4770             BX       LR
   1204              if (0 < addressTableReferenceCounts[index]) {
   \                     ??emberAfRemoveAddressTableEntry_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x....             LDR.N    R0,??DataTable27_12
   \   0000000E   0x5C13             LDRB     R3,[R2, R0]
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xBF1F             ITTTT    NE 
   1205                addressTableReferenceCounts[index]--;
   \   00000014   0x1E5B             SUBNE    R3,R3,#+1
   \   00000016   0x5413             STRBNE   R3,[R2, R0]
   1206              }
   1207              if (addressTableReferenceCounts[index] == 0) {
   \   00000018   0xB2DB             UXTBNE   R3,R3
   \   0000001A   0x2B00             CMPNE    R3,#+0
   \   0000001C   0xD104             BNE.N    ??emberAfRemoveAddressTableEntry_1
   1208                emberSetAddressTableRemoteNodeId(index,
   1209                                                 EMBER_TABLE_ENTRY_UNUSED_NODE_ID);
   \   0000001E   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000022   0x4610             MOV      R0,R2
   \   00000024   0x.... 0x....      BL       emberSetAddressTableRemoteNodeId
   1210              }
   1211              status = EMBER_SUCCESS;
   \                     ??emberAfRemoveAddressTableEntry_1: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   1212            }
   1213            return status;
   \   0000002A   0xBD02             POP      {R1,PC}          ;; return
   1214          }
   1215          #endif
   1216          

   \                                 In section .text, align 2, keep-with-next
   1217          int8u emberAfAppendCharacters(int8u * zclString,
   1218                                        int8u zclStringMaxLen,
   1219                                        const int8u * appendingChars,
   1220                                        int8u appendingCharsLen){
   \                     emberAfAppendCharacters: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461D             MOV      R5,R3
   1221            int8u freeChars;
   1222            int8u curLen;
   1223            int8u charsToWrite;
   1224          
   1225            if ((zclString == NULL)
   1226                || (zclStringMaxLen == 0)
   1227                || (appendingChars == NULL)
   1228                || (appendingCharsLen == 0)){
   \   0000000C   0xBF18             IT       NE 
   \   0000000E   0x2E00             CMPNE    R6,#+0
   \   00000010   0xD00C             BEQ.N    ??emberAfAppendCharacters_0
   \   00000012   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000016   0xBF18             IT       NE 
   \   00000018   0x2D00             CMPNE    R5,#+0
   \   0000001A   0xD007             BEQ.N    ??emberAfAppendCharacters_0
   1229              return 0;
   1230            }
   1231          
   1232            curLen = emberAfStringLength(zclString);
   \   0000001C   0x.... 0x....      BL       emberAfStringLength
   \   00000020   0x4607             MOV      R7,R0
   1233          
   1234            if ((zclString[0] == 0xFF)
   1235                || (curLen >= zclStringMaxLen)){
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x28FF             CMP      R0,#+255
   \   00000026   0xD001             BEQ.N    ??emberAfAppendCharacters_0
   \   00000028   0x42B7             CMP      R7,R6
   \   0000002A   0xDB01             BLT.N    ??emberAfAppendCharacters_1
   1236              return 0;
   \                     ??emberAfAppendCharacters_0: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE00D             B.N      ??emberAfAppendCharacters_2
   1237            }
   1238          
   1239            freeChars = zclStringMaxLen - curLen;
   \                     ??emberAfAppendCharacters_1: (+1)
   \   00000030   0x1BF0             SUBS     R0,R6,R7
   1240            charsToWrite = (freeChars > appendingCharsLen) ? appendingCharsLen: freeChars;
   \   00000032   0xB2C0             UXTB     R0,R0
   \   00000034   0x4285             CMP      R5,R0
   \   00000036   0xBF88             IT       HI 
   \   00000038   0x4605             MOVHI    R5,R0
   1241          
   1242            MEMCOPY(&zclString[1 + curLen], // 1 is to account for zcl's length byte
   1243                    appendingChars,
   1244                    charsToWrite);
   \   0000003A   0x1938             ADDS     R0,R7,R4
   \   0000003C   0x462A             MOV      R2,R5
   \   0000003E   0x4641             MOV      R1,R8
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0x.... 0x....      BL       halCommonMemMove
   1245            zclString[0] = curLen + charsToWrite;
   \   00000046   0x19E8             ADDS     R0,R5,R7
   \   00000048   0x7020             STRB     R0,[R4, #+0]
   1246            return charsToWrite;
   \   0000004A   0x4628             MOV      R0,R5
   \                     ??emberAfAppendCharacters_2: (+1)
   \   0000004C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1247          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x........         DC32     ??lastBlinkTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x........         DC32     afDeviceEnabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \   00000000   0x........         DC32     emberAfResponseApsFrame

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \   00000000   0x........         DC32     afNoSecurityForDefaultResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_4:
   \   00000000   0x........         DC32     emberAfResponseDestination

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_5:
   \   00000000   0x........         DC32     appResponseLength

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_6:
   \   00000000   0x........         DC32     appResponseData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_7:
   \   00000000   0x........         DC32     emberAfPrintActiveArea

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_8:
   \   00000000   0x........         DC32     emAfEndpoints

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_9:
   \   00000000   0x........         DC32     emberAfIncomingZclSequenceNumber

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_10:
   \   00000000   0x........         DC32     emberAfSequenceNumber

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_11:
   \   00000000   0x........         DC32     emAfTestApsSecurityOverride

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_12:
   \   00000000   0x........         DC32     addressTableReferenceCounts

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "(Unknown clus. [0x%2x])">`:
   \   00000000   0x28 0x55          DC8 "(Unknown clus. [0x%2x])"
   \              0x6E 0x6B    
   \              0x6E 0x6F    
   \              0x77 0x6E    
   \              0x20 0x63    
   \              0x6C 0x75    
   \              0x73 0x2E    
   \              0x20 0x5B    
   \              0x30 0x78    
   \              0x25 0x32    
   \              0x78 0x5D    
   \              0x29 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "(%p)">`:
   \   00000000   0x28 0x25          DC8 "(%p)"
   \              0x70 0x29    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Basic">`:
   \   00000000   0x42 0x61          DC8 "Basic"
   \              0x73 0x69    
   \              0x63 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Identify">`:
   \   00000000   0x49 0x64          DC8 "Identify"
   \              0x65 0x6E    
   \              0x74 0x69    
   \              0x66 0x79    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Groups">`:
   \   00000000   0x47 0x72          DC8 "Groups"
   \              0x6F 0x75    
   \              0x70 0x73    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Scenes">`:
   \   00000000   0x53 0x63          DC8 "Scenes"
   \              0x65 0x6E    
   \              0x65 0x73    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "On/off">`:
   \   00000000   0x4F 0x6E          DC8 "On/off"
   \              0x2F 0x6F    
   \              0x66 0x66    
   \              0x00         
   \   00000007   0x00               DC8 0
   1248          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   dispatchZclMessage
         8   -> emAfProcessClusterSpecificCommand
         0   -> emAfProcessGlobalCommand
         8   -> emberAfGroupsClusterEndpointInGroupCallback
         8   -> emberAfIndexFromEndpoint
      32   emberAfAddAddressTableEntry
        32   -> emberGetAddressTableRemoteEui64
        32   -> emberGetAddressTableRemoteNodeId
        32   -> emberSetAddressTableRemoteEui64
        32   -> emberSetAddressTableRemoteNodeId
        32   -> halCommonMemCompare
      24   emberAfAppendCharacters
        24   -> emberAfStringLength
        24   -> halCommonMemMove
      24   emberAfCompareValues
       0   emberAfCopyInt16u
       0   emberAfCopyInt24u
       0   emberAfCopyInt32u
      16   emberAfCopyLongString
        16   -> emberAfLongStringLength
        16   -> halCommonMemMove
      16   emberAfCopyString
        16   -> emberAfStringLength
        16   -> halCommonMemMove
      16   emberAfDecodeAndPrintCluster
        16   -> emberAfFindClusterNameIndex
         0   -> emberAfFlush
        16   -> emberAfPrint
      16   emberAfDetermineIfLinkSecurityIsRequired
        16   -> emberAfClusterSecurityCustomCallback
       8   emberAfEndpointEventControlGetActive
         8   -> emberAfIndexFromEndpoint
       8   emberAfEndpointEventControlSetActive
         8   -> emEventControlSetActive
         8   -> emberAfIndexFromEndpoint
      16   emberAfEndpointEventControlSetDelayMS
         0   -> emberAfEventControlSetDelayMS
        16   -> emberAfIndexFromEndpoint
      16   emberAfEndpointEventControlSetDelayMinutes
         0   -> emberAfEventControlSetDelayMinutes
        16   -> emberAfIndexFromEndpoint
      16   emberAfEndpointEventControlSetDelayQS
         0   -> emberAfEventControlSetDelayQS
        16   -> emberAfIndexFromEndpoint
       8   emberAfEndpointEventControlSetInactive
         8   -> emberAfIndexFromEndpoint
       8   emberAfFindClusterNameIndex
       0   emberAfGetAttributeAnalogOrDiscreteType
      16   emberAfGetDifference
       0   emberAfGetLastSequenceNumber
       8   emberAfInit
         0   -> emAfCallInits
         8   -> emAfInitEvents
         8   -> emberAfEndpointCount
         8   -> emberAfInitializeAttributes
         8   -> emberAfPluginAddressTableInitCallback
         8   -> emberAfPluginCountersInitCallback
         8   -> emberAfPluginNetworkFindInitCallback
         8   -> emberAfPluginReportingInitCallback
         8   -> emberAfPopNetworkIndex
         8   -> emberAfPushNetworkIndex
         8   -> emberAfSetExternalBuffer
         8   -> halCommonMemSet
       8   emberAfIsDeviceEnabled
         8   -> emberAfIndexFromEndpoint
      16   emberAfIsDeviceIdentifying
        16   -> emberAfReadServerAttribute
      16   emberAfIsThisMyEui64
        16   -> emberAfGetEui64
        16   -> halCommonMemCompare
       0   emberAfIsTypeSigned
      16   emberAfMaximumApsPayloadLength
        16   -> emberAfGetSourceRouteOverheadCallback
        16   -> emberGetAddressTableRemoteNodeId
        16   -> emberGetBindingRemoteNodeId
       0   emberAfNextSequence
      64   emberAfProcessMessage
        64   -> dispatchZclMessage
        64   -> emberAfClearResponseData
        64   -> emberAfDetermineIfLinkSecurityIsRequired
        64   -> emberAfEndpointCount
        64   -> emberAfEndpointFromIndex
        64   -> emberAfEndpointIndexIsEnabled
        64   -> emberAfPreCommandReceivedCallback
        64   -> emberAfProcessMessageIntoZclCmd
        64   -> emberAfSendDefaultResponse
        64   -> halCommonMemSet
        64   -> prepareForResponse
      16   emberAfProcessMessageIntoZclCmd
        16   -> emberAfGetInt16u
        16   -> emberGetCurrentNetwork
       8   emberAfRemoveAddressTableEntry
         8   -> emberSetAddressTableRemoteNodeId
       0   emberAfSendDefaultResponse
         0   -> emberAfSendDefaultResponseWithCallback
      16   emberAfSendDefaultResponseWithCallback
        16   -> emberAfPutInt16uInResp
        16   -> emberAfPutInt8uInResp
         0   -> emberAfSendResponseWithCallback
        16   -> prepareForResponse
       0   emberAfSendImmediateDefaultResponse
         0   -> emberAfSendImmediateDefaultResponseWithCallback
       0   emberAfSendImmediateDefaultResponseWithCallback
         0   -> emberAfSendDefaultResponseWithCallback
       0   emberAfSendResponse
         0   -> emberAfSendResponseWithCallback
      24   emberAfSendResponseWithCallback
        24   -> emberAfInterpanSendMessageCallback
        24   -> emberAfSendBroadcastWithCallback
        24   -> emberAfSendUnicastWithCallback
      24   emberAfSetAddressTableEntry
        24   -> emberSetAddressTableRemoteEui64
        24   -> emberSetAddressTableRemoteNodeId
       8   emberAfSetDeviceEnabled
         8   -> emberAfIndexFromEndpoint
       0   emberAfSetNoReplyForNextMessage
       8   emberAfStackDown
         8   -> emberAfClearReportTableCallback
         8   -> emberAfRegistrationAbortCallback
         0   -> emberAfTrustCenterKeepaliveAbortCallback
         8   -> emberNetworkState
         8   -> emberStackIsPerformingRejoin
      16   emberAfTick
        16   -- Indirect call
        16   -> emAfGetCryptoStatus
         0   -> emberAfPluginIdleSleepTickCallback
       8   platformTick
         8   -> emberAfCheckForSleepCallback
         8   -> emberAfSchedulePollEventCallback
         8   -> halCommonGetInt16uMillisecondTick
       8   prepareForResponse
         8   -> halCommonMemMove


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "(%p)">
      24  ?<Constant "(Unknown clus. [0x%2x])">
       8  ?<Constant "Basic">
       8  ?<Constant "Groups">
      12  ?<Constant "Identify">
       8  ?<Constant "On/off">
       8  ?<Constant "Scenes">
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_10
       4  ??DataTable27_11
       4  ??DataTable27_12
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       4  ??DataTable27_7
       4  ??DataTable27_8
       4  ??DataTable27_9
      10  ?Subroutine0
       8  ?Subroutine1
       8  addressTableReferenceCounts
      12  afDeviceEnabled
      32  afNoSecurityForDefaultResponse
          emberAfResponseType
          interpanResponseHeader
          emAfCurrentCommand
     104  dispatchZclMessage
       1  emAfDeviceIsPerformingKeyEstablishment
       1  emAfTestApsSecurityOverride
     104  emberAfAddAddressTableEntry
      20  emberAfAnalogDiscreteThresholds
      80  emberAfAppendCharacters
     166  emberAfCompareValues
      10  emberAfCopyInt16u
      14  emberAfCopyInt24u
      18  emberAfCopyInt32u
      62  emberAfCopyLongString
      48  emberAfCopyString
      60  emberAfDecodeAndPrintCluster
      56  emberAfDetermineIfLinkSecurityIsRequired
      24  emberAfEndpointEventControlGetActive
      26  emberAfEndpointEventControlSetActive
      28  emberAfEndpointEventControlSetDelayMS
      28  emberAfEndpointEventControlSetDelayMinutes
      28  emberAfEndpointEventControlSetDelayQS
      24  emberAfEndpointEventControlSetInactive
      38  emberAfFindClusterNameIndex
      24  emberAfGetAttributeAnalogOrDiscreteType
      48  emberAfGetDifference
      12  emberAfGetLastSequenceNumber
       2  emberAfIncomingZclSequenceNumber
          emberAfApsRetryOverride
      80  emberAfInit
      26  emberAfIsDeviceEnabled
      36  emberAfIsDeviceIdentifying
      28  emberAfIsThisMyEui64
      10  emberAfIsTypeSigned
      90  emberAfMaximumApsPayloadLength
      16  emberAfNextSequence
     248  emberAfProcessMessage
     122  emberAfProcessMessageIntoZclCmd
      44  emberAfRemoveAddressTableEntry
       4  emberAfSendDefaultResponse
     124  emberAfSendDefaultResponseWithCallback
       4  emberAfSendImmediateDefaultResponse
      12  emberAfSendImmediateDefaultResponseWithCallback
       4  emberAfSendResponse
     142  emberAfSendResponseWithCallback
       1  emberAfSequenceNumber
      56  emberAfSetAddressTableEntry
      24  emberAfSetDeviceEnabled
      22  emberAfSetNoReplyForNextMessage
      30  emberAfStackDown
      42  emberAfTick
      12  internalTickFunctions
       2  lastBlinkTime
      32  platformTick
     108  prepareForResponse
      48  zclClusterNames

 
    55 bytes in section .bss
     4 bytes in section .data
    44 bytes in section .rodata
 2 488 bytes in section .text
 
 2 488 bytes of CODE  memory
    44 bytes of CONST memory
    59 bytes of DATA  memory

Errors: none
Warnings: none

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        18/Apr/2016  12:59:11
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\attribute-storage.c
#    Command line =  
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\attribute-storage.c"
#        -D SWITCH_4_BUTTON -D NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D
#        CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"attribute-storage.c\"" -lC "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\4
#        nut\List\" --diag_suppress Pa050 -o "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\4
#        nut\Obj\" --debug --endian=little --cpu=Cortex-M3
#        --no_path_in_file_macros --separate_cluster_for_initialized_variables
#        -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        "D:\Work Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\"
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\4
#        nut\List\attribute-storage.lst
#    Object file  =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\4
#        nut\Obj\attribute-storage.o
#
###############################################################################

D:\Work Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\framework\util\attribute-storage.c
      1          // *******************************************************************
      2          // * attribute-storage.c
      3          // *
      4          // * Contains the per-endpoint configuration of attribute tables.
      5          // *
      6          // * Copyright 2013 Silicon Laboratories, Inc.                              *80*
      7          // *******************************************************************
      8          
      9          #include "app/framework/include/af.h"
     10          #include "attribute-storage.h"
     11          #include "common.h"
     12          
     13          //------------------------------------------------------------------------------
     14          // Globals
     15          // This is not declared CONST in order to handle dynamic endpoint information
     16          // retrieved from tokens.

   \                                 In section .bss, align 4
     17          EmberAfDefinedEndpoint emAfEndpoints[MAX_ENDPOINT_COUNT];
   \                     emAfEndpoints:
   \   00000000                      DS8 144
     18          
     19          #if ( ATTRIBUTE_MAX_SIZE == 0 )
     20          #define ACTUAL_ATTRIBUTE_SIZE 1
     21          #else
     22          #define ACTUAL_ATTRIBUTE_SIZE ATTRIBUTE_MAX_SIZE
     23          #endif
     24          

   \                                 In section .bss, align 4
     25          int8u attributeData[ACTUAL_ATTRIBUTE_SIZE];
     26          
     27          #if (!defined(ATTRIBUTE_SINGLETONS_SIZE)) \
     28            || (ATTRIBUTE_SINGLETONS_SIZE == 0)
     29          #define ACTUAL_SINGLETONS_SIZE 1
     30          #else
     31          #define ACTUAL_SINGLETONS_SIZE ATTRIBUTE_SINGLETONS_SIZE
     32          #endif
     33          int8u singletonAttributeData[ACTUAL_SINGLETONS_SIZE];
     34          
     35          int8u emberEndpointCount = 0;
   \                     emberEndpointCount:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \                     attributeData:
   \   00000004                      DS8 60
   \                     singletonAttributeData:
   \   00000040                      DS8 88
     36          
     37          // If we have attributes that are more than 2 bytes, then
     38          // we need this data block for the defaults
     39          #ifdef GENERATED_DEFAULTS

   \                                 In section .rodata, align 4, keep-with-next
     40          PGM int8u generatedDefaults[]               = GENERATED_DEFAULTS;
   \                     generatedDefaults:
   \   00000000   0x08 0x4C          DC8 8, 76, 117, 109, 105, 32, 82, 38, 68, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x75 0x6D    
   \              0x69 0x20    
   \              0x52 0x26    
   \              0x44 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000013   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 76, 77, 45, 83, 90, 52
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x06 0x4C    
   \              0x4D 0x2D    
   \              0x53 0x5A    
   \              0x34         
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000003F   0x00 0x00          DC8 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00         
     41          #endif // GENERATED_DEFAULTS
     42          
     43          #ifdef GENERATED_MIN_MAX_DEFAULTS
     44          PGM EmberAfAttributeMinMaxValue minMaxDefaults[]          = GENERATED_MIN_MAX_DEFAULTS;
     45          #endif //GENERATED_MIN_MAX_DEFAULTS
     46          
     47          #ifdef GENERATED_FUNCTION_ARRAYS

   \                                 In section .rodata, align 4, keep-with-next
     48          GENERATED_FUNCTION_ARRAYS
   \                     emberAfFuncArrayIdentifyClusterServer:
   \   00000000   0x........         DC32 emberAfIdentifyClusterServerInitCallback
   \   00000004   0x........         DC32 emberAfIdentifyClusterServerAttributeChangedCallback

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute void (*const emberAfFuncArrayGroupsClusterServer[1])(void)
   \                     emberAfFuncArrayGroupsClusterServer:
   \   00000000   0x........         DC32 emberAfGroupsClusterServerInitCallback

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute void (*const emberAfFuncArrayScenesClusterServer[1])(void)
   \                     emberAfFuncArrayScenesClusterServer:
   \   00000000   0x........         DC32 emberAfScenesClusterServerInitCallback
     49          #endif
     50          
     51          #ifdef EMBER_AF_SUPPORT_COMMAND_DISCOVERY

   \                                 In section .text, align 4, keep-with-next
     52          PGM EmberAfCommandMetadata generatedCommands[] = GENERATED_COMMANDS;
   \                     generatedCommands:
   \   00000000   0x0000             DC16 0
   \   00000002   0x00 0x09          DC8 0, 9
   \   00000004   0x0003             DC16 3
   \   00000006   0x00 0x09          DC8 0, 9
   \   00000008   0x0003             DC16 3
   \   0000000A   0x00 0x06          DC8 0, 6
   \   0000000C   0x0003             DC16 3
   \   0000000E   0x01 0x09          DC8 1, 9
   \   00000010   0x0004             DC16 4
   \   00000012   0x00 0x02          DC8 0, 2
   \   00000014   0x0004             DC16 4
   \   00000016   0x00 0x08          DC8 0, 8
   \   00000018   0x0004             DC16 4
   \   0000001A   0x01 0x02          DC8 1, 2
   \   0000001C   0x0004             DC16 4
   \   0000001E   0x01 0x08          DC8 1, 8
   \   00000020   0x0004             DC16 4
   \   00000022   0x02 0x02          DC8 2, 2
   \   00000024   0x0004             DC16 4
   \   00000026   0x02 0x08          DC8 2, 8
   \   00000028   0x0004             DC16 4
   \   0000002A   0x03 0x02          DC8 3, 2
   \   0000002C   0x0004             DC16 4
   \   0000002E   0x03 0x08          DC8 3, 8
   \   00000030   0x0004             DC16 4
   \   00000032   0x04 0x08          DC8 4, 8
   \   00000034   0x0004             DC16 4
   \   00000036   0x05 0x08          DC8 5, 8
   \   00000038   0x0005             DC16 5
   \   0000003A   0x00 0x02          DC8 0, 2
   \   0000003C   0x0005             DC16 5
   \   0000003E   0x00 0x08          DC8 0, 8
   \   00000040   0x0005             DC16 5
   \   00000042   0x01 0x02          DC8 1, 2
   \   00000044   0x0005             DC16 5
   \   00000046   0x01 0x08          DC8 1, 8
   \   00000048   0x0005             DC16 5
   \   0000004A   0x02 0x02          DC8 2, 2
   \   0000004C   0x0005             DC16 5
   \   0000004E   0x02 0x08          DC8 2, 8
   \   00000050   0x0005             DC16 5
   \   00000052   0x03 0x02          DC8 3, 2
   \   00000054   0x0005             DC16 5
   \   00000056   0x03 0x08          DC8 3, 8
   \   00000058   0x0005             DC16 5
   \   0000005A   0x04 0x02          DC8 4, 2
   \   0000005C   0x0005             DC16 5
   \   0000005E   0x04 0x08          DC8 4, 8
   \   00000060   0x0005             DC16 5
   \   00000062   0x05 0x08          DC8 5, 8
   \   00000064   0x0005             DC16 5
   \   00000066   0x06 0x02          DC8 6, 2
   \   00000068   0x0005             DC16 5
   \   0000006A   0x06 0x08          DC8 6, 8
   \   0000006C   0x0006             DC16 6
   \   0000006E   0x00 0x09          DC8 0, 9
   \   00000070   0x0006             DC16 6
   \   00000072   0x01 0x09          DC8 1, 9
   \   00000074   0x0006             DC16 6
   \   00000076   0x02 0x09          DC8 2, 9
     53          #endif
     54          

   \                                 In section .text, align 4, keep-with-next
     55          PGM EmberAfAttributeMetadata generatedAttributes[] = GENERATED_ATTRIBUTES;
   \                     generatedAttributes:
   \   00000000   0x0000             DC16 0
   \   00000002   0x20 0x01          DC8 32, 1, 34, 0, 0, 0
   \              0x22 0x00    
   \              0x00 0x00    
   \   00000008   0x00000001         DC32 1H
   \   0000000C   0x0001             DC16 1
   \   0000000E   0x20 0x01          DC8 32, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \   00000014   0x00000001         DC32 1H
   \   00000018   0x0002             DC16 2
   \   0000001A   0x20 0x01          DC8 32, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \   00000020   0x00000000         DC32 0H
   \   00000024   0x0003             DC16 3
   \   00000026   0x20 0x01          DC8 32, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \   0000002C   0x00000001         DC32 1H
   \   00000030   0x0004             DC16 4
   \   00000032   0x42 0x21          DC8 66, 33, 34, 0, 0, 0
   \              0x22 0x00    
   \              0x00 0x00    
   \   00000038   0x........         DC32 generatedDefaults
   \   0000003C   0x0005             DC16 5
   \   0000003E   0x42 0x21          DC8 66, 33, 34, 0, 0, 0
   \              0x22 0x00    
   \              0x00 0x00    
   \   00000044   0x........         DC32 generatedDefaults + 21H
   \   00000048   0x0006             DC16 6
   \   0000004A   0x42 0x11          DC8 66, 17, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \   00000050   0x00000000         DC32 0H
   \   00000054   0x0007             DC16 7
   \   00000056   0x30 0x01          DC8 48, 1, 34, 0, 0, 0
   \              0x22 0x00    
   \              0x00 0x00    
   \   0000005C   0x00000001         DC32 1H
   \   00000060   0x0000             DC16 0
   \   00000062   0x21 0x02          DC8 33, 2, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \   00000068   0x00000000         DC32 0H
   \   0000006C   0x0001             DC16 1
   \   0000006E   0x18 0x01          DC8 24, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000074   0x00000000         DC32 0H
   \   00000078   0x0000             DC16 0
   \   0000007A   0x18 0x01          DC8 24, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000080   0x00000000         DC32 0H
   \   00000084   0x0000             DC16 0
   \   00000086   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000008C   0x00000000         DC32 0H
   \   00000090   0x0001             DC16 1
   \   00000092   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000098   0x00000000         DC32 0H
   \   0000009C   0x0002             DC16 2
   \   0000009E   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000A4   0x00000000         DC32 0H
   \   000000A8   0x0003             DC16 3
   \   000000AA   0x10 0x01          DC8 16, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000B0   0x00000000         DC32 0H
   \   000000B4   0x0004             DC16 4
   \   000000B6   0x18 0x01          DC8 24, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000BC   0x00000000         DC32 0H
   \   000000C0   0x0000             DC16 0
   \   000000C2   0x10 0x01          DC8 16, 1, 2, 0, 0, 0
   \              0x02 0x00    
   \              0x00 0x00    
   \   000000C8   0x00000000         DC32 0H

   \                                 In section .text, align 4, keep-with-next
     56          PGM EmberAfCluster generatedClusters[]          = GENERATED_CLUSTERS;
   \                     generatedClusters:
   \   00000000   0x0000             DC16 0
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x........         DC32 generatedAttributes
   \   00000008   0x0008 0x0000      DC16 8, 0
   \   0000000C   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \   00000010   0x00000000         DC32 0H
   \   00000014   0x0003             DC16 3
   \   00000016   0x00 0x00          DC8 0, 0
   \   00000018   0x........         DC32 generatedAttributes + 60H
   \   0000001C   0x0000 0x0000      DC16 0, 0
   \   00000020   0x80 0x00          DC8 128, 0, 0, 0
   \              0x00 0x00    
   \   00000024   0x00000000         DC32 0H
   \   00000028   0x0003             DC16 3
   \   0000002A   0x00 0x00          DC8 0, 0
   \   0000002C   0x........         DC32 generatedAttributes + 60H
   \   00000030   0x0002 0x0003      DC16 2, 3
   \   00000034   0x43 0x00          DC8 67, 0, 0, 0
   \              0x00 0x00    
   \   00000038   0x........         DC32 emberAfFuncArrayIdentifyClusterServer
   \   0000003C   0x0006             DC16 6
   \   0000003E   0x00 0x00          DC8 0, 0
   \   00000040   0x........         DC32 generatedAttributes + 0C0H
   \   00000044   0x0000 0x0000      DC16 0, 0
   \   00000048   0x80 0x00          DC8 128, 0, 0, 0
   \              0x00 0x00    
   \   0000004C   0x00000000         DC32 0H
   \   00000050   0x0000             DC16 0
   \   00000052   0x00 0x00          DC8 0, 0
   \   00000054   0x........         DC32 generatedAttributes
   \   00000058   0x0008 0x0000      DC16 8, 0
   \   0000005C   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \   00000060   0x00000000         DC32 0H
   \   00000064   0x0003             DC16 3
   \   00000066   0x00 0x00          DC8 0, 0
   \   00000068   0x........         DC32 generatedAttributes + 60H
   \   0000006C   0x0000 0x0000      DC16 0, 0
   \   00000070   0x80 0x00          DC8 128, 0, 0, 0
   \              0x00 0x00    
   \   00000074   0x00000000         DC32 0H
   \   00000078   0x0003             DC16 3
   \   0000007A   0x00 0x00          DC8 0, 0
   \   0000007C   0x........         DC32 generatedAttributes + 60H
   \   00000080   0x0002 0x0003      DC16 2, 3
   \   00000084   0x43 0x00          DC8 67, 0, 0, 0
   \              0x00 0x00    
   \   00000088   0x........         DC32 emberAfFuncArrayIdentifyClusterServer
   \   0000008C   0x0004             DC16 4
   \   0000008E   0x00 0x00          DC8 0, 0
   \   00000090   0x........         DC32 generatedAttributes + 78H
   \   00000094   0x0001 0x0001      DC16 1, 1
   \   00000098   0x41 0x00          DC8 65, 0, 0, 0
   \              0x00 0x00    
   \   0000009C   0x........         DC32 emberAfFuncArrayGroupsClusterServer
   \   000000A0   0x0005             DC16 5
   \   000000A2   0x00 0x00          DC8 0, 0
   \   000000A4   0x........         DC32 generatedAttributes + 84H
   \   000000A8   0x0005 0x0006      DC16 5, 6
   \   000000AC   0x41 0x00          DC8 65, 0, 0, 0
   \              0x00 0x00    
   \   000000B0   0x........         DC32 emberAfFuncArrayScenesClusterServer
   \   000000B4   0x0006             DC16 6
   \   000000B6   0x00 0x00          DC8 0, 0
   \   000000B8   0x........         DC32 generatedAttributes + 0C0H
   \   000000BC   0x0001 0x0001      DC16 1, 1
   \   000000C0   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \   000000C4   0x00000000         DC32 0H
   \   000000C8   0x0000             DC16 0
   \   000000CA   0x00 0x00          DC8 0, 0
   \   000000CC   0x........         DC32 generatedAttributes
   \   000000D0   0x0008 0x0000      DC16 8, 0
   \   000000D4   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \   000000D8   0x00000000         DC32 0H
   \   000000DC   0x0003             DC16 3
   \   000000DE   0x00 0x00          DC8 0, 0
   \   000000E0   0x........         DC32 generatedAttributes + 60H
   \   000000E4   0x0000 0x0000      DC16 0, 0
   \   000000E8   0x80 0x00          DC8 128, 0, 0, 0
   \              0x00 0x00    
   \   000000EC   0x00000000         DC32 0H
   \   000000F0   0x0003             DC16 3
   \   000000F2   0x00 0x00          DC8 0, 0
   \   000000F4   0x........         DC32 generatedAttributes + 60H
   \   000000F8   0x0002 0x0003      DC16 2, 3
   \   000000FC   0x43 0x00          DC8 67, 0, 0, 0
   \              0x00 0x00    
   \   00000100   0x........         DC32 emberAfFuncArrayIdentifyClusterServer
   \   00000104   0x0006             DC16 6
   \   00000106   0x00 0x00          DC8 0, 0
   \   00000108   0x........         DC32 generatedAttributes + 0C0H
   \   0000010C   0x0001 0x0001      DC16 1, 1
   \   00000110   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \   00000114   0x00000000         DC32 0H

   \                                 In section .text, align 4, keep-with-next
     57          PGM EmberAfEndpointType generatedEmberAfEndpointTypes[]   = GENERATED_ENDPOINT_TYPES;
   \                     generatedEmberAfEndpointTypes:
   \   00000000   0x........         DC32 generatedClusters
   \   00000004   0x04 0x00          DC8 4, 0
   \   00000006   0x0003             DC16 3
   \   00000008   0x........         DC32 generatedClusters + 50H
   \   0000000C   0x06 0x00          DC8 6, 0
   \   0000000E   0x000B             DC16 11
   \   00000010   0x........         DC32 generatedClusters + 0C8H
   \   00000014   0x04 0x00          DC8 4, 0
   \   00000016   0x0004             DC16 4

   \                                 In section .rodata, align 1, keep-with-next
     58          PGM EmAfNetworkType emAfNetworkTypes[] = EM_AF_GENERATED_NETWORK_TYPES;
   \                     emAfNetworkTypes:
   \   00000000   0x00               DC8 0

   \                                 In section .rodata, align 2, keep-with-next
     59          PGM EmAfZigbeeProNetwork emAfZigbeeProNetworks[] = EM_AF_GENERATED_ZIGBEE_PRO_NETWORKS;
   \                     emAfZigbeeProNetworks:
   \   00000000   0x02 0x01          DC8 2, 1
     60          

   \                                 In section .text, align 4, keep-with-next
     61          PGM EmberAfManufacturerCodeEntry clusterManufacturerCodes[] = GENERATED_CLUSTER_MANUFACTURER_CODES;
   \                     clusterManufacturerCodes:
   \   00000000   0x0000 0x0000      DC16 0, 0

   \                                 In section .rodata, align 2, keep-with-next
     62          PGM int16u clusterManufacturerCodeCount = GENERATED_CLUSTER_MANUFACTURER_CODE_COUNT;
   \                     clusterManufacturerCodeCount:
   \   00000000   0x0000             DC16 0

   \                                 In section .text, align 4, keep-with-next
     63          PGM EmberAfManufacturerCodeEntry attributeManufacturerCodes[] = GENERATED_ATTRIBUTE_MANUFACTURER_CODES;
   \                     attributeManufacturerCodes:
   \   00000000   0x0000 0x0000      DC16 0, 0

   \                                 In section .rodata, align 2, keep-with-next
     64          PGM int16u attributeManufacturerCodeCount = GENERATED_ATTRIBUTE_MANUFACTURER_CODE_COUNT;
   \                     attributeManufacturerCodeCount:
   \   00000000   0x0000             DC16 0
     65          
     66          #if !defined(EMBER_SCRIPTED_TEST)
     67          #define endpointNumber(x)        fixedEndpoints[x]
     68          #define endpointProfileId(x)     fixedProfileIds[x]
     69          #define endpointDeviceId(x)      fixedDeviceIds[x]
     70          #define endpointDeviceVersion(x) fixedDeviceVersions[x]
     71          #define endpointType(x)          (EmberAfEndpointType*)&(generatedEmberAfEndpointTypes[fixedEmberAfEndpointTypes[x]])
     72          #define endpointNetworkIndex(x)  fixedNetworks[x]
     73          #endif
     74          
     75          //------------------------------------------------------------------------------
     76          // Forward declarations
     77          
     78          // Returns endpoint index within a given cluster
     79          static int8u findClusterEndpointIndex(int8u endpoint, EmberAfClusterId clusterId, int8u mask);
     80          
     81          //------------------------------------------------------------------------------
     82          
     83          // Initial configuration

   \                                 In section .text, align 2, keep-with-next
     84          void emberAfEndpointConfigure(void) {
   \                     emberAfEndpointConfigure: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB096             SUB      SP,SP,#+88
     85            int8u ep;
     86          
     87          #if !defined(EMBER_SCRIPTED_TEST)
     88            int8u fixedEndpoints[] = FIXED_ENDPOINT_ARRAY;
   \   00000004   0x.... 0x....      ADR.W    R1,`?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 15}>`
   \   00000008   0xC91C             LDM      R1!,{R2-R4}
   \   0000000A   0xA809             ADD      R0,SP,#+36
     89            int16u fixedProfileIds[] = FIXED_PROFILE_IDS;
   \   0000000C   0x.... 0x....      ADR.W    R1,`?<Constant {260, 260, 260, 260, 260, 260, 260,`
   \   00000010   0xC01C             STM      R0!,{R2-R4}
   \   00000012   0xA811             ADD      R0,SP,#+68
   \   00000014   0x2214             MOVS     R2,#+20
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy4
     90            int16u fixedDeviceIds[] = FIXED_DEVICE_IDS;
   \   0000001A   0xA80C             ADD      R0,SP,#+48
   \   0000001C   0x.... 0x....      ADR.W    R1,`?<Constant {256, 259, 256, 259, 256, 259, 256,`
   \   00000020   0x2214             MOVS     R2,#+20
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy4
     91            int8u fixedDeviceVersions[] = FIXED_DEVICE_VERSIONS;
   \   00000026   0x.... 0x....      ADR.W    R1,`?<Constant {1, 1, 1, 1, 1, 1, 1, 1, 1}>`
   \   0000002A   0xC91C             LDM      R1!,{R2-R4}
   \   0000002C   0xA806             ADD      R0,SP,#+24
     92            int8u fixedEmberAfEndpointTypes[] = FIXED_ENDPOINT_TYPES;
   \   0000002E   0x.... 0x....      ADR.W    R1,`?<Constant {1, 0, 1, 0, 1, 0, 1, 0, 2}>`
   \   00000032   0xC01C             STM      R0!,{R2-R4}
   \   00000034   0xC91C             LDM      R1!,{R2-R4}
   \   00000036   0xA803             ADD      R0,SP,#+12
     93            int8u fixedNetworks[] = FIXED_NETWORKS;
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0xC01C             STM      R0!,{R2-R4}
   \   0000003C   0xA800             ADD      R0,SP,#+0
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x460B             MOV      R3,R1
   \   00000042   0xC00E             STM      R0!,{R1-R3}
     94          #endif
     95          
     96            emberEndpointCount = FIXED_ENDPOINT_COUNT;
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable38
   \   00000048   0x2009             MOVS     R0,#+9
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
     97            for ( ep = 0; ep < FIXED_ENDPOINT_COUNT; ep++ ) {
   \   0000004C   0x4610             MOV      R0,R2
   \   0000004E   0x.... 0x....      ADR.W    R1,generatedEmberAfEndpointTypes
   \   00000052   0x.... 0x....      LDR.W    R2,??DataTable38_1
     98              emAfEndpoints[ep].endpoint      = endpointNumber(ep);
   \                     ??emberAfEndpointConfigure_0: (+1)
   \   00000056   0xAC09             ADD      R4,SP,#+36
   \   00000058   0x0103             LSLS     R3,R0,#+4
   \   0000005A   0x5D04             LDRB     R4,[R0, R4]
   \   0000005C   0x549C             STRB     R4,[R3, R2]
     99              emAfEndpoints[ep].profileId     = endpointProfileId(ep);
   \   0000005E   0x189B             ADDS     R3,R3,R2
   \   00000060   0xAC11             ADD      R4,SP,#+68
   \   00000062   0xF834 0x4010      LDRH     R4,[R4, R0, LSL #+1]
   \   00000066   0x805C             STRH     R4,[R3, #+2]
    100              emAfEndpoints[ep].deviceId      = endpointDeviceId(ep);
   \   00000068   0xAC0C             ADD      R4,SP,#+48
   \   0000006A   0xF834 0x4010      LDRH     R4,[R4, R0, LSL #+1]
   \   0000006E   0x809C             STRH     R4,[R3, #+4]
    101              emAfEndpoints[ep].deviceVersion = endpointDeviceVersion(ep);
   \   00000070   0xAC06             ADD      R4,SP,#+24
   \   00000072   0x5D04             LDRB     R4,[R0, R4]
   \   00000074   0x719C             STRB     R4,[R3, #+6]
    102              emAfEndpoints[ep].endpointType  = endpointType(ep);
   \   00000076   0xAC03             ADD      R4,SP,#+12
   \   00000078   0x5D04             LDRB     R4,[R0, R4]
   \   0000007A   0xEB01 0x04C4      ADD      R4,R1,R4, LSL #+3
   \   0000007E   0x609C             STR      R4,[R3, #+8]
    103              emAfEndpoints[ep].networkIndex  = endpointNetworkIndex(ep);
   \   00000080   0xAC00             ADD      R4,SP,#+0
   \   00000082   0x5D04             LDRB     R4,[R0, R4]
   \   00000084   0x731C             STRB     R4,[R3, #+12]
    104              emAfEndpoints[ep].bitmask = EMBER_AF_ENDPOINT_ENABLED;
    105            }
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \   00000088   0x2401             MOVS     R4,#+1
   \   0000008A   0x735C             STRB     R4,[R3, #+13]
   \   0000008C   0x2809             CMP      R0,#+9
   \   0000008E   0xDBE2             BLT.N    ??emberAfEndpointConfigure_0
    106          }
   \   00000090   0xB016             ADD      SP,SP,#+88
   \   00000092   0xBD10             POP      {R4,PC}          ;; return
    107          

   \                                 In section .text, align 2, keep-with-next
    108          void emberAfSetEndpointCount(int8u dynamicEndpointCount)
    109          {
    110            emberEndpointCount = FIXED_ENDPOINT_COUNT + dynamicEndpointCount;
   \                     emberAfSetEndpointCount: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable38
   \   00000004   0x3009             ADDS     R0,R0,#+9
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    111          }
   \   00000008   0x4770             BX       LR               ;; return
    112          

   \                                 In section .text, align 2, keep-with-next
    113          int8u emberAfFixedEndpointCount(void)
    114          {
    115            return FIXED_ENDPOINT_COUNT;
   \                     emberAfFixedEndpointCount: (+1)
   \   00000000   0x2009             MOVS     R0,#+9
   \   00000002   0x4770             BX       LR               ;; return
    116          }
    117          

   \                                 In section .text, align 2, keep-with-next
    118          int8u emberAfEndpointCount(void)
    119          {
    120            return emberEndpointCount;
   \                     emberAfEndpointCount: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable38
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    121          }
    122          

   \                                 In section .text, align 2, keep-with-next
    123          boolean emberAfEndpointIndexIsEnabled(int8u index)
    124          {
    125            return (emAfEndpoints[index].bitmask & EMBER_AF_ENDPOINT_ENABLED);
   \                     emberAfEndpointIndexIsEnabled: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable38_1
   \   00000004   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   00000008   0x7B40             LDRB     R0,[R0, #+13]
   \   0000000A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000000E   0x4770             BX       LR               ;; return
    126          }
    127          
    128          // some data types (like strings) are sent OTA in human readable order
    129          // (how they are read) instead of little endian as the data types are.

   \                                 In section .text, align 2, keep-with-next
    130          boolean emberAfIsThisDataTypeAStringType(EmberAfAttributeType dataType)
    131          {
    132            return (dataType == ZCL_OCTET_STRING_ATTRIBUTE_TYPE
    133                    || dataType == ZCL_CHAR_STRING_ATTRIBUTE_TYPE
    134                    || dataType == ZCL_LONG_OCTET_STRING_ATTRIBUTE_TYPE
    135                    || dataType == ZCL_LONG_CHAR_STRING_ATTRIBUTE_TYPE);
   \                     emberAfIsThisDataTypeAStringType: (+1)
   \   00000000   0x2841             CMP      R0,#+65
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2842             CMPNE    R0,#+66
   \   00000006   0xD003             BEQ.N    ??emberAfIsThisDataTypeAStringType_0
   \   00000008   0x2843             CMP      R0,#+67
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2844             CMPNE    R0,#+68
   \   0000000E   0xD101             BNE.N    ??emberAfIsThisDataTypeAStringType_1
   \                     ??emberAfIsThisDataTypeAStringType_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
   \                     ??emberAfIsThisDataTypeAStringType_1: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
    136          }
    137          

   \                                 In section .text, align 2, keep-with-next
    138          boolean emberAfIsStringAttributeType(EmberAfAttributeType attributeType)
    139          {
    140            return (attributeType == ZCL_OCTET_STRING_ATTRIBUTE_TYPE
    141                    || attributeType == ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
   \                     emberAfIsStringAttributeType: (+1)
   \   00000000   0x2841             CMP      R0,#+65
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2842             CMPNE    R0,#+66
   \   00000006   0xD101             BNE.N    ??emberAfIsStringAttributeType_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??emberAfIsStringAttributeType_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    142          }
    143          

   \                                 In section .text, align 2, keep-with-next
    144          boolean emberAfIsLongStringAttributeType(EmberAfAttributeType attributeType)
    145          {
    146            return (attributeType == ZCL_LONG_OCTET_STRING_ATTRIBUTE_TYPE
    147                    || attributeType == ZCL_LONG_CHAR_STRING_ATTRIBUTE_TYPE);
   \                     emberAfIsLongStringAttributeType: (+1)
   \   00000000   0x2843             CMP      R0,#+67
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2844             CMPNE    R0,#+68
   \   00000006   0xD101             BNE.N    ??emberAfIsLongStringAttributeType_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??emberAfIsLongStringAttributeType_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    148          }
    149          
    150          // This function is used to call the per-cluster default response callback

   \                                 In section .text, align 2, keep-with-next
    151          void emberAfClusterDefaultResponseCallback(int8u endpoint,
    152                                                     EmberAfClusterId clusterId,
    153                                                     int8u commandId,
    154                                                     EmberAfStatus status,
    155                                                     int8u clientServerMask)
    156          {
   \                     emberAfClusterDefaultResponseCallback: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4615             MOV      R5,R2
    157            EmberAfCluster *cluster = emberAfFindCluster(endpoint,
    158                                                         clusterId,
    159                                                         clientServerMask);
   \   00000004   0x9A06             LDR      R2,[SP, #+24]
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x461E             MOV      R6,R3
   \   0000000A   0x.... 0x....      BL       emberAfFindCluster
    160            if (cluster != NULL) {
   \   0000000E   0xB160             CBZ.N    R0,??emberAfClusterDefaultResponseCallback_0
    161              EmberAfGenericClusterFunction f =
    162                emberAfFindClusterFunction(cluster,
    163                                           CLUSTER_MASK_DEFAULT_RESPONSE_FUNCTION);
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x.... 0x....      BL       emberAfFindClusterFunction
   \   00000016   0x0007             MOVS     R7,R0
    164              if (f != NULL) {
   \   00000018   0xD007             BEQ.N    ??emberAfClusterDefaultResponseCallback_0
    165                emberAfPushEndpointNetworkIndex(endpoint);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    166                ((EmberAfDefaultResponseFunction)f)(endpoint, commandId, status);
   \   00000020   0x4632             MOV      R2,R6
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x47B8             BLX      R7
    167                emberAfPopNetworkIndex();
   \   00000028   0x....             B.N      ?Subroutine0
    168              }
    169            }
    170          }
   \                     ??emberAfClusterDefaultResponseCallback_0: (+1)
   \   0000002A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000004   0x.... 0x....      B.W      emberAfPopNetworkIndex
    171          
    172          // This function is used to call the per-cluster message sent callback

   \                                 In section .text, align 2, keep-with-next
    173          void emberAfClusterMessageSentCallback(EmberOutgoingMessageType type,
    174                                                 int16u indexOrDestination,
    175                                                 EmberApsFrame *apsFrame,
    176                                                 int16u msgLen,
    177                                                 int8u *message,
    178                                                 EmberStatus status)
    179          {
   \                     emberAfClusterMessageSentCallback: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x461F             MOV      R7,R3
    180            if (apsFrame != NULL && message != NULL && msgLen != 0) {
   \   0000000E   0xBF1C             ITT      NE 
   \   00000010   0x9D0A             LDRNE    R5,[SP, #+40]
   \   00000012   0x2D00             CMPNE    R5,#+0
   \   00000014   0xD01E             BEQ.N    ??emberAfClusterMessageSentCallback_0
   \   00000016   0xB1EF             CBZ.N    R7,??emberAfClusterMessageSentCallback_0
    181              EmberAfCluster *cluster = emberAfFindCluster(apsFrame->sourceEndpoint,
    182                                                           apsFrame->clusterId,
    183                                                           (((message[0]
    184                                                              & ZCL_FRAME_CONTROL_DIRECTION_MASK)
    185                                                             == ZCL_FRAME_CONTROL_SERVER_TO_CLIENT)
    186                                                            ? CLUSTER_MASK_SERVER
    187                                                            : CLUSTER_MASK_CLIENT));
   \   00000018   0x7828             LDRB     R0,[R5, #+0]
   \   0000001A   0x0700             LSLS     R0,R0,#+28
   \   0000001C   0xBF4C             ITE      MI 
   \   0000001E   0x2240             MOVMI    R2,#+64
   \   00000020   0x2280             MOVPL    R2,#+128
   \   00000022   0x8871             LDRH     R1,[R6, #+2]
   \   00000024   0x7930             LDRB     R0,[R6, #+4]
   \   00000026   0x.... 0x....      BL       emberAfFindCluster
    188              if (cluster != NULL) {
   \   0000002A   0xB198             CBZ.N    R0,??emberAfClusterMessageSentCallback_0
    189                EmberAfGenericClusterFunction f =
    190                  emberAfFindClusterFunction(cluster,
    191                                             CLUSTER_MASK_MESSAGE_SENT_FUNCTION);
   \   0000002C   0x2108             MOVS     R1,#+8
   \   0000002E   0x.... 0x....      BL       emberAfFindClusterFunction
   \   00000032   0x4681             MOV      R9,R0
    192                if (f != NULL) {
   \   00000034   0xB170             CBZ.N    R0,??emberAfClusterMessageSentCallback_0
    193                  emberAfPushEndpointNetworkIndex(apsFrame->sourceEndpoint);
   \   00000036   0x7930             LDRB     R0,[R6, #+4]
   \   00000038   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    194                  ((EmberAfMessageSentFunction)f)(type,
    195                                                  indexOrDestination,
    196                                                  apsFrame,
    197                                                  msgLen,
    198                                                  message,
    199                                                  status);
   \   0000003C   0x980B             LDR      R0,[SP, #+44]
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   \   00000040   0x9500             STR      R5,[SP, #+0]
   \   00000042   0x463B             MOV      R3,R7
   \   00000044   0x4632             MOV      R2,R6
   \   00000046   0x4641             MOV      R1,R8
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x47C8             BLX      R9
    200                  emberAfPopNetworkIndex();
   \   0000004C   0xE8BD 0x43F7      POP      {R0-R2,R4-R9,LR}
   \   00000050   0x.... 0x....      B.W      emberAfPopNetworkIndex
    201                }
    202              }
    203            }
    204          }
   \                     ??emberAfClusterMessageSentCallback_0: (+1)
   \   00000054   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    205          
    206          // This function is used to call the per-cluster attribute changed callback

   \                                 In section .text, align 2, keep-with-next
    207          void emAfClusterAttributeChangedCallback(int8u endpoint,
    208                                                   EmberAfClusterId clusterId,
    209                                                   EmberAfAttributeId attributeId,
    210                                                   int8u clientServerMask,
    211                                                   int16u manufacturerCode)
    212          {
   \                     emAfClusterAttributeChangedCallback: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4616             MOV      R6,R2
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x461A             MOV      R2,R3
    213            EmberAfCluster *cluster = emberAfFindCluster(endpoint,
    214                                                         clusterId,
    215                                                         clientServerMask);
   \   00000008   0x.... 0x....      BL       emberAfFindCluster
    216            if (cluster != NULL) {
   \   0000000C   0xB1D0             CBZ.N    R0,??emAfClusterAttributeChangedCallback_0
   \   0000000E   0x9C06             LDR      R4,[SP, #+24]
    217              if (manufacturerCode == EMBER_AF_NULL_MANUFACTURER_CODE) {
   \   00000010   0xB95C             CBNZ.N   R4,??emAfClusterAttributeChangedCallback_1
    218                EmberAfGenericClusterFunction f =
    219                  emberAfFindClusterFunction(cluster,
    220                                             CLUSTER_MASK_ATTRIBUTE_CHANGED_FUNCTION);
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0x.... 0x....      BL       emberAfFindClusterFunction
   \   00000018   0x0004             MOVS     R4,R0
    221                if (f != NULL) {
   \   0000001A   0xD013             BEQ.N    ??emAfClusterAttributeChangedCallback_0
    222                  emberAfPushEndpointNetworkIndex(endpoint);
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    223                  ((EmberAfClusterAttributeChangedCallback)f)(endpoint, attributeId);
   \   00000022   0x4631             MOV      R1,R6
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x47A0             BLX      R4
    224                  emberAfPopNetworkIndex();
   \   00000028   0xE00B             B.N      ??emAfClusterAttributeChangedCallback_2
    225                }
    226              } else {
    227                EmberAfGenericClusterFunction f =
    228                  emberAfFindClusterFunction(cluster,
    229                                             CLUSTER_MASK_MANUFACTURER_SPECIFIC_ATTRIBUTE_CHANGED_FUNCTION);
   \                     ??emAfClusterAttributeChangedCallback_1: (+1)
   \   0000002A   0x2110             MOVS     R1,#+16
   \   0000002C   0x.... 0x....      BL       emberAfFindClusterFunction
   \   00000030   0x0007             MOVS     R7,R0
    230                if (f != NULL) {
   \   00000032   0xD007             BEQ.N    ??emAfClusterAttributeChangedCallback_0
    231                  emberAfPushEndpointNetworkIndex(endpoint);
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    232                  ((EmberAfManufacturerSpecificClusterAttributeChangedCallback)f)(endpoint,
    233                                                                                  attributeId,
    234                                                                                  manufacturerCode);
   \   0000003A   0x4622             MOV      R2,R4
   \   0000003C   0x4631             MOV      R1,R6
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x47B8             BLX      R7
    235                  emberAfPopNetworkIndex();
    236                }
    237              }
    238            }
   \                     ??emAfClusterAttributeChangedCallback_2: (+1)
   \   00000042   0x....             B.N      ?Subroutine0
    239          }
   \                     ??emAfClusterAttributeChangedCallback_0: (+1)
   \   00000044   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    240          
    241          // This function is used to call the per-cluster pre-attribute changed callback

   \                                 In section .text, align 2, keep-with-next
    242          EmberAfStatus emAfClusterPreAttributeChangedCallback(int8u endpoint,
    243                                                               EmberAfClusterId clusterId,
    244                                                               EmberAfAttributeId attributeId,
    245                                                               int8u clientServerMask,
    246                                                               int16u manufacturerCode,
    247                                                               EmberAfAttributeType attributeType,
    248                                                               int8u size,
    249                                                               int8u* value)
    250          {
   \                     emAfClusterPreAttributeChangedCallback: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4615             MOV      R5,R2
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x461A             MOV      R2,R3
    251            EmberAfCluster *cluster = emberAfFindCluster(endpoint,
    252                                                         clusterId,
    253                                                         clientServerMask);
   \   00000008   0x.... 0x....      BL       emberAfFindCluster
    254            if (cluster == NULL) {
   \   0000000C   0xB908             CBNZ.N   R0,??emAfClusterPreAttributeChangedCallback_0
    255              return EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   0000000E   0x2086             MOVS     R0,#+134
   \   00000010   0xBDF2             POP      {R1,R4-R7,PC}
    256            } else {
    257              EmberAfStatus status = EMBER_ZCL_STATUS_SUCCESS;
    258              if (manufacturerCode == EMBER_AF_NULL_MANUFACTURER_CODE) {
   \                     ??emAfClusterPreAttributeChangedCallback_0: (+1)
   \   00000012   0x9906             LDR      R1,[SP, #+24]
   \   00000014   0x2600             MOVS     R6,#+0
   \   00000016   0xB989             CBNZ.N   R1,??emAfClusterPreAttributeChangedCallback_1
    259                EmberAfGenericClusterFunction f =
    260                  emberAfFindClusterFunction(cluster,
    261                                             CLUSTER_MASK_PRE_ATTRIBUTE_CHANGED_FUNCTION);
   \   00000018   0x2120             MOVS     R1,#+32
   \   0000001A   0x.... 0x....      BL       emberAfFindClusterFunction
   \   0000001E   0x0007             MOVS     R7,R0
    262                if (f != NULL) {
   \   00000020   0xD00C             BEQ.N    ??emAfClusterPreAttributeChangedCallback_1
    263                  emberAfPushEndpointNetworkIndex(endpoint);
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    264                  status = ((EmberAfClusterPreAttributeChangedCallback)f)(endpoint,
    265                                                                          attributeId,
    266                                                                          attributeType,
    267                                                                          size,
    268                                                                          value);
   \   00000028   0x9809             LDR      R0,[SP, #+36]
   \   0000002A   0x9B08             LDR      R3,[SP, #+32]
   \   0000002C   0x9A07             LDR      R2,[SP, #+28]
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0x4629             MOV      R1,R5
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x47B8             BLX      R7
   \   00000036   0x4606             MOV      R6,R0
    269                  emberAfPopNetworkIndex();
   \   00000038   0x.... 0x....      BL       emberAfPopNetworkIndex
    270                }
    271              }
    272              return status;
   \                     ??emAfClusterPreAttributeChangedCallback_1: (+1)
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    273            }
    274          }
    275          

   \                                 In section .text, align 2, keep-with-next
    276          static void initializeEndpoint(EmberAfDefinedEndpoint* definedEndpoint)
    277          {
   \                     initializeEndpoint: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    278            int8u clusterIndex;
    279            EmberAfEndpointType* epType = definedEndpoint->endpointType;
   \   00000004   0x68A5             LDR      R5,[R4, #+8]
    280            emberAfPushEndpointNetworkIndex(definedEndpoint->endpoint);
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       emberAfPushEndpointNetworkIndex
    281            for ( clusterIndex = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0xE010             B.N      ??initializeEndpoint_0
    282                  clusterIndex < epType->clusterCount;
    283                  clusterIndex ++ ) {
    284              EmberAfCluster *cluster = &(epType->cluster[clusterIndex]);
   \                     ??initializeEndpoint_1: (+1)
   \   00000010   0x6829             LDR      R1,[R5, #+0]
   \   00000012   0x2014             MOVS     R0,#+20
   \   00000014   0xFB00 0x1706      MLA      R7,R0,R6,R1
    285              EmberAfGenericClusterFunction f;
    286              emberAfClusterInitCallback(definedEndpoint->endpoint, cluster->clusterId);
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0x8839             LDRH     R1,[R7, #+0]
   \   0000001C   0x.... 0x....      BL       emberAfClusterInitCallback
    287              f = emberAfFindClusterFunction(cluster, CLUSTER_MASK_INIT_FUNCTION);
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x4638             MOV      R0,R7
   \   00000024   0x.... 0x....      BL       emberAfFindClusterFunction
   \   00000028   0x0001             MOVS     R1,R0
    288              if ( f != NULL ) {
   \   0000002A   0xBF1C             ITT      NE 
    289                ((EmberAfInitFunction)f)(definedEndpoint->endpoint);
   \   0000002C   0x7820             LDRBNE   R0,[R4, #+0]
   \   0000002E   0x4788             BLXNE    R1
    290              }
    291            }
   \   00000030   0x1C76             ADDS     R6,R6,#+1
   \                     ??initializeEndpoint_0: (+1)
   \   00000032   0x7928             LDRB     R0,[R5, #+4]
   \   00000034   0xB2F6             UXTB     R6,R6
   \   00000036   0x4286             CMP      R6,R0
   \   00000038   0xD3EA             BCC.N    ??initializeEndpoint_1
    292            emberAfPopNetworkIndex();
   \   0000003A                      REQUIRE ?Subroutine0
   \   0000003A                      ;; // Fall through to label ?Subroutine0
    293          }
    294          
    295          // Calls the init functions.

   \                                 In section .text, align 2, keep-with-next
    296          void emAfCallInits(void)
    297          {
   \                     emAfCallInits: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    298            int8u index;
    299            for ( index = 0; index < emberAfEndpointCount(); index++ ) {
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable38
   \   0000000C   0xE008             B.N      ??emAfCallInits_0
    300              if (emberAfEndpointIndexIsEnabled(index)) {
   \                     ??emAfCallInits_1: (+1)
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       emberAfEndpointIndexIsEnabled
   \   00000014   0xB118             CBZ.N    R0,??emAfCallInits_2
    301                initializeEndpoint(&(emAfEndpoints[index]));
   \   00000016   0xEB05 0x1004      ADD      R0,R5,R4, LSL #+4
   \   0000001A   0x.... 0x....      BL       initializeEndpoint
    302              }
    303            }
   \                     ??emAfCallInits_2: (+1)
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
   \                     ??emAfCallInits_0: (+1)
   \   00000020   0x7830             LDRB     R0,[R6, #+0]
   \   00000022   0xB2E4             UXTB     R4,R4
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD3F2             BCC.N    ??emAfCallInits_1
    304          }
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    305          
    306          // Returns the pointer to metadata, or null if it is not found

   \                                 In section .text, align 2, keep-with-next
    307          EmberAfAttributeMetadata* emberAfLocateAttributeMetadata(int8u endpoint,
    308                                                                   EmberAfClusterId clusterId,
    309                                                                   EmberAfAttributeId attributeId,
    310                                                                   int8u mask,
    311                                                                   int16u manufacturerCode)
    312          {
   \                     emberAfLocateAttributeMetadata: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    313            EmberAfAttributeMetadata *metadata = NULL;
   \   00000004   0x2400             MOVS     R4,#+0
    314            EmberAfAttributeSearchRecord record;
    315            record.endpoint = endpoint;
   \   00000006   0xF88D 0x0008      STRB     R0,[SP, #+8]
    316            record.clusterId = clusterId;
   \   0000000A   0xF8AD 0x100A      STRH     R1,[SP, #+10]
   \   0000000E   0x9401             STR      R4,[SP, #+4]
    317            record.clusterMask = mask;
   \   00000010   0xF88D 0x300C      STRB     R3,[SP, #+12]
    318            record.attributeId = attributeId;
   \   00000014   0xF8AD 0x200E      STRH     R2,[SP, #+14]
    319            record.manufacturerCode = manufacturerCode;
    320            emAfReadOrWriteAttribute(&record,
    321                                     &metadata,
    322                                     NULL,   // buffer
    323                                     0,      // buffer size
    324                                     FALSE); // write?
   \   00000018   0x9400             STR      R4,[SP, #+0]
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x9808             LDR      R0,[SP, #+32]
   \   0000001E   0xF8AD 0x0010      STRH     R0,[SP, #+16]
   \   00000022   0x4622             MOV      R2,R4
   \   00000024   0xA901             ADD      R1,SP,#+4
   \   00000026   0xA802             ADD      R0,SP,#+8
   \   00000028   0x.... 0x....      BL       emAfReadOrWriteAttribute
    325            return metadata;
   \   0000002C   0x9801             LDR      R0,[SP, #+4]
   \   0000002E   0xB006             ADD      SP,SP,#+24
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    326          }
    327          
    328          static int8u* singletonAttributeLocation(EmberAfAttributeMetadata *am)
    329          {
    330            EmberAfAttributeMetadata *m = (EmberAfAttributeMetadata *)&(generatedAttributes[0]);
    331            int16u index = 0;
    332            while ( m < am ) {
    333              if ( m->mask & ATTRIBUTE_MASK_SINGLETON ) {
    334                index += m->size;
    335              }
    336              m++;
    337            }
    338            return (int8u *)(singletonAttributeData + index);
    339          }
    340          
    341          
    342          // This function does mem copy, but smartly, which means that if the type is a
    343          // string, it will copy as much as it can.
    344          // If src == NULL, then this method will set memory to zeroes
    345          static EmberAfStatus typeSensitiveMemCopy(int8u* dest,
    346                                                    int8u* src,
    347                                                    EmberAfAttributeMetadata * am,
    348                                                    boolean write,
    349                                                    int16u readLength)
    350          {
    351            EmberAfAttributeType attributeType = am->attributeType;
    352            int16u size = (readLength == 0) ? am->size : readLength;
    353          
    354            if (emberAfIsStringAttributeType(attributeType)) {
    355              emberAfCopyString(dest, src, size - 1);
    356            } else if (emberAfIsLongStringAttributeType(attributeType)) {
    357              emberAfCopyLongString(dest, src, size - 2);
    358            } else {
    359              if (!write && readLength != 0 && readLength < am->size) {
    360                  return EMBER_ZCL_STATUS_INSUFFICIENT_SPACE;
    361              }
    362              if ( src == NULL ) {
    363                MEMSET(dest, 0, size);
    364              } else {
    365                MEMMOVE(dest, src, size);
    366              }
    367            }
    368            return EMBER_ZCL_STATUS_SUCCESS;
    369          }
    370          
    371          // Returns the manufacturer code or ::EMBER_AF_NULL_MANUFACTURER_CODE if none
    372          // could be found.

   \                                 In section .text, align 2, keep-with-next
    373          static int16u getManufacturerCode(EmberAfManufacturerCodeEntry *codes,
    374                                            int16u codeTableSize,
    375                                            int16u tableIndex)
    376          {
   \                     getManufacturerCode: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    377            int16u i;
    378            for (i = 0; i < codeTableSize; i++, codes++) {
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE001             B.N      ??getManufacturerCode_0
   \                     ??getManufacturerCode_1: (+1)
   \   00000006   0x1C5B             ADDS     R3,R3,#+1
   \   00000008   0x1D00             ADDS     R0,R0,#+4
   \                     ??getManufacturerCode_0: (+1)
   \   0000000A   0xB29B             UXTH     R3,R3
   \   0000000C   0x428B             CMP      R3,R1
   \   0000000E   0xD204             BCS.N    ??getManufacturerCode_2
    379              if (codes->index == tableIndex) {
   \   00000010   0x8804             LDRH     R4,[R0, #+0]
   \   00000012   0x4294             CMP      R4,R2
   \   00000014   0xD1F7             BNE.N    ??getManufacturerCode_1
    380                return codes->manufacturerCode;
   \   00000016   0x8840             LDRH     R0,[R0, #+2]
   \   00000018   0xBD10             POP      {R4,PC}
    381              }
    382            }
    383            return EMBER_AF_NULL_MANUFACTURER_CODE;
   \                     ??getManufacturerCode_2: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    384          }
    385          

   \                                 In section .text, align 2, keep-with-next
    386          int16u emAfGetManufacturerCodeForAttribute(EmberAfCluster *cluster,
    387                                                     EmberAfAttributeMetadata *attMetaData)
    388          {
    389            return (emberAfClusterIsManufacturerSpecific(cluster)
    390                    ? emAfGetManufacturerCodeForCluster(cluster)
    391                    : getManufacturerCode((EmberAfManufacturerCodeEntry *)attributeManufacturerCodes,
    392                                          attributeManufacturerCodeCount,
    393                                          (attMetaData - generatedAttributes)));
   \                     emAfGetManufacturerCodeForAttribute: (+1)
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xF5B2 0x4F7C      CMP      R2,#+64512
   \   00000006   0xBFA8             IT       GE 
   \   00000008   0x.... 0x....      BGE.W    emAfGetManufacturerCodeForCluster
   \   0000000C   0x.... 0x....      ADR.W    R0,generatedAttributes
   \   00000010   0x1A08             SUBS     R0,R1,R0
   \   00000012   0x210C             MOVS     R1,#+12
   \   00000014   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000018   0xB292             UXTH     R2,R2
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x.... 0x....      ADR.W    R0,attributeManufacturerCodes
   \   00000020   0x....             B.N      getManufacturerCode
    394          }
    395          

   \                                 In section .text, align 2, keep-with-next
    396          int16u emAfGetManufacturerCodeForCluster(EmberAfCluster *cluster)
    397          {
    398            return getManufacturerCode((EmberAfManufacturerCodeEntry *)clusterManufacturerCodes,
    399                                       clusterManufacturerCodeCount,
    400                                       (cluster - generatedClusters));
   \                     emAfGetManufacturerCodeForCluster: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,generatedClusters
   \   00000004   0x1A40             SUBS     R0,R0,R1
   \   00000006   0x2114             MOVS     R1,#+20
   \   00000008   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   0000000C   0xB292             UXTH     R2,R2
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x.... 0x....      ADR.W    R0,clusterManufacturerCodes
   \   00000014   0x....             B.N      getManufacturerCode
    401          }
    402          
    403          /**
    404           * @brief Matches a cluster based on cluster id, direction and manufacturer code.
    405           *   This function assumes that the passed cluster's endpoint already
    406           *   matches the endpoint of the EmberAfAttributeSearchRecord.
    407           *
    408           * Cluster's match if:
    409           *   1. Cluster ids match AND
    410           *   2. Cluster directions match as defined by cluster->mask
    411           *        and attRecord->clusterMask AND
    412           *   3. If the clusters are mf specific, their mf codes match.
    413           */

   \                                 In section .text, align 2, keep-with-next
    414          boolean emAfMatchCluster(EmberAfCluster *cluster,
    415                                   EmberAfAttributeSearchRecord *attRecord)
    416          {
   \                     emAfMatchCluster: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    417            return (cluster->clusterId == attRecord->clusterId
    418                    && cluster->mask & attRecord->clusterMask
    419                    && (!emberAfClusterIsManufacturerSpecific(cluster)
    420                        || (emAfGetManufacturerCodeForCluster(cluster)
    421                            == attRecord->manufacturerCode)));
   \   00000004   0x8801             LDRH     R1,[R0, #+0]
   \   00000006   0x8862             LDRH     R2,[R4, #+2]
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0xD10D             BNE.N    ??emAfMatchCluster_0
   \   0000000C   0x7B02             LDRB     R2,[R0, #+12]
   \   0000000E   0x7923             LDRB     R3,[R4, #+4]
   \   00000010   0x421A             TST      R2,R3
   \   00000012   0xD009             BEQ.N    ??emAfMatchCluster_0
   \   00000014   0xF5B1 0x4F7C      CMP      R1,#+64512
   \   00000018   0xDB04             BLT.N    ??emAfMatchCluster_1
   \   0000001A   0x.... 0x....      BL       emAfGetManufacturerCodeForCluster
   \   0000001E   0x8921             LDRH     R1,[R4, #+8]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD101             BNE.N    ??emAfMatchCluster_0
   \                     ??emAfMatchCluster_1: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD10             POP      {R4,PC}
   \                     ??emAfMatchCluster_0: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    422          }
    423          
    424          /**
    425           * @brief Matches an attribute based on attribute id and manufacturer code.
    426           *   This function assumes that the passed cluster already matches the
    427           *   clusterId, direction and mf specificity of the passed
    428           *   EmberAfAttributeSearchRecord.
    429           *
    430           * Note: If both the attribute and cluster are manufacturer specific,
    431           *   the cluster's mf code gets precedence.
    432           *
    433           * Attributes match if:
    434           *   1. Att ids match AND
    435           *      a. cluster IS mf specific OR
    436           *      b. both stored and saught attributes are NOT mf specific OR
    437           *      c. stored att IS mf specific AND mfg codes match.
    438           */

   \                                 In section .text, align 2, keep-with-next
    439          boolean emAfMatchAttribute(EmberAfCluster *cluster,
    440                                     EmberAfAttributeMetadata *am,
    441                                     EmberAfAttributeSearchRecord *attRecord)
    442          {
   \                     emAfMatchAttribute: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4614             MOV      R4,R2
    443            return (am->attributeId == attRecord->attributeId
    444                    && (emberAfClusterIsManufacturerSpecific(cluster)
    445                        || (emAfGetManufacturerCodeForAttribute(cluster, am)
    446                            == attRecord->manufacturerCode)));
   \   00000004   0x880A             LDRH     R2,[R1, #+0]
   \   00000006   0x88E3             LDRH     R3,[R4, #+6]
   \   00000008   0x429A             CMP      R2,R3
   \   0000000A   0xD10A             BNE.N    ??emAfMatchAttribute_0
   \   0000000C   0x8802             LDRH     R2,[R0, #+0]
   \   0000000E   0xF5B2 0x4F7C      CMP      R2,#+64512
   \   00000012   0xDA04             BGE.N    ??emAfMatchAttribute_1
   \   00000014   0x.... 0x....      BL       emAfGetManufacturerCodeForAttribute
   \   00000018   0x8921             LDRH     R1,[R4, #+8]
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??emAfMatchAttribute_0
   \                     ??emAfMatchAttribute_1: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD10             POP      {R4,PC}
   \                     ??emAfMatchAttribute_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    447          }
    448          
    449          // The callbacks to read and write externals have the same signature, so it is
    450          // easy to use function pointers to call the right one.  This typedef covers
    451          // both and makes the code a bit easier to read.
    452          typedef EmberAfStatus (*ExternalReadWriteCallback)(int8u, EmberAfClusterId, EmberAfAttributeMetadata *, int16u, int8u *);
    453          
    454          // When reading non-string attributes, this function returns an error when destination
    455          // buffer isn't large enough to accommodate the attribute type.  For strings, the
    456          // function will copy at most readLength bytes.  This means the resulting string
    457          // may be truncated.  The length byte(s) in the resulting string will reflect
    458          // any truncation.  If readLength is zero, we are working with backwards-
    459          // compatibility wrapper functions and we just cross our fingers and hope for
    460          // the best.
    461          //
    462          // When writing attributes, readLength is ignored.  For non-string attributes,
    463          // this function assumes the source buffer is the same size as the attribute
    464          // type.  For strings, the function will copy as many bytes as will fit in the
    465          // attribute.  This means the resulting string may be truncated.  The length
    466          // byte(s) in the resulting string will reflect any truncated.

   \                                 In section .text, align 2, keep-with-next
    467          EmberAfStatus emAfReadOrWriteAttribute(EmberAfAttributeSearchRecord *attRecord,
    468                                                 EmberAfAttributeMetadata **metadata,
    469                                                 int8u *buffer,
    470                                                 int16u readLength,
    471                                                 boolean write)
    472          {
   \                     emAfReadOrWriteAttribute: (+1)
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
    473            int8u i;
    474            int16u attributeOffsetIndex = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x469B             MOV      R11,R3
    475          
    476            for (i = 0; i < emberAfEndpointCount(); i++) {
   \   0000000A   0x46AA             MOV      R10,R5
   \   0000000C   0xE004             B.N      ??emAfReadOrWriteAttribute_0
    477              if (emAfEndpoints[i].endpoint == attRecord->endpoint) {
    478                EmberAfEndpointType *endpointType = emAfEndpoints[i].endpointType;
    479                int8u clusterIndex;
    480                if (!emberAfEndpointIndexIsEnabled(i)) {
    481                  continue;
    482                } 
    483                for (clusterIndex = 0;
    484                     clusterIndex < endpointType->clusterCount;
    485                     clusterIndex++) {
    486                  EmberAfCluster *cluster = &(endpointType->cluster[clusterIndex]);
    487                  if (emAfMatchCluster(cluster, attRecord)) { // Got the cluster
    488                  int16u attrIndex;
    489                    for (attrIndex = 0;
    490                         attrIndex < cluster->attributeCount;
    491                         attrIndex++) {
    492                      EmberAfAttributeMetadata *am = &(cluster->attributes[attrIndex]);
    493                      if (emAfMatchAttribute(cluster,
    494                                             am,
    495                                             attRecord)) { // Got the attribute
    496          
    497                        // If passed metadata location is not null, populate
    498                        if (metadata != NULL) {
    499                          *metadata = am;
    500                        }
    501          
    502                        {
    503                          int8u *attributeLocation = (am->mask & ATTRIBUTE_MASK_SINGLETON
    504                                                      ? singletonAttributeLocation(am)
    505                                                      : attributeData + attributeOffsetIndex);
    506                          int8u *src, *dst;
    507                          ExternalReadWriteCallback callback;
    508                          if (write) {
    509                            src = buffer;
    510                            dst = attributeLocation;
    511                            callback = emberAfExternalAttributeWriteCallback;
    512                          } else {
    513                            if (buffer == NULL) {
    514                              return EMBER_ZCL_STATUS_SUCCESS;
    515                            }
    516          
    517                            src = attributeLocation;
    518                            dst = buffer;
    519                            callback = emberAfExternalAttributeReadCallback;
    520                          }
    521          
    522                          return (am->mask & ATTRIBUTE_MASK_EXTERNAL_STORAGE
    523                                  ? (*callback)(attRecord->endpoint,
    524                                                attRecord->clusterId,
    525                                                am,
    526                                                emAfGetManufacturerCodeForAttribute(cluster, am),
    527                                                buffer)
    528                                  : typeSensitiveMemCopy(dst,
    529                                                         src,
    530                                                         am,
    531                                                         write,
    532                                                         readLength));
    533                        }
    534                      } else { // Not the attribute we are looking for
    535                        // Increase the index if attribute is not externally stored
    536                        if (!(am->mask & ATTRIBUTE_MASK_EXTERNAL_STORAGE)
    537                             && !(am->mask & ATTRIBUTE_MASK_SINGLETON) ) {
    538                          attributeOffsetIndex += emberAfAttributeSize(am);
    539                        }
    540                      }
    541                    }
    542                  } else { // Not the cluster we are looking for
    543                    attributeOffsetIndex += cluster->clusterSize;
    544                  }
    545                }
    546              } else { // Not the endpoint we are looking for
    547                attributeOffsetIndex += emAfEndpoints[i].endpointType->endpointSize;
   \                     ??emAfReadOrWriteAttribute_1: (+1)
   \   0000000E   0x88C0             LDRH     R0,[R0, #+6]
   \   00000010   0x1945             ADDS     R5,R0,R5
   \   00000012   0xB2AD             UXTH     R5,R5
    548              }
   \                     ??emAfReadOrWriteAttribute_2: (+1)
   \   00000014   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??emAfReadOrWriteAttribute_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable38
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0xFA5F 0xFA8A      UXTB     R10,R10
   \   00000022   0x4582             CMP      R10,R0
   \   00000024   0xF080 0x80B4      BCS.W    ??emAfReadOrWriteAttribute_3
   \   00000028   0xEA4F 0x110A      LSL      R1,R10,#+4
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable38_1
   \   00000030   0x.... 0x....      LDR.W    R2,??DataTable38_1
   \   00000034   0x1808             ADDS     R0,R1,R0
   \   00000036   0x5C89             LDRB     R1,[R1, R2]
   \   00000038   0xF898 0x2000      LDRB     R2,[R8, #+0]
   \   0000003C   0x6880             LDR      R0,[R0, #+8]
   \   0000003E   0x4291             CMP      R1,R2
   \   00000040   0xD1E5             BNE.N    ??emAfReadOrWriteAttribute_1
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0x4650             MOV      R0,R10
   \   00000046   0x.... 0x....      BL       emberAfEndpointIndexIsEnabled
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD0E2             BEQ.N    ??emAfReadOrWriteAttribute_2
   \   0000004E   0x2700             MOVS     R7,#+0
   \   00000050   0xE003             B.N      ??emAfReadOrWriteAttribute_4
   \                     ??emAfReadOrWriteAttribute_5: (+1)
   \   00000052   0x8960             LDRH     R0,[R4, #+10]
   \   00000054   0x1945             ADDS     R5,R0,R5
   \   00000056   0xB2AD             UXTH     R5,R5
   \                     ??emAfReadOrWriteAttribute_6: (+1)
   \   00000058   0x1C7F             ADDS     R7,R7,#+1
   \                     ??emAfReadOrWriteAttribute_4: (+1)
   \   0000005A   0x9800             LDR      R0,[SP, #+0]
   \   0000005C   0x7900             LDRB     R0,[R0, #+4]
   \   0000005E   0xB2FF             UXTB     R7,R7
   \   00000060   0x4287             CMP      R7,R0
   \   00000062   0xD2D7             BCS.N    ??emAfReadOrWriteAttribute_2
   \   00000064   0x9900             LDR      R1,[SP, #+0]
   \   00000066   0x6809             LDR      R1,[R1, #+0]
   \   00000068   0x2014             MOVS     R0,#+20
   \   0000006A   0xFB00 0x1407      MLA      R4,R0,R7,R1
   \   0000006E   0x4641             MOV      R1,R8
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       emAfMatchCluster
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD0EB             BEQ.N    ??emAfReadOrWriteAttribute_5
   \   0000007A   0xF04F 0x0900      MOV      R9,#+0
   \   0000007E   0xE008             B.N      ??emAfReadOrWriteAttribute_7
   \                     ??emAfReadOrWriteAttribute_8: (+1)
   \   00000080   0x7930             LDRB     R0,[R6, #+4]
   \   00000082   0x2130             MOVS     R1,#+48
   \   00000084   0x4208             TST      R0,R1
   \   00000086   0xD102             BNE.N    ??emAfReadOrWriteAttribute_9
   \   00000088   0x78F0             LDRB     R0,[R6, #+3]
   \   0000008A   0x1945             ADDS     R5,R0,R5
   \   0000008C   0xB2AD             UXTH     R5,R5
   \                     ??emAfReadOrWriteAttribute_9: (+1)
   \   0000008E   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??emAfReadOrWriteAttribute_7: (+1)
   \   00000092   0x8920             LDRH     R0,[R4, #+8]
   \   00000094   0xFA1F 0xF989      UXTH     R9,R9
   \   00000098   0x4581             CMP      R9,R0
   \   0000009A   0xD2DD             BCS.N    ??emAfReadOrWriteAttribute_6
   \   0000009C   0x6861             LDR      R1,[R4, #+4]
   \   0000009E   0x200C             MOVS     R0,#+12
   \   000000A0   0xFB00 0x1609      MLA      R6,R0,R9,R1
   \   000000A4   0x4642             MOV      R2,R8
   \   000000A6   0x4631             MOV      R1,R6
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0x.... 0x....      BL       emAfMatchAttribute
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD0E6             BEQ.N    ??emAfReadOrWriteAttribute_8
   \   000000B2   0x9801             LDR      R0,[SP, #+4]
   \   000000B4   0xB100             CBZ.N    R0,??emAfReadOrWriteAttribute_10
   \   000000B6   0x6006             STR      R6,[R0, #+0]
   \                     ??emAfReadOrWriteAttribute_10: (+1)
   \   000000B8   0x7930             LDRB     R0,[R6, #+4]
   \   000000BA   0x0681             LSLS     R1,R0,#+26
   \   000000BC   0xD512             BPL.N    ??emAfReadOrWriteAttribute_11
   \   000000BE   0x.... 0x....      ADR.W    R1,generatedAttributes
   \   000000C2   0x2200             MOVS     R2,#+0
   \   000000C4   0xE006             B.N      ??emAfReadOrWriteAttribute_12
   \                     ??emAfReadOrWriteAttribute_13: (+1)
   \   000000C6   0x790B             LDRB     R3,[R1, #+4]
   \   000000C8   0x069B             LSLS     R3,R3,#+26
   \   000000CA   0xD502             BPL.N    ??emAfReadOrWriteAttribute_14
   \   000000CC   0x78CB             LDRB     R3,[R1, #+3]
   \   000000CE   0x189A             ADDS     R2,R3,R2
   \   000000D0   0xB292             UXTH     R2,R2
   \                     ??emAfReadOrWriteAttribute_14: (+1)
   \   000000D2   0x310C             ADDS     R1,R1,#+12
   \                     ??emAfReadOrWriteAttribute_12: (+1)
   \   000000D4   0x42B1             CMP      R1,R6
   \   000000D6   0xD3F6             BCC.N    ??emAfReadOrWriteAttribute_13
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable38
   \   000000DC   0x1851             ADDS     R1,R2,R1
   \   000000DE   0xF101 0x0A40      ADD      R10,R1,#+64
   \   000000E2   0xE004             B.N      ??emAfReadOrWriteAttribute_15
   \                     ??emAfReadOrWriteAttribute_11: (+1)
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable38
   \   000000E8   0x1869             ADDS     R1,R5,R1
   \   000000EA   0xF101 0x0A04      ADD      R10,R1,#+4
   \                     ??emAfReadOrWriteAttribute_15: (+1)
   \   000000EE   0x9D0C             LDR      R5,[SP, #+48]
   \   000000F0   0xB11D             CBZ.N    R5,??emAfReadOrWriteAttribute_16
   \   000000F2   0x9F02             LDR      R7,[SP, #+8]
   \   000000F4   0x.... 0x....      LDR.W    R9,??DataTable38_2
   \   000000F8   0xE006             B.N      ??emAfReadOrWriteAttribute_17
   \                     ??emAfReadOrWriteAttribute_16: (+1)
   \   000000FA   0x9902             LDR      R1,[SP, #+8]
   \   000000FC   0x2900             CMP      R1,#+0
   \   000000FE   0xD045             BEQ.N    ??emAfReadOrWriteAttribute_18
   \   00000100   0x4657             MOV      R7,R10
   \   00000102   0x468A             MOV      R10,R1
   \   00000104   0x.... 0x....      LDR.W    R9,??DataTable38_3
   \                     ??emAfReadOrWriteAttribute_17: (+1)
   \   00000108   0x06C0             LSLS     R0,R0,#+27
   \   0000010A   0xD50D             BPL.N    ??emAfReadOrWriteAttribute_19
   \   0000010C   0x4631             MOV      R1,R6
   \   0000010E   0x4620             MOV      R0,R4
   \   00000110   0x.... 0x....      BL       emAfGetManufacturerCodeForAttribute
   \   00000114   0x4603             MOV      R3,R0
   \   00000116   0x9802             LDR      R0,[SP, #+8]
   \   00000118   0x9000             STR      R0,[SP, #+0]
   \   0000011A   0x4632             MOV      R2,R6
   \   0000011C   0xF8B8 0x1002      LDRH     R1,[R8, #+2]
   \   00000120   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000124   0x47C8             BLX      R9
   \   00000126   0xE034             B.N      ??emAfReadOrWriteAttribute_20
   \                     ??emAfReadOrWriteAttribute_19: (+1)
   \   00000128   0xF896 0x8002      LDRB     R8,[R6, #+2]
   \   0000012C   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000130   0xBF0C             ITE      EQ 
   \   00000132   0x78F4             LDRBEQ   R4,[R6, #+3]
   \   00000134   0x465C             MOVNE    R4,R11
   \   00000136   0x4640             MOV      R0,R8
   \   00000138   0x.... 0x....      BL       emberAfIsStringAttributeType
   \   0000013C   0xB130             CBZ.N    R0,??emAfReadOrWriteAttribute_21
   \   0000013E   0x1E62             SUBS     R2,R4,#+1
   \   00000140   0xB2D2             UXTB     R2,R2
   \   00000142   0x4639             MOV      R1,R7
   \   00000144   0x4650             MOV      R0,R10
   \   00000146   0x.... 0x....      BL       emberAfCopyString
   \   0000014A   0xE01F             B.N      ??emAfReadOrWriteAttribute_18
   \                     ??emAfReadOrWriteAttribute_21: (+1)
   \   0000014C   0x4640             MOV      R0,R8
   \   0000014E   0x.... 0x....      BL       emberAfIsLongStringAttributeType
   \   00000152   0xB130             CBZ.N    R0,??emAfReadOrWriteAttribute_22
   \   00000154   0x1EA2             SUBS     R2,R4,#+2
   \   00000156   0xB292             UXTH     R2,R2
   \   00000158   0x4639             MOV      R1,R7
   \   0000015A   0x4650             MOV      R0,R10
   \   0000015C   0x.... 0x....      BL       emberAfCopyLongString
   \   00000160   0xE014             B.N      ??emAfReadOrWriteAttribute_18
   \                     ??emAfReadOrWriteAttribute_22: (+1)
   \   00000162   0xB93D             CBNZ.N   R5,??emAfReadOrWriteAttribute_23
   \   00000164   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000168   0xD004             BEQ.N    ??emAfReadOrWriteAttribute_23
   \   0000016A   0x78F0             LDRB     R0,[R6, #+3]
   \   0000016C   0x4583             CMP      R11,R0
   \   0000016E   0xBF38             IT       CC 
   \   00000170   0x2089             MOVCC    R0,#+137
   \   00000172   0xD30E             BCC.N    ??emAfReadOrWriteAttribute_20
   \                     ??emAfReadOrWriteAttribute_23: (+1)
   \   00000174   0x2F00             CMP      R7,#+0
   \   00000176   0x4622             MOV      R2,R4
   \   00000178   0xD104             BNE.N    ??emAfReadOrWriteAttribute_24
   \   0000017A   0x2100             MOVS     R1,#+0
   \   0000017C   0x4650             MOV      R0,R10
   \   0000017E   0x.... 0x....      BL       halCommonMemSet
   \   00000182   0xE003             B.N      ??emAfReadOrWriteAttribute_18
   \                     ??emAfReadOrWriteAttribute_24: (+1)
   \   00000184   0x4639             MOV      R1,R7
   \   00000186   0x4650             MOV      R0,R10
   \   00000188   0x.... 0x....      BL       halCommonMemMove
   \                     ??emAfReadOrWriteAttribute_18: (+1)
   \   0000018C   0x2000             MOVS     R0,#+0
   \   0000018E   0xE000             B.N      ??emAfReadOrWriteAttribute_20
    549            }
    550            return EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE; // Sorry, attribute was not found.
   \                     ??emAfReadOrWriteAttribute_3: (+1)
   \   00000190   0x2086             MOVS     R0,#+134
   \                     ??emAfReadOrWriteAttribute_20: (+1)
   \   00000192   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    551          }
    552          
    553          // Check if a cluster is implemented or not. If yes, the cluster is returned.
    554          //
    555          // mask = 0 -> find either client or server
    556          // mask = CLUSTER_MASK_CLIENT -> find client
    557          // mask = CLUSTER_MASK_SERVER -> find server

   \                                 In section .text, align 2, keep-with-next
    558          EmberAfCluster *emberAfFindClusterInType(EmberAfEndpointType *endpointType,
    559                                                   EmberAfClusterId clusterId,
    560                                                   EmberAfClusterMask mask)
    561          {
   \                     emberAfFindClusterInType: (+1)
   \   00000000   0xB558             PUSH     {R3,R4,R6,LR}
   \   00000002   0x4603             MOV      R3,R0
    562            int8u i;
    563            for (i = 0; i < endpointType->clusterCount; i++) {
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0xE003             B.N      ??emberAfFindClusterInType_0
    564              EmberAfCluster *cluster = &(endpointType->cluster[i]);
    565              if (cluster->clusterId == clusterId
    566                  && (mask == 0
    567                      || (mask == CLUSTER_MASK_CLIENT && emberAfClusterIsClient(cluster))
    568                      || (mask == CLUSTER_MASK_SERVER && emberAfClusterIsServer(cluster)))) {
   \                     ??emberAfFindClusterInType_1: (+1)
   \   00000008   0x7B06             LDRB     R6,[R0, #+12]
   \   0000000A   0x0636             LSLS     R6,R6,#+24
   \   0000000C   0xD415             BMI.N    ??emberAfFindClusterInType_2
   \                     ??emberAfFindClusterInType_3: (+1)
   \   0000000E   0x1C64             ADDS     R4,R4,#+1
   \                     ??emberAfFindClusterInType_0: (+1)
   \   00000010   0x7918             LDRB     R0,[R3, #+4]
   \   00000012   0xB2E4             UXTB     R4,R4
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD20F             BCS.N    ??emberAfFindClusterInType_4
   \   00000018   0x681E             LDR      R6,[R3, #+0]
   \   0000001A   0x2014             MOVS     R0,#+20
   \   0000001C   0xFB00 0x6004      MLA      R0,R0,R4,R6
   \   00000020   0x8806             LDRH     R6,[R0, #+0]
   \   00000022   0x428E             CMP      R6,R1
   \   00000024   0xD1F3             BNE.N    ??emberAfFindClusterInType_3
   \   00000026   0xB142             CBZ.N    R2,??emberAfFindClusterInType_2
   \   00000028   0x2A80             CMP      R2,#+128
   \   0000002A   0xD0ED             BEQ.N    ??emberAfFindClusterInType_1
   \   0000002C   0x2A40             CMP      R2,#+64
   \   0000002E   0xD1EE             BNE.N    ??emberAfFindClusterInType_3
   \   00000030   0x7B06             LDRB     R6,[R0, #+12]
   \   00000032   0x0676             LSLS     R6,R6,#+25
   \   00000034   0xD5EB             BPL.N    ??emberAfFindClusterInType_3
    569                return cluster;
   \   00000036   0xBD52             POP      {R1,R4,R6,PC}
    570              }
    571            }
    572            return NULL;
   \                     ??emberAfFindClusterInType_4: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??emberAfFindClusterInType_2: (+1)
   \   0000003A   0xBD52             POP      {R1,R4,R6,PC}    ;; return
    573          }
    574          

   \                                 In section .text, align 2, keep-with-next
    575          int8u emberAfClusterIndex(int8u endpoint,
    576                                    EmberAfClusterId clusterId,
    577                                    EmberAfClusterMask mask)
    578          {
   \                     emberAfClusterIndex: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x468A             MOV      R10,R1
   \   00000008   0x4693             MOV      R11,R2
    579            int8u ep;
    580            int8u index = 0xFF;
   \   0000000A   0x27FF             MOVS     R7,#+255
    581            for ( ep=0; ep < emberAfEndpointCount(); ep++ ) {
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable38_1
   \   00000012   0x.... 0x....      LDR.W    R9,??DataTable38
   \   00000016   0xE000             B.N      ??emberAfClusterIndex_0
   \                     ??emberAfClusterIndex_1: (+1)
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
   \                     ??emberAfClusterIndex_0: (+1)
   \   0000001A   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000001E   0xB2ED             UXTB     R5,R5
   \   00000020   0x4285             CMP      R5,R0
   \   00000022   0xD20E             BCS.N    ??emberAfClusterIndex_2
    582              EmberAfEndpointType *endpointType = emAfEndpoints[ep].endpointType;
    583              if ( emberAfFindClusterInType(endpointType, clusterId, mask) != NULL ) {
   \   00000024   0x012E             LSLS     R6,R5,#+4
   \   00000026   0x1930             ADDS     R0,R6,R4
   \   00000028   0x465A             MOV      R2,R11
   \   0000002A   0x6880             LDR      R0,[R0, #+8]
   \   0000002C   0x4651             MOV      R1,R10
   \   0000002E   0x.... 0x....      BL       emberAfFindClusterInType
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD0F0             BEQ.N    ??emberAfClusterIndex_1
    584                index++;
    585                if ( emAfEndpoints[ep].endpoint == endpoint )
   \   00000036   0x5D30             LDRB     R0,[R6, R4]
   \   00000038   0x1C7F             ADDS     R7,R7,#+1
   \   0000003A   0x4540             CMP      R0,R8
   \   0000003C   0xD1EC             BNE.N    ??emberAfClusterIndex_1
    586                  return index;
   \   0000003E   0xB2F8             UXTB     R0,R7
   \   00000040   0xE000             B.N      ??emberAfClusterIndex_3
    587              }
    588            }
    589            return 0xFF;
   \                     ??emberAfClusterIndex_2: (+1)
   \   00000042   0x20FF             MOVS     R0,#+255
   \                     ??emberAfClusterIndex_3: (+1)
   \   00000044   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    590          }
    591          
    592          // Returns TRUE If endpoint contains passed cluster

   \                                 In section .text, align 2, keep-with-next
    593          boolean emberAfContainsCluster(int8u endpoint, EmberAfClusterId clusterId) {
   \                     emberAfContainsCluster: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    594            return ( emberAfFindCluster(endpoint, clusterId, 0) != NULL );
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x....             B.N      ?Subroutine1
    595          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x.... 0x....      BL       emberAfFindCluster
   \   00000004   0xB100             CBZ.N    R0,??Subroutine1_0
   \   00000006   0x2001             MOVS     R0,#+1
   \                     ??Subroutine1_0: (+1)
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    596          

   \                                 In section .text, align 2, keep-with-next
    597          boolean emberAfContainsServer(int8u endpoint, EmberAfClusterId clusterId) {
   \                     emberAfContainsServer: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    598            return ( emberAfFindCluster(endpoint, clusterId, CLUSTER_MASK_SERVER) != NULL );
   \   00000002   0x2240             MOVS     R2,#+64
   \   00000004                      REQUIRE ?Subroutine1
   \   00000004                      ;; // Fall through to label ?Subroutine1
    599          }
    600          

   \                                 In section .text, align 2, keep-with-next
    601          boolean emberAfContainsClient(int8u endpoint, EmberAfClusterId clusterId) {
   \                     emberAfContainsClient: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    602            return ( emberAfFindCluster(endpoint, clusterId, CLUSTER_MASK_CLIENT) != NULL );
   \   00000002   0x2280             MOVS     R2,#+128
   \   00000004   0x....             B.N      ?Subroutine1
    603          }
    604          

   \                                 In section .text, align 2, keep-with-next
    605          EmberAfCluster *emberAfFindCluster(int8u endpoint,
    606                                             EmberAfClusterId clusterId,
    607                                             EmberAfClusterMask mask) {
   \                     emberAfFindCluster: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    608            int8u ep = emberAfIndexFromEndpoint(endpoint);
   \   00000006   0x.... 0x....      BL       emberAfIndexFromEndpoint
    609            if ( ep == 0xFF )
   \   0000000A   0x28FF             CMP      R0,#+255
   \   0000000C   0xD101             BNE.N    ??emberAfFindCluster_0
    610              return NULL;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
    611            else
    612              return emberAfFindClusterInType(emAfEndpoints[ep].endpointType, clusterId, mask);
   \                     ??emberAfFindCluster_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R3,??DataTable38_1
   \   00000016   0x462A             MOV      R2,R5
   \   00000018   0x4621             MOV      R1,R4
   \   0000001A   0xEB03 0x1000      ADD      R0,R3,R0, LSL #+4
   \   0000001E   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000022   0x6880             LDR      R0,[R0, #+8]
   \   00000024   0x....             B.N      emberAfFindClusterInType
    613          }
    614          
    615          // Server wrapper for findClusterEndpointIndex

   \                                 In section .text, align 2, keep-with-next
    616          int8u emberAfFindClusterServerEndpointIndex(int8u endpoint, EmberAfClusterId clusterId)
    617          {
    618            return findClusterEndpointIndex(endpoint, clusterId, CLUSTER_MASK_SERVER);
   \                     emberAfFindClusterServerEndpointIndex: (+1)
   \   00000000   0x2240             MOVS     R2,#+64
   \   00000002   0x....             B.N      findClusterEndpointIndex
    619          }
    620          
    621          // Client wrapper for findClusterEndpointIndex

   \                                 In section .text, align 2, keep-with-next
    622          int8u emberAfFindClusterClientEndpointIndex(int8u endpoint, EmberAfClusterId clusterId)
    623          {
    624            return findClusterEndpointIndex(endpoint, clusterId, CLUSTER_MASK_CLIENT);
   \                     emberAfFindClusterClientEndpointIndex: (+1)
   \   00000000   0x2280             MOVS     R2,#+128
   \   00000002                      REQUIRE findClusterEndpointIndex
   \   00000002                      ;; // Fall through to label findClusterEndpointIndex
    625          }
    626          
    627          // Returns the endpoint index within a given cluster

   \                                 In section .text, align 2, keep-with-next
    628          static int8u findClusterEndpointIndex(int8u endpoint, EmberAfClusterId clusterId, int8u mask)
    629          {
   \                     findClusterEndpointIndex: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4692             MOV      R10,R2
    630            int8u i, epi = 0;
   \   0000000A   0x2500             MOVS     R5,#+0
    631          
    632            if (emberAfFindCluster(endpoint, clusterId, mask) == NULL) {
   \   0000000C   0x.... 0x....      BL       emberAfFindCluster
   \   00000010   0xB908             CBNZ.N   R0,??findClusterEndpointIndex_0
    633              return 0xFF;
   \   00000012   0x20FF             MOVS     R0,#+255
   \   00000014   0xE018             B.N      ??findClusterEndpointIndex_1
    634            }
    635          
    636            for (i = 0; i < emberAfEndpointCount(); i++) {
   \                     ??findClusterEndpointIndex_0: (+1)
   \   00000016   0x2600             MOVS     R6,#+0
   \   00000018   0x.... 0x....      LDR.W    R7,??DataTable38_1
   \   0000001C   0x.... 0x....      LDR.W    R4,??DataTable38
   \   00000020   0xE000             B.N      ??findClusterEndpointIndex_2
   \                     ??findClusterEndpointIndex_3: (+1)
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \                     ??findClusterEndpointIndex_2: (+1)
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0xB2F6             UXTB     R6,R6
   \   00000028   0x4286             CMP      R6,R0
   \   0000002A   0xD20C             BCS.N    ??findClusterEndpointIndex_4
   \   0000002C   0x0130             LSLS     R0,R6,#+4
   \   0000002E   0x5DC0             LDRB     R0,[R0, R7]
   \   00000030   0x4540             CMP      R0,R8
   \   00000032   0xD008             BEQ.N    ??findClusterEndpointIndex_4
    637              if (emAfEndpoints[i].endpoint == endpoint) {
    638                break;
    639              }
    640              epi += (emberAfFindCluster(emAfEndpoints[i].endpoint, clusterId, mask) != NULL) ? 1 : 0;
   \   00000034   0x4652             MOV      R2,R10
   \   00000036   0x4649             MOV      R1,R9
   \   00000038   0x.... 0x....      BL       emberAfFindCluster
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD0F0             BEQ.N    ??findClusterEndpointIndex_3
   \   00000040   0x1C68             ADDS     R0,R5,#+1
   \   00000042   0xB2C5             UXTB     R5,R0
   \   00000044   0xE7ED             B.N      ??findClusterEndpointIndex_3
    641            }
    642          
    643            return epi;
   \                     ??findClusterEndpointIndex_4: (+1)
   \   00000046   0x4628             MOV      R0,R5
   \                     ??findClusterEndpointIndex_1: (+1)
   \   00000048   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    644          }
    645          

   \                                 In section .text, align 2, keep-with-next
    646          static int8u findIndexFromEndpoint(int8u endpoint, boolean ignoreDisabledEndpoints)
    647          {
   \                     findIndexFromEndpoint: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    648            int8u epi;
    649            for (epi = 0; epi < emberAfEndpointCount(); epi++) {
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x....             LDR.N    R3,??DataTable38_1
   \   00000006   0xE000             B.N      ??findIndexFromEndpoint_0
   \                     ??findIndexFromEndpoint_1: (+1)
   \   00000008   0x1C52             ADDS     R2,R2,#+1
   \                     ??findIndexFromEndpoint_0: (+1)
   \   0000000A   0x....             LDR.N    R4,??DataTable38
   \   0000000C   0x7824             LDRB     R4,[R4, #+0]
   \   0000000E   0xB2D2             UXTB     R2,R2
   \   00000010   0x42A2             CMP      R2,R4
   \   00000012   0xD20A             BCS.N    ??findIndexFromEndpoint_2
    650              if (emAfEndpoints[epi].endpoint == endpoint
    651                  && (!ignoreDisabledEndpoints
    652                      || emAfEndpoints[epi].bitmask & EMBER_AF_ENDPOINT_ENABLED)) {
   \   00000014   0x0114             LSLS     R4,R2,#+4
   \   00000016   0x5CE5             LDRB     R5,[R4, R3]
   \   00000018   0x4285             CMP      R5,R0
   \   0000001A   0xD1F5             BNE.N    ??findIndexFromEndpoint_1
   \   0000001C   0xB119             CBZ.N    R1,??findIndexFromEndpoint_3
   \   0000001E   0x18E4             ADDS     R4,R4,R3
   \   00000020   0x7B64             LDRB     R4,[R4, #+13]
   \   00000022   0x07E4             LSLS     R4,R4,#+31
   \   00000024   0xD5F0             BPL.N    ??findIndexFromEndpoint_1
    653                return epi;
   \                     ??findIndexFromEndpoint_3: (+1)
   \   00000026   0x4610             MOV      R0,R2
   \   00000028   0xBD30             POP      {R4,R5,PC}
    654              }
    655            }
    656            return 0xFF;
   \                     ??findIndexFromEndpoint_2: (+1)
   \   0000002A   0x20FF             MOVS     R0,#+255
   \   0000002C   0xBD30             POP      {R4,R5,PC}       ;; return
    657          }
    658          

   \                                 In section .text, align 2, keep-with-next
    659          boolean emberAfEndpointIsEnabled(int8u endpoint)
    660          {
   \                     emberAfEndpointIsEnabled: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    661            int8u index = findIndexFromEndpoint(endpoint,
    662                                                FALSE);    // ignore disabled endpoints?
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      BL       findIndexFromEndpoint
    663          
    664            EMBER_TEST_ASSERT(0xFF != index);
    665          
    666            if (0xFF == index) {
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xBF1C             ITT      NE 
    667              return FALSE;
    668            }
    669          
    670            return emberAfEndpointIndexIsEnabled(index);
   \   0000000C   0xE8BD 0x4002      POPNE    {R1,LR}
   \   00000010   0x.... 0x....      BNE.W    emberAfEndpointIndexIsEnabled
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD02             POP      {R1,PC}
    671          }
    672          

   \                                 In section .text, align 2, keep-with-next
    673          boolean emberAfEndpointEnableDisable(int8u endpoint, boolean enable)
    674          {
   \                     emberAfEndpointEnableDisable: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460E             MOV      R6,R1
   \   00000004   0x4604             MOV      R4,R0
    675            int8u index = findIndexFromEndpoint(endpoint,
    676                                                FALSE);    // ignore disabled endpoints?
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x.... 0x....      BL       findIndexFromEndpoint
    677            boolean currentlyEnabled;
    678          
    679            if (0xFF == index) {
   \   0000000C   0x28FF             CMP      R0,#+255
   \   0000000E   0xD101             BNE.N    ??emberAfEndpointEnableDisable_0
    680              return FALSE;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xBD70             POP      {R4-R6,PC}
    681            }
    682          
    683            currentlyEnabled = emAfEndpoints[index].bitmask & EMBER_AF_ENDPOINT_ENABLED;
   \                     ??emberAfEndpointEnableDisable_0: (+1)
   \   00000014   0x....             LDR.N    R1,??DataTable38_1
   \   00000016   0xEB01 0x1500      ADD      R5,R1,R0, LSL #+4
    684          
    685            if (enable) {
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0x7B68             LDRB     R0,[R5, #+13]
   \   0000001E   0xF000 0x0101      AND      R1,R0,#0x1
   \   00000022   0xBF14             ITE      NE 
    686              emAfEndpoints[index].bitmask |= EMBER_AF_ENDPOINT_ENABLED;
   \   00000024   0xF040 0x0001      ORRNE    R0,R0,#0x1
    687            } else {
    688              emAfEndpoints[index].bitmask &= EMBER_AF_ENDPOINT_DISABLED;
   \   00000028   0x2000             MOVEQ    R0,#+0
   \   0000002A   0x7368             STRB     R0,[R5, #+13]
    689            }
    690          
    691          #if defined(EZSP_HOST)
    692            ezspSetEndpointFlags(endpoint,
    693                                 (enable
    694                                  ? EZSP_ENDPOINT_ENABLED
    695                                  : EZSP_ENDPOINT_DISABLED));
    696          #endif
    697          
    698            if (currentlyEnabled ^ enable) {
   \   0000002C   0xEA96 0x0F01      TEQ      R6,R1
   \   00000030   0xD014             BEQ.N    ??emberAfEndpointEnableDisable_1
    699              if (enable) {
   \   00000032   0xB176             CBZ.N    R6,??emberAfEndpointEnableDisable_2
    700                initializeEndpoint(&(emAfEndpoints[index]));
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       initializeEndpoint
   \   0000003A   0xE00F             B.N      ??emberAfEndpointEnableDisable_1
    701              } else {
    702                int8u i;
    703                for (i = 0; i < emAfEndpoints[index].endpointType->clusterCount; i++) {
    704                  EmberAfCluster* cluster = &((emAfEndpoints[index].endpointType->cluster)[i]);
   \                     ??emberAfEndpointEnableDisable_3: (+1)
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2114             MOVS     R1,#+20
   \   00000040   0xFB01 0x0006      MLA      R0,R1,R6,R0
    705          //        emberAfCorePrintln("Disabling cluster tick for ep:%d, cluster:0x%2X, %p",
    706          //                           endpoint,
    707          //                           cluster->clusterId,
    708          //                           ((cluster->mask & CLUSTER_MASK_CLIENT)
    709          //                            ? "client"
    710          //                            : "server"));
    711          //        emberAfCoreFlush();
    712                  emberAfDeactivateClusterTick(endpoint,
    713                                               cluster->clusterId,
    714                                               (cluster->mask & CLUSTER_MASK_CLIENT
    715                                                ? EMBER_AF_CLIENT_CLUSTER_TICK
    716                                                : EMBER_AF_SERVER_CLUSTER_TICK));
   \   00000044   0x7B01             LDRB     R1,[R0, #+12]
   \   00000046   0x09CA             LSRS     R2,R1,#+7
   \   00000048   0x8801             LDRH     R1,[R0, #+0]
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       emberAfDeactivateClusterTick
    717                }
   \   00000050   0x1C76             ADDS     R6,R6,#+1
   \                     ??emberAfEndpointEnableDisable_2: (+1)
   \   00000052   0x68A8             LDR      R0,[R5, #+8]
   \   00000054   0x7901             LDRB     R1,[R0, #+4]
   \   00000056   0xB2F6             UXTB     R6,R6
   \   00000058   0x428E             CMP      R6,R1
   \   0000005A   0xD3EF             BCC.N    ??emberAfEndpointEnableDisable_3
    718              }
    719            }
    720          
    721            return TRUE;
   \                     ??emberAfEndpointEnableDisable_1: (+1)
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return
    722          }
    723          
    724          // Returns the index of a given endpoint.  Does not consider disabled endpoints.

   \                                 In section .text, align 2, keep-with-next
    725          int8u emberAfIndexFromEndpoint(int8u endpoint)
    726          {
    727            return findIndexFromEndpoint(endpoint,
    728                                         TRUE);    // ignore disabled endpoints?
   \                     emberAfIndexFromEndpoint: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             B.N      findIndexFromEndpoint
    729          }
    730          

   \                                 In section .text, align 2, keep-with-next
    731          int8u emberAfEndpointFromIndex(int8u index)
    732          {
    733            return emAfEndpoints[index].endpoint;
   \                     emberAfEndpointFromIndex: (+1)
   \   00000000   0x0100             LSLS     R0,R0,#+4
   \   00000002   0x....             LDR.N    R1,??DataTable38_1
   \   00000004   0x5C40             LDRB     R0,[R0, R1]
   \   00000006   0x4770             BX       LR               ;; return
    734          }
    735          
    736          // If server == true, returns the number of server clusters,
    737          // otherwise number of client clusters on this endpoint

   \                                 In section .text, align 2, keep-with-next
    738          int8u emberAfClusterCount(int8u endpoint, boolean server)
    739          {
   \                     emberAfClusterCount: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    740            int8u index = emberAfIndexFromEndpoint(endpoint);
   \   00000004   0x.... 0x....      BL       emberAfIndexFromEndpoint
   \   00000008   0x4601             MOV      R1,R0
    741            int8u i, c=0;
   \   0000000A   0x2000             MOVS     R0,#+0
    742            EmberAfDefinedEndpoint *de;
    743            EmberAfCluster *cluster;
    744          
    745            if ( index == 0xFF ) {
   \   0000000C   0x29FF             CMP      R1,#+255
   \   0000000E   0xBF1F             ITTTT    NE 
    746              return 0;
    747            }
    748            de = &(emAfEndpoints[index]);
   \   00000010   0x....             LDRNE.N  R2,??DataTable38_1
   \   00000012   0xEB02 0x1101      ADDNE    R1,R2,R1, LSL #+4
    749            if ( de->endpointType == NULL) {
   \   00000016   0x6889             LDRNE    R1,[R1, #+8]
   \   00000018   0x2900             CMPNE    R1,#+0
   \   0000001A   0xD014             BEQ.N    ??emberAfClusterCount_0
    750              return 0;
    751            }
    752            for ( i=0; i<de->endpointType->clusterCount; i++ ) {
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0xE003             B.N      ??emberAfClusterCount_1
    753              cluster = &(de->endpointType->cluster[i]);
    754              if ( server && emberAfClusterIsServer(cluster) )
   \                     ??emberAfClusterCount_2: (+1)
   \   00000020   0x061B             LSLS     R3,R3,#+24
   \                     ??emberAfClusterCount_3: (+1)
   \   00000022   0xBF48             IT       MI 
    755                c++;
    756              if ( (!server) && emberAfClusterIsClient(cluster) )
    757                c++;
   \   00000024   0x4628             MOVMI    R0,R5
   \   00000026   0x1C52             ADDS     R2,R2,#+1
   \                     ??emberAfClusterCount_1: (+1)
   \   00000028   0x790B             LDRB     R3,[R1, #+4]
   \   0000002A   0xB2D2             UXTB     R2,R2
   \   0000002C   0x429A             CMP      R2,R3
   \   0000002E   0xD209             BCS.N    ??emberAfClusterCount_4
   \   00000030   0x680D             LDR      R5,[R1, #+0]
   \   00000032   0x2314             MOVS     R3,#+20
   \   00000034   0xFB03 0x5302      MLA      R3,R3,R2,R5
   \   00000038   0x1C45             ADDS     R5,R0,#+1
   \   0000003A   0x7B1B             LDRB     R3,[R3, #+12]
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD0EF             BEQ.N    ??emberAfClusterCount_2
   \   00000040   0x065B             LSLS     R3,R3,#+25
   \   00000042   0xE7EE             B.N      ??emberAfClusterCount_3
    758            }
    759            return c;
   \                     ??emberAfClusterCount_4: (+1)
   \   00000044   0xB2C0             UXTB     R0,R0
   \                     ??emberAfClusterCount_0: (+1)
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    760          }
    761          

   \                                 In section .text, align 2, keep-with-next
    762          int8u emberAfGetClusterCountForEndpoint(int8u endpoint)
    763          {
   \                     emberAfGetClusterCountForEndpoint: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    764            int8u index = emberAfIndexFromEndpoint(endpoint);
   \   00000002   0x.... 0x....      BL       emberAfIndexFromEndpoint
    765            if ( index == 0xFF) {
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD101             BNE.N    ??emberAfGetClusterCountForEndpoint_0
    766              return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD02             POP      {R1,PC}
    767            }
    768            return emAfEndpoints[index].endpointType->clusterCount;
   \                     ??emberAfGetClusterCountForEndpoint_0: (+1)
   \   0000000E   0x....             LDR.N    R1,??DataTable38_1
   \   00000010   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   00000014   0x6880             LDR      R0,[R0, #+8]
   \   00000016   0x7900             LDRB     R0,[R0, #+4]
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    769          }
    770          
    771          // Note the difference in implementation from emberAfGetNthCluster().
    772          // emberAfGetClusterByIndex() retrieves the cluster by index regardless of server/client
    773          // and those indexes may be DIFFERENT than the indexes returned from 
    774          // emberAfGetNthCluster().  In other words:
    775          //
    776          //  - Use emberAfGetClustersFromEndpoint()  with emberAfGetNthCluster()
    777          //  - Use emberAfGetClusterCountForEndpoint() with emberAfGetClusterByIndex()
    778          //
    779          // Don't mix them.

   \                                 In section .text, align 2, keep-with-next
    780          EmberAfCluster* emberAfGetClusterByIndex(int8u endpoint, int8u clusterIndex)
    781          {
   \                     emberAfGetClusterByIndex: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    782            int8u endpointIndex = emberAfIndexFromEndpoint(endpoint);
   \   00000004   0x.... 0x....      BL       emberAfIndexFromEndpoint
    783            EmberAfDefinedEndpoint* definedEndpoint;
    784          
    785            if (endpointIndex == 0xFF) {
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xD006             BEQ.N    ??emberAfGetClusterByIndex_0
    786              return NULL;
    787            } 
    788            definedEndpoint = &(emAfEndpoints[endpointIndex]);
   \   0000000C   0x....             LDR.N    R1,??DataTable38_1
   \   0000000E   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
    789          
    790            if (clusterIndex >= definedEndpoint->endpointType->clusterCount) {
   \   00000012   0x6880             LDR      R0,[R0, #+8]
   \   00000014   0x7901             LDRB     R1,[R0, #+4]
   \   00000016   0x428C             CMP      R4,R1
   \   00000018   0xD301             BCC.N    ??emberAfGetClusterByIndex_1
    791              return NULL;
   \                     ??emberAfGetClusterByIndex_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD10             POP      {R4,PC}
    792            }
    793            return &(definedEndpoint->endpointType->cluster[clusterIndex]);
   \                     ??emberAfGetClusterByIndex_1: (+1)
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2114             MOVS     R1,#+20
   \   00000022   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    794          }
    795          

   \                                 In section .text, align 2, keep-with-next
    796          EmberAfProfileId emberAfGetProfileIdForEndpoint(int8u endpoint)
    797          {
   \                     emberAfGetProfileIdForEndpoint: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    798            int8u endpointIndex = emberAfIndexFromEndpoint(endpoint);
   \   00000002   0x.... 0x....      BL       emberAfIndexFromEndpoint
    799            if (endpointIndex == 0xFF) {
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD100             BNE.N    ??emberAfGetProfileIdForEndpoint_0
    800              return EMBER_AF_INVALID_PROFILE_ID;
   \   0000000A   0x....             B.N      ?Subroutine2
    801            }
    802            return emAfEndpoints[endpointIndex].profileId;
   \                     ??emberAfGetProfileIdForEndpoint_0: (+1)
   \   0000000C   0x....             LDR.N    R1,??DataTable38_1
   \   0000000E   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   00000012   0x8840             LDRH     R0,[R0, #+2]
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    803          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000004   0xBD02             POP      {R1,PC}
    804          

   \                                 In section .text, align 2, keep-with-next
    805          int16u emberAfGetDeviceIdForEndpoint(int8u endpoint)
    806          {
   \                     emberAfGetDeviceIdForEndpoint: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    807            int8u endpointIndex = emberAfIndexFromEndpoint(endpoint);
   \   00000002   0x.... 0x....      BL       emberAfIndexFromEndpoint
    808            if (endpointIndex == 0xFF) {
   \   00000006   0x28FF             CMP      R0,#+255
   \   00000008   0xD100             BNE.N    ??emberAfGetDeviceIdForEndpoint_0
    809              return EMBER_AF_INVALID_PROFILE_ID;
   \   0000000A   0x....             B.N      ?Subroutine2
    810            }
    811            return emAfEndpoints[endpointIndex].deviceId;
   \                     ??emberAfGetDeviceIdForEndpoint_0: (+1)
   \   0000000C   0x....             LDR.N    R1,??DataTable38_1
   \   0000000E   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   00000012   0x8880             LDRH     R0,[R0, #+4]
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    812          }
    813          
    814          // Returns the cluster of Nth server or client cluster,
    815          // depending on server toggle.

   \                                 In section .text, align 2, keep-with-next
    816          EmberAfCluster *emberAfGetNthCluster(int8u endpoint, int8u n, boolean server)
    817          {
   \                     emberAfGetNthCluster: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    818            int8u index = emberAfIndexFromEndpoint(endpoint);
   \   00000006   0x.... 0x....      BL       emberAfIndexFromEndpoint
    819            EmberAfDefinedEndpoint *de;
    820            int8u i,c=0;
   \   0000000A   0x2100             MOVS     R1,#+0
    821            EmberAfCluster *cluster;
    822          
    823            if ( index == 0xFF ) return NULL;
   \   0000000C   0x28FF             CMP      R0,#+255
   \   0000000E   0xD01A             BEQ.N    ??emberAfGetNthCluster_0
    824            de = &(emAfEndpoints[index]);
   \   00000010   0x....             LDR.N    R2,??DataTable38_1
   \   00000012   0xEB02 0x1200      ADD      R2,R2,R0, LSL #+4
    825          
    826            for ( i = 0; i < de->endpointType->clusterCount; i++ ) {
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0xE001             B.N      ??emberAfGetNthCluster_1
    827              cluster = &(de->endpointType->cluster[i]);
    828          
    829              if ( ( server && emberAfClusterIsServer(cluster) )
    830                   || ( (!server) &&  emberAfClusterIsClient(cluster) ) ) {
    831                if ( c == n ) {
    832                  return cluster;
    833                }
    834                c++;
   \                     ??emberAfGetNthCluster_2: (+1)
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \                     ??emberAfGetNthCluster_3: (+1)
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??emberAfGetNthCluster_1: (+1)
   \   0000001E   0x6890             LDR      R0,[R2, #+8]
   \   00000020   0x7906             LDRB     R6,[R0, #+4]
   \   00000022   0xB2DB             UXTB     R3,R3
   \   00000024   0x42B3             CMP      R3,R6
   \   00000026   0xD20E             BCS.N    ??emberAfGetNthCluster_0
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x2614             MOVS     R6,#+20
   \   0000002C   0xFB06 0x0003      MLA      R0,R6,R3,R0
   \   00000030   0x7B06             LDRB     R6,[R0, #+12]
   \   00000032   0xB115             CBZ.N    R5,??emberAfGetNthCluster_4
   \   00000034   0x0676             LSLS     R6,R6,#+25
   \   00000036   0xD402             BMI.N    ??emberAfGetNthCluster_5
   \   00000038   0xE7F0             B.N      ??emberAfGetNthCluster_3
   \                     ??emberAfGetNthCluster_4: (+1)
   \   0000003A   0x0636             LSLS     R6,R6,#+24
   \   0000003C   0xD5EE             BPL.N    ??emberAfGetNthCluster_3
   \                     ??emberAfGetNthCluster_5: (+1)
   \   0000003E   0xB2C9             UXTB     R1,R1
   \   00000040   0x42A1             CMP      R1,R4
   \   00000042   0xD1EA             BNE.N    ??emberAfGetNthCluster_2
   \   00000044   0xBD70             POP      {R4-R6,PC}
    835              }
    836          
    837            }
    838            return NULL;
   \                     ??emberAfGetNthCluster_0: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
    839          }
    840          
    841          // Returns number of clusters put into the passed cluster list
    842          // for the given endpoint and client/server polarity

   \                                 In section .text, align 2, keep-with-next
    843          int8u emberAfGetClustersFromEndpoint(int8u endpoint, EmberAfClusterId *clusterList, int8u listLen, boolean server) {
   \                     emberAfGetClustersFromEndpoint: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x461F             MOV      R7,R3
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x4616             MOV      R6,R2
    844            int8u clusterCount = emberAfClusterCount(endpoint, server);
   \   0000000C   0x4639             MOV      R1,R7
   \   0000000E   0x.... 0x....      BL       emberAfClusterCount
   \   00000012   0x4680             MOV      R8,R0
    845            int8u i;
    846            EmberAfCluster *cluster;
    847            if (clusterCount > listLen) {
   \   00000014   0x4546             CMP      R6,R8
   \   00000016   0xBFB8             IT       LT 
    848              clusterCount = listLen;
   \   00000018   0x46B0             MOVLT    R8,R6
    849            }
    850            for (i = 0; i < clusterCount; i++) {
   \   0000001A   0x2600             MOVS     R6,#+0
   \   0000001C   0xE002             B.N      ??emberAfGetClustersFromEndpoint_0
    851              cluster = emberAfGetNthCluster(endpoint, i, server);
    852              clusterList[i] = (cluster == NULL ? 0xFFFF : cluster->clusterId);
   \                     ??emberAfGetClustersFromEndpoint_1: (+1)
   \   0000001E   0xF825 0x0019      STRH     R0,[R5, R9, LSL #+1]
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \                     ??emberAfGetClustersFromEndpoint_0: (+1)
   \   00000024   0xB2F6             UXTB     R6,R6
   \   00000026   0x46B1             MOV      R9,R6
   \   00000028   0x45C1             CMP      R9,R8
   \   0000002A   0xDA0A             BGE.N    ??emberAfGetClustersFromEndpoint_2
   \   0000002C   0x463A             MOV      R2,R7
   \   0000002E   0x4631             MOV      R1,R6
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       emberAfGetNthCluster
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xBF0C             ITE      EQ 
   \   0000003A   0xF64F 0x70FF      MOVWEQ   R0,#+65535
   \   0000003E   0x8800             LDRHNE   R0,[R0, #+0]
   \   00000040   0xE7ED             B.N      ??emberAfGetClustersFromEndpoint_1
    853            }
    854            return clusterCount;
   \                     ??emberAfGetClustersFromEndpoint_2: (+1)
   \   00000042   0x4640             MOV      R0,R8
   \   00000044   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    855          }
    856          

   \                                 In section .text, align 2, keep-with-next
    857          void emberAfInitializeAttributes(int8u endpoint)
    858          {
    859            emAfLoadAttributeDefaults(endpoint, FALSE);
   \                     emberAfInitializeAttributes: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      emAfLoadAttributeDefaults
    860          }
    861          

   \                                 In section .text, align 2, keep-with-next
    862          void emberAfResetAttributes(int8u endpoint)
    863          {
    864            emAfLoadAttributeDefaults(endpoint, TRUE);
   \                     emberAfResetAttributes: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002                      REQUIRE emAfLoadAttributeDefaults
   \   00000002                      ;; // Fall through to label emAfLoadAttributeDefaults
    865          }
    866          

   \                                 In section .text, align 2, keep-with-next
    867          void emAfLoadAttributeDefaults(int8u endpoint, boolean writeTokens)
    868          {
   \                     emAfLoadAttributeDefaults: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x4688             MOV      R8,R1
    869            int8u ep, clusterI, curNetwork = emberGetCurrentNetwork();
   \   00000008   0x.... 0x....      BL       emberGetCurrentNetwork
   \   0000000C   0x9005             STR      R0,[SP, #+20]
    870            int16u attr;
    871            int8u *ptr;
    872            for ( ep = 0; ep < emberAfEndpointCount(); ep++ ) {
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   00000014   0x9001             STR      R0,[SP, #+4]
   \   00000016   0xE000             B.N      ??emAfLoadAttributeDefaults_0
   \                     ??emAfLoadAttributeDefaults_1: (+1)
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
   \                     ??emAfLoadAttributeDefaults_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable38
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0xB2ED             UXTB     R5,R5
   \   00000020   0x4285             CMP      R5,R0
   \   00000022   0xD276             BCS.N    ??emAfLoadAttributeDefaults_2
    873              EmberAfDefinedEndpoint *de;
    874              if (endpoint != EMBER_BROADCAST_ENDPOINT) {
   \   00000024   0x9801             LDR      R0,[SP, #+4]
   \   00000026   0x28FF             CMP      R0,#+255
   \   00000028   0xD006             BEQ.N    ??emAfLoadAttributeDefaults_3
    875                ep = emberAfIndexFromEndpoint(endpoint);
   \   0000002A   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \   0000002E   0x.... 0x....      BL       emberAfIndexFromEndpoint
   \   00000032   0x4605             MOV      R5,R0
    876                if (ep == 0xFF) {
   \   00000034   0x2DFF             CMP      R5,#+255
   \   00000036   0xD073             BEQ.N    ??emAfLoadAttributeDefaults_4
    877                  return;
    878                }
    879              }
    880              de = &(emAfEndpoints[ep]);
   \                     ??emAfLoadAttributeDefaults_3: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable38_1
   \   0000003A   0xEB00 0x1605      ADD      R6,R0,R5, LSL #+4
    881          
    882              // Ensure that the endpoint is on the current network
    883              if (endpoint == EMBER_BROADCAST_ENDPOINT
    884                  && de->networkIndex != curNetwork) {
   \   0000003E   0x9801             LDR      R0,[SP, #+4]
   \   00000040   0x28FF             CMP      R0,#+255
   \   00000042   0xD103             BNE.N    ??emAfLoadAttributeDefaults_5
   \   00000044   0x7B30             LDRB     R0,[R6, #+12]
   \   00000046   0x9905             LDR      R1,[SP, #+20]
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD1E5             BNE.N    ??emAfLoadAttributeDefaults_1
    885                continue;
    886              }
    887              for ( clusterI = 0; clusterI < de->endpointType->clusterCount; clusterI++) {
   \                     ??emAfLoadAttributeDefaults_5: (+1)
   \   0000004C   0xF04F 0x0A00      MOV      R10,#+0
   \   00000050   0xE001             B.N      ??emAfLoadAttributeDefaults_6
   \                     ??emAfLoadAttributeDefaults_7: (+1)
   \   00000052   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??emAfLoadAttributeDefaults_6: (+1)
   \   00000056   0x68B0             LDR      R0,[R6, #+8]
   \   00000058   0x7901             LDRB     R1,[R0, #+4]
   \   0000005A   0xFA5F 0xFA8A      UXTB     R10,R10
   \   0000005E   0x458A             CMP      R10,R1
   \   00000060   0xD254             BCS.N    ??emAfLoadAttributeDefaults_8
    888                EmberAfCluster *cluster = &(de->endpointType->cluster[clusterI]);
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x2114             MOVS     R1,#+20
   \   00000066   0xFB01 0x040A      MLA      R4,R1,R10,R0
    889          
    890                // when the attributeCount is high, the loop takes too long to run and a
    891                // watchdog kicks in causing a reset. As a workaround, we'll
    892                // conditionally manually reset the watchdog. 300 sounds like a good
    893                // magic number for now.
    894                if (cluster->attributeCount > 300){
   \   0000006A   0x8920             LDRH     R0,[R4, #+8]
   \   0000006C   0xF5B0 0x7F96      CMP      R0,#+300
   \   00000070   0xBFC8             IT       GT 
    895                  halResetWatchdog();
   \   00000072   0x.... 0x....      BLGT     halInternalResetWatchDog
    896                }
    897                for ( attr = 0; attr < cluster->attributeCount; attr++) {
   \   00000076   0xF04F 0x0900      MOV      R9,#+0
   \   0000007A   0xE013             B.N      ??emAfLoadAttributeDefaults_9
    898                  EmberAfAttributeMetadata *am = &(cluster->attributes[attr]);
    899                  if (!(am->mask & ATTRIBUTE_MASK_EXTERNAL_STORAGE)) {
    900                    EmberAfAttributeSearchRecord record;
    901                    record.endpoint = de->endpoint;
    902                    record.clusterId = cluster->clusterId;
    903                    record.clusterMask = (emberAfAttributeIsClient(am)
    904                                          ? CLUSTER_MASK_CLIENT
    905                                          : CLUSTER_MASK_SERVER);
    906                    record.attributeId = am->attributeId;
    907                    record.manufacturerCode = emAfGetManufacturerCodeForAttribute(cluster,
    908                                                                                  am);
    909                    if (am->mask & ATTRIBUTE_MASK_MIN_MAX) {
    910                      if ( emberAfAttributeSize(am) <= 2 ) {
    911                        ptr = (int8u*)&(am->defaultValue.ptrToMinMaxValue->defaultValue.defaultValue);
    912                      } else {
    913                        ptr = (int8u*)am->defaultValue.ptrToMinMaxValue->defaultValue.ptrToDefaultValue;
    914                      }
    915                    } else {
    916                      if ( emberAfAttributeSize(am) <= 2 ) {
    917                        ptr = (int8u*)&(am->defaultValue.defaultValue);
    918                      } else {
    919                        ptr = (int8u*)am->defaultValue.ptrToDefaultValue;
    920                      }
    921                    }
    922                    // At this point, ptr either points to a default value, or is NULL, in which case
    923                    // it should be treated as if it is pointing to an array of all zeroes.
    924          
    925          #if (BIGENDIAN_CPU)
    926                    // The default value for one- and two-byte attributes is stored in an
    927                    // int16u.  On big-endian platforms, a pointer to the default value of
    928                    // a one-byte attribute will point to the wrong byte.  So, for those
    929                    // cases, nudge the pointer forward so it points to the correct byte.
    930                    if (emberAfAttributeSize(am) == 1 && ptr != NULL) {
    931                      *ptr++;
    932                    }
    933          #endif //BIGENDIAN
    934                    emAfReadOrWriteAttribute(&record,
    935                                             NULL,  // metadata - unused
    936                                             ptr,
    937                                             0,     // buffer size - unused
    938                                             TRUE); // write?
   \                     ??emAfLoadAttributeDefaults_10: (+1)
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0x9000             STR      R0,[SP, #+0]
   \   00000080   0x2300             MOVS     R3,#+0
   \   00000082   0x465A             MOV      R2,R11
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0xA802             ADD      R0,SP,#+8
   \   00000088   0x.... 0x....      BL       emAfReadOrWriteAttribute
    939                    if (writeTokens) {
   \   0000008C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000090   0xD006             BEQ.N    ??emAfLoadAttributeDefaults_11
    940                      emAfSaveAttributeToToken(ptr, de->endpoint, record.clusterId, am);
   \   00000092   0xF8BD 0x200A      LDRH     R2,[SP, #+10]
   \   00000096   0x7831             LDRB     R1,[R6, #+0]
   \   00000098   0x463B             MOV      R3,R7
   \   0000009A   0x4658             MOV      R0,R11
   \   0000009C   0x.... 0x....      BL       emAfSaveAttributeToToken
    941                    }
   \                     ??emAfLoadAttributeDefaults_11: (+1)
   \   000000A0   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??emAfLoadAttributeDefaults_9: (+1)
   \   000000A4   0x8920             LDRH     R0,[R4, #+8]
   \   000000A6   0xFA1F 0xF989      UXTH     R9,R9
   \   000000AA   0x4581             CMP      R9,R0
   \   000000AC   0xD2D1             BCS.N    ??emAfLoadAttributeDefaults_7
   \   000000AE   0x6861             LDR      R1,[R4, #+4]
   \   000000B0   0x200C             MOVS     R0,#+12
   \   000000B2   0xFB00 0x1709      MLA      R7,R0,R9,R1
   \   000000B6   0x7938             LDRB     R0,[R7, #+4]
   \   000000B8   0x06C0             LSLS     R0,R0,#+27
   \   000000BA   0xD4F1             BMI.N    ??emAfLoadAttributeDefaults_11
   \   000000BC   0x7830             LDRB     R0,[R6, #+0]
   \   000000BE   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   000000C2   0x8820             LDRH     R0,[R4, #+0]
   \   000000C4   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   \   000000C8   0x7938             LDRB     R0,[R7, #+4]
   \   000000CA   0x0640             LSLS     R0,R0,#+25
   \   000000CC   0xBF4C             ITE      MI 
   \   000000CE   0x2080             MOVMI    R0,#+128
   \   000000D0   0x2040             MOVPL    R0,#+64
   \   000000D2   0xF88D 0x000C      STRB     R0,[SP, #+12]
   \   000000D6   0x4639             MOV      R1,R7
   \   000000D8   0x8838             LDRH     R0,[R7, #+0]
   \   000000DA   0xF8AD 0x000E      STRH     R0,[SP, #+14]
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0x.... 0x....      BL       emAfGetManufacturerCodeForAttribute
   \   000000E4   0xF8AD 0x0010      STRH     R0,[SP, #+16]
   \   000000E8   0x7939             LDRB     R1,[R7, #+4]
   \   000000EA   0x78F8             LDRB     R0,[R7, #+3]
   \   000000EC   0x0749             LSLS     R1,R1,#+29
   \   000000EE   0xD506             BPL.N    ??emAfLoadAttributeDefaults_12
   \   000000F0   0xF8D7 0xB008      LDR      R11,[R7, #+8]
   \   000000F4   0x2803             CMP      R0,#+3
   \   000000F6   0xDBC1             BLT.N    ??emAfLoadAttributeDefaults_10
   \   000000F8   0xF8DB 0xB000      LDR      R11,[R11, #+0]
   \   000000FC   0xE7BE             B.N      ??emAfLoadAttributeDefaults_10
   \                     ??emAfLoadAttributeDefaults_12: (+1)
   \   000000FE   0x2803             CMP      R0,#+3
   \   00000100   0xBFB4             ITE      LT 
   \   00000102   0xF107 0x0B08      ADDLT    R11,R7,#+8
   \   00000106   0xF8D7 0xB008      LDRGE    R11,[R7, #+8]
   \   0000010A   0xE7B7             B.N      ??emAfLoadAttributeDefaults_10
    942                  }
    943                }
    944              }
    945              if (endpoint != EMBER_BROADCAST_ENDPOINT) {
   \                     ??emAfLoadAttributeDefaults_8: (+1)
   \   0000010C   0x9801             LDR      R0,[SP, #+4]
   \   0000010E   0x28FF             CMP      R0,#+255
   \   00000110   0xD082             BEQ.N    ??emAfLoadAttributeDefaults_1
    946                break;
    947              }
    948            }
    949          
    950            if (!writeTokens) {
   \                     ??emAfLoadAttributeDefaults_2: (+1)
   \   00000112   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000116   0xBF04             ITT      EQ 
    951              emAfLoadAttributesFromTokens(endpoint);
   \   00000118   0xF89D 0x0018      LDRBEQ   R0,[SP, #+24]
   \   0000011C   0x.... 0x....      BLEQ     emAfLoadAttributesFromTokens
    952            }
    953          }
   \                     ??emAfLoadAttributeDefaults_4: (+1)
   \   00000120   0xB007             ADD      SP,SP,#+28
   \   00000122   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    954          

   \                                 In section .text, align 2, keep-with-next
    955          void emAfLoadAttributesFromTokens(int8u endpoint)
    956          {
   \                     emAfLoadAttributesFromTokens: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x4604             MOV      R4,R0
    957            // On EZSP host we currently do not support this. We need to come up with some
    958            // callbacks.
    959          #ifndef EZSP_HOST
    960            GENERATED_TOKEN_LOADER(endpoint);
   \   00000006   0x.... 0x....      BL       emberGetCurrentNetwork
   \   0000000A   0x4605             MOV      R5,R0
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x227F             MOVS     R2,#+127
   \   00000010   0x211E             MOVS     R1,#+30
   \   00000012   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_17: (+1)
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0xAB01             ADD      R3,SP,#+4
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000022   0x2321             MOVS     R3,#+33
   \   00000024   0x227F             MOVS     R2,#+127
   \   00000026   0x211F             MOVS     R1,#+31
   \   00000028   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_16: (+1)
   \   0000002C   0x2042             MOVS     R0,#+66
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0xAB01             ADD      R3,SP,#+4
   \   00000032   0x2204             MOVS     R2,#+4
   \   00000034   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000038   0x2321             MOVS     R3,#+33
   \   0000003A   0x227F             MOVS     R2,#+127
   \   0000003C   0x2120             MOVS     R1,#+32
   \   0000003E   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000042   0x2042             MOVS     R0,#+66
   \   00000044   0x9000             STR      R0,[SP, #+0]
   \   00000046   0xAB01             ADD      R3,SP,#+4
   \   00000048   0x2205             MOVS     R2,#+5
   \   0000004A   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000004E   0x2301             MOVS     R3,#+1
   \   00000050   0x227F             MOVS     R2,#+127
   \   00000052   0x2121             MOVS     R1,#+33
   \   00000054   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_14: (+1)
   \   00000058   0x2030             MOVS     R0,#+48
   \   0000005A   0x9000             STR      R0,[SP, #+0]
   \   0000005C   0xAB01             ADD      R3,SP,#+4
   \   0000005E   0x2207             MOVS     R2,#+7
   \   00000060   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0x.... 0x....      BL       emberAfNetworkIndexFromEndpoint
   \   0000006A   0x2C01             CMP      R4,#+1
   \   0000006C   0xD003             BEQ.N    ??emAfLoadAttributesFromTokens_0
   \   0000006E   0x2CFF             CMP      R4,#+255
   \   00000070   0xBF08             IT       EQ 
   \   00000072   0x42A8             CMPEQ    R0,R5
   \   00000074   0xD109             BNE.N    ??emAfLoadAttributesFromTokens_1
   \                     ??emAfLoadAttributesFromTokens_0: (+1)
   \   00000076   0x2301             MOVS     R3,#+1
   \   00000078   0x227F             MOVS     R2,#+127
   \   0000007A   0x2122             MOVS     R1,#+34
   \   0000007C   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000080   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x.... 0x....      BL       emberAfWriteServerAttribute
   \                     ??emAfLoadAttributesFromTokens_1: (+1)
   \   0000008A   0x2003             MOVS     R0,#+3
   \   0000008C   0x.... 0x....      BL       emberAfNetworkIndexFromEndpoint
   \   00000090   0x2C03             CMP      R4,#+3
   \   00000092   0xD003             BEQ.N    ??emAfLoadAttributesFromTokens_2
   \   00000094   0x2CFF             CMP      R4,#+255
   \   00000096   0xBF08             IT       EQ 
   \   00000098   0x42A8             CMPEQ    R0,R5
   \   0000009A   0xD109             BNE.N    ??emAfLoadAttributesFromTokens_3
   \                     ??emAfLoadAttributesFromTokens_2: (+1)
   \   0000009C   0x2301             MOVS     R3,#+1
   \   0000009E   0x227F             MOVS     R2,#+127
   \   000000A0   0x2123             MOVS     R1,#+35
   \   000000A2   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_12: (+1)
   \   000000A6   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_1: (+1)
   \   000000AA   0x2003             MOVS     R0,#+3
   \   000000AC   0x.... 0x....      BL       emberAfWriteServerAttribute
   \                     ??emAfLoadAttributesFromTokens_3: (+1)
   \   000000B0   0x2005             MOVS     R0,#+5
   \   000000B2   0x.... 0x....      BL       emberAfNetworkIndexFromEndpoint
   \   000000B6   0x2C05             CMP      R4,#+5
   \   000000B8   0xD003             BEQ.N    ??emAfLoadAttributesFromTokens_4
   \   000000BA   0x2CFF             CMP      R4,#+255
   \   000000BC   0xBF08             IT       EQ 
   \   000000BE   0x42A8             CMPEQ    R0,R5
   \   000000C0   0xD109             BNE.N    ??emAfLoadAttributesFromTokens_5
   \                     ??emAfLoadAttributesFromTokens_4: (+1)
   \   000000C2   0x2301             MOVS     R3,#+1
   \   000000C4   0x227F             MOVS     R2,#+127
   \   000000C6   0x2124             MOVS     R1,#+36
   \   000000C8   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_11: (+1)
   \   000000CC   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_2: (+1)
   \   000000D0   0x2005             MOVS     R0,#+5
   \   000000D2   0x.... 0x....      BL       emberAfWriteServerAttribute
   \                     ??emAfLoadAttributesFromTokens_5: (+1)
   \   000000D6   0x2007             MOVS     R0,#+7
   \   000000D8   0x.... 0x....      BL       emberAfNetworkIndexFromEndpoint
   \   000000DC   0x2C07             CMP      R4,#+7
   \   000000DE   0xD003             BEQ.N    ??emAfLoadAttributesFromTokens_6
   \   000000E0   0x2CFF             CMP      R4,#+255
   \   000000E2   0xBF08             IT       EQ 
   \   000000E4   0x42A8             CMPEQ    R0,R5
   \   000000E6   0xD109             BNE.N    ??emAfLoadAttributesFromTokens_7
   \                     ??emAfLoadAttributesFromTokens_6: (+1)
   \   000000E8   0x2301             MOVS     R3,#+1
   \   000000EA   0x227F             MOVS     R2,#+127
   \   000000EC   0x2125             MOVS     R1,#+37
   \   000000EE   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_10: (+1)
   \   000000F2   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_3: (+1)
   \   000000F6   0x2007             MOVS     R0,#+7
   \   000000F8   0x.... 0x....      BL       emberAfWriteServerAttribute
   \                     ??emAfLoadAttributesFromTokens_7: (+1)
   \   000000FC   0x200F             MOVS     R0,#+15
   \   000000FE   0x.... 0x....      BL       emberAfNetworkIndexFromEndpoint
   \   00000102   0x2C0F             CMP      R4,#+15
   \   00000104   0xD003             BEQ.N    ??emAfLoadAttributesFromTokens_8
   \   00000106   0x2CFF             CMP      R4,#+255
   \   00000108   0xBF08             IT       EQ 
   \   0000010A   0x42A8             CMPEQ    R0,R5
   \   0000010C   0xD109             BNE.N    ??emAfLoadAttributesFromTokens_9
   \                     ??emAfLoadAttributesFromTokens_8: (+1)
   \   0000010E   0x2301             MOVS     R3,#+1
   \   00000110   0x227F             MOVS     R2,#+127
   \   00000112   0x2126             MOVS     R1,#+38
   \   00000114   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000118   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000011C   0x200F             MOVS     R0,#+15
   \   0000011E   0x.... 0x....      BL       emberAfWriteServerAttribute
    961          #endif // EZSP_HOST
    962          }
   \                     ??emAfLoadAttributesFromTokens_9: (+1)
   \   00000122   0xB00B             ADD      SP,SP,#+44
   \   00000124   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0xA801             ADD      R0,SP,#+4
   \   00000002   0x.... 0x....      B.W      halInternalGetTokenData

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      B.W      emberAfWriteServerAttribute

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2010             MOVS     R0,#+16
   \   00000002   0x9000             STR      R0,[SP, #+0]
   \   00000004   0xAB01             ADD      R3,SP,#+4
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2106             MOVS     R1,#+6
   \   0000000A   0x4770             BX       LR
    963          
    964          // 'data' argument may be null, since we changed the ptrToDefaultValue
    965          // to be null instead of pointing to all zeroes.
    966          // This function has to be able to deal with that.

   \                                 In section .text, align 2, keep-with-next
    967          void emAfSaveAttributeToToken(int8u *data,
    968                                        int8u endpoint,
    969                                        EmberAfClusterId clusterId,
    970                                        EmberAfAttributeMetadata *metadata)
    971          {
   \                     emAfSaveAttributeToToken: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x461E             MOV      R6,R3
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x4607             MOV      R7,R0
    972            // Get out of here if this attribute doesn't have a token.
    973            if ( !emberAfAttributeIsTokenized(metadata)) return;
   \   00000008   0x7930             LDRB     R0,[R6, #+4]
   \   0000000A   0x460C             MOV      R4,R1
   \   0000000C   0x4615             MOV      R5,R2
   \   0000000E   0x0780             LSLS     R0,R0,#+30
   \   00000010   0xD57A             BPL.N    ??emAfSaveAttributeToToken_0
    974          
    975          // On EZSP host we currently do not support this. We need to come up with some
    976          // callbacks.
    977          #ifndef EZSP_HOST
    978            GENERATED_TOKEN_SAVER;
   \   00000012   0x2221             MOVS     R2,#+33
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xA800             ADD      R0,SP,#+0
   \   00000018   0x.... 0x....      BL       halCommonMemSet
   \   0000001C   0xB907             CBNZ.N   R7,??emAfSaveAttributeToToken_1
   \   0000001E   0xAF00             ADD      R7,SP,#+0
   \                     ??emAfSaveAttributeToToken_1: (+1)
   \   00000020   0xBB65             CBNZ.N   R5,??emAfSaveAttributeToToken_2
   \   00000022   0x8830             LDRH     R0,[R6, #+0]
   \   00000024   0xB938             CBNZ.N   R0,??emAfSaveAttributeToToken_3
   \   00000026   0x7930             LDRB     R0,[R6, #+4]
   \   00000028   0x0640             LSLS     R0,R0,#+25
   \   0000002A   0xD427             BMI.N    ??emAfSaveAttributeToToken_2
   \   0000002C   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_18: (+1)
   \   00000030   0x201E             MOVS     R0,#+30
   \   00000032   0x.... 0x....      BL       halInternalSetTokenData
   \                     ??emAfSaveAttributeToToken_3: (+1)
   \   00000036   0x8830             LDRH     R0,[R6, #+0]
   \   00000038   0x2804             CMP      R0,#+4
   \   0000003A   0xD108             BNE.N    ??emAfSaveAttributeToToken_4
   \   0000003C   0x7930             LDRB     R0,[R6, #+4]
   \   0000003E   0x0640             LSLS     R0,R0,#+25
   \   00000040   0xD405             BMI.N    ??emAfSaveAttributeToToken_4
   \   00000042   0x2321             MOVS     R3,#+33
   \   00000044   0x463A             MOV      R2,R7
   \   00000046   0x217F             MOVS     R1,#+127
   \   00000048   0x201F             MOVS     R0,#+31
   \   0000004A   0x.... 0x....      BL       halInternalSetTokenData
   \                     ??emAfSaveAttributeToToken_4: (+1)
   \   0000004E   0x8830             LDRH     R0,[R6, #+0]
   \   00000050   0x2805             CMP      R0,#+5
   \   00000052   0xD108             BNE.N    ??emAfSaveAttributeToToken_5
   \   00000054   0x7930             LDRB     R0,[R6, #+4]
   \   00000056   0x0640             LSLS     R0,R0,#+25
   \   00000058   0xD405             BMI.N    ??emAfSaveAttributeToToken_5
   \   0000005A   0x2321             MOVS     R3,#+33
   \   0000005C   0x463A             MOV      R2,R7
   \   0000005E   0x217F             MOVS     R1,#+127
   \   00000060   0x2020             MOVS     R0,#+32
   \   00000062   0x.... 0x....      BL       halInternalSetTokenData
   \                     ??emAfSaveAttributeToToken_5: (+1)
   \   00000066   0x8830             LDRH     R0,[R6, #+0]
   \   00000068   0x2807             CMP      R0,#+7
   \   0000006A   0xD107             BNE.N    ??emAfSaveAttributeToToken_2
   \   0000006C   0x7930             LDRB     R0,[R6, #+4]
   \   0000006E   0x0640             LSLS     R0,R0,#+25
   \   00000070   0xD404             BMI.N    ??emAfSaveAttributeToToken_2
   \   00000072   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_19: (+1)
   \   00000076   0x2021             MOVS     R0,#+33
   \   00000078   0x.... 0x....      BL       halInternalSetTokenData
   \                     ??emAfSaveAttributeToToken_2: (+1)
   \   0000007C   0x2C01             CMP      R4,#+1
   \   0000007E   0xD10B             BNE.N    ??emAfSaveAttributeToToken_6
   \   00000080   0x2D06             CMP      R5,#+6
   \   00000082   0xBF04             ITT      EQ 
   \   00000084   0x8830             LDRHEQ   R0,[R6, #+0]
   \   00000086   0x2800             CMPEQ    R0,#+0
   \   00000088   0xD13E             BNE.N    ??emAfSaveAttributeToToken_0
   \   0000008A   0x7930             LDRB     R0,[R6, #+4]
   \   0000008C   0x0640             LSLS     R0,R0,#+25
   \   0000008E   0xD43B             BMI.N    ??emAfSaveAttributeToToken_0
   \   00000090   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_20: (+1)
   \   00000094   0x2022             MOVS     R0,#+34
   \   00000096   0xE035             B.N      ??emAfSaveAttributeToToken_7
   \                     ??emAfSaveAttributeToToken_6: (+1)
   \   00000098   0x2C03             CMP      R4,#+3
   \   0000009A   0xD10B             BNE.N    ??emAfSaveAttributeToToken_8
   \   0000009C   0x2D06             CMP      R5,#+6
   \   0000009E   0xBF04             ITT      EQ 
   \   000000A0   0x8830             LDRHEQ   R0,[R6, #+0]
   \   000000A2   0x2800             CMPEQ    R0,#+0
   \   000000A4   0xD130             BNE.N    ??emAfSaveAttributeToToken_0
   \   000000A6   0x7930             LDRB     R0,[R6, #+4]
   \   000000A8   0x0640             LSLS     R0,R0,#+25
   \   000000AA   0xD42D             BMI.N    ??emAfSaveAttributeToToken_0
   \   000000AC   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_21: (+1)
   \   000000B0   0x2023             MOVS     R0,#+35
   \   000000B2   0xE027             B.N      ??emAfSaveAttributeToToken_7
   \                     ??emAfSaveAttributeToToken_8: (+1)
   \   000000B4   0x2C05             CMP      R4,#+5
   \   000000B6   0xD10B             BNE.N    ??emAfSaveAttributeToToken_9
   \   000000B8   0x2D06             CMP      R5,#+6
   \   000000BA   0xBF04             ITT      EQ 
   \   000000BC   0x8830             LDRHEQ   R0,[R6, #+0]
   \   000000BE   0x2800             CMPEQ    R0,#+0
   \   000000C0   0xD122             BNE.N    ??emAfSaveAttributeToToken_0
   \   000000C2   0x7930             LDRB     R0,[R6, #+4]
   \   000000C4   0x0640             LSLS     R0,R0,#+25
   \   000000C6   0xD41F             BMI.N    ??emAfSaveAttributeToToken_0
   \   000000C8   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_22: (+1)
   \   000000CC   0x2024             MOVS     R0,#+36
   \   000000CE   0xE019             B.N      ??emAfSaveAttributeToToken_7
   \                     ??emAfSaveAttributeToToken_9: (+1)
   \   000000D0   0x2C07             CMP      R4,#+7
   \   000000D2   0xD10B             BNE.N    ??emAfSaveAttributeToToken_10
   \   000000D4   0x2D06             CMP      R5,#+6
   \   000000D6   0xBF04             ITT      EQ 
   \   000000D8   0x8830             LDRHEQ   R0,[R6, #+0]
   \   000000DA   0x2800             CMPEQ    R0,#+0
   \   000000DC   0xD114             BNE.N    ??emAfSaveAttributeToToken_0
   \   000000DE   0x7930             LDRB     R0,[R6, #+4]
   \   000000E0   0x0640             LSLS     R0,R0,#+25
   \   000000E2   0xD411             BMI.N    ??emAfSaveAttributeToToken_0
   \   000000E4   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_23: (+1)
   \   000000E8   0x2025             MOVS     R0,#+37
   \   000000EA   0xE00B             B.N      ??emAfSaveAttributeToToken_7
   \                     ??emAfSaveAttributeToToken_10: (+1)
   \   000000EC   0x2C0F             CMP      R4,#+15
   \   000000EE   0xBF08             IT       EQ 
   \   000000F0   0x2D06             CMPEQ    R5,#+6
   \   000000F2   0xD109             BNE.N    ??emAfSaveAttributeToToken_0
   \   000000F4   0x8830             LDRH     R0,[R6, #+0]
   \   000000F6   0xB938             CBNZ.N   R0,??emAfSaveAttributeToToken_0
   \   000000F8   0x7930             LDRB     R0,[R6, #+4]
   \   000000FA   0x0640             LSLS     R0,R0,#+25
   \   000000FC   0xD404             BMI.N    ??emAfSaveAttributeToToken_0
   \   000000FE   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_24: (+1)
   \   00000102   0x2026             MOVS     R0,#+38
   \                     ??emAfSaveAttributeToToken_7: (+1)
   \   00000104   0x.... 0x....      BL       halInternalSetTokenData
    979          #endif // EZSP_HOST
    980          }
   \                     ??emAfSaveAttributeToToken_0: (+1)
   \   00000108   0xB009             ADD      SP,SP,#+36
   \   0000010A   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x2301             MOVS     R3,#+1
   \   00000002   0x463A             MOV      R2,R7
   \   00000004   0x217F             MOVS     R1,#+127
   \   00000006   0x4770             BX       LR
    981          
    982          // This function returns the actual function point from the array,
    983          // iterating over the function bits.

   \                                 In section .text, align 2, keep-with-next
    984          EmberAfGenericClusterFunction
    985          emberAfFindClusterFunction(EmberAfCluster *cluster,
    986                                     EmberAfClusterMask functionMask) {
   \                     emberAfFindClusterFunction: (+1)
   \   00000000   0xB518             PUSH     {R3,R4,LR}
    987            EmberAfClusterMask mask = 0x01;
    988            int8u functionIndex = 0;
    989          
    990            if ( (cluster->mask & functionMask) == 0 )
   \   00000002   0x7B04             LDRB     R4,[R0, #+12]
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x420C             TST      R4,R1
   \   0000000A   0xD105             BNE.N    ??emberAfFindClusterFunction_0
    991              return NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD12             POP      {R1,R4,PC}
    992          
    993            while ( mask < functionMask ) {
    994              if ( (cluster->mask & mask) != 0 )
   \                     ??emberAfFindClusterFunction_1: (+1)
   \   00000010   0x4214             TST      R4,R2
   \   00000012   0xBF18             IT       NE 
    995                functionIndex++;
   \   00000014   0x1C5B             ADDNE    R3,R3,#+1
    996              mask <<= 1;
   \   00000016   0x0052             LSLS     R2,R2,#+1
    997            }
   \                     ??emberAfFindClusterFunction_0: (+1)
   \   00000018   0xB2D2             UXTB     R2,R2
   \   0000001A   0x428A             CMP      R2,R1
   \   0000001C   0xD3F8             BCC.N    ??emberAfFindClusterFunction_1
    998            return cluster->functions[functionIndex];
   \   0000001E   0x6900             LDR      R0,[R0, #+16]
   \   00000020   0xB2DB             UXTB     R3,R3
   \   00000022   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
   \   00000026   0xBD12             POP      {R1,R4,PC}       ;; return
    999          }
   1000          
   1001          #ifdef EMBER_AF_SUPPORT_COMMAND_DISCOVERY
   1002          /**
   1003           * This function populates command IDs into a given buffer.
   1004           *
   1005           * It returns TRUE if commands are complete, meaning there are NO MORE
   1006           * commands that would be returned after the last command.
   1007           * It returns FALSE, if there were more commands, but were not populated
   1008           * because of maxIdCount limitation.
   1009           */

   \                                 In section .text, align 2, keep-with-next
   1010          boolean emberAfExtractCommandIds(boolean outgoing,
   1011                                           EmberAfClusterCommand *cmd,
   1012                                           int16u clusterId,
   1013                                           int8u *buffer,
   1014                                           int16u bufferLength,
   1015                                           int16u *bufferIndex,
   1016                                           int8u startId,
   1017                                           int8u maxIdCount) {
   \                     emberAfExtractCommandIds: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x460A             MOV      R2,R1
   1018            int16u i, count=0;
   \   00000006   0x2700             MOVS     R7,#+0
   1019            boolean returnValue = TRUE;
   \   00000008   0x2101             MOVS     R1,#+1
   1020            int8u cmdDirMask = 0;
   1021          
   1022            // determine the appropriate mask to match the request
   1023            // discover commands generated, client is asking server what commands do you generate?
   1024            if (outgoing && (cmd->direction == ZCL_DIRECTION_CLIENT_TO_SERVER)) {
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0x7D50             LDRB     R0,[R2, #+21]
   \   0000000E   0xD007             BEQ.N    ??emberAfExtractCommandIds_0
   \   00000010   0xB910             CBNZ.N   R0,??emberAfExtractCommandIds_1
   1025              cmdDirMask = COMMAND_MASK_OUTGOING_SERVER;
   \   00000012   0xF04F 0x0C02      MOV      R12,#+2
   \   00000016   0xE009             B.N      ??emberAfExtractCommandIds_2
   1026            // discover commands generated server is asking client what commands do you generate?
   1027            } else if (outgoing && (cmd->direction == ZCL_DIRECTION_SERVER_TO_CLIENT)) {
   \                     ??emberAfExtractCommandIds_1: (+1)
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD105             BNE.N    ??emberAfExtractCommandIds_3
   1028              cmdDirMask = COMMAND_MASK_OUTGOING_CLIENT;
   \   0000001C   0x468C             MOV      R12,R1
   \   0000001E   0xE005             B.N      ??emberAfExtractCommandIds_2
   1029            // discover commands received client is asking server what commands do you receive?
   1030            } else if (!outgoing && (cmd->direction == ZCL_DIRECTION_CLIENT_TO_SERVER)) {
   \                     ??emberAfExtractCommandIds_0: (+1)
   \   00000020   0xB910             CBNZ.N   R0,??emberAfExtractCommandIds_3
   1031              cmdDirMask = COMMAND_MASK_INCOMING_SERVER;
   \   00000022   0xF04F 0x0C08      MOV      R12,#+8
   \   00000026   0xE001             B.N      ??emberAfExtractCommandIds_2
   1032            // discover commands received server is asking client what commands do you receive?
   1033            } else {
   1034              cmdDirMask = COMMAND_MASK_INCOMING_CLIENT;
   \                     ??emberAfExtractCommandIds_3: (+1)
   \   00000028   0xF04F 0x0C04      MOV      R12,#+4
   1035            }
   1036          
   1037            for ( i = 0; i < EMBER_AF_GENERATED_COMMAND_COUNT; i++ ) {
   \                     ??emberAfExtractCommandIds_2: (+1)
   \   0000002C   0x980A             LDR      R0,[SP, #+40]
   \   0000002E   0x9C0B             LDR      R4,[SP, #+44]
   \   00000030   0xF8DD 0x9030      LDR      R9,[SP, #+48]
   \   00000034   0xF8DD 0xA034      LDR      R10,[SP, #+52]
   \   00000038   0x.... 0x....      ADR.W    R8,generatedCommands
   \   0000003C   0x46BE             MOV      LR,R7
   1038              if ( generatedCommands[i].clusterId != clusterId )
   \                     ??emberAfExtractCommandIds_4: (+1)
   \   0000003E   0xF838 0x602E      LDRH     R6,[R8, LR, LSL #+2]
   \   00000042   0xF8BD 0x5000      LDRH     R5,[SP, #+0]
   \   00000046   0x42AE             CMP      R6,R5
   \   00000048   0xD11C             BNE.N    ??emberAfExtractCommandIds_5
   1039                continue;
   1040          
   1041              if ((generatedCommands[i].mask & cmdDirMask) == 0 )
   \   0000004A   0xEB08 0x058E      ADD      R5,R8,LR, LSL #+2
   \   0000004E   0x78EE             LDRB     R6,[R5, #+3]
   \   00000050   0xEA16 0x0F0C      TST      R6,R12
   \   00000054   0xD016             BEQ.N    ??emberAfExtractCommandIds_5
   1042                continue;
   1043          
   1044              //Only start from the passed command id
   1045              if (generatedCommands[i].commandId < startId)
   \   00000056   0x78AE             LDRB     R6,[R5, #+2]
   \   00000058   0x454E             CMP      R6,R9
   \   0000005A   0xD313             BCC.N    ??emberAfExtractCommandIds_5
   1046                continue;
   1047          
   1048              // According to spec: if cmd->mfgSpecific is set, then we ONLY return the
   1049              // mfg specific commands. If it's not, then we ONLY return non-mfg specific.
   1050              if ( generatedCommands[i].mask & COMMAND_MASK_MANUFACTURER_SPECIFIC ) {
   \   0000005C   0x78EE             LDRB     R6,[R5, #+3]
   \   0000005E   0x06F6             LSLS     R6,R6,#+27
   \   00000060   0x7BD6             LDRB     R6,[R2, #+15]
   \   00000062   0xD501             BPL.N    ??emberAfExtractCommandIds_6
   1051                 // Command is Mfg specific
   1052                if ( !cmd->mfgSpecific ) continue; // ignore if asking for not mfg specific
   \   00000064   0xB90E             CBNZ.N   R6,??emberAfExtractCommandIds_7
   \   00000066   0xE00D             B.N      ??emberAfExtractCommandIds_5
   1053             } else {
   1054                // Command is not mfg specific.
   1055                if ( cmd->mfgSpecific ) continue; // Ignore if asking for mfg specific
   \                     ??emberAfExtractCommandIds_6: (+1)
   \   00000068   0xB966             CBNZ.N   R6,??emberAfExtractCommandIds_5
   1056              }
   1057          
   1058              // The one we are about to put in, is beyond the maxIdCount,
   1059              // so instead of populating it in, we set the return flag to
   1060              // false and get out of here.
   1061              if ( maxIdCount == count || count >= bufferLength ) {
   \                     ??emberAfExtractCommandIds_7: (+1)
   \   0000006A   0x45BA             CMP      R10,R7
   \   0000006C   0xD001             BEQ.N    ??emberAfExtractCommandIds_8
   \   0000006E   0x4287             CMP      R7,R0
   \   00000070   0xDB01             BLT.N    ??emberAfExtractCommandIds_9
   1062                returnValue = FALSE;
   \                     ??emberAfExtractCommandIds_8: (+1)
   \   00000072   0x2100             MOVS     R1,#+0
   1063                break;
   \   00000074   0xE00D             B.N      ??emberAfExtractCommandIds_10
   1064              }
   1065              buffer[count] = generatedCommands[i].commandId;
   \                     ??emberAfExtractCommandIds_9: (+1)
   \   00000076   0x78AE             LDRB     R6,[R5, #+2]
   \   00000078   0x54FE             STRB     R6,[R7, R3]
   1066              (*bufferIndex)++;
   1067              count++;
   \   0000007A   0x1C7F             ADDS     R7,R7,#+1
   \   0000007C   0x8826             LDRH     R6,[R4, #+0]
   \   0000007E   0x1C76             ADDS     R6,R6,#+1
   \   00000080   0x8026             STRH     R6,[R4, #+0]
   \   00000082   0xB2BF             UXTH     R7,R7
   1068            }
   \                     ??emberAfExtractCommandIds_5: (+1)
   \   00000084   0xF10E 0x0601      ADD      R6,LR,#+1
   \   00000088   0xFA1F 0xFE86      UXTH     LR,R6
   \   0000008C   0xF1BE 0x0F1E      CMP      LR,#+30
   \   00000090   0xDBD5             BLT.N    ??emberAfExtractCommandIds_4
   1069            return returnValue;
   \                     ??emberAfExtractCommandIds_10: (+1)
   \   00000092   0x4608             MOV      R0,R1
   \   00000094   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1070          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   0x........         DC32     emberEndpointCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \   00000000   0x........         DC32     emAfEndpoints

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_2:
   \   00000000   0x........         DC32     emberAfExternalAttributeWriteCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_3:
   \   00000000   0x........         DC32     emberAfExternalAttributeReadCallback

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0, 0, 0, 0, 0, 0, 0, 0, 0}>`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 15}>`:
   \   00000000   0x01 0x02          DC8 1, 2, 3, 4, 5, 6, 7, 8, 15, 0, 0, 0
   \              0x03 0x04    
   \              0x05 0x06    
   \              0x07 0x08    
   \              0x0F 0x00    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {260, 260, 260, 260, 260, 260, 260,`:
   \   00000000   0x0104 0x0104      DC16 260, 260, 260, 260, 260, 260, 260, 260, 260
   \              0x0104 0x0104
   \              0x0104 0x0104
   \              0x0104 0x0104
   \              0x0104       
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {256, 259, 256, 259, 256, 259, 256,`:
   \   00000000   0x0100 0x0103      DC16 256, 259, 256, 259, 256, 259, 256, 259, 256
   \              0x0100 0x0103
   \              0x0100 0x0103
   \              0x0100 0x0103
   \              0x0100       
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {1, 1, 1, 1, 1, 1, 1, 1, 1}>`:
   \   00000000   0x01 0x01          DC8 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x01    
   \              0x01 0x00    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {1, 0, 1, 0, 1, 0, 1, 0, 2}>`:
   \   00000000   0x01 0x00          DC8 1, 0, 1, 0, 1, 0, 1, 0, 2, 0, 0, 0
   \              0x01 0x00    
   \              0x01 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x00 0x00    
   1071          #else
   1072          // We just need an empty stub if we don't support it
   1073          boolean emberAfExtractCommandIds(boolean outgoing,
   1074                                           EmberAfClusterCommand *cmd,
   1075                                           int16u clusterId,
   1076                                           int8u *buffer,
   1077                                           int16u bufferLength,
   1078                                           int16u *bufferIndex,
   1079                                           int8u startId,
   1080                                           int8u maxIdCount) {
   1081            return TRUE;
   1082          }
   1083          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   emAfCallInits
        16   -> emberAfEndpointIndexIsEnabled
        16   -> initializeEndpoint
      24   emAfClusterAttributeChangedCallback
        24   -- Indirect call
        24   -> emberAfFindCluster
        24   -> emberAfFindClusterFunction
         0   -> emberAfPopNetworkIndex
        24   -> emberAfPushEndpointNetworkIndex
      24   emAfClusterPreAttributeChangedCallback
        24   -- Indirect call
        24   -> emberAfFindCluster
        24   -> emberAfFindClusterFunction
        24   -> emberAfPopNetworkIndex
        24   -> emberAfPushEndpointNetworkIndex
       0   emAfGetManufacturerCodeForAttribute
         0   -> emAfGetManufacturerCodeForCluster
         0   -> getManufacturerCode
       0   emAfGetManufacturerCodeForCluster
         0   -> getManufacturerCode
      64   emAfLoadAttributeDefaults
        64   -> emAfGetManufacturerCodeForAttribute
        64   -> emAfLoadAttributesFromTokens
        64   -> emAfReadOrWriteAttribute
        64   -> emAfSaveAttributeToToken
        64   -> emberAfIndexFromEndpoint
        64   -> emberGetCurrentNetwork
        64   -> halInternalResetWatchDog
      56   emAfLoadAttributesFromTokens
        56   -> emberAfNetworkIndexFromEndpoint
        56   -> emberAfWriteServerAttribute
        56   -> emberGetCurrentNetwork
        56   -> halInternalGetTokenData
       8   emAfMatchAttribute
         8   -> emAfGetManufacturerCodeForAttribute
       8   emAfMatchCluster
         8   -> emAfGetManufacturerCodeForCluster
      48   emAfReadOrWriteAttribute
        48   -- Indirect call
        48   -> emAfGetManufacturerCodeForAttribute
        48   -> emAfMatchAttribute
        48   -> emAfMatchCluster
        48   -> emberAfCopyLongString
        48   -> emberAfCopyString
        48   -> emberAfEndpointIndexIsEnabled
        48   -> emberAfIsLongStringAttributeType
        48   -> emberAfIsStringAttributeType
        48   -> halCommonMemMove
        48   -> halCommonMemSet
      56   emAfSaveAttributeToToken
        56   -> halCommonMemSet
        56   -> halInternalSetTokenData
      16   emberAfClusterCount
        16   -> emberAfIndexFromEndpoint
      24   emberAfClusterDefaultResponseCallback
        24   -- Indirect call
        24   -> emberAfFindCluster
        24   -> emberAfFindClusterFunction
         0   -> emberAfPopNetworkIndex
        24   -> emberAfPushEndpointNetworkIndex
      40   emberAfClusterIndex
        40   -> emberAfFindClusterInType
      40   emberAfClusterMessageSentCallback
        40   -- Indirect call
        40   -> emberAfFindCluster
        40   -> emberAfFindClusterFunction
         0   -> emberAfPopNetworkIndex
        40   -> emberAfPushEndpointNetworkIndex
       8   emberAfContainsClient
         8   -> emberAfFindCluster
       8   emberAfContainsCluster
         8   -> emberAfFindCluster
       8   emberAfContainsServer
         8   -> emberAfFindCluster
      96   emberAfEndpointConfigure
        96   -> __aeabi_memcpy4
       0   emberAfEndpointCount
      16   emberAfEndpointEnableDisable
        16   -> emberAfDeactivateClusterTick
        16   -> findIndexFromEndpoint
        16   -> initializeEndpoint
       0   emberAfEndpointFromIndex
       0   emberAfEndpointIndexIsEnabled
       8   emberAfEndpointIsEnabled
         8   -> emberAfEndpointIndexIsEnabled
         8   -> findIndexFromEndpoint
      40   emberAfExtractCommandIds
      16   emberAfFindCluster
         0   -> emberAfFindClusterInType
        16   -> emberAfIndexFromEndpoint
       0   emberAfFindClusterClientEndpointIndex
         0   -> findClusterEndpointIndex
      12   emberAfFindClusterFunction
      16   emberAfFindClusterInType
       0   emberAfFindClusterServerEndpointIndex
         0   -> findClusterEndpointIndex
       0   emberAfFixedEndpointCount
       8   emberAfGetClusterByIndex
         8   -> emberAfIndexFromEndpoint
       8   emberAfGetClusterCountForEndpoint
         8   -> emberAfIndexFromEndpoint
      32   emberAfGetClustersFromEndpoint
        32   -> emberAfClusterCount
        32   -> emberAfGetNthCluster
       8   emberAfGetDeviceIdForEndpoint
         8   -> emberAfIndexFromEndpoint
      16   emberAfGetNthCluster
        16   -> emberAfIndexFromEndpoint
       8   emberAfGetProfileIdForEndpoint
         8   -> emberAfIndexFromEndpoint
       0   emberAfIndexFromEndpoint
         0   -> findIndexFromEndpoint
       0   emberAfInitializeAttributes
         0   -> emAfLoadAttributeDefaults
       0   emberAfIsLongStringAttributeType
       0   emberAfIsStringAttributeType
       0   emberAfIsThisDataTypeAStringType
      32   emberAfLocateAttributeMetadata
        32   -> emAfReadOrWriteAttribute
       0   emberAfResetAttributes
         0   -> emAfLoadAttributeDefaults
       0   emberAfSetEndpointCount
      32   findClusterEndpointIndex
        32   -> emberAfFindCluster
      12   findIndexFromEndpoint
       8   getManufacturerCode
      24   initializeEndpoint
        24   -- Indirect call
        24   -> emberAfClusterInitCallback
        24   -> emberAfFindClusterFunction
         0   -> emberAfPopNetworkIndex
        24   -> emberAfPushEndpointNetworkIndex


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant {0, 0, 0, 0, 0, 0, 0, 0, 0}>
      12  ?<Constant {1, 0, 1, 0, 1, 0, 1, 0, 2}>
      12  ?<Constant {1, 1, 1, 1, 1, 1, 1, 1, 1}>
      12  ?<Constant {1, 2, 3, 4, 5, 6, 7, 8, 15}>
      20  ?<Constant {256, 259, 256, 259, 256, 259, 256,
      20  ?<Constant {260, 260, 260, 260, 260, 260, 260,
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_2
       4  ??DataTable38_3
       8  ?Subroutine0
      10  ?Subroutine1
       6  ?Subroutine2
      12  ?Subroutine3
       8  ?Subroutine4
       6  ?Subroutine5
       8  ?Subroutine6
       2  attributeManufacturerCodeCount
       4  attributeManufacturerCodes
       2  clusterManufacturerCodeCount
       4  clusterManufacturerCodes
      42  emAfCallInits
      70  emAfClusterAttributeChangedCallback
      64  emAfClusterPreAttributeChangedCallback
     144  emAfEndpoints
      34  emAfGetManufacturerCodeForAttribute
      22  emAfGetManufacturerCodeForCluster
     294  emAfLoadAttributeDefaults
     294  emAfLoadAttributesFromTokens
      38  emAfMatchAttribute
      44  emAfMatchCluster
       1  emAfNetworkTypes
     406  emAfReadOrWriteAttribute
     268  emAfSaveAttributeToToken
       2  emAfZigbeeProNetworks
      72  emberAfClusterCount
      44  emberAfClusterDefaultResponseCallback
      72  emberAfClusterIndex
      88  emberAfClusterMessageSentCallback
       6  emberAfContainsClient
       6  emberAfContainsCluster
       4  emberAfContainsServer
     148  emberAfEndpointConfigure
       8  emberAfEndpointCount
      96  emberAfEndpointEnableDisable
       8  emberAfEndpointFromIndex
      16  emberAfEndpointIndexIsEnabled
      24  emberAfEndpointIsEnabled
     152  emberAfExtractCommandIds
      38  emberAfFindCluster
       2  emberAfFindClusterClientEndpointIndex
      40  emberAfFindClusterFunction
      60  emberAfFindClusterInType
       4  emberAfFindClusterServerEndpointIndex
       4  emberAfFixedEndpointCount
       4  emberAfFuncArrayGroupsClusterServer
       8  emberAfFuncArrayIdentifyClusterServer
       4  emberAfFuncArrayScenesClusterServer
      40  emberAfGetClusterByIndex
      26  emberAfGetClusterCountForEndpoint
      72  emberAfGetClustersFromEndpoint
      22  emberAfGetDeviceIdForEndpoint
      74  emberAfGetNthCluster
      22  emberAfGetProfileIdForEndpoint
       4  emberAfIndexFromEndpoint
       4  emberAfInitializeAttributes
      16  emberAfIsLongStringAttributeType
      16  emberAfIsStringAttributeType
      24  emberAfIsThisDataTypeAStringType
      50  emberAfLocateAttributeMetadata
       2  emberAfResetAttributes
      10  emberAfSetEndpointCount
     152  emberEndpointCount
          attributeData
          singletonAttributeData
      76  findClusterEndpointIndex
      46  findIndexFromEndpoint
     204  generatedAttributes
     280  generatedClusters
     120  generatedCommands
      68  generatedDefaults
      24  generatedEmberAfEndpointTypes
      30  getManufacturerCode
      58  initializeEndpoint

 
   296 bytes in section .bss
   103 bytes in section .rodata
 3 846 bytes in section .text
 
 3 846 bytes of CODE  memory
   103 bytes of CONST memory
   296 bytes of DATA  memory

Errors: none
Warnings: none

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        19/Apr/2016  16:28:30
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\UART_task.c
#    Command line =  
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\UART_task.c"
#        -D SWITCH_4_BUTTON -D NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D
#        CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"UART_task.c\"" -lC "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\4
#        nut\List\" --diag_suppress Pa050 -o "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\4
#        nut\Obj\" --debug --endian=little --cpu=Cortex-M3
#        --no_path_in_file_macros --separate_cluster_for_initialized_variables
#        -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\" -I
#        "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\"
#        -I "D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\"
#        -Ohz --use_c++_inline
#    List file    =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\4
#        nut\List\UART_task.lst
#    Object file  =  
#        D:\Work
#        Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\4
#        nut\Obj\UART_task.o
#
###############################################################################

D:\Work Space\Silabs\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\UART_task.c
      1          
      2          
      3          
      4          
      5          
      6          
      7          //-----------------------------Khai bao thu vien---------------------//
      8          
      9          
     10          #include "app/framework/include/af.h"
     11          #include "task.h"
     12          #include "ButtonExe.h"
     13          #include "UART_task.h"
     14          #include "halDelay.h"
     15          #include "ConfigDevice.h"
     16          
     17          //-----------------------------Khai bao bien-------------------------//

   \                                 In section .data, align 2
     18          int8u UART_PACKET_KEY[2]	=	{0x4C,0x4D};
   \                     UART_PACKET_KEY:
   \   00000000   0x4C 0x4D          DC8 76, 77
     19          
     20          
     21          

   \                                 In section .bss, align 4
     22          int8u UartTxCommandBuff[256];
   \                     UartTxCommandBuff:
   \   00000000                      DS8 256
     23          #define MAX_RX_BUFFER  256

   \                                 In section .bss, align 2
     24          int16u UartTxCommandStartWaitTimer = 0;
   \                     UartTxCommandStartWaitTimer:
   \   00000000                      DS8 2
     25          int16u UartTxCommandCurrentTimeOut = 0;
   \                     UartTxCommandCurrentTimeOut:
   \   00000002                      DS8 2
     26          
     27          
     28          

   \                                 In section .bss, align 4
     29          int8u UartRxDataStep = 0;
   \                     UartRxDataStep:
   \   00000000                      DS8 1
     30          int8u UartRxPacketLength;
   \                     UartRxPacketLength:
   \   00000001                      DS8 1
     31          int8u UartRxPacketCheckXor = 0;
     32          int8u UartRxCommandData[64] = {0};
     33          int8u UartRxCurrentLength = 0;
   \                     UartRxCurrentLength:
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \                     UartRxCommandData:
   \   00000004                      DS8 64

   \                                 In section .bss, align 1
   \                     UartRxPacketCheckXor:
   \   00000000                      DS8 1
     34          
     35          //extern int8u McReadyStatus;
     36          
     37          
     38          
     39          //-------------------------------Enum------------------------------//
     40          
     41          
     42          typedef enum UartRxCommand_ID{
     43          	RelayStatusChange 	= 0xA0,
     44          	CurtainLevelChange 	= 0xA1,
     45          	DimmerLevelChange 	= 0xA2,
     46          	FanLevelChange 	  	= 0x03,
     47          	TouchButtonHold 	= 0xA7,
     48          	McTimmerCalibrate	= 0xAE,
     49          	CheckMcReady		= 0xD0,
     50          	McClockCalibrate	= 0xD1,
     51          };
                  ^
Warning[Pe375]: declaration requires a typedef name
     52          
     53          
     54          
     55          //-------------------------------CallTask------------------------------//
     56          
     57          
     58          //------------------------CallTaskRelayChangeCommand-------------------//
     59          typedef enum RelayStateCmd{
     60          	RelayOff			= 0,
     61          	RelayOn				= 1,
     62          };
                  ^
Warning[Pe375]: declaration requires a typedef name
     63          
     64          
     65          

   \                                 In section .text, align 2, keep-with-next
     66          void CallTaskRelayChangeCommand( unsigned char *Data){
   \                     CallTaskRelayChangeCommand: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
     67               int8u i;
     68          	 int8u RelayState = Data[1];
   \   00000002   0x7844             LDRB     R4,[R0, #+1]
     69          	 int8u CurrentState[4] = {0};
   \   00000004   0xA802             ADD      R0,SP,#+8
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6001             STR      R1,[R0, #+0]
     70          	 for(i=0;i<4;i++){
   \   0000000A   0x2500             MOVS     R5,#+0
     71          		emberAfReadServerAttribute(2*i+1, ZCL_ON_OFF_CLUSTER_ID,ZCL_ON_OFF_ATTRIBUTE_ID,
     72          						&CurrentState[i], sizeof(CurrentState[i]));
   \                     ??CallTaskRelayChangeCommand_0: (+1)
   \   0000000C   0x0068             LSLS     R0,R5,#+1
   \   0000000E   0x1C46             ADDS     R6,R0,#+1
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xA802             ADD      R0,SP,#+8
   \   00000018   0x182B             ADDS     R3,R5,R0
   \   0000001A   0x2106             MOVS     R1,#+6
   \   0000001C   0xB2F0             UXTB     R0,R6
   \   0000001E   0x.... 0x....      BL       emberAfReadServerAttribute
     73          		if(CurrentState[i] != ((RelayState >> i) & 0x01)){
   \   00000022   0xA802             ADD      R0,SP,#+8
   \   00000024   0xFA24 0xF705      LSR      R7,R4,R5
   \   00000028   0x5C28             LDRB     R0,[R5, R0]
   \   0000002A   0xF007 0x0101      AND      R1,R7,#0x1
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD02E             BEQ.N    ??CallTaskRelayChangeCommand_1
     74          			int8u Relay;
     75          			//call button press call back;
     76          			 CallButtonPress(i);
   \   00000032   0xB2E8             UXTB     R0,R5
   \   00000034   0x.... 0x....      BL       beButtonPress
     77          			// and always wtite relay attribute
     78          			 switch((RelayState >> i) & 0x01){
   \   00000038   0xF017 0x0001      ANDS     R0,R7,#0x1
   \   0000003C   0xD004             BEQ.N    ??CallTaskRelayChangeCommand_2
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD10C             BNE.N    ??CallTaskRelayChangeCommand_3
     79          				 case RelayOn:
     80          				 {
     81          					Relay = 1;
   \   00000042   0xF88D 0x0004      STRB     R0,[SP, #+4]
     82          					emberAfWriteServerAttribute(2*i+1,
     83          						ZCL_ON_OFF_CLUSTER_ID,ZCL_ON_OFF_ATTRIBUTE_ID, &Relay, sizeof(Relay));
   \   00000046   0xE002             B.N      ??CallTaskRelayChangeCommand_4
     84          				 }
     85          					break;
     86          				 case RelayOff:
     87          				 {
     88          					Relay = 0;
   \                     ??CallTaskRelayChangeCommand_2: (+1)
   \   00000048   0xF88D 0x0004      STRB     R0,[SP, #+4]
     89          					emberAfWriteServerAttribute(2*i+1,
     90          						ZCL_ON_OFF_CLUSTER_ID,ZCL_ON_OFF_ATTRIBUTE_ID, &Relay, sizeof(Relay));
   \   0000004C   0x2001             MOVS     R0,#+1
   \                     ??CallTaskRelayChangeCommand_4: (+1)
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0xAB01             ADD      R3,SP,#+4
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x2106             MOVS     R1,#+6
   \   00000056   0xB2F0             UXTB     R0,R6
   \   00000058   0x.... 0x....      BL       emberAfWriteServerAttribute
     91          				 }
     92          					break;
     93          				default:
     94          					break;
     95          			}
     96          			EmberNetworkStatus NetworkStatus;
     97          			NetworkStatus = emberAfNetworkState();
     98          
     99          			if(NetworkStatus == EMBER_JOINED_NETWORK) {
   \                     ??CallTaskRelayChangeCommand_3: (+1)
   \   0000005C   0x.... 0x....      BL       emberAfNetworkState
   \   00000060   0x2802             CMP      R0,#+2
   \   00000062   0xD10A             BNE.N    ??CallTaskRelayChangeCommand_5
    100                          EmberStatus sendStatus;
                                             ^
Warning[Pe550]: variable "sendStatus" was set but never used
    101          
    102          		//	 	Send to Bind Device
    103          				sendStatus = SendViaBindingTable(2*i+1,Relay,OnOffType);
   \   00000064   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000068   0x2201             MOVS     R2,#+1
   \   0000006A   0xB2F0             UXTB     R0,R6
   \   0000006C   0x.... 0x....      BL       SendViaBindingTable
    104          
    105          		//		Send On-Off AttributeResponse, Zipato stupid update :D-----------------------------//
    106          				SendOnOffControlReadAttribute(2*i+1,Relay);
   \   00000070   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000074   0xB2F0             UXTB     R0,R6
   \   00000076   0x.... 0x....      BL       SendOnOffControlReadAttribute
    107          			}
    108          
    109          		// on-off led
    110          
    111          			if(Relay == 1){
   \                     ??CallTaskRelayChangeCommand_5: (+1)
   \   0000007A   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000007E   0x1C68             ADDS     R0,R5,#+1
   \   00000080   0x2901             CMP      R1,#+1
   \   00000082   0xB2C0             UXTB     R0,R0
   \   00000084   0xD102             BNE.N    ??CallTaskRelayChangeCommand_6
    112          				CommonSetLed(i+1);
   \   00000086   0x.... 0x....      BL       CommonSetLed
   \   0000008A   0xE001             B.N      ??CallTaskRelayChangeCommand_1
    113          			}
    114          			else{
    115          				CommonClearLed(i+1);
   \                     ??CallTaskRelayChangeCommand_6: (+1)
   \   0000008C   0x.... 0x....      BL       CommonClearLed
    116          			}
    117          		}
    118          	}
   \                     ??CallTaskRelayChangeCommand_1: (+1)
   \   00000090   0x1C6D             ADDS     R5,R5,#+1
   \   00000092   0x2D04             CMP      R5,#+4
   \   00000094   0xDBBA             BLT.N    ??CallTaskRelayChangeCommand_0
    119          }
   \   00000096   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    120          
    121          //------------------------CallTaskLevelControlCommand-------------------//
    122          
    123          

   \                                 In section .text, align 2, keep-with-next
    124          void CallTaskDimmerLevelChangeCommand(int8u *Data){
   \                     CallTaskDimmerLevelChangeCommand: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    125          	int8u DimmerLevel;
    126          	DimmerLevel = Data[1];
   \   00000004   0x7840             LDRB     R0,[R0, #+1]
   \   00000006   0xF88D 0x0004      STRB     R0,[SP, #+4]
    127          
    128          
    129              int8u CurrentDimmerLevel;
    130          	emberAfReadServerAttribute(DimmerInClusterEndpoint, ZCL_LEVEL_CONTROL_CLUSTER_ID,ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    131          				&CurrentDimmerLevel, sizeof(CurrentDimmerLevel));
   \   0000000A   0xF10D 0x0306      ADD      R3,SP,#+6
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x2108             MOVS     R1,#+8
   \   00000016   0x.... 0x....      BL       emberAfReadServerAttribute
    132          	if(CurrentDimmerLevel != DimmerLevel) {
   \   0000001A   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   0000001E   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD027             BEQ.N    ??CallTaskDimmerLevelChangeCommand_0
    133          
    134          // 		write attribute
    135          		emberAfWriteServerAttribute(DimmerInClusterEndpoint,ZCL_LEVEL_CONTROL_CLUSTER_ID,
    136          									ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    137          									&DimmerLevel, sizeof(DimmerLevel));
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0xAB01             ADD      R3,SP,#+4
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x2108             MOVS     R1,#+8
   \   00000030   0x.... 0x....      BL       emberAfWriteServerAttribute
    138          		int8u OnOffValue;
    139          		if(DimmerLevel == 0){
   \   00000034   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xBF07             ITTEE    EQ 
    140          			OnOffValue = 0;
   \   0000003C   0xF88D 0x0005      STRBEQ   R0,[SP, #+5]
    141          			emberAfWriteServerAttribute(DimmerInClusterEndpoint,ZCL_ON_OFF_CLUSTER_ID,
    142          									ZCL_ON_OFF_ATTRIBUTE_ID,
    143          									&OnOffValue, sizeof(OnOffValue));
   \   00000040   0x2001             MOVEQ    R0,#+1
    144          		}
    145          		else{
    146          			OnOffValue = 1;
   \   00000042   0x2001             MOVNE    R0,#+1
   \   00000044   0xF88D 0x0005      STRBNE   R0,[SP, #+5]
    147          			emberAfWriteServerAttribute(DimmerInClusterEndpoint,ZCL_ON_OFF_CLUSTER_ID,
    148          						ZCL_ON_OFF_ATTRIBUTE_ID,
    149          						&OnOffValue, sizeof(OnOffValue));
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0xF10D 0x0305      ADD      R3,SP,#+5
   \   0000004E   0x2200             MOVS     R2,#+0
   \   00000050   0x2106             MOVS     R1,#+6
   \   00000052   0x.... 0x....      BL       emberAfWriteServerAttribute
    150          		}
    151          //	 	Send to Bind Device
    152          		EmberStatus sendStatus;
                 		            ^
Warning[Pe550]: variable "sendStatus" was set but never used
    153          		sendStatus = SendViaBindingTable(DimmerInClusterEndpoint,DimmerLevel,LevelWithOnOffType);
   \   00000056   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000005A   0x2203             MOVS     R2,#+3
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x.... 0x....      BL       SendViaBindingTable
    154          
    155          //		Send Level AttributeResponse, Zipato stupid update :D-----------------------------//
    156          		SendLevelControlReadAttribute(DimmerInClusterEndpoint,DimmerLevel);
   \   00000062   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x.... 0x....      BL       SendLevelControlReadAttribute
    157          //		Send On-Off AttributeResponse, Zipato stupid update :D-----------------------------//
    158          		SendOnOffControlReadAttribute(DimmerInClusterEndpoint,OnOffValue);
   \   0000006C   0xF89D 0x1005      LDRB     R1,[SP, #+5]
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x.... 0x....      BL       SendOnOffControlReadAttribute
    159          	}
    160          }
   \                     ??CallTaskDimmerLevelChangeCommand_0: (+1)
   \   00000076   0xBD07             POP      {R0-R2,PC}       ;; return
    161          
    162          
    163          
    164          //------------------------CallTaskMcClockCalibrate-------------------//
    165          
    166          
    167          

   \                                 In section .text, align 2, keep-with-next
    168          void CallTaskMcClockCalibrate(int8u *Data){
   \                     CallTaskMcClockCalibrate: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    169          	int8u DataCheckKey[16] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,
    170          										0xBB,0xCC,0xDD,0xEE,0xFF};
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1`
   \   0000000A   0x.... 0x....      BL       ?Subroutine6
    171          	if(MEMCOMPARE(&Data[1], DataCheckKey, 0) == 0){
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000000E   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000012   0xB908             CBNZ.N   R0,??CallTaskMcClockCalibrate_0
    172          		UartSendMcClockCalibrate();
   \   00000014   0x.... 0x....      BL       UartSendMcClockCalibrate
    173          	}
    174          }
   \                     ??CallTaskMcClockCalibrate_0: (+1)
   \   00000018   0xBD1F             POP      {R0-R4,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0xA900             ADD      R1,SP,#+0
   \   00000004   0x1C60             ADDS     R0,R4,#+1
   \   00000006   0x.... 0x....      B.W      halCommonMemCompare

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x2210             MOVS     R2,#+16
   \   00000002   0x.... 0x....      B.W      __aeabi_memcpy4
    175          //------------------------CallTaskCheckMcReady-------------------//
    176          // This Uart Command Indicator MC StartUp, or EM reset end StartUp

   \                                 In section .text, align 2, keep-with-next
    177          void CallTaskCheckMcReady(int8u *Data){
   \                     CallTaskCheckMcReady: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    178          	EmberNetworkStatus NetworkStatus;
    179          	int8u DataCheckKey[16] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,
    180          										0xBB,0xCC,0xDD,0xEE,0xFF};
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_1`
   \   0000000A   0x.... 0x....      BL       ?Subroutine6
    181          	if(MEMCOMPARE(&Data[1], DataCheckKey, 0) == 0){
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000000E   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000012   0xB9D8             CBNZ.N   R0,??CallTaskCheckMcReady_0
    182          
    183          		UartSendBlinkLed(0x0F, 2);
   \   00000014   0x2102             MOVS     R1,#+2
   \   00000016   0x200F             MOVS     R0,#+15
   \   00000018   0x.... 0x....      BL       UartSendBlinkLed
    184          #ifdef SWITCH_TYPE
    185          		UartSendSwitchControlStateMark(0x00);  // Get switch state after reset
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       UartSendSwitchControlStateMark
    186          #endif
    187          
    188          		NetworkStatus = emberAfNetworkState();
    189          		if(NetworkStatus == EMBER_JOINED_NETWORK) {
   \   00000022   0x.... 0x....      BL       emberAfNetworkState
   \   00000026   0x2802             CMP      R0,#+2
   \   00000028   0xD106             BNE.N    ??CallTaskCheckMcReady_1
    190          			UartSendBlinkLed(0x0F, 1);
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x200F             MOVS     R0,#+15
   \   0000002E   0x.... 0x....      BL       UartSendBlinkLed
    191          //		This Command is EM after reset, so all startup code can be set here.
    192          			GetHcActiveEndPoint();
                 			^
Warning[Pe223]: function "GetHcActiveEndPoint" declared implicitly
   \   00000032   0x.... 0x....      BL       GetHcActiveEndPoint
   \   00000036   0xBD1F             POP      {R0-R4,PC}
    193          		}
    194          		else{
    195          		    CallJoinTask(0xFF,3000 + ((int8u)halCommonGetRandom()<<2));
   \                     ??CallTaskCheckMcReady_1: (+1)
   \   00000038   0x.... 0x....      BL       halCommonGetRandom
   \   0000003C   0x0600             LSLS     R0,R0,#+24
   \   0000003E   0x0D80             LSRS     R0,R0,#+22
   \   00000040   0xF600 0x31B8      ADDW     R1,R0,#+3000
   \   00000044   0xB289             UXTH     R1,R1
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0x.... 0x....      BL       CallJoinTask
    196          		}
    197          	}
    198          }
   \                     ??CallTaskCheckMcReady_0: (+1)
   \   0000004C   0xBD1F             POP      {R0-R4,PC}       ;; return
    199          //------------------------CallTaskTouchButtonHold--------------------//
    200          typedef enum ButtonHoldCmd{
    201          	ButtonUnpress		= 0,
    202          	ButtonShortHold		= 1,
    203          	ButtonLongHold		= 2,
    204              ButtonResetHold		= 3,
    205          };
                  ^
Warning[Pe375]: declaration requires a typedef name

   \                                 In section .text, align 2, keep-with-next
    206          void CallTaskTouchButtonHold(int8u *Data){
    207          	int8u ButtonPress = Data[1] + 1;
   \                     CallTaskTouchButtonHold: (+1)
   \   00000000   0x7841             LDRB     R1,[R0, #+1]
    208          	int8u ButtonHoldType = Data[2];
    209          
    210          	switch (ButtonHoldType & 0x03){
   \   00000002   0x7880             LDRB     R0,[R0, #+2]
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \   00000006   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000000A   0xD003             BEQ.N    ??CallTaskTouchButtonHold_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD007             BEQ.N    ??CallTaskTouchButtonHold_1
   \   00000010   0xD303             BCC.N    ??CallTaskTouchButtonHold_2
   \   00000012   0x4770             BX       LR
    211          		case ButtonUnpress:
    212          			CallButtonRelease(ButtonPress);
   \                     ??CallTaskTouchButtonHold_0: (+1)
   \   00000014   0xB2C8             UXTB     R0,R1
   \   00000016   0x.... 0x....      B.W      beButtonRealease
    213          		break;
    214          		case ButtonShortHold:
    215          			CallButtonShortHold(ButtonPress);
   \                     ??CallTaskTouchButtonHold_2: (+1)
   \   0000001A   0xB2C8             UXTB     R0,R1
   \   0000001C   0x.... 0x....      B.W      beButtonPress2Time
    216          		break;
    217          		case ButtonLongHold:
    218          			CallButtonLongHold(ButtonPress);
   \                     ??CallTaskTouchButtonHold_1: (+1)
   \   00000020   0xB2C8             UXTB     R0,R1
   \   00000022   0x.... 0x....      B.W      beButtonPress3Time
    219          		break;
    220          		case ButtonResetHold:
    221          		break;
    222          		default:
    223          		break;
    224          
    225          	}
    226          }
    227          //------------------------CallTaskCalibrateTimmer--------------------//

   \                                 In section .text, align 2, keep-with-next
    228          void CallTaskMcTimmerCalibrate(int8u *Data){
    229          	int8u Inverval = Data[1];
    230          	int8u Times	= Data[2];
    231          	CallMcTimmerCalibrateTask(Inverval,Times);
   \                     CallTaskMcTimmerCalibrate: (+1)
   \   00000000   0x7881             LDRB     R1,[R0, #+2]
   \   00000002   0x7840             LDRB     R0,[R0, #+1]
   \   00000004   0x.... 0x....      B.W      CallMcTimmerCalibrateTask
    232          
    233          }
    234          
    235          //----------------------------CallTask--------------------------------//
    236          

   \                                 In section .text, align 2, keep-with-next
    237          void CallUartTask(int8u *UartPacketCommand){
    238          	int8u UartPacketID = UartPacketCommand[0];
    239          
    240          	switch(UartPacketID){
   \                     CallUartTask: (+1)
   \   00000000   0x7801             LDRB     R1,[R0, #+0]
   \   00000002   0x29A0             CMP      R1,#+160
   \   00000004   0xD00A             BEQ.N    ??CallUartTask_0
   \   00000006   0x29A2             CMP      R1,#+162
   \   00000008   0xD009             BEQ.N    ??CallUartTask_1
   \   0000000A   0x29A7             CMP      R1,#+167
   \   0000000C   0xD008             BEQ.N    ??CallUartTask_2
   \   0000000E   0x29AE             CMP      R1,#+174
   \   00000010   0xD007             BEQ.N    ??CallUartTask_3
   \   00000012   0x29D0             CMP      R1,#+208
   \   00000014   0xD007             BEQ.N    ??CallUartTask_4
   \   00000016   0x29D1             CMP      R1,#+209
   \   00000018   0xD004             BEQ.N    ??CallUartTask_5
   \   0000001A   0x4770             BX       LR
    241          		case RelayStatusChange:
    242          			CallTaskRelayChangeCommand(UartPacketCommand);
   \                     ??CallUartTask_0: (+1)
   \   0000001C   0x....             B.N      CallTaskRelayChangeCommand
    243          			break;
    244          		case CurtainLevelChange:
    245          			break;
    246          		case DimmerLevelChange:
    247          			CallTaskDimmerLevelChangeCommand(UartPacketCommand);
   \                     ??CallUartTask_1: (+1)
   \   0000001E   0x....             B.N      CallTaskDimmerLevelChangeCommand
    248          			break;
    249          		case FanLevelChange:
    250          			break;
    251          		case TouchButtonHold:
    252          			CallTaskTouchButtonHold(UartPacketCommand);
   \                     ??CallUartTask_2: (+1)
   \   00000020   0x....             B.N      CallTaskTouchButtonHold
    253          			break;
    254          		case McTimmerCalibrate:
    255          			CallTaskMcTimmerCalibrate(UartPacketCommand);
   \                     ??CallUartTask_3: (+1)
   \   00000022   0x....             B.N      CallTaskMcTimmerCalibrate
    256          			break;
    257          		case McClockCalibrate:
    258          			CallTaskMcClockCalibrate(UartPacketCommand);
   \                     ??CallUartTask_5: (+1)
   \   00000024   0x....             B.N      CallTaskMcClockCalibrate
    259          			break;
    260          		case CheckMcReady:
    261          			CallTaskCheckMcReady(UartPacketCommand);
   \                     ??CallUartTask_4: (+1)
   \   00000026   0x....             B.N      CallTaskCheckMcReady
    262          			break;
    263          		default:
    264          			break;
    265          	}
    266          }
    267          
    268          
    269          
    270          

   \                                 In section .text, align 2, keep-with-next
    271          void UartScanCommand(void){
   \                     UartScanCommand: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    272          	int16u NumberOfByteReCeiver;
    273          	int8u ReadSerialData;
    274          	int8u ReadStatus;
    275          
    276          
    277          	NumberOfByteReCeiver = emberSerialReadAvailable (1);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       emberSerialReadAvailable
   \   00000008   0x0004             MOVS     R4,R0
    278          	if(NumberOfByteReCeiver > 0){
   \   0000000A   0xD047             BEQ.N    ??UartScanCommand_0
    279          		ReadStatus = emberSerialReadByte(1, &ReadSerialData);
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       emberSerialReadByte
   \   00000014   0x4605             MOV      R5,R0
    280          		{
    281          
    282          			emberSerialWriteData(1,&ReadSerialData,NumberOfByteReCeiver) ;
   \   00000016   0xB2E2             UXTB     R2,R4
   \   00000018   0xA900             ADD      R1,SP,#+0
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x.... 0x....      BL       emberSerialWriteData
    283          
    284          			if(ReadStatus == EMBER_SUCCESS){
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD13B             BNE.N    ??UartScanCommand_0
    285          
    286          				switch (UartRxDataStep){
   \   00000024   0x.... 0x....      LDR.W    R4,??DataTable11
   \   00000028   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002C   0x7821             LDRB     R1,[R4, #+0]
   \   0000002E   0xB129             CBZ.N    R1,??UartScanCommand_1
   \   00000030   0x2902             CMP      R1,#+2
   \   00000032   0xD00C             BEQ.N    ??UartScanCommand_2
   \   00000034   0xD306             BCC.N    ??UartScanCommand_3
   \   00000036   0x2903             CMP      R1,#+3
   \   00000038   0xD00F             BEQ.N    ??UartScanCommand_4
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}
    287          				case 0:
    288          					if(ReadSerialData == 0x4C){
   \                     ??UartScanCommand_1: (+1)
   \   0000003C   0x284C             CMP      R0,#+76
   \   0000003E   0xD12D             BNE.N    ??UartScanCommand_0
    289          						UartRxDataStep = 1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE02A             B.N      ??UartScanCommand_5
    290          					}
    291          					else{
    292          						UartRxDataStep = 0;
    293          					}
    294          				break;
    295          				case 1:
    296          					if(ReadSerialData == 0x4D){
   \                     ??UartScanCommand_3: (+1)
   \   00000044   0x284D             CMP      R0,#+77
   \   00000046   0xBF14             ITE      NE 
    297          						UartRxDataStep = 2;
    298          					}
    299          					else{
    300          						UartRxDataStep = 0;
   \   00000048   0x2000             MOVNE    R0,#+0
    301          					}
   \   0000004A   0x2002             MOVEQ    R0,#+2
   \   0000004C   0xE025             B.N      ??UartScanCommand_5
    302          				break;
    303          				case 2:
    304          					UartRxPacketLength = ReadSerialData;
   \                     ??UartScanCommand_2: (+1)
   \   0000004E   0x7060             STRB     R0,[R4, #+1]
    305          					if(UartRxPacketLength >40){
   \   00000050   0x2829             CMP      R0,#+41
   \   00000052   0xBFB4             ITE      LT 
    306          						UartRxDataStep = 0;
    307          					}
    308          					else{
    309          						UartRxDataStep = 3;
   \   00000054   0x2003             MOVLT    R0,#+3
    310          					}
   \   00000056   0x2000             MOVGE    R0,#+0
   \   00000058   0xE01F             B.N      ??UartScanCommand_5
    311          				break;
    312          				case 3:
    313          					if(UartRxCurrentLength < UartRxPacketLength-1){
   \                     ??UartScanCommand_4: (+1)
   \   0000005A   0x7860             LDRB     R0,[R4, #+1]
   \   0000005C   0x78A1             LDRB     R1,[R4, #+2]
   \   0000005E   0x1E40             SUBS     R0,R0,#+1
   \   00000060   0x4281             CMP      R1,R0
   \   00000062   0xDA06             BGE.N    ??UartScanCommand_6
    314          						UartRxCommandData[UartRxCurrentLength] =  ReadSerialData;
   \   00000064   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000068   0x190A             ADDS     R2,R1,R4
   \   0000006A   0x7110             STRB     R0,[R2, #+4]
    315          						UartRxCurrentLength ++;
   \   0000006C   0x1C48             ADDS     R0,R1,#+1
   \   0000006E   0x70A0             STRB     R0,[R4, #+2]
   \   00000070   0xBD31             POP      {R0,R4,R5,PC}
    316          					}
    317          					else{
    318          						int8u PacketCheckXor;
    319          						int8u CheckXor =0;
   \                     ??UartScanCommand_6: (+1)
   \   00000072   0x2100             MOVS     R1,#+0
    320          						PacketCheckXor =  ReadSerialData;
   \   00000074   0xF89D 0x2000      LDRB     R2,[SP, #+0]
    321          						{
    322          							for(int8u j=0;j < UartRxPacketLength-1;j++){
   \   00000078   0x2300             MOVS     R3,#+0
   \   0000007A   0xE003             B.N      ??UartScanCommand_7
    323          								CheckXor = CheckXor ^ UartRxCommandData[j];
   \                     ??UartScanCommand_8: (+1)
   \   0000007C   0x191D             ADDS     R5,R3,R4
    324          							}
   \   0000007E   0x1C5B             ADDS     R3,R3,#+1
   \   00000080   0x792D             LDRB     R5,[R5, #+4]
   \   00000082   0x4069             EORS     R1,R5,R1
   \                     ??UartScanCommand_7: (+1)
   \   00000084   0xB2DB             UXTB     R3,R3
   \   00000086   0x4283             CMP      R3,R0
   \   00000088   0xDBF8             BLT.N    ??UartScanCommand_8
    325          						}
    326          						if(PacketCheckXor == CheckXor){
   \   0000008A   0xB2C9             UXTB     R1,R1
   \   0000008C   0x428A             CMP      R2,R1
   \   0000008E   0xBF04             ITT      EQ 
    327          							CallUartTask(UartRxCommandData);
   \   00000090   0x1D20             ADDEQ    R0,R4,#+4
   \   00000092   0x.... 0x....      BLEQ     CallUartTask
    328          						}
    329          						UartRxCurrentLength = 0;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x70A0             STRB     R0,[R4, #+2]
    330          						UartRxDataStep = 0;
   \                     ??UartScanCommand_5: (+1)
   \   0000009A   0x7020             STRB     R0,[R4, #+0]
    331          					}
    332          				break;
    333          					default:
    334          				break;
    335          
    336          				}
    337          			}
    338          		}
    339          	}
    340          }
   \                     ??UartScanCommand_0: (+1)
   \   0000009C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    341          
    342          
    343          
    344          //--------------------------------------------UART Send Command--------------------------//
    345          
    346          
    347          typedef enum UartTxCommand_ID{
    348          	SwitchControlCmdId		=	0xB0,
    349          	DimmerLevelControlCmdID =	0xB2,
    350          	ChangeSpecialLedTxCmdId	=	0xB7,
    351          	AttributeSetupCmdId		=	0xBC,
    352          	McClockCalibrateCmdId  = 	0xC1,
    353          	McReadyCmdId			=	0xC0,
    354          	McTimerCalibrateCmdId	=	0xBE,
    355          };
                  ^
Warning[Pe375]: declaration requires a typedef name
    356          
    357          //----------------------------UART Send Command Utility-----------------------//
    358          

   \                                 In section .text, align 2, keep-with-next
    359          unsigned char GetLastTxUartCmd(void){
    360              unsigned char Head = 0;
   \                     GetLastTxUartCmd: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
    361              unsigned char Length = 0;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \   00000006   0xE002             B.N      ??GetLastTxUartCmd_0
    362              while(UartTxCommandBuff[Head] != 0){
    363                  if(UartTxCommandBuff[Head] != 0){
    364                      Length = UartTxCommandBuff[Head];
    365                      Head = Head+Length+2;
   \                     ??GetLastTxUartCmd_1: (+1)
   \   00000008   0x1810             ADDS     R0,R2,R0
   \   0000000A   0x1C80             ADDS     R0,R0,#+2
   \   0000000C   0xB2C0             UXTB     R0,R0
    366                  }
    367              }
   \                     ??GetLastTxUartCmd_0: (+1)
   \   0000000E   0x5C42             LDRB     R2,[R0, R1]
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD1F9             BNE.N    ??GetLastTxUartCmd_1
    368              return Head;
   \   00000014   0x4770             BX       LR               ;; return
    369          }
    370          
    371          //------------------------------Send Dimmer Level Control Command----------------//
    372           /*
    373          Mau ban tin:
    374          
    375          CommandID			Dimmer Level
    376          1byte				1 Byte
    377          0xB1
    378          */

   \                                 In section .text, align 2, keep-with-next
    379          void UartSendDimLevel (int8u currentDimLevel) {
   \                     UartSendDimLevel: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    380          	UartSendLevelControlDataBuffer UartSendLevelControlData;
    381          
    382          	UartSendLevelControlData.Length = 3;
   \   00000004   0x.... 0x....      BL       ?Subroutine9
    383          	UartSendLevelControlData.Id = DimmerLevelControlCmdID;
    384          	UartSendLevelControlData.Data = currentDimLevel;
    385              UartSendLevelControlData.CheckXor =  UartSendLevelControlData.Id ^ UartSendLevelControlData.Data;
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000008   0xF080 0x00B2      EOR      R0,R0,#0xB2
   \   0000000C   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000010   0x21B2             MOVS     R1,#+178
    386          	UartSendLevelControlData.TimeOut = NormalTimeOut;
   \   00000012   0x....             B.N      ?Subroutine0
    387          
    388          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendLevelControlData,
    389          			sizeof(UartSendLevelControlDataBuffer));
    390          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x20FF             MOVS     R0,#+255
   \   00000002   0xF88D 0x1001      STRB     R1,[SP, #+1]
   \                     ??Subroutine0_0: (+1)
   \   00000006   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   0000000A   0x.... 0x....      BL       GetLastTxUartCmd
   \   0000000E   0x2205             MOVS     R2,#+5
   \   00000010                      REQUIRE ??Subroutine13_0
   \   00000010                      ;; // Fall through to label ??Subroutine13_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine13_0: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable11_1
   \   00000002   0xA900             ADD      R1,SP,#+0
   \   00000004   0x18C0             ADDS     R0,R0,R3
   \   00000006   0x.... 0x....      BL       halCommonMemMove
   \   0000000A   0xBD07             POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x2103             MOVS     R1,#+3
   \   00000002   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000006   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \   0000000A   0x4770             BX       LR
    391          
    392          //------------------------------Send Switch Control Command----------------//
    393           /*
    394          Mau ban tin:
    395          
    396          CommandID			Switch State
    397          1byte				11Byte
    398          0xB0
    399          */
    400          
    401          
    402          
    403          // State off Relay Use SwitchStateEnum

   \                                 In section .text, align 2, keep-with-next
    404          void UartSendSwitchControlNumber(int8u SwitchNumber, int8u State){
   \                     UartSendSwitchControlNumber: (+1)
   \   00000000   0xB500             PUSH     {LR}
    405          	UartSendSwitchControlDataBuffer UartSendSwitchControlData;
    406          
    407          	UartSendSwitchControlData.Length = 3;
    408          	UartSendSwitchControlData.Id = SwitchControlCmdId;
    409          	UartSendSwitchControlData.Data = (State << 2*(SwitchNumber-1));
   \   00000002   0x1E40             SUBS     R0,R0,#+1
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_18: (+1)
   \   0000000A   0x2203             MOVS     R2,#+3
    410              UartSendSwitchControlData.CheckXor =  UartSendSwitchControlData.Id ^ UartSendSwitchControlData.Data;
   \   0000000C   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000010   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \   00000014   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000018   0x22B0             MOVS     R2,#+176
    411          	UartSendSwitchControlData.TimeOut = NormalTimeOut;
   \   0000001A   0x20FF             MOVS     R0,#+255
   \   0000001C   0xF88D 0x2001      STRB     R2,[SP, #+1]
   \   00000020   0x....             B.N      ??Subroutine0_0
    412          
    413          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendSwitchControlData,
    414          			sizeof(UartSendSwitchControlDataBuffer));
    415          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0xF080 0x00B0      EOR      R0,R0,#0xB0
   \   00000004   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x0040             LSLS     R0,R0,#+1
   \   00000002   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000006   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   0000000A   0x4770             BX       LR
    416          

   \                                 In section .text, align 2, keep-with-next
    417          void UartSendSwitchControlMark(int8u SwitchMark, int8u State){
   \                     UartSendSwitchControlMark: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    418          	int8u i;
    419          	UartSendSwitchControlDataBuffer UartSendSwitchControlData;
    420          
    421          	for(i=0;i<4;i++){
   \   00000002   0x.... 0x....      BL       ?Subroutine3
    422          		if(((SwitchMark >> i) & 0x01) == 1){
    423          			UartSendSwitchControlData.Data = UartSendSwitchControlData.Data | (State << 2*i);
    424          		}
    425          	}
    426          	UartSendSwitchControlData.Length = 3;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000006   0x2003             MOVS     R0,#+3
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
    427          	UartSendSwitchControlData.Id = SwitchControlCmdId;
   \   0000000C   0x20B0             MOVS     R0,#+176
   \   0000000E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    428          	UartSendSwitchControlData.CheckXor = UartSendSwitchControlData.Id ^ UartSendSwitchControlData.Data;
   \   00000012   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000016   0x.... 0x....      BL       ?Subroutine8
    429          	UartSendSwitchControlData.TimeOut = NormalTimeOut;
   \                     ??CrossCallReturnLabel_14: (+1)
   \   0000001A   0x20FF             MOVS     R0,#+255
   \   0000001C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    430          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendSwitchControlData,
    431          			sizeof(UartSendSwitchControlDataBuffer));
   \   00000020   0x.... 0x....      BL       GetLastTxUartCmd
   \   00000024   0x2205             MOVS     R2,#+5
   \   00000026   0x....             B.N      ??Subroutine14_0
    432          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \                     ??Subroutine3_0: (+1)
   \   00000002   0xFA40 0xF302      ASR      R3,R0,R2
   \   00000006   0x07DB             LSLS     R3,R3,#+31
   \   00000008   0xD507             BPL.N    ??Subroutine3_1
   \   0000000A   0xF89D 0x3002      LDRB     R3,[SP, #+2]
   \   0000000E   0x0054             LSLS     R4,R2,#+1
   \   00000010   0xFA01 0xF404      LSL      R4,R1,R4
   \   00000014   0x4323             ORRS     R3,R4,R3
   \   00000016   0xF88D 0x3002      STRB     R3,[SP, #+2]
   \                     ??Subroutine3_1: (+1)
   \   0000001A   0x1C52             ADDS     R2,R2,#+1
   \   0000001C   0x2A04             CMP      R2,#+4
   \   0000001E   0xDBF0             BLT.N    ??Subroutine3_0
   \   00000020   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine14_0: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable11_1
   \   00000002   0xA900             ADD      R1,SP,#+0
   \   00000004   0x18C0             ADDS     R0,R0,R3
   \   00000006   0x.... 0x....      BL       halCommonMemMove
   \   0000000A   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
    433          void UartSendSwitchControlStateMark(int8u SwitchStateMark){
   \                     UartSendSwitchControlStateMark: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    434          	UartSendSwitchControlDataBuffer UartSendSwitchControlData;
    435          
    436          	UartSendSwitchControlData.Length = 3;
   \   00000004   0x.... 0x....      BL       ?Subroutine9
    437          	UartSendSwitchControlData.Id = SwitchControlCmdId;
    438          	UartSendSwitchControlData.Data = SwitchStateMark;
    439              UartSendSwitchControlData.CheckXor =  UartSendSwitchControlData.Id ^ UartSendSwitchControlData.Data;
   \                     ??CrossCallReturnLabel_17: (+1)
   \   00000008   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_15: (+1)
   \   0000000C   0x21B0             MOVS     R1,#+176
    440          	UartSendSwitchControlData.TimeOut = NormalTimeOut;
   \   0000000E                      REQUIRE ?Subroutine0
   \   0000000E                      ;; // Fall through to label ?Subroutine0
    441          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendSwitchControlData,
    442          			sizeof(UartSendSwitchControlDataBuffer));
    443          }
    444          
    445          //------------------------------Send Attribute Setup Command----------------//
    446           /*
    447          Mau ban tin:
    448          
    449          CommandID			Attribute			Value
    450          1byte				1Byte               1 Byte
    451          0xBC
    452          */
    453          
    454          // Option of Store value use StoreAttributeEnum
    455          // AttribteId use SetupAttributeIdEnum

   \                                 In section .text, align 2, keep-with-next
    456          void UartSendStoreAttribute(int8u SwitchMark, int8u Option){
   \                     UartSendStoreAttribute: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    457          	UartSendAttributeSetupDataBuffer UartSendAttributeSetupData;
    458          	int8u i;
    459          	for(i=0;i<4;i++){
   \   00000004   0x2200             MOVS     R2,#+0
    460          		if(((SwitchMark<<i) & 0x01) == 1){
   \                     ??UartSendStoreAttribute_0: (+1)
   \   00000006   0xFA00 0xF302      LSL      R3,R0,R2
   \   0000000A   0x07DB             LSLS     R3,R3,#+31
   \   0000000C   0xD507             BPL.N    ??UartSendStoreAttribute_1
    461          			UartSendAttributeSetupData.Value[0] = UartSendAttributeSetupData.Value[0] | (Option<<(2*i));
   \   0000000E   0xF89D 0x3003      LDRB     R3,[SP, #+3]
   \   00000012   0x0054             LSLS     R4,R2,#+1
   \   00000014   0xFA01 0xF404      LSL      R4,R1,R4
   \   00000018   0x4323             ORRS     R3,R4,R3
   \   0000001A   0xF88D 0x3003      STRB     R3,[SP, #+3]
    462          		}
    463          	}
   \                     ??UartSendStoreAttribute_1: (+1)
   \   0000001E   0x1C52             ADDS     R2,R2,#+1
   \   00000020   0x2A04             CMP      R2,#+4
   \   00000022   0xDBF0             BLT.N    ??UartSendStoreAttribute_0
    464          
    465          
    466          	UartSendAttributeSetupData.Length = 8;
   \   00000024   0x2008             MOVS     R0,#+8
   \   00000026   0xF88D 0x0000      STRB     R0,[SP, #+0]
    467          	UartSendAttributeSetupData.Id = AttributeSetupCmdId;
   \   0000002A   0x20BC             MOVS     R0,#+188
   \   0000002C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    468          	UartSendAttributeSetupData.AttribteId = SaveState;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xF88D 0x0002      STRB     R0,[SP, #+2]
    469          	UartSendAttributeSetupData.CheckXor = UartSendAttributeSetupData.Value[0] ^ UartSendAttributeSetupData.AttribteId
    470          		^ UartSendAttributeSetupData.Id;
   \   00000036   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000003A   0xF080 0x00BD      EOR      R0,R0,#0xBD
   \   0000003E   0xF88D 0x0008      STRB     R0,[SP, #+8]
    471              UartSendAttributeSetupData.TimeOut = NormalTimeOut;
   \   00000042   0x20FF             MOVS     R0,#+255
   \   00000044   0xF88D 0x0009      STRB     R0,[SP, #+9]
    472          
    473              MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendAttributeSetupData,
    474          			sizeof(UartSendAttributeSetupDataBuffer));
   \   00000048   0x.... 0x....      BL       GetLastTxUartCmd
   \   0000004C   0x220A             MOVS     R2,#+10
   \   0000004E   0x.... 0x....      BL       ?Subroutine4
    475          }
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000052   0xBD1F             POP      {R0-R4,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable11_1
   \   00000002   0xA900             ADD      R1,SP,#+0
   \   00000004   0x18C0             ADDS     R0,R0,R3
   \   00000006   0x.... 0x....      B.W      halCommonMemMove
    476          
    477          
    478          
    479          
    480          //------------------------------Send MC Clock Calibrate Command----------------//
    481           /*
    482          Mau ban tin:
    483          
    484          CommandID			Calibrate Data
    485          1byte				16Byte
    486          0xC1				0x00 ->0xFF
    487          */
    488          
    489          
    490          

   \                                 In section .text, align 2, keep-with-next
    491          void UartSendMcClockCalibrate(void){
   \                     UartSendMcClockCalibrate: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    492          	UartSendMcClockCalibrateDataBuffer UartSendMcClockCalibrateData;
    493          	int8u DataCheckKey[16] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,
    494          										0xBB,0xCC,0xDD,0xEE,0xFF};
   \   00000004   0xA805             ADD      R0,SP,#+20
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_2`
   \   0000000A   0x.... 0x....      BL       ?Subroutine6
    495          	UartSendMcClockCalibrateData.Length = 18;
   \                     ??CrossCallReturnLabel_9: (+1)
   \   0000000E   0x2012             MOVS     R0,#+18
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    496          	UartSendMcClockCalibrateData.Id		= McClockCalibrateCmdId;
    497          	MEMCOPY(&UartSendMcClockCalibrateData.Data, DataCheckKey, sizeof(DataCheckKey));
   \   00000014   0x2210             MOVS     R2,#+16
   \   00000016   0x20C1             MOVS     R0,#+193
   \   00000018   0x.... 0x....      BL       ?Subroutine7
    498          	UartSendMcClockCalibrateData.CheckXor = McClockCalibrateCmdId;
   \                     ??CrossCallReturnLabel_12: (+1)
   \   0000001C   0x20C1             MOVS     R0,#+193
   \   0000001E   0x....             B.N      ?Subroutine2
    499          	UartSendMcClockCalibrateData.TimeOut = NormalTimeOut;
    500          
    501          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendMcClockCalibrateData,
    502          			sizeof(UartSendMcClockCalibrateData));
    503          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xF88D 0x0012      STRB     R0,[SP, #+18]
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0xF88D 0x0013      STRB     R0,[SP, #+19]
   \   0000000A   0x.... 0x....      BL       GetLastTxUartCmd
   \   0000000E   0x2214             MOVS     R2,#+20
   \   00000010   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000014   0xB009             ADD      SP,SP,#+36
   \   00000016   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000004   0xA905             ADD      R1,SP,#+20
   \   00000006   0xF10D 0x0002      ADD      R0,SP,#+2
   \   0000000A   0x.... 0x....      B.W      halCommonMemMove
    504          
    505          
    506          //----------------------------------Send Special Led Command------------------------//
    507           /*
    508          Mau ban tin:
    509          
    510          CommandID			State			Extra
    511          1byte				1Byte			1Byte
    512          0xB7
    513          */
    514          
    515          
    516          // State off Special Led use LedStateEnum
    517          // State off Led after Blink use LedStateEnum

   \                                 In section .text, align 2, keep-with-next
    518          void UartSendRefreshAllLed(void){
    519          	UartSendSpecialLedMark(0x0F, 0);
   \                     UartSendRefreshAllLed: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x200F             MOVS     R0,#+15
   \   00000004   0x....             B.N      UartSendSpecialLedMark
    520          }

   \                                 In section .text, align 2, keep-with-next
    521          void UartSendRefreshLedNumber(int8u LedNumber){
    522          	UartSendSpecialLedNumber(LedNumber, 0);
   \                     UartSendRefreshLedNumber: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      UartSendSpecialLedNumber
    523          }

   \                                 In section .text, align 2, keep-with-next
    524          void UartSendSpecialLedMark (int8u LedNumberMark, int8u State){
   \                     UartSendSpecialLedMark: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    525          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    526          	int8u i;
    527          
    528          	for(i=0;i<4;i++){
   \   00000002   0x.... 0x....      BL       ?Subroutine3
    529          		if(((LedNumberMark >> i) & 0x01) == 1){
    530          			UartSendSpecialLedMarkData.State = UartSendSpecialLedMarkData.State | (State << 2*i);
    531          		}
    532          	}
    533          	UartSendSpecialLedMarkData.Extra = 0;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000006   0x....             B.N      ?Subroutine1
    534          	UartSendSpecialLedMarkData.Length = 4;
    535          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    536          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    537          		UartSendSpecialLedMarkData.Extra;
    538          
    539          	UartSendSpecialLedMarkData.TimeOut = NormalTimeOut;
    540          
    541             	MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    542          			sizeof(UartSendSpecialLedDataBuffer));
    543          
    544          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000C   0x20B7             MOVS     R0,#+183
   \   0000000E   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000012   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000016   0xF080 0x00B7      EOR      R0,R0,#0xB7
   \   0000001A   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   0000001E   0x20FF             MOVS     R0,#+255
   \   00000020   0xF88D 0x0005      STRB     R0,[SP, #+5]
   \   00000024   0x.... 0x....      BL       GetLastTxUartCmd
   \   00000028   0x2206             MOVS     R2,#+6
   \   0000002A                      REQUIRE ??Subroutine14_0
   \   0000002A                      ;; // Fall through to label ??Subroutine14_0
    545          
    546          

   \                                 In section .text, align 2, keep-with-next
    547          void UartSendSpecialLedNumber (int8u LedNumber, int8u State){
   \                     UartSendSpecialLedNumber: (+1)
   \   00000000   0xB500             PUSH     {LR}
    548          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    549          
    550          
    551          	UartSendSpecialLedMarkData.State =  (State << (2*(LedNumber -1)));
   \   00000002   0x1E40             SUBS     R0,R0,#+1
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x.... 0x....      BL       ?Subroutine10
    552          	UartSendSpecialLedMarkData.Extra = 0;
   \                     ??CrossCallReturnLabel_19: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    553          	UartSendSpecialLedMarkData.Length = 4;
   \   00000010   0x.... 0x....      BL       ?Subroutine11
    554          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    555          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    556          		UartSendSpecialLedMarkData.Extra;
   \                     ??CrossCallReturnLabel_20: (+1)
   \   00000014   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000018   0xF080 0x00B7      EOR      R0,R0,#0xB7
   \   0000001C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    557              UartSendSpecialLedMarkData.TimeOut = NormalTimeOut;
   \   00000020   0x20FF             MOVS     R0,#+255
   \   00000022   0xF88D 0x0005      STRB     R0,[SP, #+5]
    558          	MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    559          			sizeof(UartSendSpecialLedDataBuffer));
   \   00000026   0x.... 0x....      BL       GetLastTxUartCmd
   \   0000002A   0x2206             MOVS     R2,#+6
   \   0000002C   0x....             B.N      ??Subroutine13_0
    560          
    561          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0x2004             MOVS     R0,#+4
   \   00000002   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000006   0x20B7             MOVS     R0,#+183
   \   00000008   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000000C   0x4770             BX       LR
    562          
    563          
    564          

   \                                 In section .text, align 2, keep-with-next
    565          void UartSendPinkLed(int8u LedNumberMark){
   \                     UartSendPinkLed: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    566          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    567          
    568          	int8u i;
    569          
    570          	for(i=0;i<4;i++){
   \   00000002   0x2100             MOVS     R1,#+0
    571          		if(((LedNumberMark >> i) & 0x01) == 1){
   \                     ??UartSendPinkLed_0: (+1)
   \   00000004   0xFA40 0xF201      ASR      R2,R0,R1
   \   00000008   0x07D2             LSLS     R2,R2,#+31
   \   0000000A   0xD504             BPL.N    ??CrossCallReturnLabel_22
    572          			UartSendSpecialLedMarkData.State = UartSendSpecialLedMarkData.State | (PinkState << 2*i);
   \   0000000C   0xF89D 0x2002      LDRB     R2,[SP, #+2]
   \   00000010   0x2302             MOVS     R3,#+2
   \   00000012   0x.... 0x....      BL       ?Subroutine12
    573          		}
    574          	}
   \                     ??CrossCallReturnLabel_22: (+1)
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0x2904             CMP      R1,#+4
   \   0000001A   0xDBF3             BLT.N    ??UartSendPinkLed_0
    575          	UartSendSpecialLedMarkData.Extra = 0;
   \   0000001C                      REQUIRE ?Subroutine1
   \   0000001C                      ;; // Fall through to label ?Subroutine1
    576          	UartSendSpecialLedMarkData.Length = 4;
    577          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    578          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    579          		UartSendSpecialLedMarkData.Extra;
    580          
    581          	UartSendSpecialLedMarkData.TimeOut = NormalTimeOut;
    582              MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    583          			sizeof(UartSendSpecialLedDataBuffer));
    584          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \   00000000   0x004C             LSLS     R4,R1,#+1
   \   00000002   0x40A3             LSLS     R3,R3,R4
   \   00000004   0x431A             ORRS     R2,R3,R2
   \   00000006   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \   0000000A   0x4770             BX       LR
    585          
    586          

   \                                 In section .text, align 2, keep-with-next
    587          void UartSendOffLed(int8u LedNumberMark){
   \                     UartSendOffLed: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    588          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    589          
    590          	int8u i;
    591          
    592          	for(i=0;i<4;i++){
   \   00000002   0x2100             MOVS     R1,#+0
    593          		if(((LedNumberMark >> i) & 0x01) == 1){
   \                     ??UartSendOffLed_0: (+1)
   \   00000004   0xFA40 0xF201      ASR      R2,R0,R1
   \   00000008   0x07D2             LSLS     R2,R2,#+31
   \   0000000A   0xD504             BPL.N    ??CrossCallReturnLabel_23
    594          			UartSendSpecialLedMarkData.State = UartSendSpecialLedMarkData.State | (OffState << 2*i);
   \   0000000C   0xF89D 0x2002      LDRB     R2,[SP, #+2]
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x.... 0x....      BL       ?Subroutine12
    595          		}
    596          	}
   \                     ??CrossCallReturnLabel_23: (+1)
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0x2904             CMP      R1,#+4
   \   0000001A   0xDBF3             BLT.N    ??UartSendOffLed_0
    597          
    598          	UartSendSpecialLedMarkData.Extra = 0;
   \   0000001C   0x....             B.N      ?Subroutine1
    599          	UartSendSpecialLedMarkData.Length = 4;
    600          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    601          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    602          		UartSendSpecialLedMarkData.Extra;
    603          	UartSendSpecialLedMarkData.TimeOut = NormalTimeOut;
    604          	MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    605          			sizeof(UartSendSpecialLedDataBuffer));
    606          }
    607          
    608          
    609          

   \                                 In section .text, align 2, keep-with-next
    610          void UartSendBlinkLed(int8u LedNumberMark, int8u BlinkTime){
   \                     UartSendBlinkLed: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    611          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    612          
    613              BlinkStateExtra BlinkStateExtraData;
    614          	int8u i;
    615          
    616          	for(i=0;i<4;i++){
   \   00000004   0x2100             MOVS     R1,#+0
    617          		if(((LedNumberMark >> i) & 0x01) == 1){
   \                     ??UartSendBlinkLed_0: (+1)
   \   00000006   0xFA40 0xF201      ASR      R2,R0,R1
   \   0000000A   0x07D2             LSLS     R2,R2,#+31
   \   0000000C   0xD507             BPL.N    ??UartSendBlinkLed_1
    618          			UartSendSpecialLedMarkData.State = UartSendSpecialLedMarkData.State | (BlinkState << 2*i);
   \   0000000E   0xF89D 0x2002      LDRB     R2,[SP, #+2]
   \   00000012   0x2303             MOVS     R3,#+3
   \   00000014   0x004D             LSLS     R5,R1,#+1
   \   00000016   0x40AB             LSLS     R3,R3,R5
   \   00000018   0x431A             ORRS     R2,R3,R2
   \   0000001A   0xF88D 0x2002      STRB     R2,[SP, #+2]
    619          		}
    620          	}
   \                     ??UartSendBlinkLed_1: (+1)
   \   0000001E   0x1C49             ADDS     R1,R1,#+1
   \   00000020   0x2904             CMP      R1,#+4
   \   00000022   0xDBF0             BLT.N    ??UartSendBlinkLed_0
    621          	BlinkStateExtraData.BlinkTime = BlinkTime;
    622          	BlinkStateExtraData.LedState = NormalState;
    623          	BlinkStateExtraData.RelayStatus = NoChange;
   \   00000024   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000028   0xF000 0x001F      AND      R0,R0,#0x1F
   \   0000002C   0xEA40 0x1044      ORR      R0,R0,R4, LSL #+5
   \   00000030   0xF000 0x00E1      AND      R0,R0,#0xE1
   \   00000034   0xF88D 0x0008      STRB     R0,[SP, #+8]
    624          
    625          	MEMCOPY(&UartSendSpecialLedMarkData.Extra, &BlinkStateExtraData, sizeof(UartSendSpecialLedMarkData.Extra));
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0xA902             ADD      R1,SP,#+8
   \   0000003C   0xF10D 0x0003      ADD      R0,SP,#+3
   \   00000040   0x.... 0x....      BL       halCommonMemMove
    626          	UartSendSpecialLedMarkData.Length = 4;
   \   00000044   0x.... 0x....      BL       ?Subroutine11
    627          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    628          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    629          		UartSendSpecialLedMarkData.Extra;
    630          	UartSendSpecialLedMarkData.TimeOut = BlinkTime;
   \                     ??CrossCallReturnLabel_21: (+1)
   \   00000048   0xF88D 0x4005      STRB     R4,[SP, #+5]
   \   0000004C   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000050   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000054   0x4048             EORS     R0,R1,R0
   \   00000056   0xF080 0x00B7      EOR      R0,R0,#0xB7
   \   0000005A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    631          	MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    632          			sizeof(UartSendSpecialLedDataBuffer));
   \   0000005E   0x.... 0x....      BL       GetLastTxUartCmd
   \   00000062   0x2206             MOVS     R2,#+6
   \   00000064   0x.... 0x....      BL       ?Subroutine4
    633          }
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000068   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
    634          void UartSendToggleLed(int8u LedNumberMark){
    635          	UartSendBlinkLed(LedNumberMark,0);
   \                     UartSendToggleLed: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      UartSendBlinkLed
    636          }
    637          
    638          //----------------------------------Send Check MC Ready------------------------//
    639           /*
    640          Mau ban tin:
    641          
    642          CommandID			 Data
    643          1byte				16Byte
    644          0xB0				0x00 -> 0xFF
    645          */

   \                                 In section .text, align 2, keep-with-next
    646          void UartSendCheckMcReady(void){
   \                     UartSendCheckMcReady: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    647          	UartSendCheckMcReadyDataBuffer UartSendCheckMcReadyData;
    648          	int8u DataCheckKey[16] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,
    649          										0xBB,0xCC,0xDD,0xEE,0xFF};
   \   00000004   0xA805             ADD      R0,SP,#+20
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_3`
   \   0000000A   0x.... 0x....      BL       ?Subroutine6
    650          	UartSendCheckMcReadyData.Length = 18;
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000000E   0x2012             MOVS     R0,#+18
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    651          	UartSendCheckMcReadyData.Id		= McReadyCmdId;
    652          	MEMCOPY(&UartSendCheckMcReadyData.Data, DataCheckKey, sizeof(DataCheckKey));
   \   00000014   0x2210             MOVS     R2,#+16
   \   00000016   0x20C0             MOVS     R0,#+192
   \   00000018   0x.... 0x....      BL       ?Subroutine7
    653          	UartSendCheckMcReadyData.CheckXor = McReadyCmdId;
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000001C   0x20C0             MOVS     R0,#+192
   \   0000001E                      REQUIRE ?Subroutine2
   \   0000001E                      ;; // Fall through to label ?Subroutine2
    654          	UartSendCheckMcReadyData.TimeOut = NormalTimeOut;
    655          
    656          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendCheckMcReadyData,
    657          			sizeof(UartSendCheckMcReadyData));
    658          //	McReadyStatus = McChecking;
    659          }
    660          
    661          
    662          //----------------------------------Send MC Timmer Calibrate ------------------------//
    663           /*
    664          Mau ban tin:
    665          
    666          CommandID			 Interval		TotalTime			TimeCounter
    667          1byte				1Byte           1byte                1byte
    668          0xBE
    669          */

   \                                 In section .text, align 2, keep-with-next
    670          void UartSendMcTimerCalibrate(int8u inverval, int8u totalTimes, int8u timesCounter){
   \                     UartSendMcTimerCalibrate: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    671          	UartSendMcTimerCalibrateDataBuffer UartSendMcTimerCalibrateData;
    672          
    673          	UartSendMcTimerCalibrateData.Length = 5;
   \   00000004   0x2305             MOVS     R3,#+5
    674          	UartSendMcTimerCalibrateData.Id		= McTimerCalibrateCmdId;
    675          	UartSendMcTimerCalibrateData.Inverval = inverval;
   \   00000006   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   0000000A   0xF88D 0x3000      STRB     R3,[SP, #+0]
    676          	UartSendMcTimerCalibrateData.TotalTimes = totalTimes;
    677          	UartSendMcTimerCalibrateData.TimesCounter= timesCounter;
    678          	UartSendMcTimerCalibrateData.CheckXor = McTimerCalibrateCmdId ^ inverval ^ totalTimes ^ timesCounter;
   \   0000000E   0x4048             EORS     R0,R1,R0
   \   00000010   0x4050             EORS     R0,R2,R0
   \   00000012   0xF080 0x00BE      EOR      R0,R0,#0xBE
   \   00000016   0xF88D 0x0005      STRB     R0,[SP, #+5]
   \   0000001A   0x23BE             MOVS     R3,#+190
    679          	UartSendMcTimerCalibrateData.TimeOut = NormalTimeOut;
   \   0000001C   0x20FF             MOVS     R0,#+255
   \   0000001E   0xF88D 0x3001      STRB     R3,[SP, #+1]
   \   00000022   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \   00000026   0xF88D 0x2004      STRB     R2,[SP, #+4]
   \   0000002A   0xF88D 0x0006      STRB     R0,[SP, #+6]
    680          
    681          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendMcTimerCalibrateData,
    682          			sizeof(UartSendMcTimerCalibrateDataBuffer));
   \   0000002E   0x.... 0x....      BL       GetLastTxUartCmd
   \   00000032   0x2207             MOVS     R2,#+7
   \   00000034   0x....             B.N      ??Subroutine13_0
    683          //	McReadyStatus = McChecking;
    684          }
    685          
    686          
    687          
    688          
    689          //---------------------------------Check Uart Status And Send Quere Data Buffer-------------------------------//
    690          typedef enum {
    691          	CmdReady,
    692          	CmdBusy,
    693          }uartSendCommandStatus;
    694          

   \                                 In section .text, align 2, keep-with-next
    695          int8u CheckWaitTimeOut(void){
   \                     CheckWaitTimeOut: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    696          
    697          	if(UartTxCommandStartWaitTimer !=0 ){
   \   00000002   0x....             LDR.N    R4,??DataTable11_2
   \   00000004   0x8820             LDRH     R0,[R4, #+0]
   \   00000006   0xB140             CBZ.N    R0,??CheckWaitTimeOut_0
    698          		if(CommonGetDurationTime(UartTxCommandStartWaitTimer) >= UartTxCommandCurrentTimeOut){
   \   00000008   0x.... 0x....      BL       CommonGetDurationTime
   \   0000000C   0x8861             LDRH     R1,[R4, #+2]
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD302             BCC.N    ??CheckWaitTimeOut_1
    699          			//clear timer
    700          			UartTxCommandStartWaitTimer = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    701          			return CmdReady;
   \   00000016   0xBD10             POP      {R4,PC}
    702          		}
    703          		else{
    704          			return CmdBusy;
   \                     ??CheckWaitTimeOut_1: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
    705          		}
    706          	}
    707          	else{
    708          		return CmdReady;
   \                     ??CheckWaitTimeOut_0: (+1)
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    709          	}
    710          }

   \                                 In section .text, align 2, keep-with-next
    711          void UartSendCommand(void){
   \                     UartSendCommand: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    712          	//	Check buff
    713          	if(UartTxCommandBuff[0] != 0){
   \   00000002   0x....             LDR.N    R4,??DataTable11_1
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xB328             CBZ.N    R0,??UartSendCommand_0
    714          		//	Check Timeout
    715          
    716          
    717          		switch (CheckWaitTimeOut()){
   \   00000008   0x.... 0x....      BL       CheckWaitTimeOut
   \   0000000C   0xBB10             CBNZ.N   R0,??UartSendCommand_0
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x1900             ADDS     R0,R0,R4
   \   00000012   0x7840             LDRB     R0,[R0, #+1]
   \   00000014   0x28FF             CMP      R0,#+255
   \   00000016   0xBF0E             ITEE     EQ 
    718          			case CmdBusy:
    719          			break;
    720          			case CmdReady:
    721          				//	Send buff
    722          				if(UartTxCommandBuff[UartTxCommandBuff[0]+1] == NormalTimeOut){
    723          					UartTxCommandCurrentTimeOut = NORMAL_TIMEOUT;
   \   00000018   0x201E             MOVEQ    R0,#+30
    724          				}
    725          				else{
    726          					UartTxCommandCurrentTimeOut = UartTxCommandBuff[UartTxCommandBuff[0]+1] * MinimumTimeOut;
   \   0000001A   0xF44F 0x717A      MOVNE    R1,#+1000
   \   0000001E   0x4348             MULNE    R0,R1,R0
   \   00000020   0x....             LDR.N    R5,??DataTable11_2
    727          				}
    728          				emberSerialWriteData(1,UART_PACKET_KEY,2);
   \   00000022   0x....             LDR.N    R1,??DataTable11_3
   \   00000024   0x8068             STRH     R0,[R5, #+2]
   \   00000026   0x2202             MOVS     R2,#+2
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       emberSerialWriteData
    729          				emberSerialWriteData(1,UartTxCommandBuff, (UartTxCommandBuff[0]+1));
   \   0000002E   0x7820             LDRB     R0,[R4, #+0]
   \   00000030   0x1C42             ADDS     R2,R0,#+1
   \   00000032   0xB2D2             UXTB     R2,R2
   \   00000034   0x4621             MOV      R1,R4
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       emberSerialWriteData
    730          				MEMCOPY(UartTxCommandBuff, &UartTxCommandBuff[UartTxCommandBuff[0]+2],
    731          						(MAX_RX_BUFFER - (UartTxCommandBuff[0]+2)));
   \   0000003C   0x7820             LDRB     R0,[R4, #+0]
   \   0000003E   0xF1C0 0x02FE      RSB      R2,R0,#+254
   \   00000042   0x1900             ADDS     R0,R0,R4
   \   00000044   0x1C81             ADDS     R1,R0,#+2
   \   00000046   0xB292             UXTH     R2,R2
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       halCommonMemMove
    732          				UartTxCommandStartWaitTimer = (int16u)halCommonGetInt32uMillisecondTick();
   \   0000004E   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000052   0x8028             STRH     R0,[R5, #+0]
    733          			break;
    734          			default:
    735          			break;
    736          		}
    737          	}
    738          }
   \                     ??UartSendCommand_0: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     UartRxDataStep

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     UartTxCommandBuff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     UartTxCommandStartWaitTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     UART_PACKET_KEY

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1`:
   \   00000000   0x00 0x11          DC8 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238
   \              0x22 0x33    
   \              0x44 0x55    
   \              0x66 0x77    
   \              0x88 0x99    
   \              0xAA 0xBB    
   \              0xCC 0xDD    
   \              0xEE         
   \   0000000F   0xFF               DC8 255

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_1`:
   \   00000000   0x00 0x11          DC8 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238
   \              0x22 0x33    
   \              0x44 0x55    
   \              0x66 0x77    
   \              0x88 0x99    
   \              0xAA 0xBB    
   \              0xCC 0xDD    
   \              0xEE         
   \   0000000F   0xFF               DC8 255

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_2`:
   \   00000000   0x00 0x11          DC8 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238
   \              0x22 0x33    
   \              0x44 0x55    
   \              0x66 0x77    
   \              0x88 0x99    
   \              0xAA 0xBB    
   \              0xCC 0xDD    
   \              0xEE         
   \   0000000F   0xFF               DC8 255

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_3`:
   \   00000000   0x00 0x11          DC8 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238
   \              0x22 0x33    
   \              0x44 0x55    
   \              0x66 0x77    
   \              0x88 0x99    
   \              0xAA 0xBB    
   \              0xCC 0xDD    
   \              0xEE         
   \   0000000F   0xFF               DC8 255

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    739          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   CallTaskCheckMcReady
        24   -> CallJoinTask
        24   -> GetHcActiveEndPoint
        24   -> UartSendBlinkLed
        24   -> UartSendSwitchControlStateMark
        24   -> __aeabi_memcpy4
        24   -> emberAfNetworkState
        24   -> halCommonGetRandom
        24   -> halCommonMemCompare
      16   CallTaskDimmerLevelChangeCommand
        16   -> SendLevelControlReadAttribute
        16   -> SendOnOffControlReadAttribute
        16   -> SendViaBindingTable
        16   -> emberAfReadServerAttribute
        16   -> emberAfWriteServerAttribute
      24   CallTaskMcClockCalibrate
        24   -> UartSendMcClockCalibrate
        24   -> __aeabi_memcpy4
        24   -> halCommonMemCompare
       0   CallTaskMcTimmerCalibrate
         0   -> CallMcTimmerCalibrateTask
      32   CallTaskRelayChangeCommand
        32   -> CommonClearLed
        32   -> CommonSetLed
        32   -> SendOnOffControlReadAttribute
        32   -> SendViaBindingTable
        32   -> beButtonPress
        32   -> emberAfNetworkState
        32   -> emberAfReadServerAttribute
        32   -> emberAfWriteServerAttribute
       0   CallTaskTouchButtonHold
         0   -> beButtonPress2Time
         0   -> beButtonPress3Time
         0   -> beButtonRealease
       0   CallUartTask
         0   -> CallTaskCheckMcReady
         0   -> CallTaskDimmerLevelChangeCommand
         0   -> CallTaskMcClockCalibrate
         0   -> CallTaskMcTimmerCalibrate
         0   -> CallTaskRelayChangeCommand
         0   -> CallTaskTouchButtonHold
       8   CheckWaitTimeOut
         8   -> CommonGetDurationTime
       0   GetLastTxUartCmd
      16   UartScanCommand
        16   -> CallUartTask
        16   -> emberSerialReadAvailable
        16   -> emberSerialReadByte
        16   -> emberSerialWriteData
      24   UartSendBlinkLed
        24   -> GetLastTxUartCmd
        24   -> halCommonMemMove
      40   UartSendCheckMcReady
        40   -> GetLastTxUartCmd
        40   -> __aeabi_memcpy4
        40   -> halCommonMemMove
      16   UartSendCommand
        16   -> CheckWaitTimeOut
        16   -> emberSerialWriteData
        16   -> halCommonGetInt32uMillisecondTick
        16   -> halCommonMemMove
      16   UartSendDimLevel
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      40   UartSendMcClockCalibrate
        40   -> GetLastTxUartCmd
        40   -> __aeabi_memcpy4
        40   -> halCommonMemMove
      16   UartSendMcTimerCalibrate
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      16   UartSendOffLed
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      16   UartSendPinkLed
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
       0   UartSendRefreshAllLed
         0   -> UartSendSpecialLedMark
       0   UartSendRefreshLedNumber
         0   -> UartSendSpecialLedNumber
      16   UartSendSpecialLedMark
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      16   UartSendSpecialLedNumber
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      24   UartSendStoreAttribute
        24   -> GetLastTxUartCmd
        24   -> halCommonMemMove
      16   UartSendSwitchControlMark
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      16   UartSendSwitchControlNumber
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      16   UartSendSwitchControlStateMark
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
       0   UartSendToggleLed
         0   -> UartSendBlinkLed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1
      16  ?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_1
      16  ?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_2
      16  ?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_3
       4  ?<Constant {0}>
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
      12  ??Subroutine13_0
      12  ??Subroutine14_0
      16  ?Subroutine0
      42  ?Subroutine1
      12  ?Subroutine10
      14  ?Subroutine11
      12  ?Subroutine12
      24  ?Subroutine2
      34  ?Subroutine3
      10  ?Subroutine4
      10  ?Subroutine5
       6  ?Subroutine6
      14  ?Subroutine7
      10  ?Subroutine8
      12  ?Subroutine9
      78  CallTaskCheckMcReady
     120  CallTaskDimmerLevelChangeCommand
      26  CallTaskMcClockCalibrate
       8  CallTaskMcTimmerCalibrate
     152  CallTaskRelayChangeCommand
      38  CallTaskTouchButtonHold
      40  CallUartTask
      28  CheckWaitTimeOut
      22  GetLastTxUartCmd
       2  UART_PACKET_KEY
      68  UartRxDataStep
          UartRxPacketLength
          UartRxCurrentLength
          UartRxCommandData
       1  UartRxPacketCheckXor
     158  UartScanCommand
     106  UartSendBlinkLed
      30  UartSendCheckMcReady
      86  UartSendCommand
      20  UartSendDimLevel
      32  UartSendMcClockCalibrate
      54  UartSendMcTimerCalibrate
      30  UartSendOffLed
      28  UartSendPinkLed
       6  UartSendRefreshAllLed
       4  UartSendRefreshLedNumber
       8  UartSendSpecialLedMark
      46  UartSendSpecialLedNumber
      84  UartSendStoreAttribute
      40  UartSendSwitchControlMark
      34  UartSendSwitchControlNumber
      14  UartSendSwitchControlStateMark
       4  UartSendToggleLed
     256  UartTxCommandBuff
       4  UartTxCommandStartWaitTimer
          UartTxCommandCurrentTimeOut

 
   329 bytes in section .bss
     2 bytes in section .data
     4 bytes in section .rodata
 1 616 bytes in section .text
 
 1 616 bytes of CODE  memory
     4 bytes of CONST memory
   331 bytes of DATA  memory

Errors: none
Warnings: 7

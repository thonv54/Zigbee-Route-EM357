// This file is generated by Ember Desktop.  Please do not edit manually.
//
//

// This file contains the tokens for attributes stored in flash


#include "ConfigDevice.h"
#ifdef SWITCH_3_BUTTON
		// Identifier tags for tokens
		// Creator for attribute: ZCL version, singleton.
		#define CREATOR_VERSION_SINGLETON 0xB000
		// Creator for attribute: manufacturer name, singleton.
		#define CREATOR_MANUFACTURER_NAME_SINGLETON 0xB001
		// Creator for attribute: model identifier, singleton.
		#define CREATOR_MODEL_IDENTIFIER_SINGLETON 0xB002
		// Creator for attribute: power source, singleton.
		#define CREATOR_POWER_SOURCE_SINGLETON 0xB003
		// Creator for attribute: on/off, endpoint: 1
		#define CREATOR_ON_OFF_1 0xB004
		// Creator for attribute: on/off, endpoint: 3
		#define CREATOR_ON_OFF_3 0xB005
		// Creator for attribute: on/off, endpoint: 5
		#define CREATOR_ON_OFF_5 0xB006


		// Types for the tokens
		#ifdef DEFINETYPES
		typedef int8u  tokType_on_off;
		typedef int8u  tokType_version;
		typedef int8u  tokType_manufacturer_name[33];
		typedef int8u  tokType_model_identifier[33];
		typedef int8u  tokType_power_source;
		#endif // DEFINETYPES


		// Actual token definitions
		#ifdef DEFINETOKENS
		DEFINE_BASIC_TOKEN(VERSION_SINGLETON, tokType_version, 0x01)
		DEFINE_BASIC_TOKEN(MANUFACTURER_NAME_SINGLETON, tokType_manufacturer_name, {ManufacturerName})
		DEFINE_BASIC_TOKEN(MODEL_IDENTIFIER_SINGLETON, tokType_model_identifier, {ModelId})
		DEFINE_BASIC_TOKEN(POWER_SOURCE_SINGLETON, tokType_power_source, 0x01)
		DEFINE_BASIC_TOKEN(ON_OFF_1, tokType_on_off, 0x00)
		DEFINE_BASIC_TOKEN(ON_OFF_3, tokType_on_off, 0x00)
		DEFINE_BASIC_TOKEN(ON_OFF_5, tokType_on_off, 0x00)
		#endif // DEFINETOKENS


		// Macro snippet that loads all the attributes from tokens
		#define GENERATED_TOKEN_LOADER(endpoint) do {\
		  int8u ptr[33]; \
		  int8u curNetwork = emberGetCurrentNetwork(); \
		  int8u epNetwork; \
		  halCommonGetToken((tokType_version *)ptr, TOKEN_VERSION_SINGLETON); \
		  emberAfWriteServerAttribute(1, ZCL_BASIC_CLUSTER_ID, ZCL_VERSION_ATTRIBUTE_ID, (int8u*)ptr, ZCL_INT8U_ATTRIBUTE_TYPE); \
		  halCommonGetToken((tokType_manufacturer_name *)ptr, TOKEN_MANUFACTURER_NAME_SINGLETON); \
		  emberAfWriteServerAttribute(1, ZCL_BASIC_CLUSTER_ID, ZCL_MANUFACTURER_NAME_ATTRIBUTE_ID, (int8u*)ptr, ZCL_CHAR_STRING_ATTRIBUTE_TYPE); \
		  halCommonGetToken((tokType_model_identifier *)ptr, TOKEN_MODEL_IDENTIFIER_SINGLETON); \
		  emberAfWriteServerAttribute(1, ZCL_BASIC_CLUSTER_ID, ZCL_MODEL_IDENTIFIER_ATTRIBUTE_ID, (int8u*)ptr, ZCL_CHAR_STRING_ATTRIBUTE_TYPE); \
		  halCommonGetToken((tokType_power_source *)ptr, TOKEN_POWER_SOURCE_SINGLETON); \
		  emberAfWriteServerAttribute(1, ZCL_BASIC_CLUSTER_ID, ZCL_POWER_SOURCE_ATTRIBUTE_ID, (int8u*)ptr, ZCL_ENUM8_ATTRIBUTE_TYPE); \
		  epNetwork = emberAfNetworkIndexFromEndpoint(1); \
		  if((endpoint) == 1 || ((endpoint) == EMBER_BROADCAST_ENDPOINT && epNetwork == curNetwork)) { \
		    halCommonGetToken((tokType_on_off *)ptr, TOKEN_ON_OFF_1); \
		    emberAfWriteServerAttribute(1, ZCL_ON_OFF_CLUSTER_ID, ZCL_ON_OFF_ATTRIBUTE_ID, (int8u*)ptr, ZCL_BOOLEAN_ATTRIBUTE_TYPE); \
		  } \
		  epNetwork = emberAfNetworkIndexFromEndpoint(3); \
		  if((endpoint) == 3 || ((endpoint) == EMBER_BROADCAST_ENDPOINT && epNetwork == curNetwork)) { \
		    halCommonGetToken((tokType_on_off *)ptr, TOKEN_ON_OFF_3); \
		    emberAfWriteServerAttribute(3, ZCL_ON_OFF_CLUSTER_ID, ZCL_ON_OFF_ATTRIBUTE_ID, (int8u*)ptr, ZCL_BOOLEAN_ATTRIBUTE_TYPE); \
		  } \
		  epNetwork = emberAfNetworkIndexFromEndpoint(5); \
		  if((endpoint) == 5 || ((endpoint) == EMBER_BROADCAST_ENDPOINT && epNetwork == curNetwork)) { \
		    halCommonGetToken((tokType_on_off *)ptr, TOKEN_ON_OFF_5); \
		    emberAfWriteServerAttribute(5, ZCL_ON_OFF_CLUSTER_ID, ZCL_ON_OFF_ATTRIBUTE_ID, (int8u*)ptr, ZCL_BOOLEAN_ATTRIBUTE_TYPE); \
		  } \
		} while(FALSE)


		// Macro snippet that saves the attribute to token
		#define GENERATED_TOKEN_SAVER do {\
		  int8u allZeroData[33]; \
		  MEMSET(allZeroData, 0, 33); \
		  if ( data == NULL ) data = allZeroData; \
		  if ( clusterId == 0x00 ) { \
		    if ( metadata->attributeId == 0x0000 && !emberAfAttributeIsClient(metadata) ) \
		      halCommonSetToken(TOKEN_VERSION_SINGLETON, data); \
		    if ( metadata->attributeId == 0x0004 && !emberAfAttributeIsClient(metadata) ) \
		      halCommonSetToken(TOKEN_MANUFACTURER_NAME_SINGLETON, data); \
		    if ( metadata->attributeId == 0x0005 && !emberAfAttributeIsClient(metadata) ) \
		      halCommonSetToken(TOKEN_MODEL_IDENTIFIER_SINGLETON, data); \
		    if ( metadata->attributeId == 0x0007 && !emberAfAttributeIsClient(metadata) ) \
		      halCommonSetToken(TOKEN_POWER_SOURCE_SINGLETON, data); \
		  }\
		  if ( endpoint == 1 ) { \
		    if ( clusterId == 0x06 ) { \
		      if ( metadata->attributeId == 0x0000 && !emberAfAttributeIsClient(metadata) ) \
		        halCommonSetToken(TOKEN_ON_OFF_1, data); \
		    } \
		  } else if ( endpoint == 3) { \
		    if ( clusterId == 0x06 ) { \
		      if ( metadata->attributeId == 0x0000 && !emberAfAttributeIsClient(metadata) ) \
		        halCommonSetToken(TOKEN_ON_OFF_3, data); \
		    } \
		  } else if ( endpoint == 5) { \
		    if ( clusterId == 0x06 ) { \
		      if ( metadata->attributeId == 0x0000 && !emberAfAttributeIsClient(metadata) ) \
		        halCommonSetToken(TOKEN_ON_OFF_5, data); \
		    } \
		  } \
		} while(FALSE)



#endif
#ifdef DIMMER
	// Identifier tags for tokens
	// Creator for attribute: ZCL version, singleton.
	#define CREATOR_VERSION_SINGLETON 0xB000
	// Creator for attribute: manufacturer name, singleton.
	#define CREATOR_MANUFACTURER_NAME_SINGLETON 0xB001
	// Creator for attribute: model identifier, singleton.
	#define CREATOR_MODEL_IDENTIFIER_SINGLETON 0xB002
	// Creator for attribute: power source, singleton.
	#define CREATOR_POWER_SOURCE_SINGLETON 0xB003
	// Creator for attribute: on/off, endpoint: 1
	#define CREATOR_ON_OFF_9 0xB004


	// Types for the tokens
	#ifdef DEFINETYPES
	typedef int8u  tokType_on_off;
	typedef int8u  tokType_version;
	typedef int8u  tokType_manufacturer_name[33];
	typedef int8u  tokType_model_identifier[33];
	typedef int8u  tokType_power_source;
	#endif // DEFINETYPES


	// Actual token definitions
	#ifdef DEFINETOKENS
	DEFINE_BASIC_TOKEN(VERSION_SINGLETON, tokType_version, 0x01)

	DEFINE_BASIC_TOKEN(MANUFACTURER_NAME_SINGLETON, tokType_manufacturer_name, {ManufacturerName})
	DEFINE_BASIC_TOKEN(MODEL_IDENTIFIER_SINGLETON, tokType_model_identifier, {ModelId})

	DEFINE_BASIC_TOKEN(POWER_SOURCE_SINGLETON, tokType_power_source, 0x01)
	DEFINE_BASIC_TOKEN(ON_OFF_9, tokType_on_off, 0x00)
	#endif // DEFINETOKENS


	// Macro snippet that loads all the attributes from tokens
	#define GENERATED_TOKEN_LOADER(endpoint) do {\
	  int8u ptr[33]; \
	  int8u curNetwork = emberGetCurrentNetwork(); \
	  int8u epNetwork; \
	  halCommonGetToken((tokType_version *)ptr, TOKEN_VERSION_SINGLETON); \
	  emberAfWriteServerAttribute(10, ZCL_BASIC_CLUSTER_ID, ZCL_VERSION_ATTRIBUTE_ID, (int8u*)ptr, ZCL_INT8U_ATTRIBUTE_TYPE); \
	  halCommonGetToken((tokType_manufacturer_name *)ptr, TOKEN_MANUFACTURER_NAME_SINGLETON); \
	  emberAfWriteServerAttribute(10, ZCL_BASIC_CLUSTER_ID, ZCL_MANUFACTURER_NAME_ATTRIBUTE_ID, (int8u*)ptr, ZCL_CHAR_STRING_ATTRIBUTE_TYPE); \
	  halCommonGetToken((tokType_model_identifier *)ptr, TOKEN_MODEL_IDENTIFIER_SINGLETON); \
	  emberAfWriteServerAttribute(10, ZCL_BASIC_CLUSTER_ID, ZCL_MODEL_IDENTIFIER_ATTRIBUTE_ID, (int8u*)ptr, ZCL_CHAR_STRING_ATTRIBUTE_TYPE); \
	  halCommonGetToken((tokType_power_source *)ptr, TOKEN_POWER_SOURCE_SINGLETON); \
	  emberAfWriteServerAttribute(10, ZCL_BASIC_CLUSTER_ID, ZCL_POWER_SOURCE_ATTRIBUTE_ID, (int8u*)ptr, ZCL_ENUM8_ATTRIBUTE_TYPE); \
	  epNetwork = emberAfNetworkIndexFromEndpoint(9); \
	  if((endpoint) == 9 || ((endpoint) == EMBER_BROADCAST_ENDPOINT && epNetwork == curNetwork)) { \
	    halCommonGetToken((tokType_on_off *)ptr, TOKEN_ON_OFF_9); \
	    emberAfWriteServerAttribute(9, ZCL_ON_OFF_CLUSTER_ID, ZCL_ON_OFF_ATTRIBUTE_ID, (int8u*)ptr, ZCL_BOOLEAN_ATTRIBUTE_TYPE); \
		} \
	} while(FALSE)

	// Macro snippet that saves the attribute to token
	#define GENERATED_TOKEN_SAVER do {\
	  int8u allZeroData[33]; \
	  MEMSET(allZeroData, 0, 33); \
	  if ( data == NULL ) data = allZeroData; \
	  if ( clusterId == 0x00 ) { \
	    if ( metadata->attributeId == 0x0000 && !emberAfAttributeIsClient(metadata) ) \
	      halCommonSetToken(TOKEN_VERSION_SINGLETON, data); \
	    if ( metadata->attributeId == 0x0004 && !emberAfAttributeIsClient(metadata) ) \
	      halCommonSetToken(TOKEN_MANUFACTURER_NAME_SINGLETON, data); \
	    if ( metadata->attributeId == 0x0005 && !emberAfAttributeIsClient(metadata) ) \
	      halCommonSetToken(TOKEN_MODEL_IDENTIFIER_SINGLETON, data); \
	    if ( metadata->attributeId == 0x0007 && !emberAfAttributeIsClient(metadata) ) \
	      halCommonSetToken(TOKEN_POWER_SOURCE_SINGLETON, data); \
	  }\
	  if ( endpoint == 9 ) { \
	    if ( clusterId == 0x06 ) { \
	      if ( metadata->attributeId == 0x0000 && !emberAfAttributeIsClient(metadata) ) \
	        halCommonSetToken(TOKEN_ON_OFF_9, data); \
	    } \
	  } \
	} while(FALSE)

#endif

#ifdef SWITCH_1_BUTTON

	// Identifier tags for tokens
	// Creator for attribute: ZCL version, singleton.
	#define CREATOR_VERSION_SINGLETON 0xB000
	// Creator for attribute: manufacturer name, singleton.
	#define CREATOR_MANUFACTURER_NAME_SINGLETON 0xB001
	// Creator for attribute: model identifier, singleton.
	#define CREATOR_MODEL_IDENTIFIER_SINGLETON 0xB002
	// Creator for attribute: power source, singleton.
	#define CREATOR_POWER_SOURCE_SINGLETON 0xB003
	// Creator for attribute: on/off, endpoint: 1
	#define CREATOR_ON_OFF_1 0xB004


	// Types for the tokens
	#ifdef DEFINETYPES
	typedef int8u  tokType_on_off;
	typedef int8u  tokType_version;
	typedef int8u  tokType_manufacturer_name[33];
	typedef int8u  tokType_model_identifier[33];
	typedef int8u  tokType_power_source;
	#endif // DEFINETYPES


	// Actual token definitions
	#ifdef DEFINETOKENS
	DEFINE_BASIC_TOKEN(VERSION_SINGLETON, tokType_version, 0x01)
	DEFINE_BASIC_TOKEN(MANUFACTURER_NAME_SINGLETON, tokType_manufacturer_name, {ManufacturerName})
	DEFINE_BASIC_TOKEN(MODEL_IDENTIFIER_SINGLETON, tokType_model_identifier, {ModelId})
	DEFINE_BASIC_TOKEN(POWER_SOURCE_SINGLETON, tokType_power_source, 0x01)
	DEFINE_BASIC_TOKEN(ON_OFF_1, tokType_on_off, 0x00)
	#endif // DEFINETOKENS


	// Macro snippet that loads all the attributes from tokens
	#define GENERATED_TOKEN_LOADER(endpoint) do {\
	  int8u ptr[33]; \
	  int8u curNetwork = emberGetCurrentNetwork(); \
	  int8u epNetwork; \
	  halCommonGetToken((tokType_version *)ptr, TOKEN_VERSION_SINGLETON); \
	  emberAfWriteServerAttribute(1, ZCL_BASIC_CLUSTER_ID, ZCL_VERSION_ATTRIBUTE_ID, (int8u*)ptr, ZCL_INT8U_ATTRIBUTE_TYPE); \
	  halCommonGetToken((tokType_manufacturer_name *)ptr, TOKEN_MANUFACTURER_NAME_SINGLETON); \
	  emberAfWriteServerAttribute(1, ZCL_BASIC_CLUSTER_ID, ZCL_MANUFACTURER_NAME_ATTRIBUTE_ID, (int8u*)ptr, ZCL_CHAR_STRING_ATTRIBUTE_TYPE); \
	  halCommonGetToken((tokType_model_identifier *)ptr, TOKEN_MODEL_IDENTIFIER_SINGLETON); \
	  emberAfWriteServerAttribute(1, ZCL_BASIC_CLUSTER_ID, ZCL_MODEL_IDENTIFIER_ATTRIBUTE_ID, (int8u*)ptr, ZCL_CHAR_STRING_ATTRIBUTE_TYPE); \
	  halCommonGetToken((tokType_power_source *)ptr, TOKEN_POWER_SOURCE_SINGLETON); \
	  emberAfWriteServerAttribute(1, ZCL_BASIC_CLUSTER_ID, ZCL_POWER_SOURCE_ATTRIBUTE_ID, (int8u*)ptr, ZCL_ENUM8_ATTRIBUTE_TYPE); \
	  epNetwork = emberAfNetworkIndexFromEndpoint(1); \
	  if((endpoint) == 1 || ((endpoint) == EMBER_BROADCAST_ENDPOINT && epNetwork == curNetwork)) { \
	    halCommonGetToken((tokType_on_off *)ptr, TOKEN_ON_OFF_1); \
	    emberAfWriteServerAttribute(1, ZCL_ON_OFF_CLUSTER_ID, ZCL_ON_OFF_ATTRIBUTE_ID, (int8u*)ptr, ZCL_BOOLEAN_ATTRIBUTE_TYPE); \
	  } \
	} while(FALSE)


	// Macro snippet that saves the attribute to token
	#define GENERATED_TOKEN_SAVER do {\
	  int8u allZeroData[33]; \
	  MEMSET(allZeroData, 0, 33); \
	  if ( data == NULL ) data = allZeroData; \
	  if ( clusterId == 0x00 ) { \
	    if ( metadata->attributeId == 0x0000 && !emberAfAttributeIsClient(metadata) ) \
	      halCommonSetToken(TOKEN_VERSION_SINGLETON, data); \
	    if ( metadata->attributeId == 0x0004 && !emberAfAttributeIsClient(metadata) ) \
	      halCommonSetToken(TOKEN_MANUFACTURER_NAME_SINGLETON, data); \
	    if ( metadata->attributeId == 0x0005 && !emberAfAttributeIsClient(metadata) ) \
	      halCommonSetToken(TOKEN_MODEL_IDENTIFIER_SINGLETON, data); \
	    if ( metadata->attributeId == 0x0007 && !emberAfAttributeIsClient(metadata) ) \
	      halCommonSetToken(TOKEN_POWER_SOURCE_SINGLETON, data); \
	  }\
	  if ( endpoint == 1 ) { \
	    if ( clusterId == 0x06 ) { \
	      if ( metadata->attributeId == 0x0000 && !emberAfAttributeIsClient(metadata) ) \
	        halCommonSetToken(TOKEN_ON_OFF_1, data); \
	    } \
	  } \
	} while(FALSE)




#endif
#ifdef SWITCH_2_BUTTON

			// Identifier tags for tokens
			// Creator for attribute: ZCL version, singleton.
			#define CREATOR_VERSION_SINGLETON 0xB000
			// Creator for attribute: manufacturer name, singleton.
			#define CREATOR_MANUFACTURER_NAME_SINGLETON 0xB001
			// Creator for attribute: model identifier, singleton.
			#define CREATOR_MODEL_IDENTIFIER_SINGLETON 0xB002
			// Creator for attribute: power source, singleton.
			#define CREATOR_POWER_SOURCE_SINGLETON 0xB003
			// Creator for attribute: on/off, endpoint: 1
			#define CREATOR_ON_OFF_1 0xB004
			// Creator for attribute: on/off, endpoint: 3
			#define CREATOR_ON_OFF_3 0xB005


			// Types for the tokens
			#ifdef DEFINETYPES
			typedef int8u  tokType_on_off;
			typedef int8u  tokType_version;
			typedef int8u  tokType_manufacturer_name[33];
			typedef int8u  tokType_model_identifier[33];
			typedef int8u  tokType_power_source;
			#endif // DEFINETYPES


			// Actual token definitions
			#ifdef DEFINETOKENS
			DEFINE_BASIC_TOKEN(VERSION_SINGLETON, tokType_version, 0x01)
			DEFINE_BASIC_TOKEN(MANUFACTURER_NAME_SINGLETON, tokType_manufacturer_name, {ManufacturerName})
			DEFINE_BASIC_TOKEN(MODEL_IDENTIFIER_SINGLETON, tokType_model_identifier, {ModelId})
			DEFINE_BASIC_TOKEN(POWER_SOURCE_SINGLETON, tokType_power_source, 0x01)
			DEFINE_BASIC_TOKEN(ON_OFF_1, tokType_on_off, 0x00)
			DEFINE_BASIC_TOKEN(ON_OFF_3, tokType_on_off, 0x00)
			#endif // DEFINETOKENS


			// Macro snippet that loads all the attributes from tokens
			#define GENERATED_TOKEN_LOADER(endpoint) do {\
			  int8u ptr[33]; \
			  int8u curNetwork = emberGetCurrentNetwork(); \
			  int8u epNetwork; \
			  halCommonGetToken((tokType_version *)ptr, TOKEN_VERSION_SINGLETON); \
			  emberAfWriteServerAttribute(1, ZCL_BASIC_CLUSTER_ID, ZCL_VERSION_ATTRIBUTE_ID, (int8u*)ptr, ZCL_INT8U_ATTRIBUTE_TYPE); \
			  halCommonGetToken((tokType_manufacturer_name *)ptr, TOKEN_MANUFACTURER_NAME_SINGLETON); \
			  emberAfWriteServerAttribute(1, ZCL_BASIC_CLUSTER_ID, ZCL_MANUFACTURER_NAME_ATTRIBUTE_ID, (int8u*)ptr, ZCL_CHAR_STRING_ATTRIBUTE_TYPE); \
			  halCommonGetToken((tokType_model_identifier *)ptr, TOKEN_MODEL_IDENTIFIER_SINGLETON); \
			  emberAfWriteServerAttribute(1, ZCL_BASIC_CLUSTER_ID, ZCL_MODEL_IDENTIFIER_ATTRIBUTE_ID, (int8u*)ptr, ZCL_CHAR_STRING_ATTRIBUTE_TYPE); \
			  halCommonGetToken((tokType_power_source *)ptr, TOKEN_POWER_SOURCE_SINGLETON); \
			  emberAfWriteServerAttribute(1, ZCL_BASIC_CLUSTER_ID, ZCL_POWER_SOURCE_ATTRIBUTE_ID, (int8u*)ptr, ZCL_ENUM8_ATTRIBUTE_TYPE); \
			  epNetwork = emberAfNetworkIndexFromEndpoint(1); \
			  if((endpoint) == 1 || ((endpoint) == EMBER_BROADCAST_ENDPOINT && epNetwork == curNetwork)) { \
			    halCommonGetToken((tokType_on_off *)ptr, TOKEN_ON_OFF_1); \
			    emberAfWriteServerAttribute(1, ZCL_ON_OFF_CLUSTER_ID, ZCL_ON_OFF_ATTRIBUTE_ID, (int8u*)ptr, ZCL_BOOLEAN_ATTRIBUTE_TYPE); \
			  } \
			  epNetwork = emberAfNetworkIndexFromEndpoint(3); \
			  if((endpoint) == 3 || ((endpoint) == EMBER_BROADCAST_ENDPOINT && epNetwork == curNetwork)) { \
			    halCommonGetToken((tokType_on_off *)ptr, TOKEN_ON_OFF_3); \
			    emberAfWriteServerAttribute(3, ZCL_ON_OFF_CLUSTER_ID, ZCL_ON_OFF_ATTRIBUTE_ID, (int8u*)ptr, ZCL_BOOLEAN_ATTRIBUTE_TYPE); \
			  } \
			} while(FALSE)


			// Macro snippet that saves the attribute to token
			#define GENERATED_TOKEN_SAVER do {\
			  int8u allZeroData[33]; \
			  MEMSET(allZeroData, 0, 33); \
			  if ( data == NULL ) data = allZeroData; \
			  if ( clusterId == 0x00 ) { \
			    if ( metadata->attributeId == 0x0000 && !emberAfAttributeIsClient(metadata) ) \
			      halCommonSetToken(TOKEN_VERSION_SINGLETON, data); \
			    if ( metadata->attributeId == 0x0004 && !emberAfAttributeIsClient(metadata) ) \
			      halCommonSetToken(TOKEN_MANUFACTURER_NAME_SINGLETON, data); \
			    if ( metadata->attributeId == 0x0005 && !emberAfAttributeIsClient(metadata) ) \
			      halCommonSetToken(TOKEN_MODEL_IDENTIFIER_SINGLETON, data); \
			    if ( metadata->attributeId == 0x0007 && !emberAfAttributeIsClient(metadata) ) \
			      halCommonSetToken(TOKEN_POWER_SOURCE_SINGLETON, data); \
			  }\
			  if ( endpoint == 1 ) { \
			    if ( clusterId == 0x06 ) { \
			      if ( metadata->attributeId == 0x0000 && !emberAfAttributeIsClient(metadata) ) \
			        halCommonSetToken(TOKEN_ON_OFF_1, data); \
			    } \
			  } else if ( endpoint == 3) { \
			    if ( clusterId == 0x06 ) { \
			      if ( metadata->attributeId == 0x0000 && !emberAfAttributeIsClient(metadata) ) \
			        halCommonSetToken(TOKEN_ON_OFF_3, data); \
			    } \
			  } \
			} while(FALSE)

#endif




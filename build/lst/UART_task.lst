###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        09/Sep/2015  17:13:24
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\UART_task.c
#    Command line =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\UART_task.c -D
#        NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM357 -D
#        PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"UART_task.c\"" -lC
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\build\lst\
#        --diag_suppress Pa050 -o
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\build\obj\ --debug
#        --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\build\lst\UART_task.lst
#    Object file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\build\obj\UART_task.o
#
###############################################################################

E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\UART_task.c
      1          
      2          
      3          
      4          
      5          
      6          
      7          //-----------------------------Khai bao thu vien---------------------//
      8          
      9          
     10          #include "app/framework/include/af.h"
     11          #include "task.h"
     12          #include "ButtonExe.h"
     13          #include "UART_task.h"
     14          #include "halDelay.h"
     15          
     16          //-----------------------------Khai bao bien-------------------------//

   \                                 In section .data, align 2
     17          int8u UART_PACKET_KEY[2]	=	{0x4C,0x4D};
   \                     UART_PACKET_KEY:
   \   00000000   0x4C 0x4D          DC8 76, 77
     18          
     19          
     20          

   \                                 In section .bss, align 4
     21          int8u UartTxCommandBuff[128];
   \                     UartTxCommandBuff:
   \   00000000                      DS8 128
     22          #define MAX_RX_BUFFER  128

   \                                 In section .bss, align 2
     23          int16u UartTxCommandStartWaitTimer = 0;
   \                     UartTxCommandStartWaitTimer:
   \   00000000                      DS8 2
     24          int16u UartTxCommandCurrentTimeOut = 0;
   \                     UartTxCommandCurrentTimeOut:
   \   00000002                      DS8 2
     25          
     26          
     27          

   \                                 In section .bss, align 4
     28          int8u UartRxDataStep = 0;
   \                     UartRxDataStep:
   \   00000000                      DS8 1
     29          int8u UartRxPacketLength;
   \                     UartRxPacketLength:
   \   00000001                      DS8 1
     30          int8u UartRxPacketCheckXor = 0;
     31          int8u UartRxCommandData[64] = {0};
     32          int8u UartRxCurrentLength = 0;
   \                     UartRxCurrentLength:
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \                     UartRxCommandData:
   \   00000004                      DS8 64

   \                                 In section .bss, align 1
   \                     UartRxPacketCheckXor:
   \   00000000                      DS8 1
     33          
     34          //extern int8u McReadyStatus;
     35          
     36          
     37          
     38          //-------------------------------Enum------------------------------//
     39          
     40          
     41          enum UartRxCommand_ID{
     42          	RelayStatusChange 	= 0xA0,
     43          	CurtainLevelChange 	= 0xA1,
     44          	DimmerLevelChange 	= 0xA2,
     45          	FanLevelChange 	  	= 0x03,
     46          	TouchButtonHold 	= 0xA7,
     47          	McTimmerCalibrate	= 0xAE,
     48          	CheckMcReady		= 0xD0,
     49          	McClockCalibrate	= 0xD1,
     50          };
     51          
     52          
     53          
     54          //-------------------------------CallTask------------------------------//
     55          
     56          
     57          //------------------------CallTaskRelayChangeCommand-------------------//
     58          enum RelayStateCmd{
     59          	RelayOff			= 0,
     60          	RelayOn				= 1,
     61          };

   \                                 In section .text, align 2, keep-with-next
     62          void CallTaskRelayChangeCommand( unsigned char *Data){
   \                     CallTaskRelayChangeCommand: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
     63               int8u i;
     64          	 int8u RelayState = Data[1];
   \   00000002   0x7844             LDRB     R4,[R0, #+1]
     65          	 int8u CurrentState[4] = {0};
   \   00000004   0xA802             ADD      R0,SP,#+8
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6001             STR      R1,[R0, #+0]
     66          	 for(i=0;i<4;i++){
   \   0000000A   0x2500             MOVS     R5,#+0
     67          		emberAfReadServerAttribute(i+1, ZCL_ON_OFF_CLUSTER_ID,ZCL_ON_OFF_ATTRIBUTE_ID,
     68          						&CurrentState[i], sizeof(CurrentState[i]));
   \                     ??CallTaskRelayChangeCommand_0: (+1)
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x1C6E             ADDS     R6,R5,#+1
   \   00000012   0xA802             ADD      R0,SP,#+8
   \   00000014   0x182B             ADDS     R3,R5,R0
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x2106             MOVS     R1,#+6
   \   0000001A   0xB2F0             UXTB     R0,R6
   \   0000001C   0x.... 0x....      BL       emberAfReadServerAttribute
     69          		if(CurrentState[i] != ((RelayState >> i) & 0x01)){
   \   00000020   0xA802             ADD      R0,SP,#+8
   \   00000022   0xFA24 0xF705      LSR      R7,R4,R5
   \   00000026   0x5C28             LDRB     R0,[R5, R0]
   \   00000028   0xF007 0x0101      AND      R1,R7,#0x1
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD014             BEQ.N    ??CallTaskRelayChangeCommand_1
     70          			//call button press call back;
     71          			 CallButtonPress(i);
   \   00000030   0xB2E8             UXTB     R0,R5
   \   00000032   0x.... 0x....      BL       beButtonPress
     72          			// and always wtite relay attribute
     73          			 switch((RelayState >> i) & 0x01){
   \   00000036   0xF017 0x0001      ANDS     R0,R7,#0x1
   \   0000003A   0xD004             BEQ.N    ??CallTaskRelayChangeCommand_2
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD10C             BNE.N    ??CallTaskRelayChangeCommand_1
     74          				 case RelayOn:
     75          				 {
     76          					int8u Relay = 1;
   \   00000040   0xF88D 0x0004      STRB     R0,[SP, #+4]
     77          					emberAfWriteServerAttribute(i+1,
     78          						ZCL_ON_OFF_CLUSTER_ID,ZCL_ON_OFF_ATTRIBUTE_ID, &Relay, sizeof(Relay));
   \   00000044   0xE002             B.N      ??CallTaskRelayChangeCommand_3
     79          				 }
     80          					break;
     81          				 case RelayOff:
     82          				 {
     83          					int8u	Relay = 0;
   \                     ??CallTaskRelayChangeCommand_2: (+1)
   \   00000046   0xF88D 0x0004      STRB     R0,[SP, #+4]
     84          					emberAfWriteServerAttribute(i+1,
     85          						ZCL_ON_OFF_CLUSTER_ID,ZCL_ON_OFF_ATTRIBUTE_ID, &Relay, sizeof(Relay));
   \   0000004A   0x2001             MOVS     R0,#+1
   \                     ??CallTaskRelayChangeCommand_3: (+1)
   \   0000004C   0x9000             STR      R0,[SP, #+0]
   \   0000004E   0xAB01             ADD      R3,SP,#+4
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x2106             MOVS     R1,#+6
   \   00000054   0xB2F0             UXTB     R0,R6
   \   00000056   0x.... 0x....      BL       emberAfWriteServerAttribute
     86          				 }
     87          					break;
     88          				default:
     89          					break;
     90          			 }
     91          
     92          		}
     93          	}
   \                     ??CallTaskRelayChangeCommand_1: (+1)
   \   0000005A   0x1C6D             ADDS     R5,R5,#+1
   \   0000005C   0x2D04             CMP      R5,#+4
   \   0000005E   0xDBD5             BLT.N    ??CallTaskRelayChangeCommand_0
     94          }
   \   00000060   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
     95          
     96          //------------------------CallTaskMcClockCalibrate-------------------//
     97          

   \                                 In section .text, align 2, keep-with-next
     98          void CallTaskMcClockCalibrate(int8u *Data){
   \                     CallTaskMcClockCalibrate: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     99          	int8u DataCheckKey[16] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,
    100          										0xBB,0xCC,0xDD,0xEE,0xFF};
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1`
   \   0000000A   0x.... 0x....      BL       ?Subroutine8
    101          	if(MEMCOMPARE(&Data[1], DataCheckKey, 0) == 0){
   \                     ??CrossCallReturnLabel_13: (+1)
   \   0000000E   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000012   0xB908             CBNZ.N   R0,??CallTaskMcClockCalibrate_0
    102          		UartSendMcClockCalibrate();
   \   00000014   0x.... 0x....      BL       UartSendMcClockCalibrate
    103          	}
    104          }
   \                     ??CallTaskMcClockCalibrate_0: (+1)
   \   00000018   0xBD1F             POP      {R0-R4,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0xA900             ADD      R1,SP,#+0
   \   00000004   0x1C60             ADDS     R0,R4,#+1
   \   00000006   0x.... 0x....      B.W      halCommonMemCompare

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x2210             MOVS     R2,#+16
   \   00000002   0x.... 0x....      B.W      __aeabi_memcpy4
    105          //------------------------CallTaskCheckMcReady-------------------//
    106          // This Uart Command Indicator MC StartUp, or EM reset end StartUp

   \                                 In section .text, align 2, keep-with-next
    107          void CallTaskCheckMcReady(int8u *Data){
   \                     CallTaskCheckMcReady: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    108          	EmberNetworkStatus NetworkStatus;
    109          	int8u DataCheckKey[16] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,
    110          										0xBB,0xCC,0xDD,0xEE,0xFF};
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_1`
   \   0000000A   0x.... 0x....      BL       ?Subroutine8
    111          	if(MEMCOMPARE(&Data[1], DataCheckKey, 0) == 0){
   \                     ??CrossCallReturnLabel_14: (+1)
   \   0000000E   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000012   0xB9C0             CBNZ.N   R0,??CallTaskCheckMcReady_0
    112          
    113          		UartSendBlinkLed(0x0F, 2);
   \   00000014   0x2102             MOVS     R1,#+2
   \   00000016   0x200F             MOVS     R0,#+15
   \   00000018   0x.... 0x....      BL       UartSendBlinkLed
    114          		UartSendSwitchControlStateMark(0x00);  // Get switch state after reset
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       UartSendSwitchControlStateMark
    115                  CallJoinTask(0xFF,3000 + ((int8u)halCommonGetRandom()<<2));
   \   00000022   0x.... 0x....      BL       halCommonGetRandom
   \   00000026   0x0600             LSLS     R0,R0,#+24
   \   00000028   0x0D80             LSRS     R0,R0,#+22
   \   0000002A   0xF600 0x31B8      ADDW     R1,R0,#+3000
   \   0000002E   0xB289             UXTH     R1,R1
   \   00000030   0x20FF             MOVS     R0,#+255
   \   00000032   0x.... 0x....      BL       CallJoinTask
    116          		NetworkStatus = emberAfNetworkState();
    117          		if(NetworkStatus == EMBER_JOINED_NETWORK) {
   \   00000036   0x.... 0x....      BL       emberAfNetworkState
   \   0000003A   0x2802             CMP      R0,#+2
   \   0000003C   0xD103             BNE.N    ??CallTaskCheckMcReady_0
    118          			UartSendBlinkLed(0x0F, 1);
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x200F             MOVS     R0,#+15
   \   00000042   0x.... 0x....      BL       UartSendBlinkLed
    119          		}
    120          	}
    121          }
   \                     ??CallTaskCheckMcReady_0: (+1)
   \   00000046   0xBD1F             POP      {R0-R4,PC}       ;; return
    122          //------------------------CallTaskTouchButtonHold--------------------//
    123          enum ButtonHoldCmd{
    124          	ButtonUnpress		= 0,
    125          	ButtonShortHold		= 1,
    126          	ButtonLongHold		= 2,
    127              ButtonResetHold		= 3,
    128          };

   \                                 In section .text, align 2, keep-with-next
    129          void CallTaskTouchButtonHold(int8u *Data){
    130          	int8u ButtonPress = Data[1] + 1;
   \                     CallTaskTouchButtonHold: (+1)
   \   00000000   0x7841             LDRB     R1,[R0, #+1]
    131          	int8u ButtonHoldType = Data[2];
    132          
    133          	switch (ButtonHoldType & 0x03){
   \   00000002   0x7880             LDRB     R0,[R0, #+2]
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \   00000006   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000000A   0xD003             BEQ.N    ??CallTaskTouchButtonHold_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD007             BEQ.N    ??CallTaskTouchButtonHold_1
   \   00000010   0xD303             BCC.N    ??CallTaskTouchButtonHold_2
   \   00000012   0x4770             BX       LR
    134          		case ButtonUnpress:
    135          			CallButtonRelease(ButtonPress);
   \                     ??CallTaskTouchButtonHold_0: (+1)
   \   00000014   0xB2C8             UXTB     R0,R1
   \   00000016   0x.... 0x....      B.W      beButtonRealease
    136          		break;
    137          		case ButtonShortHold:
    138          			CallButtonShortHold(ButtonPress);
   \                     ??CallTaskTouchButtonHold_2: (+1)
   \   0000001A   0xB2C8             UXTB     R0,R1
   \   0000001C   0x.... 0x....      B.W      beButtonPress2Time
    139          		break;
    140          		case ButtonLongHold:
    141          			CallButtonLongHold(ButtonPress);
   \                     ??CallTaskTouchButtonHold_1: (+1)
   \   00000020   0xB2C8             UXTB     R0,R1
   \   00000022   0x.... 0x....      B.W      beButtonPress3Time
    142          		break;
    143          		case ButtonResetHold:
    144          		break;
    145          		default:
    146          		break;
    147          
    148          	}
    149          }
    150          
    151          //----------------------------CallTask--------------------------------//
    152          

   \                                 In section .text, align 2, keep-with-next
    153          void CallUartTask(int8u *UartPacketCommand){
    154          	int8u UartPacketID = UartPacketCommand[0];
    155          
    156          	switch(UartPacketID){
   \                     CallUartTask: (+1)
   \   00000000   0x7801             LDRB     R1,[R0, #+0]
   \   00000002   0x29A0             CMP      R1,#+160
   \   00000004   0xD006             BEQ.N    ??CallUartTask_0
   \   00000006   0x29A7             CMP      R1,#+167
   \   00000008   0xD005             BEQ.N    ??CallUartTask_1
   \   0000000A   0x29D0             CMP      R1,#+208
   \   0000000C   0xD005             BEQ.N    ??CallUartTask_2
   \   0000000E   0x29D1             CMP      R1,#+209
   \   00000010   0xD002             BEQ.N    ??CallUartTask_3
   \   00000012   0x4770             BX       LR
    157          		case RelayStatusChange:
    158          			CallTaskRelayChangeCommand(UartPacketCommand);
   \                     ??CallUartTask_0: (+1)
   \   00000014   0x....             B.N      CallTaskRelayChangeCommand
    159          			break;
    160          		case CurtainLevelChange:
    161          			break;
    162          		case DimmerLevelChange:
    163          			break;
    164          		case FanLevelChange:
    165          			break;
    166          		case TouchButtonHold:
    167          			CallTaskTouchButtonHold(UartPacketCommand);
   \                     ??CallUartTask_1: (+1)
   \   00000016   0x....             B.N      CallTaskTouchButtonHold
    168          			break;
    169          		case McTimmerCalibrate:
    170          			break;
    171          		case McClockCalibrate:
    172          			CallTaskMcClockCalibrate(UartPacketCommand);
   \                     ??CallUartTask_3: (+1)
   \   00000018   0x....             B.N      CallTaskMcClockCalibrate
    173          			break;
    174          		case CheckMcReady:
    175          			CallTaskCheckMcReady(UartPacketCommand);
   \                     ??CallUartTask_2: (+1)
   \   0000001A   0x....             B.N      CallTaskCheckMcReady
    176          			break;
    177          		default:
    178          			break;
    179          	}
    180          }
    181          
    182          
    183          
    184          

   \                                 In section .text, align 2, keep-with-next
    185          void UartScanCommand(void){
   \                     UartScanCommand: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    186          	int16u NumberOfByteReCeiver;
    187          	int8u ReadSerialData;
    188          	int8u ReadStatus;
    189          
    190          
    191          	NumberOfByteReCeiver = emberSerialReadAvailable (1);
    192          	if(NumberOfByteReCeiver > 0){
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       emberSerialReadAvailable
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD041             BEQ.N    ??UartScanCommand_0
    193          		ReadStatus = emberSerialReadByte(1, &ReadSerialData);
    194          		{
    195          			if(ReadStatus == EMBER_SUCCESS){
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       emberSerialReadByte
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD13B             BNE.N    ??UartScanCommand_0
    196          
    197          				switch (UartRxDataStep){
   \   00000018   0x.... 0x....      LDR.W    R4,??DataTable11
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0x7821             LDRB     R1,[R4, #+0]
   \   00000022   0xB129             CBZ.N    R1,??UartScanCommand_1
   \   00000024   0x2902             CMP      R1,#+2
   \   00000026   0xD00C             BEQ.N    ??UartScanCommand_2
   \   00000028   0xD306             BCC.N    ??UartScanCommand_3
   \   0000002A   0x2903             CMP      R1,#+3
   \   0000002C   0xD00F             BEQ.N    ??UartScanCommand_4
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}
    198          				case 0:
    199          					if(ReadSerialData == 0x4C){
   \                     ??UartScanCommand_1: (+1)
   \   00000030   0x284C             CMP      R0,#+76
   \   00000032   0xD12D             BNE.N    ??UartScanCommand_0
    200          						UartRxDataStep = 1;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE02A             B.N      ??UartScanCommand_5
    201          					}
    202          					else{
    203          						UartRxDataStep = 0;
    204          					}
    205          				break;
    206          				case 1:
    207          					if(ReadSerialData == 0x4D){
   \                     ??UartScanCommand_3: (+1)
   \   00000038   0x284D             CMP      R0,#+77
   \   0000003A   0xBF14             ITE      NE 
    208          						UartRxDataStep = 2;
    209          					}
    210          					else{
    211          						UartRxDataStep = 0;
   \   0000003C   0x2000             MOVNE    R0,#+0
    212          					}
   \   0000003E   0x2002             MOVEQ    R0,#+2
   \   00000040   0xE025             B.N      ??UartScanCommand_5
    213          				break;
    214          				case 2:
    215          					UartRxPacketLength = ReadSerialData;
   \                     ??UartScanCommand_2: (+1)
   \   00000042   0x7060             STRB     R0,[R4, #+1]
    216          					if(UartRxPacketLength >40){
   \   00000044   0x2829             CMP      R0,#+41
   \   00000046   0xBFB4             ITE      LT 
    217          						UartRxDataStep = 0;
    218          					}
    219          					else{
    220          						UartRxDataStep = 3;
   \   00000048   0x2003             MOVLT    R0,#+3
    221          					}
   \   0000004A   0x2000             MOVGE    R0,#+0
   \   0000004C   0xE01F             B.N      ??UartScanCommand_5
    222          				break;
    223          				case 3:
    224          					if(UartRxCurrentLength < UartRxPacketLength-1){
   \                     ??UartScanCommand_4: (+1)
   \   0000004E   0x7860             LDRB     R0,[R4, #+1]
   \   00000050   0x78A1             LDRB     R1,[R4, #+2]
   \   00000052   0x1E40             SUBS     R0,R0,#+1
   \   00000054   0x4281             CMP      R1,R0
   \   00000056   0xDA06             BGE.N    ??UartScanCommand_6
    225          						UartRxCommandData[UartRxCurrentLength] =  ReadSerialData;
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0x190A             ADDS     R2,R1,R4
   \   0000005E   0x7110             STRB     R0,[R2, #+4]
    226          						UartRxCurrentLength ++;
   \   00000060   0x1C48             ADDS     R0,R1,#+1
   \   00000062   0x70A0             STRB     R0,[R4, #+2]
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}
    227          					}
    228          					else{
    229          						int8u PacketCheckXor;
    230          						int8u CheckXor =0;
   \                     ??UartScanCommand_6: (+1)
   \   00000066   0x2100             MOVS     R1,#+0
    231          						PacketCheckXor =  ReadSerialData;
   \   00000068   0xF89D 0x2000      LDRB     R2,[SP, #+0]
    232          						{
    233          							for(int8u j=0;j < UartRxPacketLength-1;j++){
   \   0000006C   0x2300             MOVS     R3,#+0
   \   0000006E   0xE003             B.N      ??UartScanCommand_7
    234          								CheckXor = CheckXor ^ UartRxCommandData[j];
   \                     ??UartScanCommand_8: (+1)
   \   00000070   0x191D             ADDS     R5,R3,R4
    235          							}
   \   00000072   0x1C5B             ADDS     R3,R3,#+1
   \   00000074   0x792D             LDRB     R5,[R5, #+4]
   \   00000076   0x4069             EORS     R1,R5,R1
   \                     ??UartScanCommand_7: (+1)
   \   00000078   0xB2DB             UXTB     R3,R3
   \   0000007A   0x4283             CMP      R3,R0
   \   0000007C   0xDBF8             BLT.N    ??UartScanCommand_8
    236          						}
    237          						if(PacketCheckXor == CheckXor){
   \   0000007E   0xB2C9             UXTB     R1,R1
   \   00000080   0x428A             CMP      R2,R1
   \   00000082   0xBF04             ITT      EQ 
    238          							CallUartTask(UartRxCommandData);
   \   00000084   0x1D20             ADDEQ    R0,R4,#+4
   \   00000086   0x.... 0x....      BLEQ     CallUartTask
    239          						}
    240          						UartRxCurrentLength = 0;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x70A0             STRB     R0,[R4, #+2]
    241          						UartRxDataStep = 0;
   \                     ??UartScanCommand_5: (+1)
   \   0000008E   0x7020             STRB     R0,[R4, #+0]
    242          					}
    243          				break;
    244          					default:
    245          				break;
    246          
    247          				}
    248          			}
    249          		}
    250          	}
    251          }
   \                     ??UartScanCommand_0: (+1)
   \   00000090   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    252          
    253          
    254          
    255          //--------------------------------------------UART Send Command--------------------------//
    256          
    257          
    258          enum UartTxCommand_ID{
    259          	SwitchControlCmdId		=	0xB0,
    260          	ChangeSpecialLedTxCmdId	=	0xB7,
    261          	AttributeSetupCmdId		=	0xBC,
    262          	McClockCalibrateCmdId  = 	0xC1,
    263          	McReadyCmdId			=	0xC0,
    264          };
    265          
    266          //----------------------------UART Send Command Utility-----------------------//
    267          

   \                                 In section .text, align 2, keep-with-next
    268          unsigned char GetLastTxUartCmd(void){
    269              unsigned char Head = 0;
   \                     GetLastTxUartCmd: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
    270              unsigned char Length = 0;
   \   00000002   0x....             LDR.N    R1,??DataTable11_1
   \   00000004   0xE002             B.N      ??GetLastTxUartCmd_0
    271              while(UartTxCommandBuff[Head] != 0){
    272                  if(UartTxCommandBuff[Head] != 0){
    273                      Length = UartTxCommandBuff[Head];
    274                      Head = Head+Length+2;
   \                     ??GetLastTxUartCmd_1: (+1)
   \   00000006   0x1810             ADDS     R0,R2,R0
   \   00000008   0x1C80             ADDS     R0,R0,#+2
   \   0000000A   0xB2C0             UXTB     R0,R0
    275                  }
    276              }
   \                     ??GetLastTxUartCmd_0: (+1)
   \   0000000C   0x5C42             LDRB     R2,[R0, R1]
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD1F9             BNE.N    ??GetLastTxUartCmd_1
    277              return Head;
   \   00000012   0x4770             BX       LR               ;; return
    278          }
    279          
    280          
    281          //------------------------------Send Switch Control Command----------------//
    282           /*
    283          Mau ban tin:
    284          
    285          CommandID			Switch State
    286          1byte				11Byte
    287          0xB0
    288          */
    289          
    290          
    291          
    292          // State off Relay Use SwitchStateEnum

   \                                 In section .text, align 2, keep-with-next
    293          void UartSendSwitchControlNumber(int8u SwitchNumber, int8u State){
   \                     UartSendSwitchControlNumber: (+1)
   \   00000000   0xB500             PUSH     {LR}
    294          	UartSendSwitchControlDataBuffer UartSendSwitchControlData;
    295          
    296          	UartSendSwitchControlData.Length = 3;
    297          	UartSendSwitchControlData.Id = SwitchControlCmdId;
    298          	UartSendSwitchControlData.Data = (State << 2*(SwitchNumber-1));
   \   00000002   0x1E40             SUBS     R0,R0,#+1
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_17: (+1)
   \   0000000A   0x2203             MOVS     R2,#+3
    299              UartSendSwitchControlData.CheckXor =  UartSendSwitchControlData.Id ^ UartSendSwitchControlData.Data;
   \   0000000C   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000010   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \   00000014   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000018   0x22B0             MOVS     R2,#+176
    300          	UartSendSwitchControlData.TimeOut = NormalTimeOut;
   \   0000001A   0x20FF             MOVS     R0,#+255
   \   0000001C   0xF88D 0x2001      STRB     R2,[SP, #+1]
   \   00000020   0x....             B.N      ?Subroutine0
    301          
    302          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendSwitchControlData,
    303          			sizeof(UartSendSwitchControlDataBuffer));
    304          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0xF080 0x00B0      EOR      R0,R0,#0xB0
   \   00000004   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000004   0x2205             MOVS     R2,#+5
   \                     ??Subroutine0_0: (+1)
   \   00000006   0x....             LDR.N    R3,??DataTable11_1
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x18C0             ADDS     R0,R0,R3
   \   0000000C   0x.... 0x....      BL       halCommonMemMove
   \   00000010   0xBD07             POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   00000004   0x....             B.N      GetLastTxUartCmd

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x0040             LSLS     R0,R0,#+1
   \   00000002   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000006   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   0000000A   0x4770             BX       LR
    305          

   \                                 In section .text, align 2, keep-with-next
    306          void UartSendSwitchControlMark(int8u SwitchMark, int8u State){
   \                     UartSendSwitchControlMark: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    307          	int8u i;
    308          	UartSendSwitchControlDataBuffer UartSendSwitchControlData;
    309          
    310          	for(i=0;i<4;i++){
   \   00000002   0x.... 0x....      BL       ?Subroutine3
    311          		if(((SwitchMark >> i) & 0x01) == 1){
    312          			UartSendSwitchControlData.Data = UartSendSwitchControlData.Data | (State << 2*i);
    313          		}
    314          	}
    315          	UartSendSwitchControlData.Length = 3;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000006   0x2003             MOVS     R0,#+3
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
    316          	UartSendSwitchControlData.Id = SwitchControlCmdId;
   \   0000000C   0x20B0             MOVS     R0,#+176
   \   0000000E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    317          	UartSendSwitchControlData.CheckXor = UartSendSwitchControlData.Id ^ UartSendSwitchControlData.Data;
   \   00000012   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000016   0x.... 0x....      BL       ?Subroutine6
    318          	UartSendSwitchControlData.TimeOut = NormalTimeOut;
   \                     ??CrossCallReturnLabel_9: (+1)
   \   0000001A   0x20FF             MOVS     R0,#+255
   \   0000001C   0x.... 0x....      BL       ?Subroutine4
    319          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendSwitchControlData,
    320          			sizeof(UartSendSwitchControlDataBuffer));
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000020   0x2205             MOVS     R2,#+5
   \   00000022   0x....             B.N      ??Subroutine13_0
    321          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \                     ??Subroutine3_0: (+1)
   \   00000002   0xFA40 0xF302      ASR      R3,R0,R2
   \   00000006   0x07DB             LSLS     R3,R3,#+31
   \   00000008   0xD507             BPL.N    ??Subroutine3_1
   \   0000000A   0xF89D 0x3002      LDRB     R3,[SP, #+2]
   \   0000000E   0x0054             LSLS     R4,R2,#+1
   \   00000010   0xFA01 0xF404      LSL      R4,R1,R4
   \   00000014   0x4323             ORRS     R3,R4,R3
   \   00000016   0xF88D 0x3002      STRB     R3,[SP, #+2]
   \                     ??Subroutine3_1: (+1)
   \   0000001A   0x1C52             ADDS     R2,R2,#+1
   \   0000001C   0x2A04             CMP      R2,#+4
   \   0000001E   0xDBF0             BLT.N    ??Subroutine3_0
   \   00000020   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine13_0: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable11_1
   \   00000002   0xA900             ADD      R1,SP,#+0
   \   00000004   0x18C0             ADDS     R0,R0,R3
   \   00000006   0x.... 0x....      BL       halCommonMemMove
   \   0000000A   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
    322          void UartSendSwitchControlStateMark(int8u SwitchStateMark){
   \                     UartSendSwitchControlStateMark: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    323          	UartSendSwitchControlDataBuffer UartSendSwitchControlData;
    324          
    325          	UartSendSwitchControlData.Length = 3;
   \   00000004   0x2103             MOVS     R1,#+3
    326          	UartSendSwitchControlData.Id = SwitchControlCmdId;
    327          	UartSendSwitchControlData.Data = SwitchStateMark;
   \   00000006   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   0000000A   0xF88D 0x1000      STRB     R1,[SP, #+0]
    328              UartSendSwitchControlData.CheckXor =  UartSendSwitchControlData.Id ^ UartSendSwitchControlData.Data;
   \   0000000E   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000012   0x21B0             MOVS     R1,#+176
    329          	UartSendSwitchControlData.TimeOut = NormalTimeOut;
   \   00000014   0x20FF             MOVS     R0,#+255
   \   00000016   0xF88D 0x1001      STRB     R1,[SP, #+1]
   \   0000001A                      REQUIRE ?Subroutine0
   \   0000001A                      ;; // Fall through to label ?Subroutine0
    330          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendSwitchControlData,
    331          			sizeof(UartSendSwitchControlDataBuffer));
    332          }
    333          
    334          //------------------------------Send Attribute Setup Command----------------//
    335           /*
    336          Mau ban tin:
    337          
    338          CommandID			Attribute			Value
    339          1byte				1Byte               1 Byte
    340          0xBC
    341          */
    342          
    343          // Option of Store value use StoreAttributeEnum
    344          // AttribteId use SetupAttributeIdEnum

   \                                 In section .text, align 2, keep-with-next
    345          void UartSendStoreAttribute(int8u SwitchMark, int8u Option){
   \                     UartSendStoreAttribute: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    346          	UartSendAttributeSetupDataBuffer UartSendAttributeSetupData;
    347          	int8u i;
    348          	for(i=0;i<4;i++){
   \   00000004   0x2200             MOVS     R2,#+0
    349          		if(((SwitchMark<<i) & 0x01) == 1){
   \                     ??UartSendStoreAttribute_0: (+1)
   \   00000006   0xFA00 0xF302      LSL      R3,R0,R2
   \   0000000A   0x07DB             LSLS     R3,R3,#+31
   \   0000000C   0xD507             BPL.N    ??UartSendStoreAttribute_1
    350          			UartSendAttributeSetupData.Value[0] = UartSendAttributeSetupData.Value[0] | (Option<<(2*i));
   \   0000000E   0xF89D 0x3003      LDRB     R3,[SP, #+3]
   \   00000012   0x0054             LSLS     R4,R2,#+1
   \   00000014   0xFA01 0xF404      LSL      R4,R1,R4
   \   00000018   0x4323             ORRS     R3,R4,R3
   \   0000001A   0xF88D 0x3003      STRB     R3,[SP, #+3]
    351          		}
    352          	}
   \                     ??UartSendStoreAttribute_1: (+1)
   \   0000001E   0x1C52             ADDS     R2,R2,#+1
   \   00000020   0x2A04             CMP      R2,#+4
   \   00000022   0xDBF0             BLT.N    ??UartSendStoreAttribute_0
    353          
    354          
    355          	UartSendAttributeSetupData.Length = 8;
   \   00000024   0x2008             MOVS     R0,#+8
   \   00000026   0xF88D 0x0000      STRB     R0,[SP, #+0]
    356          	UartSendAttributeSetupData.Id = AttributeSetupCmdId;
   \   0000002A   0x20BC             MOVS     R0,#+188
   \   0000002C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    357          	UartSendAttributeSetupData.AttribteId = SaveState;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xF88D 0x0002      STRB     R0,[SP, #+2]
    358          	UartSendAttributeSetupData.CheckXor = UartSendAttributeSetupData.Value[0] ^ UartSendAttributeSetupData.AttribteId
    359          		^ UartSendAttributeSetupData.Id;
   \   00000036   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000003A   0xF080 0x00BD      EOR      R0,R0,#0xBD
   \   0000003E   0xF88D 0x0008      STRB     R0,[SP, #+8]
    360              UartSendAttributeSetupData.TimeOut = NormalTimeOut;
   \   00000042   0x20FF             MOVS     R0,#+255
   \   00000044   0xF88D 0x0009      STRB     R0,[SP, #+9]
    361          
    362              MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendAttributeSetupData,
    363          			sizeof(UartSendAttributeSetupDataBuffer));
   \   00000048   0x.... 0x....      BL       GetLastTxUartCmd
   \   0000004C   0x220A             MOVS     R2,#+10
   \   0000004E   0x.... 0x....      BL       ?Subroutine5
    364          }
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000052   0xBD1F             POP      {R0-R4,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable11_1
   \   00000002   0xA900             ADD      R1,SP,#+0
   \   00000004   0x18C0             ADDS     R0,R0,R3
   \   00000006   0x.... 0x....      B.W      halCommonMemMove
    365          
    366          
    367          
    368          
    369          //------------------------------Send MC Clock Calibrate Command----------------//
    370           /*
    371          Mau ban tin:
    372          
    373          CommandID			Calibrate Data
    374          1byte				16Byte
    375          0xC1				0x00 ->0xFF
    376          */
    377          
    378          
    379          

   \                                 In section .text, align 2, keep-with-next
    380          void UartSendMcClockCalibrate(void){
   \                     UartSendMcClockCalibrate: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    381          	UartSendMcClockCalibrateDataBuffer UartSendMcClockCalibrateData;
    382          	int8u DataCheckKey[16] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,
    383          										0xBB,0xCC,0xDD,0xEE,0xFF};
   \   00000004   0xA805             ADD      R0,SP,#+20
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_2`
   \   0000000A   0x.... 0x....      BL       ?Subroutine8
    384          	UartSendMcClockCalibrateData.Length = 18;
   \                     ??CrossCallReturnLabel_15: (+1)
   \   0000000E   0x2012             MOVS     R0,#+18
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    385          	UartSendMcClockCalibrateData.Id		= McClockCalibrateCmdId;
    386          	MEMCOPY(&UartSendMcClockCalibrateData.Data, DataCheckKey, sizeof(DataCheckKey));
   \   00000014   0x2210             MOVS     R2,#+16
   \   00000016   0x20C1             MOVS     R0,#+193
   \   00000018   0x.... 0x....      BL       ?Subroutine10
    387          	UartSendMcClockCalibrateData.CheckXor = McClockCalibrateCmdId;
   \                     ??CrossCallReturnLabel_20: (+1)
   \   0000001C   0x20C1             MOVS     R0,#+193
   \   0000001E   0x....             B.N      ?Subroutine2
    388          	UartSendMcClockCalibrateData.TimeOut = NormalTimeOut;
    389          
    390          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendMcClockCalibrateData,
    391          			sizeof(UartSendMcClockCalibrateData));
    392          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xF88D 0x0012      STRB     R0,[SP, #+18]
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0xF88D 0x0013      STRB     R0,[SP, #+19]
   \   0000000A   0x.... 0x....      BL       GetLastTxUartCmd
   \   0000000E   0x2214             MOVS     R2,#+20
   \   00000010   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000014   0xB009             ADD      SP,SP,#+36
   \   00000016   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000004   0xA905             ADD      R1,SP,#+20
   \   00000006   0xF10D 0x0002      ADD      R0,SP,#+2
   \   0000000A   0x.... 0x....      B.W      halCommonMemMove
    393          
    394          
    395          //----------------------------------Send Special Led Command------------------------//
    396           /*
    397          Mau ban tin:
    398          
    399          CommandID			State			Extra
    400          1byte				1Byte			1Byte
    401          0xB7
    402          */
    403          
    404          
    405          // State off Special Led use LedStateEnum
    406          // State off Led after Blink use LedStateEnum

   \                                 In section .text, align 2, keep-with-next
    407          void UartSendRefreshAllLed(void){
    408          	UartSendSpecialLedMark(0x0F, 0);
   \                     UartSendRefreshAllLed: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x200F             MOVS     R0,#+15
   \   00000004   0x....             B.N      UartSendSpecialLedMark
    409          }

   \                                 In section .text, align 2, keep-with-next
    410          void UartSendRefreshLedNumber(int8u LedNumber){
    411          	UartSendSpecialLedNumber(LedNumber, 0);
   \                     UartSendRefreshLedNumber: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      UartSendSpecialLedNumber
    412          }

   \                                 In section .text, align 2, keep-with-next
    413          void UartSendSpecialLedMark (int8u LedNumberMark, int8u State){
   \                     UartSendSpecialLedMark: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    414          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    415          	int8u i;
    416          
    417          	for(i=0;i<4;i++){
   \   00000002   0x.... 0x....      BL       ?Subroutine3
    418          		if(((LedNumberMark >> i) & 0x01) == 1){
    419          			UartSendSpecialLedMarkData.State = UartSendSpecialLedMarkData.State | (State << 2*i);
    420          		}
    421          	}
    422          	UartSendSpecialLedMarkData.Extra = 0;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000006   0x....             B.N      ?Subroutine1
    423          	UartSendSpecialLedMarkData.Length = 4;
    424          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    425          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    426          		UartSendSpecialLedMarkData.Extra;
    427          
    428          	UartSendSpecialLedMarkData.TimeOut = NormalTimeOut;
    429          
    430             	MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    431          			sizeof(UartSendSpecialLedDataBuffer));
    432          
    433          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000C   0x20B7             MOVS     R0,#+183
   \   0000000E   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000012   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000016   0xF080 0x00B7      EOR      R0,R0,#0xB7
   \   0000001A   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   0000001E   0x20FF             MOVS     R0,#+255
   \   00000020   0xF88D 0x0005      STRB     R0,[SP, #+5]
   \   00000024   0x.... 0x....      BL       GetLastTxUartCmd
   \   00000028   0x2206             MOVS     R2,#+6
   \   0000002A                      REQUIRE ??Subroutine13_0
   \   0000002A                      ;; // Fall through to label ??Subroutine13_0
    434          
    435          

   \                                 In section .text, align 2, keep-with-next
    436          void UartSendSpecialLedNumber (int8u LedNumber, int8u State){
   \                     UartSendSpecialLedNumber: (+1)
   \   00000000   0xB500             PUSH     {LR}
    437          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    438          
    439          
    440          	UartSendSpecialLedMarkData.State =  (State << (2*(LedNumber -1)));
   \   00000002   0x1E40             SUBS     R0,R0,#+1
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x.... 0x....      BL       ?Subroutine9
    441          	UartSendSpecialLedMarkData.Extra = 0;
   \                     ??CrossCallReturnLabel_18: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    442          	UartSendSpecialLedMarkData.Length = 4;
   \   00000010   0x.... 0x....      BL       ?Subroutine11
    443          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    444          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    445          		UartSendSpecialLedMarkData.Extra;
   \                     ??CrossCallReturnLabel_21: (+1)
   \   00000014   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000018   0xF080 0x00B7      EOR      R0,R0,#0xB7
   \   0000001C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    446              UartSendSpecialLedMarkData.TimeOut = NormalTimeOut;
   \   00000020   0x20FF             MOVS     R0,#+255
   \   00000022   0xF88D 0x0005      STRB     R0,[SP, #+5]
    447          	MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    448          			sizeof(UartSendSpecialLedDataBuffer));
   \   00000026   0x.... 0x....      BL       GetLastTxUartCmd
   \   0000002A   0x2206             MOVS     R2,#+6
   \   0000002C   0x....             B.N      ??Subroutine0_0
    449          
    450          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0x2004             MOVS     R0,#+4
   \   00000002   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000006   0x20B7             MOVS     R0,#+183
   \   00000008   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000000C   0x4770             BX       LR
    451          
    452          
    453          

   \                                 In section .text, align 2, keep-with-next
    454          void UartSendPinkLed(int8u LedNumberMark){
   \                     UartSendPinkLed: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    455          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    456          
    457          	int8u i;
    458          
    459          	for(i=0;i<4;i++){
   \   00000002   0x2100             MOVS     R1,#+0
    460          		if(((LedNumberMark >> i) & 0x01) == 1){
   \                     ??UartSendPinkLed_0: (+1)
   \   00000004   0xFA40 0xF201      ASR      R2,R0,R1
   \   00000008   0x07D2             LSLS     R2,R2,#+31
   \   0000000A   0xD504             BPL.N    ??CrossCallReturnLabel_23
    461          			UartSendSpecialLedMarkData.State = UartSendSpecialLedMarkData.State | (PinkState << 2*i);
   \   0000000C   0xF89D 0x2002      LDRB     R2,[SP, #+2]
   \   00000010   0x2302             MOVS     R3,#+2
   \   00000012   0x.... 0x....      BL       ?Subroutine12
    462          		}
    463          	}
   \                     ??CrossCallReturnLabel_23: (+1)
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0x2904             CMP      R1,#+4
   \   0000001A   0xDBF3             BLT.N    ??UartSendPinkLed_0
    464          	UartSendSpecialLedMarkData.Extra = 0;
   \   0000001C                      REQUIRE ?Subroutine1
   \   0000001C                      ;; // Fall through to label ?Subroutine1
    465          	UartSendSpecialLedMarkData.Length = 4;
    466          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    467          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    468          		UartSendSpecialLedMarkData.Extra;
    469          
    470          	UartSendSpecialLedMarkData.TimeOut = NormalTimeOut;
    471              MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    472          			sizeof(UartSendSpecialLedDataBuffer));
    473          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \   00000000   0x004C             LSLS     R4,R1,#+1
   \   00000002   0x40A3             LSLS     R3,R3,R4
   \   00000004   0x431A             ORRS     R2,R3,R2
   \   00000006   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \   0000000A   0x4770             BX       LR
    474          
    475          

   \                                 In section .text, align 2, keep-with-next
    476          void UartSendOffLed(int8u LedNumberMark){
   \                     UartSendOffLed: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    477          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    478          
    479          	int8u i;
    480          
    481          	for(i=0;i<4;i++){
   \   00000002   0x2100             MOVS     R1,#+0
    482          		if(((LedNumberMark >> i) & 0x01) == 1){
   \                     ??UartSendOffLed_0: (+1)
   \   00000004   0xFA40 0xF201      ASR      R2,R0,R1
   \   00000008   0x07D2             LSLS     R2,R2,#+31
   \   0000000A   0xD504             BPL.N    ??CrossCallReturnLabel_24
    483          			UartSendSpecialLedMarkData.State = UartSendSpecialLedMarkData.State | (OffState << 2*i);
   \   0000000C   0xF89D 0x2002      LDRB     R2,[SP, #+2]
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x.... 0x....      BL       ?Subroutine12
    484          		}
    485          	}
   \                     ??CrossCallReturnLabel_24: (+1)
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0x2904             CMP      R1,#+4
   \   0000001A   0xDBF3             BLT.N    ??UartSendOffLed_0
    486          
    487          	UartSendSpecialLedMarkData.Extra = 0;
   \   0000001C   0x....             B.N      ?Subroutine1
    488          	UartSendSpecialLedMarkData.Length = 4;
    489          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    490          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    491          		UartSendSpecialLedMarkData.Extra;
    492          	UartSendSpecialLedMarkData.TimeOut = NormalTimeOut;
    493          	MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    494          			sizeof(UartSendSpecialLedDataBuffer));
    495          }
    496          
    497          
    498          

   \                                 In section .text, align 2, keep-with-next
    499          void UartSendBlinkLed(int8u LedNumberMark, int8u BlinkTime){
   \                     UartSendBlinkLed: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    500          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    501          
    502              BlinkStateExtra BlinkStateExtraData;
    503          	int8u i;
    504          
    505          	for(i=0;i<4;i++){
   \   00000004   0x2100             MOVS     R1,#+0
    506          		if(((LedNumberMark >> i) & 0x01) == 1){
   \                     ??UartSendBlinkLed_0: (+1)
   \   00000006   0xFA40 0xF201      ASR      R2,R0,R1
   \   0000000A   0x07D2             LSLS     R2,R2,#+31
   \   0000000C   0xD507             BPL.N    ??UartSendBlinkLed_1
    507          			UartSendSpecialLedMarkData.State = UartSendSpecialLedMarkData.State | (BlinkState << 2*i);
   \   0000000E   0xF89D 0x2002      LDRB     R2,[SP, #+2]
   \   00000012   0x2303             MOVS     R3,#+3
   \   00000014   0x004D             LSLS     R5,R1,#+1
   \   00000016   0x40AB             LSLS     R3,R3,R5
   \   00000018   0x431A             ORRS     R2,R3,R2
   \   0000001A   0xF88D 0x2002      STRB     R2,[SP, #+2]
    508          		}
    509          	}
   \                     ??UartSendBlinkLed_1: (+1)
   \   0000001E   0x1C49             ADDS     R1,R1,#+1
   \   00000020   0x2904             CMP      R1,#+4
   \   00000022   0xDBF0             BLT.N    ??UartSendBlinkLed_0
    510          	BlinkStateExtraData.BlinkTime = BlinkTime;
    511          	BlinkStateExtraData.LedState = NormalState;
    512          	BlinkStateExtraData.RelayStatus = NoChange;
   \   00000024   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000028   0xF000 0x001F      AND      R0,R0,#0x1F
   \   0000002C   0xEA40 0x1044      ORR      R0,R0,R4, LSL #+5
   \   00000030   0xF000 0x00E1      AND      R0,R0,#0xE1
   \   00000034   0xF88D 0x0008      STRB     R0,[SP, #+8]
    513          
    514          	MEMCOPY(&UartSendSpecialLedMarkData.Extra, &BlinkStateExtraData, sizeof(UartSendSpecialLedMarkData.Extra));
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0xA902             ADD      R1,SP,#+8
   \   0000003C   0xF10D 0x0003      ADD      R0,SP,#+3
   \   00000040   0x.... 0x....      BL       halCommonMemMove
    515          	UartSendSpecialLedMarkData.Length = 4;
   \   00000044   0x.... 0x....      BL       ?Subroutine11
    516          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    517          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    518          		UartSendSpecialLedMarkData.Extra;
    519          	UartSendSpecialLedMarkData.TimeOut = BlinkTime;
   \                     ??CrossCallReturnLabel_22: (+1)
   \   00000048   0xF88D 0x4005      STRB     R4,[SP, #+5]
   \   0000004C   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000050   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000054   0x4048             EORS     R0,R1,R0
   \   00000056   0xF080 0x00B7      EOR      R0,R0,#0xB7
   \   0000005A   0x.... 0x....      BL       ?Subroutine4
    520          	MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    521          			sizeof(UartSendSpecialLedDataBuffer));
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000005E   0x2206             MOVS     R2,#+6
   \   00000060   0x.... 0x....      BL       ?Subroutine5
    522          }
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000064   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
    523          void UartSendToggleLed(int8u LedNumberMark){
    524          	UartSendBlinkLed(LedNumberMark,0);
   \                     UartSendToggleLed: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      UartSendBlinkLed
    525          }
    526          
    527          //----------------------------------Send Check MC Ready------------------------//
    528           /*
    529          Mau ban tin:
    530          
    531          CommandID			 Data
    532          1byte				16Byte
    533          0xB0				0x00 -> 0xFF
    534          */

   \                                 In section .text, align 2, keep-with-next
    535          void UartSendCheckMcReady(void){
   \                     UartSendCheckMcReady: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    536          	UartSendCheckMcReadyDataBuffer UartSendCheckMcReadyData;
    537          	int8u DataCheckKey[16] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,
    538          										0xBB,0xCC,0xDD,0xEE,0xFF};
   \   00000004   0xA805             ADD      R0,SP,#+20
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_3`
   \   0000000A   0x.... 0x....      BL       ?Subroutine8
    539          	UartSendCheckMcReadyData.Length = 18;
   \                     ??CrossCallReturnLabel_16: (+1)
   \   0000000E   0x2012             MOVS     R0,#+18
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    540          	UartSendCheckMcReadyData.Id		= McReadyCmdId;
    541          	MEMCOPY(&UartSendCheckMcReadyData.Data, DataCheckKey, sizeof(DataCheckKey));
   \   00000014   0x2210             MOVS     R2,#+16
   \   00000016   0x20C0             MOVS     R0,#+192
   \   00000018   0x.... 0x....      BL       ?Subroutine10
    542          	UartSendCheckMcReadyData.CheckXor = McReadyCmdId;
   \                     ??CrossCallReturnLabel_19: (+1)
   \   0000001C   0x20C0             MOVS     R0,#+192
   \   0000001E                      REQUIRE ?Subroutine2
   \   0000001E                      ;; // Fall through to label ?Subroutine2
    543          	UartSendCheckMcReadyData.TimeOut = NormalTimeOut;
    544          
    545          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendCheckMcReadyData,
    546          			sizeof(UartSendCheckMcReadyData));
    547          //	McReadyStatus = McChecking;
    548          }
    549          
    550          
    551          
    552          
    553          //---------------------------------Check Uart Status And Send Quere Data Buffer-------------------------------//
    554          enum {
    555          	CmdReady,
    556          	CmdBusy,

   \                                 In section .bss, align 1
    557          }uartSendCommandStatus;
   \                     uartSendCommandStatus:
   \   00000000                      DS8 1
    558          

   \                                 In section .text, align 2, keep-with-next
    559          int8u CheckWaitTimeOut(void){
   \                     CheckWaitTimeOut: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    560          
    561          	if(UartTxCommandStartWaitTimer !=0 ){
   \   00000002   0x....             LDR.N    R4,??DataTable11_2
   \   00000004   0x8820             LDRH     R0,[R4, #+0]
   \   00000006   0xB140             CBZ.N    R0,??CheckWaitTimeOut_0
    562          		if(CommonGetDurationTime(UartTxCommandStartWaitTimer) >= UartTxCommandCurrentTimeOut){
   \   00000008   0x.... 0x....      BL       CommonGetDurationTime
   \   0000000C   0x8861             LDRH     R1,[R4, #+2]
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD302             BCC.N    ??CheckWaitTimeOut_1
    563          			//clear timer
    564          			UartTxCommandStartWaitTimer = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    565          			return CmdReady;
   \   00000016   0xBD10             POP      {R4,PC}
    566          		}
    567          		else{
    568          			return CmdBusy;
   \                     ??CheckWaitTimeOut_1: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
    569          		}
    570          	}
    571          	else{
    572          		return CmdReady;
   \                     ??CheckWaitTimeOut_0: (+1)
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    573          	}
    574          }

   \                                 In section .text, align 2, keep-with-next
    575          void UartSendCommand(void){
   \                     UartSendCommand: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    576          	//	Check buff
    577          	if(UartTxCommandBuff[0] != 0){
   \   00000002   0x....             LDR.N    R4,??DataTable11_1
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xB328             CBZ.N    R0,??UartSendCommand_0
    578          		//	Check Timeout
    579          
    580          
    581          		switch (CheckWaitTimeOut()){
   \   00000008   0x.... 0x....      BL       CheckWaitTimeOut
   \   0000000C   0xBB10             CBNZ.N   R0,??UartSendCommand_0
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x1900             ADDS     R0,R0,R4
   \   00000012   0x7840             LDRB     R0,[R0, #+1]
   \   00000014   0x28FF             CMP      R0,#+255
   \   00000016   0xBF0E             ITEE     EQ 
    582          			case CmdBusy:
    583          			break;
    584          			case CmdReady:
    585          				//	Send buff
    586          				if(UartTxCommandBuff[UartTxCommandBuff[0]+1] == NormalTimeOut){
    587          					UartTxCommandCurrentTimeOut = NORMAL_TIMEOUT;
   \   00000018   0x2032             MOVEQ    R0,#+50
    588          				}
    589          				else{
    590          					UartTxCommandCurrentTimeOut = UartTxCommandBuff[UartTxCommandBuff[0]+1] * MinimumTimeOut;
   \   0000001A   0xF44F 0x717A      MOVNE    R1,#+1000
   \   0000001E   0x4348             MULNE    R0,R1,R0
   \   00000020   0x....             LDR.N    R5,??DataTable11_2
    591          				}
    592          				emberSerialWriteData(1,UART_PACKET_KEY,2);
   \   00000022   0x....             LDR.N    R1,??DataTable11_3
   \   00000024   0x8068             STRH     R0,[R5, #+2]
   \   00000026   0x2202             MOVS     R2,#+2
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       emberSerialWriteData
    593          				emberSerialWriteData(1,UartTxCommandBuff, (UartTxCommandBuff[0]+1));
   \   0000002E   0x7820             LDRB     R0,[R4, #+0]
   \   00000030   0x1C42             ADDS     R2,R0,#+1
   \   00000032   0xB2D2             UXTB     R2,R2
   \   00000034   0x4621             MOV      R1,R4
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       emberSerialWriteData
    594          				MEMCOPY(UartTxCommandBuff, &UartTxCommandBuff[UartTxCommandBuff[0]+2],
    595          						(MAX_RX_BUFFER - (UartTxCommandBuff[0]+2)));
   \   0000003C   0x7820             LDRB     R0,[R4, #+0]
   \   0000003E   0xF1C0 0x027E      RSB      R2,R0,#+126
   \   00000042   0x1900             ADDS     R0,R0,R4
   \   00000044   0x1C81             ADDS     R1,R0,#+2
   \   00000046   0xB292             UXTH     R2,R2
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       halCommonMemMove
    596          				UartTxCommandStartWaitTimer = (int16u)halCommonGetInt32uMillisecondTick();
   \   0000004E   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000052   0x8028             STRH     R0,[R5, #+0]
    597          			break;
    598          			default:
    599          			break;
    600          		}
    601          	}
    602          }
   \                     ??UartSendCommand_0: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     UartRxDataStep

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     UartTxCommandBuff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     UartTxCommandStartWaitTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     UART_PACKET_KEY

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1`:
   \   00000000   0x00 0x11          DC8 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238
   \              0x22 0x33    
   \              0x44 0x55    
   \              0x66 0x77    
   \              0x88 0x99    
   \              0xAA 0xBB    
   \              0xCC 0xDD    
   \              0xEE         
   \   0000000F   0xFF               DC8 255

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_1`:
   \   00000000   0x00 0x11          DC8 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238
   \              0x22 0x33    
   \              0x44 0x55    
   \              0x66 0x77    
   \              0x88 0x99    
   \              0xAA 0xBB    
   \              0xCC 0xDD    
   \              0xEE         
   \   0000000F   0xFF               DC8 255

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_2`:
   \   00000000   0x00 0x11          DC8 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238
   \              0x22 0x33    
   \              0x44 0x55    
   \              0x66 0x77    
   \              0x88 0x99    
   \              0xAA 0xBB    
   \              0xCC 0xDD    
   \              0xEE         
   \   0000000F   0xFF               DC8 255

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_3`:
   \   00000000   0x00 0x11          DC8 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238
   \              0x22 0x33    
   \              0x44 0x55    
   \              0x66 0x77    
   \              0x88 0x99    
   \              0xAA 0xBB    
   \              0xCC 0xDD    
   \              0xEE         
   \   0000000F   0xFF               DC8 255

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    603          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   CallTaskCheckMcReady
        24   -> CallJoinTask
        24   -> UartSendBlinkLed
        24   -> UartSendSwitchControlStateMark
        24   -> __aeabi_memcpy4
        24   -> emberAfNetworkState
        24   -> halCommonGetRandom
        24   -> halCommonMemCompare
      24   CallTaskMcClockCalibrate
        24   -> UartSendMcClockCalibrate
        24   -> __aeabi_memcpy4
        24   -> halCommonMemCompare
      32   CallTaskRelayChangeCommand
        32   -> beButtonPress
        32   -> emberAfReadServerAttribute
        32   -> emberAfWriteServerAttribute
       0   CallTaskTouchButtonHold
         0   -> beButtonPress2Time
         0   -> beButtonPress3Time
         0   -> beButtonRealease
       0   CallUartTask
         0   -> CallTaskCheckMcReady
         0   -> CallTaskMcClockCalibrate
         0   -> CallTaskRelayChangeCommand
         0   -> CallTaskTouchButtonHold
       8   CheckWaitTimeOut
         8   -> CommonGetDurationTime
       0   GetLastTxUartCmd
      16   UartScanCommand
        16   -> CallUartTask
        16   -> emberSerialReadAvailable
        16   -> emberSerialReadByte
      24   UartSendBlinkLed
        24   -> GetLastTxUartCmd
        24   -> halCommonMemMove
      40   UartSendCheckMcReady
        40   -> GetLastTxUartCmd
        40   -> __aeabi_memcpy4
        40   -> halCommonMemMove
      16   UartSendCommand
        16   -> CheckWaitTimeOut
        16   -> emberSerialWriteData
        16   -> halCommonGetInt32uMillisecondTick
        16   -> halCommonMemMove
      40   UartSendMcClockCalibrate
        40   -> GetLastTxUartCmd
        40   -> __aeabi_memcpy4
        40   -> halCommonMemMove
      16   UartSendOffLed
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      16   UartSendPinkLed
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
       0   UartSendRefreshAllLed
         0   -> UartSendSpecialLedMark
       0   UartSendRefreshLedNumber
         0   -> UartSendSpecialLedNumber
      16   UartSendSpecialLedMark
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      16   UartSendSpecialLedNumber
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      24   UartSendStoreAttribute
        24   -> GetLastTxUartCmd
        24   -> halCommonMemMove
      16   UartSendSwitchControlMark
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      16   UartSendSwitchControlNumber
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      16   UartSendSwitchControlStateMark
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
       0   UartSendToggleLed
         0   -> UartSendBlinkLed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1
      16  ?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_1
      16  ?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_2
      16  ?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_3
       4  ?<Constant {0}>
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
      12  ??Subroutine13_0
      18  ?Subroutine0
      42  ?Subroutine1
      14  ?Subroutine10
      14  ?Subroutine11
      12  ?Subroutine12
      24  ?Subroutine2
      34  ?Subroutine3
       6  ?Subroutine4
      10  ?Subroutine5
      10  ?Subroutine6
      10  ?Subroutine7
       6  ?Subroutine8
      12  ?Subroutine9
      72  CallTaskCheckMcReady
      26  CallTaskMcClockCalibrate
      98  CallTaskRelayChangeCommand
      38  CallTaskTouchButtonHold
      28  CallUartTask
      28  CheckWaitTimeOut
      20  GetLastTxUartCmd
       2  UART_PACKET_KEY
      68  UartRxDataStep
          UartRxPacketLength
          UartRxCurrentLength
          UartRxCommandData
       1  UartRxPacketCheckXor
     146  UartScanCommand
     102  UartSendBlinkLed
      30  UartSendCheckMcReady
      86  UartSendCommand
      32  UartSendMcClockCalibrate
      30  UartSendOffLed
      28  UartSendPinkLed
       6  UartSendRefreshAllLed
       4  UartSendRefreshLedNumber
       8  UartSendSpecialLedMark
      46  UartSendSpecialLedNumber
      84  UartSendStoreAttribute
      36  UartSendSwitchControlMark
      34  UartSendSwitchControlNumber
      26  UartSendSwitchControlStateMark
       4  UartSendToggleLed
     128  UartTxCommandBuff
       4  UartTxCommandStartWaitTimer
          UartTxCommandCurrentTimeOut
       1  uartSendCommandStatus

 
   202 bytes in section .bss
     2 bytes in section .data
     4 bytes in section .rodata
 1 316 bytes in section .text
 
 1 316 bytes of CODE  memory
     4 bytes of CONST memory
   204 bytes of DATA  memory

Errors: none
Warnings: none

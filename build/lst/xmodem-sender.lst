###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        31/Aug/2015  14:18:53
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\framework\plugin\xmodem-sender\xmodem-sender.c
#    Command line =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\framework\plugin\xmodem-sender\xmodem-sender.c
#        -D NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM357 -D
#        PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"xmodem-sender.c\"" -lC
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\build\lst\
#        --diag_suppress Pa050 -o
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\build\obj\ --debug
#        --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\framework\plugin\xmodem-sender\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\build\lst\xmodem-sender.lst
#    Object file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\build\obj\xmodem-sender.o
#
###############################################################################

E:\Zigbee\EmberZNet5.6.0-GA\app\framework\plugin\xmodem-sender\xmodem-sender.c
      1          // ****************************************************************************
      2          // * xmodem-sender.c
      3          // *
      4          // * State machine for sending data via xmodem.  This code is agnostic to the
      5          // * data being sent or the actual transport mechanism.  It has callbacks to
      6          // * send the Xmodem formatted data over-the-air or via serial.
      7          // * 
      8          // * Copyright 2012 by Ember Corporation. All rights reserved.              *80*
      9          // *****************************************************************************
     10          
     11          #include "app/framework/include/af.h"
     12          #include "xmodem-sender.h"
     13          
     14          //------------------------------------------------------------------------------
     15          // Globals
     16          
     17          typedef enum {
     18            XMODEM_SEND_STATE_NONE,
     19            XMODEM_SEND_STATE_WAITING_READY,
     20            XMODEM_SEND_STATE_WAITING_DATA_ACK,
     21            XMODEM_SEND_STATE_WAITING_EOT_ACK,
     22          } XmodemSendState;
     23          

   \                                 In section .bss, align 4
     24          static XmodemSendState xmodemSendState = XMODEM_SEND_STATE_NONE;
   \                     xmodemSendState:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \   00000004                      DS8 1
   \   00000005                      DS8 3
     25          static EmberAfXmodemSenderTransmitFunction* sendFunction;
     26          static EmberAfXmodemSenderGetNextBlockFunction* getNextBlockFunction;
     27          static EmberAfXmodemSenderFinishedFunction* finishedFunction;
     28          static int32u currentOffset;
     29          static int8u blockNum;
     30          static int8u retries;
     31          
     32          // Normally Xmodem always operates on 128 byte packets.  However
     33          // to send Xmodem over-the-air we are limited by a 128-byte MTU
     34          // in 802.15.4.  Therefore we allow the sender to use a smaller
     35          // block size to compensate.  The receiver must understand
     36          // this ahead of time as this is non-standard.
     37          static int8u maxBlockSize;
     38          
     39          // It is necessary to have both this variable and the XmodemSendState
     40          // indicating whether we are waiting for a data ACK or an EOT ACK.
     41          // In the case where we are retrying the final block, we must
     42          // keep track of the fact that upon successful ACK we move on to
     43          // the EOT state.
     44          static boolean lastBlock;
     45          
     46          EmberEventControl emberAfPluginXmodemSenderMyEventEventControl;
   \                     emberAfPluginXmodemSenderMyEventEventControl:
   \   00000008                      DS8 8
   \   00000010                      DS8 4
   \   00000014                      DS8 4
   \   00000018                      DS8 4
   \   0000001C                      DS8 4
     47          
     48          #define ACK_TIMEOUT_SECONDS 2
     49          #define READY_TIMEOUT_SECONDS 10
     50          
     51          #define xmodemPrint(...)    emberAfCorePrint(__VA_ARGS__)
     52          #define xmodemPrintln(...)  emberAfCorePrintln(__VA_ARGS__)
     53          
     54          #define XMODEM_MAX_DATA_SIZE 128
     55          
     56          // Overhead
     57          // 1 byte control
     58          // 1 byte Block Num
     59          // 1 byte One's complement of Block num
     60          // (data)
     61          // 2 byte CRC (at end)
     62          #define XMODEM_OVERHEAD 5   
     63          
     64          #define CONTROL_OFFSET      (0)
     65          #define BLOCK_NUM_OFFSET    (1)
     66          #define BLOCK_COMP_OFFSET   (2)
     67          #define DATA_OFFSET         (3)
     68          
     69          #define MAX_RETRIES 10
     70          
     71          #define ACK_LENGTH 2
     72          
     73          //------------------------------------------------------------------------------
     74          // Forward Declarations
     75          
     76          //------------------------------------------------------------------------------
     77          
     78          

   \                                 In section .text, align 2, keep-with-next
     79          static void resetState(boolean success)
     80          {
   \                     resetState: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     81            (*finishedFunction)(success);
   \   00000002   0x....             LDR.N    R4,??DataTable15_1
   \   00000004   0x69A1             LDR      R1,[R4, #+24]
   \   00000006   0x4788             BLX      R1
     82            xmodemSendState = XMODEM_SEND_STATE_NONE;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x7020             STRB     R0,[R4, #+0]
     83          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
     84          

   \                                 In section .text, align 2, keep-with-next
     85          static EmberStatus sendNextBlock(boolean success)
     86          {
   \                     sendNextBlock: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
     87            int8u returnLength;
     88            EmberStatus status;
     89            int8u dataBuffer[XMODEM_MAX_DATA_SIZE + XMODEM_OVERHEAD];
     90            boolean sendEot = (xmodemSendState == XMODEM_SEND_STATE_WAITING_EOT_ACK);
   \   00000002   0x....             LDR.N    R4,??DataTable15_1
   \   00000004   0x7821             LDRB     R1,[R4, #+0]
   \   00000006   0xB0A4             SUB      SP,SP,#+144
   \   00000008   0x2903             CMP      R1,#+3
   \   0000000A   0xBF0C             ITE      EQ 
   \   0000000C   0x2501             MOVEQ    R5,#+1
   \   0000000E   0x2500             MOVNE    R5,#+0
     91          
     92            if (!success) {
   \   00000010   0xB9C0             CBNZ.N   R0,??sendNextBlock_0
     93              retries--;
   \   00000012   0x78A0             LDRB     R0,[R4, #+2]
   \   00000014   0x1E40             SUBS     R0,R0,#+1
   \   00000016   0x70A0             STRB     R0,[R4, #+2]
     94              if (retries == 0) {
   \   00000018   0xB2C0             UXTB     R0,R0
   \   0000001A   0xB950             CBNZ.N   R0,??sendNextBlock_1
     95                xmodemPrintln("Error: Max retry count hit (%d), giving up.", MAX_RETRIES);
   \   0000001C   0x220A             MOVS     R2,#+10
   \   0000001E   0x.... 0x....      ADR.W    R1,`?<Constant "Error: Max retry coun...">`
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x.... 0x....      BL       emberAfPrintln
     96                resetState(FALSE);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      BL       resetState
     97                return EMBER_ERR_FATAL;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE071             B.N      ??sendNextBlock_2
     98              }
     99              xmodemPrintln("Error: Block Number %d, Retry count: %d", blockNum, MAX_RETRIES - retries);
   \                     ??sendNextBlock_1: (+1)
   \   00000032   0xF1C0 0x030A      RSB      R3,R0,#+10
   \   00000036   0x7862             LDRB     R2,[R4, #+1]
   \   00000038   0x.... 0x....      ADR.W    R1,`?<Constant "Error: Block Number %...">`
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x.... 0x....      BL       emberAfPrintln
   \   00000042   0xE001             B.N      ??sendNextBlock_3
    100            } else {
    101              retries = MAX_RETRIES;
   \                     ??sendNextBlock_0: (+1)
   \   00000044   0x200A             MOVS     R0,#+10
   \   00000046   0x70A0             STRB     R0,[R4, #+2]
    102            }
    103          
    104            MEMSET(dataBuffer, 0xFF, XMODEM_MAX_DATA_SIZE + XMODEM_OVERHEAD);
   \                     ??sendNextBlock_3: (+1)
   \   00000048   0x2285             MOVS     R2,#+133
   \   0000004A   0x21FF             MOVS     R1,#+255
   \   0000004C   0xA802             ADD      R0,SP,#+8
   \   0000004E   0x.... 0x....      BL       halCommonMemSet
    105          
    106            if (!sendEot) {
   \   00000052   0xB9B5             CBNZ.N   R5,??sendNextBlock_4
    107              status = (*getNextBlockFunction)(currentOffset, 
    108                                               maxBlockSize,
    109                                               &dataBuffer[DATA_OFFSET],
    110                                               &returnLength,
    111                                               &lastBlock);
   \   00000054   0x1D20             ADDS     R0,R4,#+4
   \   00000056   0x9000             STR      R0,[SP, #+0]
   \   00000058   0x78E1             LDRB     R1,[R4, #+3]
   \   0000005A   0x69E0             LDR      R0,[R4, #+28]
   \   0000005C   0x6966             LDR      R6,[R4, #+20]
   \   0000005E   0xAB01             ADD      R3,SP,#+4
   \   00000060   0xF10D 0x020B      ADD      R2,SP,#+11
   \   00000064   0x47B0             BLX      R6
   \   00000066   0x0006             MOVS     R6,R0
    112              if (status != EMBER_SUCCESS) {
   \   00000068   0xD012             BEQ.N    ??sendNextBlock_5
    113                xmodemPrintln("Error: Failed to retreive data for offset 0x%4X, size: %d.  Aborting", 
    114                              currentOffset, 
    115                              returnLength);
   \   0000006A   0xF89D 0x3004      LDRB     R3,[SP, #+4]
   \   0000006E   0x69E2             LDR      R2,[R4, #+28]
   \   00000070   0x.... 0x....      ADR.W    R1,`?<Constant "Error: Failed to retr...">`
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x.... 0x....      BL       emberAfPrintln
    116                resetState(FALSE);
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x.... 0x....      BL       resetState
    117                return status;
   \   00000080   0xE048             B.N      ??sendNextBlock_6
    118              }
    119              
    120            }
    121            
    122            if (sendEot) {
    123              dataBuffer[CONTROL_OFFSET] = XMODEM_EOT;
   \                     ??sendNextBlock_4: (+1)
   \   00000082   0x2004             MOVS     R0,#+4
   \   00000084   0xF88D 0x0008      STRB     R0,[SP, #+8]
    124              returnLength = 1;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   0000008E   0xE01E             B.N      ??sendNextBlock_7
    125            } else {
    126              int8u i;
    127              int16u crc = 0;
   \                     ??sendNextBlock_5: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
    128              returnLength = XMODEM_OVERHEAD + maxBlockSize;
   \   00000092   0x78E1             LDRB     R1,[R4, #+3]
   \   00000094   0x1D49             ADDS     R1,R1,#+5
   \   00000096   0xF88D 0x1004      STRB     R1,[SP, #+4]
    129              dataBuffer[CONTROL_OFFSET] = XMODEM_SOH;
    130              dataBuffer[BLOCK_NUM_OFFSET] = blockNum;
   \   0000009A   0xAA02             ADD      R2,SP,#+8
   \   0000009C   0x2101             MOVS     R1,#+1
   \   0000009E   0xF88D 0x1008      STRB     R1,[SP, #+8]
    131              dataBuffer[BLOCK_COMP_OFFSET] = ~blockNum;
    132          
    133              for (i = 0; i < maxBlockSize; i++) {
   \   000000A2   0x2600             MOVS     R6,#+0
   \   000000A4   0x7861             LDRB     R1,[R4, #+1]
   \   000000A6   0x7051             STRB     R1,[R2, #+1]
   \   000000A8   0x43C9             MVNS     R1,R1
   \   000000AA   0x7091             STRB     R1,[R2, #+2]
   \   000000AC   0xE006             B.N      ??sendNextBlock_8
    134                crc = halCommonCrc16(dataBuffer[i + DATA_OFFSET], crc);
   \                     ??sendNextBlock_9: (+1)
   \   000000AE   0x4601             MOV      R1,R0
   \   000000B0   0xA802             ADD      R0,SP,#+8
   \   000000B2   0x1830             ADDS     R0,R6,R0
   \   000000B4   0x78C0             LDRB     R0,[R0, #+3]
   \   000000B6   0x.... 0x....      BL       halCommonCrc16
    135              }
   \   000000BA   0x1C76             ADDS     R6,R6,#+1
   \                     ??sendNextBlock_8: (+1)
   \   000000BC   0x78E1             LDRB     R1,[R4, #+3]
   \   000000BE   0xB2F6             UXTB     R6,R6
   \   000000C0   0x428E             CMP      R6,R1
   \   000000C2   0xD3F4             BCC.N    ??sendNextBlock_9
    136              dataBuffer[maxBlockSize + XMODEM_OVERHEAD - 2] = HIGH_BYTE(crc);
   \   000000C4   0xAA02             ADD      R2,SP,#+8
   \   000000C6   0x1889             ADDS     R1,R1,R2
   \   000000C8   0x0A02             LSRS     R2,R0,#+8
   \   000000CA   0x70CA             STRB     R2,[R1, #+3]
    137              dataBuffer[maxBlockSize + XMODEM_OVERHEAD - 1] = LOW_BYTE(crc);
   \   000000CC   0x7108             STRB     R0,[R1, #+4]
    138            }
    139            
    140            status = (*sendFunction)(dataBuffer, returnLength);
   \                     ??sendNextBlock_7: (+1)
   \   000000CE   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   000000D2   0x6922             LDR      R2,[R4, #+16]
   \   000000D4   0xA802             ADD      R0,SP,#+8
   \   000000D6   0x4790             BLX      R2
   \   000000D8   0x0006             MOVS     R6,R0
    141            if (status != EMBER_SUCCESS) {
   \   000000DA   0xD010             BEQ.N    ??sendNextBlock_10
    142              xmodemPrint("Error:  Failed to send ");
   \   000000DC   0x.... 0x....      ADR.W    R1,`?<Constant "Error:  Failed to send ">`
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0x.... 0x....      BL       emberAfPrint
    143              xmodemPrintln((sendEot
    144                             ? "EOT"
    145                             : "block %d, aborting."),
    146                            blockNum);
   \   000000E6   0x2D00             CMP      R5,#+0
   \   000000E8   0xBF14             ITE      NE 
   \   000000EA   0x....             ADRNE.N  R1,??DataTable15  ;; "EOT"
   \   000000EC   0x.... 0x....      ADREQ.W  R1,`?<Constant "block %d, aborting.">`
   \   000000F0   0x7862             LDRB     R2,[R4, #+1]
   \   000000F2   0x2001             MOVS     R0,#+1
   \   000000F4   0x.... 0x....      BL       emberAfPrintln
    147              resetState(FALSE);
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x.... 0x....      BL       resetState
    148            }
    149          
    150            emberEventControlSetDelayQS(emberAfPluginXmodemSenderMyEventEventControl,
    151                                        ACK_TIMEOUT_SECONDS << 2);
   \                     ??sendNextBlock_10: (+1)
   \   000000FE   0xF44F 0x6100      MOV      R1,#+2048
   \   00000102   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000106   0x.... 0x....      BL       emEventControlSetDelayMS
    152            xmodemSendState = (sendEot
    153                               ? XMODEM_SEND_STATE_WAITING_EOT_ACK
    154                               : XMODEM_SEND_STATE_WAITING_DATA_ACK);
   \   0000010A   0x2D00             CMP      R5,#+0
   \   0000010C   0xBF14             ITE      NE 
   \   0000010E   0x2003             MOVNE    R0,#+3
   \   00000110   0x2002             MOVEQ    R0,#+2
   \   00000112   0x7020             STRB     R0,[R4, #+0]
    155          
    156            return status;
   \                     ??sendNextBlock_6: (+1)
   \   00000114   0x4630             MOV      R0,R6
   \                     ??sendNextBlock_2: (+1)
   \   00000116   0xB024             ADD      SP,SP,#+144
   \   00000118   0xBD70             POP      {R4-R6,PC}       ;; return
    157          }
    158          

   \                                 In section .text, align 2, keep-with-next
    159          void emberAfPluginXmodemSenderIncomingBlock(int8u* data,
    160                                                      int8u  length)
    161          {
   \                     emberAfPluginXmodemSenderIncomingBlock: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    162            boolean success = TRUE;
    163          
    164            switch (xmodemSendState) {
   \   00000002   0x....             LDR.N    R4,??DataTable15_1
   \   00000004   0x7825             LDRB     R5,[R4, #+0]
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0x1E6A             SUBS     R2,R5,#+1
   \   0000000A   0xD045             BEQ.N    ??emberAfPluginXmodemSenderIncomingBlock_0
   \   0000000C   0x1E52             SUBS     R2,R2,#+1
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xD849             BHI.N    ??emberAfPluginXmodemSenderIncomingBlock_1
    165            case XMODEM_SEND_STATE_WAITING_DATA_ACK:
    166            case XMODEM_SEND_STATE_WAITING_EOT_ACK: {
    167              if (data[CONTROL_OFFSET] == XMODEM_ACK) {
   \   00000012   0x7802             LDRB     R2,[R0, #+0]
   \   00000014   0x2A06             CMP      R2,#+6
   \   00000016   0xD129             BNE.N    ??emberAfPluginXmodemSenderIncomingBlock_2
    168                if (xmodemSendState == XMODEM_SEND_STATE_WAITING_DATA_ACK) {
   \   00000018   0x7862             LDRB     R2,[R4, #+1]
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xD115             BNE.N    ??emberAfPluginXmodemSenderIncomingBlock_3
    169                  if (length < ACK_LENGTH) {
   \   0000001E   0x2902             CMP      R1,#+2
   \   00000020   0xDA07             BGE.N    ??emberAfPluginXmodemSenderIncomingBlock_4
    170                    xmodemPrintln("Error: Response too short (%d < %d).  Aborting.", length, ACK_LENGTH);
   \   00000022   0x460A             MOV      R2,R1
   \   00000024   0x2302             MOVS     R3,#+2
   \   00000026   0x.... 0x....      ADR.W    R1,`?<Constant "Error: Response too s...">`
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x.... 0x....      BL       emberAfPrintln
    171                    resetState(FALSE);
   \   00000030   0xE027             B.N      ??emberAfPluginXmodemSenderIncomingBlock_5
    172                    return;
    173                  }
    174                  if (data[BLOCK_NUM_OFFSET] != blockNum) {
   \                     ??emberAfPluginXmodemSenderIncomingBlock_4: (+1)
   \   00000032   0x7840             LDRB     R0,[R0, #+1]
   \   00000034   0x4290             CMP      R0,R2
   \   00000036   0xD00C             BEQ.N    ??emberAfPluginXmodemSenderIncomingBlock_6
    175                    xmodemPrintln("Warning: Got ack for wrong packet.  Expected: %d, Actual: %d.  Ignoring.", 
    176                                  blockNum, 
    177                                  data[BLOCK_NUM_OFFSET]);
   \   00000038   0xB001             ADD      SP,SP,#+4
   \   0000003A   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000003E   0x4603             MOV      R3,R0
   \   00000040   0x.... 0x....      ADR.W    R1,`?<Constant "Warning: Got ack for ...">`
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x.... 0x....      B.W      emberAfPrintln
    178                    return;
    179                  }
    180                }
    181          
    182                if (xmodemSendState == XMODEM_SEND_STATE_WAITING_EOT_ACK) {
   \                     ??emberAfPluginXmodemSenderIncomingBlock_3: (+1)
   \   0000004A   0x2D03             CMP      R5,#+3
   \   0000004C   0xBF08             IT       EQ 
    183                  // Done
    184                  resetState(TRUE);
   \   0000004E   0x2001             MOVEQ    R0,#+1
   \   00000050   0xD018             BEQ.N    ??emberAfPluginXmodemSenderIncomingBlock_7
    185                  return;;
    186                }
    187          
    188                if (lastBlock) {
   \                     ??emberAfPluginXmodemSenderIncomingBlock_6: (+1)
   \   00000052   0x7920             LDRB     R0,[R4, #+4]
   \   00000054   0xB118             CBZ.N    R0,??emberAfPluginXmodemSenderIncomingBlock_8
    189                  xmodemSendState = XMODEM_SEND_STATE_WAITING_EOT_ACK;
   \   00000056   0x2003             MOVS     R0,#+3
   \   00000058   0x7020             STRB     R0,[R4, #+0]
    190                } else {
    191                  blockNum++;
    192                  currentOffset += maxBlockSize;
    193                }
    194          
    195              } else if (data[CONTROL_OFFSET] == XMODEM_NAK) {
    196                success = FALSE;
    197              } else if (data[CONTROL_OFFSET] == XMODEM_CANCEL) {
    198                xmodemPrintln("Received CANCEL.  Aborting.");
    199                resetState(FALSE);
    200                return;
    201              } else {
    202                xmodemPrintln("Error: Unrecognized xmodem packet received: 0x%X, Ignoring.", data[CONTROL_OFFSET]);
    203                return;
    204              }
    205          
    206              sendNextBlock(success);
   \                     ??emberAfPluginXmodemSenderIncomingBlock_9: (+1)
   \   0000005A   0x4618             MOV      R0,R3
   \   0000005C   0xE020             B.N      ??emberAfPluginXmodemSenderIncomingBlock_10
   \                     ??emberAfPluginXmodemSenderIncomingBlock_8: (+1)
   \   0000005E   0x1C50             ADDS     R0,R2,#+1
   \   00000060   0x7060             STRB     R0,[R4, #+1]
   \   00000062   0x78E1             LDRB     R1,[R4, #+3]
   \   00000064   0x69E0             LDR      R0,[R4, #+28]
   \   00000066   0x1808             ADDS     R0,R1,R0
   \   00000068   0x61E0             STR      R0,[R4, #+28]
   \   0000006A   0xE7F6             B.N      ??emberAfPluginXmodemSenderIncomingBlock_9
   \                     ??emberAfPluginXmodemSenderIncomingBlock_2: (+1)
   \   0000006C   0x2A15             CMP      R2,#+21
   \   0000006E   0xBF08             IT       EQ 
   \   00000070   0x2300             MOVEQ    R3,#+0
   \   00000072   0xD0F2             BEQ.N    ??emberAfPluginXmodemSenderIncomingBlock_9
   \   00000074   0x2A18             CMP      R2,#+24
   \   00000076   0xD108             BNE.N    ??emberAfPluginXmodemSenderIncomingBlock_11
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x.... 0x....      ADR.W    R1,`?<Constant "Received CANCEL.  Abo...">`
   \   0000007E   0x.... 0x....      BL       emberAfPrintln
   \                     ??emberAfPluginXmodemSenderIncomingBlock_5: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \                     ??emberAfPluginXmodemSenderIncomingBlock_7: (+1)
   \   00000084   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000088   0x....             B.N      resetState
   \                     ??emberAfPluginXmodemSenderIncomingBlock_11: (+1)
   \   0000008A   0x.... 0x....      ADR.W    R1,`?<Constant "Error: Unrecognized x...">`
   \   0000008E   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0x.... 0x....      B.W      emberAfPrintln
    207              break;
    208            }
    209            case XMODEM_SEND_STATE_WAITING_READY: {
    210              if (data[CONTROL_OFFSET] == 'C') {
   \                     ??emberAfPluginXmodemSenderIncomingBlock_0: (+1)
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x2843             CMP      R0,#+67
   \   0000009C   0xD103             BNE.N    ??emberAfPluginXmodemSenderIncomingBlock_1
    211                sendNextBlock(TRUE);
   \   0000009E   0x2001             MOVS     R0,#+1
   \                     ??emberAfPluginXmodemSenderIncomingBlock_10: (+1)
   \   000000A0   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   000000A4   0x....             B.N      sendNextBlock
    212              }
    213              // Else, ignore.
    214              break;
    215            }
    216            // Adding a default case makes compilers happier.
    217            default:
    218              break;
    219            }
    220          }
   \                     ??emberAfPluginXmodemSenderIncomingBlock_1: (+1)
   \   000000A6   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    221          

   \                                 In section .text, align 2, keep-with-next
    222          void emberAfPluginXmodemSenderMyEventEventHandler(void)
    223          {
   \                     emberAfPluginXmodemSenderMyEventEventHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    224            emberEventControlSetInactive(emberAfPluginXmodemSenderMyEventEventControl);
   \   00000002   0x....             LDR.N    R0,??DataTable15_1
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7201             STRB     R1,[R0, #+8]
    225          
    226            switch (xmodemSendState) {
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x1E41             SUBS     R1,R0,#+1
   \   0000000C   0x2902             CMP      R1,#+2
   \   0000000E   0xD80C             BHI.N    ??emberAfPluginXmodemSenderMyEventEventHandler_0
    227            case XMODEM_SEND_STATE_WAITING_DATA_ACK:
    228            case XMODEM_SEND_STATE_WAITING_EOT_ACK:
    229              // Fall through
    230          
    231            case XMODEM_SEND_STATE_WAITING_READY: {
    232              if (xmodemSendState == XMODEM_SEND_STATE_WAITING_READY) {
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD106             BNE.N    ??emberAfPluginXmodemSenderMyEventEventHandler_1
    233                xmodemPrintln("Error: Timeout waiting for ready character.  Giving up.");
   \   00000014   0x.... 0x....      ADR.W    R1,`?<Constant "Error: Timeout waitin...">`
   \   00000018   0x.... 0x....      BL       emberAfPrintln
    234                resetState(FALSE);
   \   0000001C   0xE8BD 0x4002      POP      {R1,LR}
   \   00000020   0x....             B.N      ?Subroutine0
    235                return;
    236              }
    237          
    238              sendNextBlock(FALSE);
   \                     ??emberAfPluginXmodemSenderMyEventEventHandler_1: (+1)
   \   00000022   0xE8BD 0x4002      POP      {R1,LR}
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x....             B.N      sendNextBlock
    239              break;
    240            }
    241            default:
    242              break;
    243            };
    244          }
   \                     ??emberAfPluginXmodemSenderMyEventEventHandler_0: (+1)
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             B.N      resetState
    245          

   \                                 In section .text, align 2, keep-with-next
    246          EmberStatus emberAfPluginXmodemSenderStart(EmberAfXmodemSenderTransmitFunction* sendRoutine,
    247                                                     EmberAfXmodemSenderGetNextBlockFunction* getNextBlockRoutine,
    248                                                     EmberAfXmodemSenderFinishedFunction* finishedRoutine,
    249                                                     int8u maxSizeOfBlock,
    250                                                     boolean waitForReady)
    251                                                     
    252          {
   \                     emberAfPluginXmodemSenderStart: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    253            if (xmodemSendState != XMODEM_SEND_STATE_NONE
    254                || maxSizeOfBlock > XMODEM_MAX_DATA_SIZE) {
   \   00000002   0x....             LDR.N    R4,??DataTable15_1
   \   00000004   0x7825             LDRB     R5,[R4, #+0]
   \   00000006   0xB90D             CBNZ.N   R5,??emberAfPluginXmodemSenderStart_0
   \   00000008   0x2B81             CMP      R3,#+129
   \   0000000A   0xDB01             BLT.N    ??emberAfPluginXmodemSenderStart_1
    255              return EMBER_INVALID_CALL;
   \                     ??emberAfPluginXmodemSenderStart_0: (+1)
   \   0000000C   0x2070             MOVS     R0,#+112
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    256            }
    257          
    258            sendFunction = sendRoutine;
   \                     ??emberAfPluginXmodemSenderStart_1: (+1)
   \   00000010   0x6120             STR      R0,[R4, #+16]
    259            getNextBlockFunction = getNextBlockRoutine;
   \   00000012   0x6161             STR      R1,[R4, #+20]
    260            finishedFunction = finishedRoutine;
    261            currentOffset = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x61E0             STR      R0,[R4, #+28]
   \   00000018   0x61A2             STR      R2,[R4, #+24]
    262            // Per the Xmodem spec, this starts at 1 goes to 255, and wraps back to 0.
    263            blockNum = 1;   
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x7060             STRB     R0,[R4, #+1]
    264            lastBlock = FALSE;
    265            maxBlockSize = maxSizeOfBlock;
   \   0000001E   0x70E3             STRB     R3,[R4, #+3]
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x7120             STRB     R0,[R4, #+4]
    266          
    267            if (waitForReady) {
   \   00000024   0x9804             LDR      R0,[SP, #+16]
   \   00000026   0xB148             CBZ.N    R0,??emberAfPluginXmodemSenderStart_2
    268              emberEventControlSetDelayQS(emberAfPluginXmodemSenderMyEventEventControl,
    269                                          READY_TIMEOUT_SECONDS << 2);
   \   00000028   0xF44F 0x5120      MOV      R1,#+10240
   \   0000002C   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000030   0x.... 0x....      BL       emEventControlSetDelayMS
    270              xmodemSendState = XMODEM_SEND_STATE_WAITING_READY;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x7020             STRB     R0,[R4, #+0]
    271              return EMBER_SUCCESS;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}
    272            }
    273          
    274            return sendNextBlock(TRUE);
   \                     ??emberAfPluginXmodemSenderStart_2: (+1)
   \   0000003C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x....             B.N      sendNextBlock
    275          }
    276          

   \                                 In section .text, align 2, keep-with-next
    277          void emberAfPluginXmodemSenderAbort(void)
   \                     emberAfPluginXmodemSenderAbort: (+1)
   \   00000000   0xBF00             Nop      
    278          {
    279            resetState(FALSE);
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x45 0x4F          DC8      "EOT"
   \              0x54 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     xmodemSendState

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "EOT">`:
   \   00000000   0x45 0x4F          DC8 "EOT"
   \              0x54 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error: Max retry coun...">`:
   \   00000000   0x45 0x72          DC8 "Error: Max retry count hit (%d), giving up."
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x61 0x78    
   \              0x20 0x72    
   \              0x65 0x74    
   \              0x72 0x79    
   \              0x20 0x63    
   \              0x6F 0x75    
   \              0x6E 0x74    
   \              0x20 0x68    
   \              0x69 0x74    
   \              0x20 0x28    
   \              0x25 0x64    
   \              0x29 0x2C    
   \              0x20 0x67    
   \              0x69 0x76    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x75 0x70    
   \              0x2E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error: Block Number %...">`:
   \   00000000   0x45 0x72          DC8 "Error: Block Number %d, Retry count: %d"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x42    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x20 0x4E    
   \              0x75 0x6D    
   \              0x62 0x65    
   \              0x72 0x20    
   \              0x25 0x64    
   \              0x2C 0x20    
   \              0x52 0x65    
   \              0x74 0x72    
   \              0x79 0x20    
   \              0x63 0x6F    
   \              0x75 0x6E    
   \              0x74 0x3A    
   \              0x20 0x25    
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error: Failed to retr...">`:
   \   00000000   0x45 0x72          DC8 45H, 72H, 72H, 6FH, 72H, 3AH, 20H, 46H
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x46    
   \   00000008   0x61 0x69          DC8 61H, 69H, 6CH, 65H, 64H, 20H, 74H, 6FH
   \              0x6C 0x65    
   \              0x64 0x20    
   \              0x74 0x6F    
   \   00000010   0x20 0x72          DC8 20H, 72H, 65H, 74H, 72H, 65H, 69H, 76H
   \              0x65 0x74    
   \              0x72 0x65    
   \              0x69 0x76    
   \   00000018   0x65 0x20          DC8 65H, 20H, 64H, 61H, 74H, 61H, 20H, 66H
   \              0x64 0x61    
   \              0x74 0x61    
   \              0x20 0x66    
   \   00000020   0x6F 0x72          DC8 6FH, 72H, 20H, 6FH, 66H, 66H, 73H, 65H
   \              0x20 0x6F    
   \              0x66 0x66    
   \              0x73 0x65    
   \   00000028   0x74 0x20          DC8 74H, 20H, 30H, 78H, 25H, 34H, 58H, 2CH
   \              0x30 0x78    
   \              0x25 0x34    
   \              0x58 0x2C    
   \   00000030   0x20 0x73          DC8 20H, 73H, 69H, 7AH, 65H, 3AH, 20H, 25H
   \              0x69 0x7A    
   \              0x65 0x3A    
   \              0x20 0x25    
   \   00000038   0x64 0x2E          DC8 64H, 2EH, 20H, 20H, 41H, 62H, 6FH, 72H
   \              0x20 0x20    
   \              0x41 0x62    
   \              0x6F 0x72    
   \   00000040   0x74 0x69          DC8 74H, 69H, 6EH, 67H, 0
   \              0x6E 0x67    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error:  Failed to send ">`:
   \   00000000   0x45 0x72          DC8 "Error:  Failed to send "
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x20    
   \              0x46 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x73 0x65    
   \              0x6E 0x64    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "block %d, aborting.">`:
   \   00000000   0x62 0x6C          DC8 "block %d, aborting."
   \              0x6F 0x63    
   \              0x6B 0x20    
   \              0x25 0x64    
   \              0x2C 0x20    
   \              0x61 0x62    
   \              0x6F 0x72    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x2E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error: Response too s...">`:
   \   00000000   0x45 0x72          DC8 "Error: Response too short (%d < %d).  Aborting."
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x52    
   \              0x65 0x73    
   \              0x70 0x6F    
   \              0x6E 0x73    
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x6F 0x20    
   \              0x73 0x68    
   \              0x6F 0x72    
   \              0x74 0x20    
   \              0x28 0x25    
   \              0x64 0x20    
   \              0x3C 0x20    
   \              0x25 0x64    
   \              0x29 0x2E    
   \              0x20 0x20    
   \              0x41 0x62    
   \              0x6F 0x72    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x2E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Warning: Got ack for ...">`:
   \   00000000   0x57 0x61          DC8 57H, 61H, 72H, 6EH, 69H, 6EH, 67H, 3AH
   \              0x72 0x6E    
   \              0x69 0x6E    
   \              0x67 0x3A    
   \   00000008   0x20 0x47          DC8 20H, 47H, 6FH, 74H, 20H, 61H, 63H, 6BH
   \              0x6F 0x74    
   \              0x20 0x61    
   \              0x63 0x6B    
   \   00000010   0x20 0x66          DC8 20H, 66H, 6FH, 72H, 20H, 77H, 72H, 6FH
   \              0x6F 0x72    
   \              0x20 0x77    
   \              0x72 0x6F    
   \   00000018   0x6E 0x67          DC8 6EH, 67H, 20H, 70H, 61H, 63H, 6BH, 65H
   \              0x20 0x70    
   \              0x61 0x63    
   \              0x6B 0x65    
   \   00000020   0x74 0x2E          DC8 74H, 2EH, 20H, 20H, 45H, 78H, 70H, 65H
   \              0x20 0x20    
   \              0x45 0x78    
   \              0x70 0x65    
   \   00000028   0x63 0x74          DC8 63H, 74H, 65H, 64H, 3AH, 20H, 25H, 64H
   \              0x65 0x64    
   \              0x3A 0x20    
   \              0x25 0x64    
   \   00000030   0x2C 0x20          DC8 2CH, 20H, 41H, 63H, 74H, 75H, 61H, 6CH
   \              0x41 0x63    
   \              0x74 0x75    
   \              0x61 0x6C    
   \   00000038   0x3A 0x20          DC8 3AH, 20H, 25H, 64H, 2EH, 20H, 20H, 49H
   \              0x25 0x64    
   \              0x2E 0x20    
   \              0x20 0x49    
   \   00000040   0x67 0x6E          DC8 67H, 6EH, 6FH, 72H, 69H, 6EH, 67H, 2EH
   \              0x6F 0x72    
   \              0x69 0x6E    
   \              0x67 0x2E    
   \   00000048   0x00               DC8 0
   \   00000049   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Received CANCEL.  Abo...">`:
   \   00000000   0x52 0x65          DC8 "Received CANCEL.  Aborting."
   \              0x63 0x65    
   \              0x69 0x76    
   \              0x65 0x64    
   \              0x20 0x43    
   \              0x41 0x4E    
   \              0x43 0x45    
   \              0x4C 0x2E    
   \              0x20 0x20    
   \              0x41 0x62    
   \              0x6F 0x72    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x2E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error: Unrecognized x...">`:
   \   00000000   0x45 0x72          DC8 45H, 72H, 72H, 6FH, 72H, 3AH, 20H, 55H
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x55    
   \   00000008   0x6E 0x72          DC8 6EH, 72H, 65H, 63H, 6FH, 67H, 6EH, 69H
   \              0x65 0x63    
   \              0x6F 0x67    
   \              0x6E 0x69    
   \   00000010   0x7A 0x65          DC8 7AH, 65H, 64H, 20H, 78H, 6DH, 6FH, 64H
   \              0x64 0x20    
   \              0x78 0x6D    
   \              0x6F 0x64    
   \   00000018   0x65 0x6D          DC8 65H, 6DH, 20H, 70H, 61H, 63H, 6BH, 65H
   \              0x20 0x70    
   \              0x61 0x63    
   \              0x6B 0x65    
   \   00000020   0x74 0x20          DC8 74H, 20H, 72H, 65H, 63H, 65H, 69H, 76H
   \              0x72 0x65    
   \              0x63 0x65    
   \              0x69 0x76    
   \   00000028   0x65 0x64          DC8 65H, 64H, 3AH, 20H, 30H, 78H, 25H, 58H
   \              0x3A 0x20    
   \              0x30 0x78    
   \              0x25 0x58    
   \   00000030   0x2C 0x20          DC8 2CH, 20H, 49H, 67H, 6EH, 6FH, 72H, 69H
   \              0x49 0x67    
   \              0x6E 0x6F    
   \              0x72 0x69    
   \   00000038   0x6E 0x67          DC8 6EH, 67H, 2EH, 0
   \              0x2E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error: Timeout waitin...">`:
   \   00000000   0x45 0x72          DC8 45H, 72H, 72H, 6FH, 72H, 3AH, 20H, 54H
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x54    
   \   00000008   0x69 0x6D          DC8 69H, 6DH, 65H, 6FH, 75H, 74H, 20H, 77H
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x20 0x77    
   \   00000010   0x61 0x69          DC8 61H, 69H, 74H, 69H, 6EH, 67H, 20H, 66H
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x20 0x66    
   \   00000018   0x6F 0x72          DC8 6FH, 72H, 20H, 72H, 65H, 61H, 64H, 79H
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \   00000020   0x20 0x63          DC8 20H, 63H, 68H, 61H, 72H, 61H, 63H, 74H
   \              0x68 0x61    
   \              0x72 0x61    
   \              0x63 0x74    
   \   00000028   0x65 0x72          DC8 65H, 72H, 2EH, 20H, 20H, 47H, 69H, 76H
   \              0x2E 0x20    
   \              0x20 0x47    
   \              0x69 0x76    
   \   00000030   0x69 0x6E          DC8 69H, 6EH, 67H, 20H, 75H, 70H, 2EH, 0
   \              0x67 0x20    
   \              0x75 0x70    
   \              0x2E 0x00    
    280          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   emberAfPluginXmodemSenderAbort
         0   -> resetState
      16   emberAfPluginXmodemSenderIncomingBlock
         0   -> emberAfPrintln
        16   -> emberAfPrintln
         0   -> resetState
         0   -> sendNextBlock
       8   emberAfPluginXmodemSenderMyEventEventHandler
         8   -> emberAfPrintln
         0   -> resetState
         0   -> sendNextBlock
      16   emberAfPluginXmodemSenderStart
        16   -> emEventControlSetDelayMS
         0   -> sendNextBlock
       8   resetState
         8   -- Indirect call
     160   sendNextBlock
       160   -- Indirect call
       160   -> emEventControlSetDelayMS
       160   -> emberAfPrint
       160   -> emberAfPrintln
       160   -> halCommonCrc16
       160   -> halCommonMemSet
       160   -> resetState


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant "EOT">
      24  ?<Constant "Error:  Failed to send ">
      40  ?<Constant "Error: Block Number %...">
      72  ?<Constant "Error: Failed to retr...">
      44  ?<Constant "Error: Max retry coun...">
      48  ?<Constant "Error: Response too s...">
      56  ?<Constant "Error: Timeout waitin...">
      60  ?<Constant "Error: Unrecognized x...">
      28  ?<Constant "Received CANCEL.  Abo...">
      76  ?<Constant "Warning: Got ack for ...">
      20  ?<Constant "block %d, aborting.">
       4  ??DataTable15
       4  ??DataTable15_1
       4  ?Subroutine0
       2  emberAfPluginXmodemSenderAbort
     168  emberAfPluginXmodemSenderIncomingBlock
      44  emberAfPluginXmodemSenderMyEventEventHandler
      68  emberAfPluginXmodemSenderStart
      14  resetState
     282  sendNextBlock
      32  xmodemSendState
          blockNum
          retries
          maxBlockSize
          lastBlock
          emberAfPluginXmodemSenderMyEventEventControl
          sendFunction
          getNextBlockFunction
          finishedFunction
          currentOffset

 
    32 bytes in section .bss
     4 bytes in section .rodata
 1 058 bytes in section .text
 
 1 058 bytes of CODE  memory
     4 bytes of CONST memory
    32 bytes of DATA  memory

Errors: none
Warnings: none

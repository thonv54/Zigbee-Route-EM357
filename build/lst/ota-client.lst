###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        31/Aug/2015  14:04:37
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\framework\plugin\ota-client\ota-client.c
#    Command line =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\framework\plugin\ota-client\ota-client.c
#        -D NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM357 -D
#        PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"ota-client.c\"" -lC
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\build\lst\
#        --diag_suppress Pa050 -o
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\build\obj\ --debug
#        --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\framework\plugin\ota-client\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\build\lst\ota-client.lst
#    Object file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\build\obj\ota-client.o
#
###############################################################################

E:\Zigbee\EmberZNet5.6.0-GA\app\framework\plugin\ota-client\ota-client.c
      1          // *****************************************************************************
      2          // * ota-client.c
      3          // *
      4          // * Zigbee Over-the-air bootload cluster for upgrading firmware and 
      5          // * downloading device specific file.
      6          // * 
      7          // * Copyright 2009 by Ember Corporation. All rights reserved.              *80*
      8          // *****************************************************************************
      9          
     10          #include "app/framework/include/af.h"
     11          #include "callback.h"
     12          #include "app/framework/util/util.h"
     13          #include "app/framework/util/common.h"
     14          #include "app/framework/plugin/ota-common/ota.h"
     15          
     16          #include "app/framework/util/af-main.h"
     17          
     18          #include "app/framework/plugin/ota-storage-common/ota-storage.h"
     19          #include "app/framework/plugin/ota-client/ota-client.h"
     20          #include "app/framework/plugin/ota-client-policy/ota-client-policy.h"
     21          #include "ota-client-signature-verify.h"
     22          #include "ota-client-page-request.h"
     23          #include "app/framework/plugin/partner-link-key-exchange/partner-link-key-exchange.h"
     24          
     25          #if defined(EZSP_HOST)
     26            // For emberIeeeAddressRequest()
     27            #include "app/util/zigbee-framework/zigbee-device-host.h"
     28          #else
     29            #include "stack/include/ember.h"
     30          #endif
     31          
     32          #if defined(EMBER_AF_PLUGIN_OTA_CLIENT_SET_IMAGE_STAMP) \
     33              && !defined(EZSP_HOST) \
     34              && defined(ZCL_USING_OTA_BOOTLOAD_CLUSTER_IMAGE_STAMP_ATTRIBUTE) \
     35              && !defined(XAP2B)
     36              
     37              #define USE_IMAGE_STAMP
     38              #include "hal/micro/cortexm3/memmap.h"
     39              #include "hal/micro/cortexm3/memmap-tables.h"
     40          #endif
     41          
     42          //------------------------------------------------------------------------------
     43          // Globals
     44          
     45          enum BootloadState
     46          {
     47            BOOTLOAD_STATE_NONE,
     48            BOOTLOAD_STATE_DELAY,
     49            BOOTLOAD_STATE_DISCOVER_SERVER,
     50            BOOTLOAD_STATE_GET_SERVER_EUI,
     51            BOOTLOAD_STATE_OBTAIN_LINK_KEY,
     52            BOOTLOAD_STATE_QUERY_NEXT_IMAGE,
     53            BOOTLOAD_STATE_DOWNLOAD,
     54            BOOTLOAD_STATE_VERIFY_IMAGE,
     55            BOOTLOAD_STATE_WAITING_FOR_UPGRADE_MESSAGE,
     56            BOOTLOAD_STATE_COUNTDOWN_TO_UPGRADE,
     57          };
     58          typedef int8u BootloadState;
     59          
     60          static PGM_P bootloadStateNames[] = {
     61            "None",
     62            "Random Delay before start",
     63            "Discovering OTA Server",
     64            "Get OTA Server EUI",
     65            "Obtain link key",
     66            "Querying Next Image",
     67            "Downloading Image",
     68            "Verifying Image",
     69            "Waiting for Upgrade message",
     70            "Countdown to Upgrade",
     71          };
     72          
     73          // This relates the bootload state above to the status that is externally
     74          // reported via the attribute.

   \                                 In section .text, align 4, keep-with-next
     75          static PGM int8u bootloadStateToExternalState[] = {
   \                     bootloadStateToExternalState:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x00 0x00    
     76            OTA_UPGRADE_STATUS_NORMAL,
     77            OTA_UPGRADE_STATUS_NORMAL,
     78            OTA_UPGRADE_STATUS_NORMAL,
     79            OTA_UPGRADE_STATUS_NORMAL,
     80            OTA_UPGRADE_STATUS_NORMAL,
     81            OTA_UPGRADE_STATUS_NORMAL,
     82            OTA_UPGRADE_STATUS_DOWNLOAD_IN_PROGRESS,
     83            OTA_UPGRADE_STATUS_DOWNLOAD_COMPLETE,
     84            OTA_UPGRADE_STATUS_WAIT,
     85            OTA_UPGRADE_STATUS_COUNTDOWN
     86          };
     87          
     88          #define UNDEFINED_ENDPOINT 0xFF
     89          
     90          static BootloadState currentBootloadState = BOOTLOAD_STATE_NONE;
     91          

   \                                 In section .data, align 2
     92          static int8u myEndpoint = UNDEFINED_ENDPOINT;
   \                     myEndpoint:
   \   00000000   0xFF               DC8 255
   \   00000001   0xFF               DC8 255
   \   00000002   0xFFFD             DC16 65533
     93          static int8u serverEndpoint = UNDEFINED_ENDPOINT;
     94          static EmberNodeId serverNodeId = EMBER_UNKNOWN_NODE_ID;
     95          static int8u errors = 0;
     96          static int32u totalImageSize = 0;
     97          static EmberAfOtaImageId currentDownloadFile;
     98          static int16u hardwareVersion;
     99          
    100          #define WAIT_FOR_UPGRADE_MESSAGE 0xFFFFFFFF
    101          
    102          #define ZCL_COMMAND_ID_INDEX 2
    103          
    104          #define IMAGE_NOTIFY_NO_PAYLOAD              0
    105          #define IMAGE_NOTIFY_MANUFACTURER_ONLY_TYPE  1
    106          #define IMAGE_NOTIFY_MFG_AND_IMAGE_TYPE      2
    107          #define IMAGE_NOTIFY_FULL_VERSION_TYPE       3
    108          #define IMAGE_NOTIFY_LAST_VALID_TYPE         IMAGE_NOTIFY_FULL_VERSION_TYPE       
    109          
    110          
    111          
    112          // These lengths correspond to the #defines above.

   \                                 In section .text, align 4, keep-with-next
    113          static PGM int8u imageNotifyPayloadLengths[] = {
   \                     imageNotifyPayloadLengths:
   \   00000000   0x05 0x07          DC8 5, 7, 9, 13
   \              0x09 0x0D    

   \                                 In section .bss, align 4
   \                     currentBootloadState:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \   00000004                      DS8 1
   \   00000005                      DS8 3
   \   00000008                      DS8 16
   \   00000018                      DS8 2
   \   0000001A                      DS8 2
   \   0000001C                      DS8 4
   \   00000020                      DS8 4
    114            (EMBER_AF_ZCL_OVERHEAD + 2),  // Payload and Jitter only.
    115            (EMBER_AF_ZCL_OVERHEAD + 4),  // and MFG ID
    116            (EMBER_AF_ZCL_OVERHEAD + 6),  // and Image Type ID
    117            (EMBER_AF_ZCL_OVERHEAD + 10), // and Version
    118          };
    119          
    120          // Values per the spec.
    121          #define IMAGE_BLOCK_RESPONSE_SUCCESS_MIN_LENGTH      (EMBER_AF_ZCL_OVERHEAD + 14)
    122          #define UPGRADE_END_RESPONSE_MIN_LENGTH              (EMBER_AF_ZCL_OVERHEAD + 16)
    123          #define QUERY_NEXT_IMAGE_SUCCESS_RESPONSE_MIN_LENGTH (EMBER_AF_ZCL_OVERHEAD + 13)
    124          
    125          static boolean waitingForResponse = FALSE;
    126          static int32u nextEventTimer;
    127          
    128          #define WAITING_FOR_MESSAGE      TRUE
    129          #define NO_MESSAGE_RESPONSE_WAIT FALSE
    130          
    131          // Maximum amount of data that the client is willing to accept in one packet
    132          // The server can always give us less data (sizing the response based on its
    133          // send parameters, eg. source routing).  But it can't give us more.
    134          // Since no 
    135          #define MAX_CLIENT_DATA_SIZE      63   // in bytes
    136          
    137          // We only support the Zigbbe Pro stack version.
    138          #define STACK_VERSION ZIGBEE_PRO_STACK_VERSION
    139          
    140          // Handy defines to make the code more readable.
    141          #define TIMEOUT_REACHED  TRUE
    142          #define START_NEW_TIMER  FALSE
    143          
    144          // queryNextImage() defines
    145          typedef enum {
    146            DELAY_BEFORE_SEND_QUERY = 0,
    147            SEND_QUERY_NOW = 1,
    148          } SendNextQueryState;
    149          
    150          // This defines how long to wait for a message response before considering it
    151          // an error.  It also defines how long a sleepy stays awake waiting for
    152          // a message.
    153          #define MESSAGE_TIMEOUT_MS 3000L
    154          
    155          #define IMAGE_BLOCK_ABORT_LENGTH                   (EMBER_AF_ZCL_OVERHEAD + 1)
    156          #define IMAGE_BLOCK_RESPONSE_SUCCESS_MIN_LENGTH    (EMBER_AF_ZCL_OVERHEAD + 14)
    157          
    158          // This is the length WITHOUT the Minimum Block Request Period
    159          #define IMAGE_BLOCK_RESPONSE_WAIT_FOR_DATA_LENGTH_MIN  (EMBER_AF_ZCL_OVERHEAD + 8)
    160          
    161          #define IMAGE_BLOCK_RESPONSE_WAIT_FOR_DATA_MIN_BLOCK_RESPONSE_LENGTH \
    162            (IMAGE_BLOCK_RESPONSE_WAIT_FOR_DATA_LENGTH_MIN + 2)
    163          
    164          // Maximum wait time that the client would wait to retrive data or to be
    165          // upgraded. If the server is not ready for the operation, it should tell the
    166          // client to wait (again).  But the client would only wait up to the value 
    167          // defined below.  Regarding upgrading, current OTA spec recommends that the
    168          // client should query the server every 60 mins even though it is told to wait 
    169          // longer.
    170          #define TIMEOUT_MAX_WAIT_TIME_MS   (60 * MINUTES_IN_MS)
    171          
    172          // If the server sent us an invalid delay time for the an image block
    173          // download, this is how long we will delay before getting the
    174          // next block.
    175          #define CALCULATE_TIME_ERROR_IMAGE_BLOCK_DELAY_MS (5 * MINUTES_IN_MS)
    176          
    177          // If the server sent us an invalid delay time for the upgrade end response,
    178          // we use this value for the next request.
    179          #define CALCULATE_TIME_ERROR_UPGRADE_END_RESPONSE_DELAY_MS (1 * HOURS_IN_MS)
    180          
    181          // When the server asks us to wait indefinitely to apply an upgrade,
    182          // we will ask them again in this much time.
    183          #define WAIT_FOR_UPGRADE_DELAY_MS (1 * HOURS_IN_MS)
    184          
    185          // How often a print is done indicating client download progress.
    186          // e.g. "Download 5% complete"
    187          #define DOWNLOAD_PERCENTAGE_UPDATE_RATE 5
    188          
    189          #define MESSAGE_TIMEOUT_BACKOFF_MS (2 * SECONDS_IN_MS)
    190          
    191          // Even when we are told to upgrade immediately, we want to insure there
    192          // is a chance for the APS retries and ZCL response to get back to their 
    193          // senders.
    194          #define IMMEDIATE_UPGRADE_DELAY_MS (3 * SECONDS_IN_MS)
    195          
    196          #if defined(EMBER_AF_PLUGIN_OTA_CLIENT_USE_PAGE_REQUEST)
    197            #define USE_PAGE_REQUEST_DEFAULT TRUE
    198          #else
    199            #define USE_PAGE_REQUEST_DEFAULT FALSE
    200          #endif
    201          
    202          // HA 1.2 feature
    203          static int16u minBlockRequestPeriodMs;
    204          
    205          // This is not a CONST because even if the client supports page request,
    206          // the server may not.  So we will dynamically turn off sending page requests
    207          // when it is enabled and the server doesn't support it.
    208          static boolean usePageRequest = USE_PAGE_REQUEST_DEFAULT;
    209          
    210          typedef enum {
    211            NO_CUSTOM_VERIFY,
    212            NEW_CUSTOM_VERIFY,
    213            CUSTOM_VERIFY_IN_PROGRESS,
    214          } CustomVerifyStatus;
    215          static boolean customVerifyStatus = NO_CUSTOM_VERIFY;
    216          
    217          // TODO: need to gate this when we're better equipped to do so
    218          // with the generated CLI
    219          //#if defined(EMBER_TEST)
    220          // If set to 100, will not stop download.

   \                                 In section .data, align 1
    221          int8u emAfOtaClientStopDownloadPercentage = 100;
   \                     emAfOtaClientStopDownloadPercentage:
   \   00000000   0x64               DC8 100
    222          //#endif
    223          
    224          // The spec says pick a random number up to 5 minutes.  We limit
    225          // ourselves to 4.25 minutes to make it easier to mask out the upper
    226          // bits and limit the number retrieved from halCommonGetRandom()
    227          #define MAXIMUM_RANDOM_DELAY_SECONDS_MASK 0x00FF  
    228          
    229          //------------------------------------------------------------------------------
    230          // Forward Declarations
    231          
    232          static void recordUpgradeStatus(BootloadState state);
    233          static void putImageInfoInMessage(void);
    234          static void startServerDiscovery(void);
    235          static void euiLookupErrorOccurred(void);
    236          static void euiLookup(void);
    237          static void queryNextImage(SendNextQueryState nextQuery,
    238                                     boolean queryErrorOccurred);
    239          static void continueImageDownload(void);
    240          static void continueImageVerification(EmberAfImageVerifyStatus status);
    241          static void askServerToRunUpgrade(boolean timeout);
    242          static void runUpgrade(void);
    243          static int32u updateCurrentOffset(int32u currentOffset);
    244          static void updateDownloadFileVersion(int32u version);
    245          static boolean downloadAndVerifyFinish(EmberAfOtaDownloadResult result);
    246          static void determineNextState(void);
    247          static EmberAfStatus imageNotifyParse(boolean broadcast, 
    248                                                int8u* buffer, 
    249                                                int8u index, 
    250                                                int8u length);
    251          static EmberAfStatus queryNextImageResponseParse(int8u* buffer, 
    252                                                           int8u index, 
    253                                                           int8u length);
    254          static EmberAfStatus imageBlockResponseParse(int8u* buffer, 
    255                                                       int8u index, 
    256                                                       int8u length);
    257          static EmberAfStatus upgradeEndResponseParse(int8u status,
    258                                                       int8u* buffer, 
    259                                                       int8u length);
    260          static boolean calculateTimer(int32u currentTime, 
    261                                        int32u targetTime, 
    262                                        int32u* returnTime);
    263          
    264          //------------------------------------------------------------------------------
    265          

   \                                 In section .text, align 2, keep-with-next
    266          static void updateCurrentImageAttributes(EmberAfOtaImageId* imageId)
    267          {
   \                     updateCurrentImageAttributes: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    268          #if defined(ZCL_USING_OTA_BOOTLOAD_CLUSTER_MANUFACTURER_ID_ATTRIBUTE)
    269            emberAfWriteAttribute(myEndpoint,
    270                                  ZCL_OTA_BOOTLOAD_CLUSTER_ID, 
    271                                  ZCL_MANUFACTURER_ID_ATTRIBUTE_ID,
    272                                  CLUSTER_MASK_CLIENT,
    273                                  (int8u*)&(imageId->manufacturerId),
    274                                  ZCL_INT16U_ATTRIBUTE_TYPE);
    275          #endif
    276          
    277          #if defined(ZCL_USING_OTA_BOOTLOAD_CLUSTER_IMAGE_TYPE_ID_ATTRIBUTE)
    278            emberAfWriteAttribute(myEndpoint,
    279                                  ZCL_OTA_BOOTLOAD_CLUSTER_ID, 
    280                                  ZCL_IMAGE_TYPE_ID_ATTRIBUTE_ID,
    281                                  CLUSTER_MASK_CLIENT,
    282                                  (int8u*)&(imageId->imageTypeId),
    283                                  ZCL_INT16U_ATTRIBUTE_TYPE);
    284          #endif
    285          
    286          #if defined(ZCL_USING_OTA_BOOTLOAD_CLUSTER_CURRENT_FILE_VERSION_ATTRIBUTE)
    287            emberAfWriteAttribute(myEndpoint,
    288                                  ZCL_OTA_BOOTLOAD_CLUSTER_ID, 
    289                                  ZCL_CURRENT_FILE_VERSION_ATTRIBUTE_ID,
    290                                  CLUSTER_MASK_CLIENT,
    291                                  (int8u*)&(imageId->firmwareVersion),
    292                                  ZCL_INT32U_ATTRIBUTE_TYPE);
   \   00000004   0x1D00             ADDS     R0,R0,#+4
   \   00000006   0x9000             STR      R0,[SP, #+0]
   \   00000008   0x2123             MOVS     R1,#+35
   \   0000000A   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000000E   0x9101             STR      R1,[SP, #+4]
   \   00000010   0x2380             MOVS     R3,#+128
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0x2119             MOVS     R1,#+25
   \   00000016   0x.... 0x....      BL       emberAfWriteAttribute
    293          #endif
    294          }
   \   0000001A   0xBD07             POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x9000             STR      R0,[SP, #+0]
   \                     ??Subroutine1_0: (+1)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable35
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x4770             BX       LR
    295          
    296          static void updateMinBlockRequestPeriodAttribute(int16u value)
    297          {
    298            minBlockRequestPeriodMs = value;
    299          
    300          #if defined(ZCL_USING_OTA_BOOTLOAD_CLUSTER_MINIMUM_BLOCK_REQUEST_PERIOD_ATTRIBUTE)
    301            {
    302              emberAfWriteAttribute(myEndpoint,
    303                                    ZCL_OTA_BOOTLOAD_CLUSTER_ID, 
    304                                    ZCL_MINIMUM_BLOCK_REQUEST_PERIOD_ATTRIBUTE_ID, 
    305                                    CLUSTER_MASK_CLIENT,
    306                                    (int8u*)&minBlockRequestPeriodMs,
    307                                    ZCL_INT16U_ATTRIBUTE_TYPE);
    308            }
    309          #endif
    310          }
    311          

   \                                 In section .text, align 2, keep-with-next
    312          void emberAfOtaBootloadClusterClientInitCallback(int8u endpoint)
    313          {
    314            if (myEndpoint != UNDEFINED_ENDPOINT) {
   \                     emberAfOtaBootloadClusterClientInitCallback: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable35
   \   00000004   0x780A             LDRB     R2,[R1, #+0]
   \   00000006   0x2AFF             CMP      R2,#+255
   \   00000008   0xD000             BEQ.N    ??emberAfOtaBootloadClusterClientInitCallback_0
   \   0000000A   0x4770             BX       LR
    315              // We have already been initialized
    316              return;
    317            }
    318            myEndpoint = endpoint;
   \                     ??emberAfOtaBootloadClusterClientInitCallback_0: (+1)
   \   0000000C   0xB500             PUSH     {LR}
   \   0000000E   0xB085             SUB      SP,SP,#+20
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    319          
    320            emberAfOtaStorageInitCallback();
   \   00000012   0x.... 0x....      BL       emberAfOtaStorageInitCallback
    321          
    322          #if defined(ZCL_USING_OTA_BOOTLOAD_CLUSTER_CURRENT_ZIGBEE_STACK_VERSION_ATTRIBUTE)
    323            {
    324              int16u currentZigbeeStackVersion = ZIGBEE_PRO_STACK_VERSION;
    325              emberAfWriteAttribute(myEndpoint,
    326                                    ZCL_OTA_BOOTLOAD_CLUSTER_ID, 
    327                                    ZCL_CURRENT_ZIGBEE_STACK_VERSION_ATTRIBUTE_ID, 
    328                                    CLUSTER_MASK_CLIENT,
    329                                    (int8u*)&currentZigbeeStackVersion,
    330                                    ZCL_INT16U_ATTRIBUTE_TYPE);
    331            }
    332          #endif
    333          
    334            // Assume we can download as fast as we want until told otherwise by server.
    335            updateMinBlockRequestPeriodAttribute(0); // minBlockRequestPeriod.
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \   0000001C   0x8348             STRH     R0,[R1, #+26]
    336          
    337          
    338          #if defined(USE_IMAGE_STAMP)
    339            {
    340              // Unfortunately the AAT data struct is declared const,
    341              // so we must copy out the image stamp to satisfy the compiler.
    342              int8u data[IMAGE_STAMP_SIZE];
    343              MEMMOVE(data, halAppAddressTable.imageStamp, IMAGE_STAMP_SIZE);
    344              emberAfWriteAttribute(myEndpoint,
    345                                    ZCL_OTA_BOOTLOAD_CLUSTER_ID,
    346                                    ZCL_IMAGE_STAMP_ATTRIBUTE_ID,
    347                                    CLUSTER_MASK_CLIENT,
    348                                    data,
    349                                    ZCL_INT32U_ATTRIBUTE_TYPE);
    350            }
    351          #endif
    352          
    353            {
    354              EmberAfOtaImageId id;
    355              int16u hwVer;    
    356              emberAfOtaClientVersionInfoCallback(&id, 
    357                                                  &hwVer);
   \   0000001E   0xA900             ADD      R1,SP,#+0
   \   00000020   0xA801             ADD      R0,SP,#+4
   \   00000022   0x.... 0x....      BL       emberAfOtaClientVersionInfoCallback
    358              updateCurrentImageAttributes(&id);
   \   00000026   0xA801             ADD      R0,SP,#+4
   \   00000028   0x.... 0x....      BL       updateCurrentImageAttributes
    359            }
    360          }
   \   0000002C   0xB005             ADD      SP,SP,#+20
   \   0000002E   0xBD00             POP      {PC}             ;; return
    361          
    362          // Returns whether or not a timer has been set.  For timer = 0, will return FALSE

   \                                 In section .text, align 2, keep-with-next
    363          static boolean setTimer(int32u timeMs)
    364          {
   \                     setTimer: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    365            int32u timer;
    366          
    367            // When waiting for page request replies I want to use the timer that is defined
    368            // in App. Builder and passed through to here since I am expecting multiple
    369            // messages coming back from the server.
    370            if (waitingForResponse
    371                && emAfGetCurrentPageRequestStatus() != EM_AF_WAITING_PAGE_REQUEST_REPLIES) {
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable35_1
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x78A8             LDRB     R0,[R5, #+2]
   \   0000000A   0xB138             CBZ.N    R0,??setTimer_0
   \   0000000C   0x.... 0x....      BL       emAfGetCurrentPageRequestStatus
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD003             BEQ.N    ??setTimer_0
    372              timer = MESSAGE_TIMEOUT_MS;
    373              nextEventTimer = timeMs;
   \   00000014   0x622C             STR      R4,[R5, #+32]
   \   00000016   0xF640 0x36B8      MOVW     R6,#+3000
   \   0000001A   0xE003             B.N      ??setTimer_1
    374            } else {
    375              timer = timeMs;
    376              nextEventTimer = 0;
   \                     ??setTimer_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x4626             MOV      R6,R4
   \   00000020   0x6228             STR      R0,[R5, #+32]
    377            }
    378          
    379            // A timer set at 0 means we are not counting down to some event.
    380            // We may still be in an active state of waiting, but are waiting
    381            // for an event to fire rather than a timer to expire.  For example, service
    382            // discovery will generate a callback when it is complete.  No need for
    383            // keeping track of time here as well.
    384            if (timer != 0) {
   \   00000022   0xB1AE             CBZ.N    R6,??setTimer_2
    385              //    otaPrintln("Setting timer: 0x%4X ms", timer);
    386              EmberAfEventPollControl pollControl = EMBER_AF_SHORT_POLL;
   \                     ??setTimer_1: (+1)
   \   00000024   0x2401             MOVS     R4,#+1
    387              EmberAfEventSleepControl sleepControl = EMBER_AF_OK_TO_SLEEP;
    388              if (currentBootloadState == BOOTLOAD_STATE_VERIFY_IMAGE) {
   \   00000026   0x7828             LDRB     R0,[R5, #+0]
   \   00000028   0x2700             MOVS     R7,#+0
   \   0000002A   0x2807             CMP      R0,#+7
   \   0000002C   0xBF08             IT       EQ 
    389                sleepControl = EMBER_AF_STAY_AWAKE;
   \   0000002E   0x2702             MOVEQ    R7,#+2
   \   00000030   0xD005             BEQ.N    ??setTimer_3
    390              } else if (!waitingForResponse
    391                         && (emAfGetCurrentPageRequestStatus() 
    392                             == EM_AF_NO_PAGE_REQUEST)) {
   \   00000032   0x78A8             LDRB     R0,[R5, #+2]
   \   00000034   0xB918             CBNZ.N   R0,??setTimer_3
   \   00000036   0x.... 0x....      BL       emAfGetCurrentPageRequestStatus
   \   0000003A   0xB900             CBNZ.N   R0,??setTimer_3
    393                pollControl = EMBER_AF_LONG_POLL;
   \   0000003C   0x2400             MOVS     R4,#+0
    394              }
    395              emberAfScheduleClientTickExtended(myEndpoint,
    396                                                ZCL_OTA_BOOTLOAD_CLUSTER_ID,
    397                                                timer,
    398                                                pollControl,
    399                                                sleepControl);
   \                     ??setTimer_3: (+1)
   \   0000003E   0x.... 0x....      BL       ??Subroutine1_0
    400            }
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000042   0x9700             STR      R7,[SP, #+0]
   \   00000044   0x4623             MOV      R3,R4
   \   00000046   0x4632             MOV      R2,R6
   \   00000048   0x2119             MOVS     R1,#+25
   \   0000004A   0x.... 0x....      BL       emberAfScheduleClientTickExtended
   \   0000004E   0x2001             MOVS     R0,#+1
   \                     ??setTimer_2: (+1)
   \   00000050   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    401            return (timer != 0);
    402          }
    403          

   \                                 In section .text, align 2, keep-with-next
    404          void emberAfPluginOtaClientStackStatusCallback(EmberStatus status)
    405          {
    406          #if defined(EMBER_AF_PLUGIN_OTA_CLIENT_AUTO_START)
    407            int16u randomDelaySeconds;
    408            if (status != EMBER_NETWORK_UP
    409                || currentBootloadState != BOOTLOAD_STATE_NONE) {
   \                     emberAfPluginOtaClientStackStatusCallback: (+1)
   \   00000000   0x2890             CMP      R0,#+144
   \   00000002   0xD000             BEQ.N    ??emberAfPluginOtaClientStackStatusCallback_0
   \   00000004   0x4770             BX       LR
   \                     ??emberAfPluginOtaClientStackStatusCallback_0: (+1)
   \   00000006   0xB510             PUSH     {R4,LR}
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xB950             CBNZ.N   R0,??emberAfPluginOtaClientStackStatusCallback_1
    410              return;
    411            }
    412            randomDelaySeconds = (halCommonGetRandom()
    413                                  & MAXIMUM_RANDOM_DELAY_SECONDS_MASK);
   \   00000010   0x.... 0x....      BL       halCommonGetRandom
   \   00000014   0x4604             MOV      R4,R0
    414            recordUpgradeStatus(BOOTLOAD_STATE_DELAY);
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x.... 0x....      BL       recordUpgradeStatus
    415            otaPrintln("Delaying %d seconds before starting OTA client", randomDelaySeconds);
    416            // the setTimer(int32u) function wants milliseconds
    417            setTimer(randomDelaySeconds * MILLISECOND_TICKS_PER_SECOND);
   \   0000001C   0x0620             LSLS     R0,R4,#+24
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x0B80             LSRS     R0,R0,#+14
   \   00000024   0x....             B.N      setTimer
   \                     ??emberAfPluginOtaClientStackStatusCallback_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    418          #endif
    419          }
    420          

   \                                 In section .text, align 4, keep-with-next
    421          static void otaClientTick(void)
    422          {
   \                     otaClientTick: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    423            boolean errorOccurred = FALSE;
   \   00000002   0x2400             MOVS     R4,#+0
    424            // Getting here means either we timed out our last operation,
    425            // or we need to kick off a periodic event.
    426          
    427            emAfPageRequestTimerExpired();
   \   00000004   0x.... 0x....      BL       emAfPageRequestTimerExpired
    428             
    429            if (waitingForResponse) {
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000000C   0x7801             LDRB     R1,[R0, #+0]
   \   0000000E   0x7882             LDRB     R2,[R0, #+2]
   \   00000010   0xB182             CBZ.N    R2,??otaClientTick_1
    430              otaPrintln("Timeout waiting for message.");
    431              errorOccurred = TRUE;
    432              errors++;
   \   00000012   0x7842             LDRB     R2,[R0, #+1]
   \   00000014   0x1C52             ADDS     R2,R2,#+1
   \   00000016   0x7042             STRB     R2,[R0, #+1]
   \   00000018   0x2401             MOVS     R4,#+1
    433              waitingForResponse = FALSE;
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x7082             STRB     R2,[R0, #+2]
    434                
    435              if (currentBootloadState == BOOTLOAD_STATE_DOWNLOAD) {
   \   0000001E   0x2906             CMP      R1,#+6
   \   00000020   0xD108             BNE.N    ??otaClientTick_1
    436                // Especially important if the download delay is 0, we want
    437                // to backoff a little and make sure we don't continue to
    438                // blast the server with requests.
    439                setTimer((nextEventTimer > MESSAGE_TIMEOUT_BACKOFF_MS)
    440                         ? nextEventTimer
    441                         : MESSAGE_TIMEOUT_BACKOFF_MS);
   \   00000022   0x6A00             LDR      R0,[R0, #+32]
   \   00000024   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   00000028   0xBF98             IT       LS 
   \   0000002A   0xF44F 0x60FA      MOVLS    R0,#+2000
   \   0000002E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000032   0x....             B.N      setTimer
    442                return;
    443              }
    444            }
    445          
    446            switch (currentBootloadState) {
   \                     ??otaClientTick_1: (+1)
   \   00000034   0x1E49             SUBS     R1,R1,#+1
   \   00000036   0x2908             CMP      R1,#+8
   \   00000038   0xD821             BHI.N    ??otaClientTick_2
   \   0000003A   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??otaClientTick_0:
   \   0000003E   0x05 0x08          DC8      0x5,0x8,0xB,0x20
   \              0x0B 0x20    
   \   00000042   0x0E 0x13          DC8      0xE,0x13,0x16,0x1A
   \              0x16 0x1A    
   \   00000046   0x1E 0x00          DC8      0x1E,0x0
    447            case BOOTLOAD_STATE_DELAY:
    448              emberAfOtaClientStartCallback();
   \                     ??otaClientTick_3: (+1)
   \   00000048   0xE8BD 0x4010      POP      {R4,LR}
   \   0000004C   0x....             B.N      emberAfOtaClientStartCallback
    449              break;
    450            case BOOTLOAD_STATE_DISCOVER_SERVER:
    451              startServerDiscovery();
   \                     ??otaClientTick_4: (+1)
   \   0000004E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000052   0x....             B.N      startServerDiscovery
    452              break;
    453            case BOOTLOAD_STATE_GET_SERVER_EUI:
    454              euiLookupErrorOccurred();
   \                     ??otaClientTick_5: (+1)
   \   00000054   0xE8BD 0x4010      POP      {R4,LR}
   \   00000058   0x....             B.N      euiLookupErrorOccurred
    455              break;
    456            case BOOTLOAD_STATE_QUERY_NEXT_IMAGE:
    457              queryNextImage(SEND_QUERY_NOW, 
    458                             errorOccurred);
   \                     ??otaClientTick_6: (+1)
   \   0000005A   0x4621             MOV      R1,R4
   \   0000005C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x....             B.N      queryNextImage
    459              break;
    460            case BOOTLOAD_STATE_DOWNLOAD:
    461              continueImageDownload();
   \                     ??otaClientTick_7: (+1)
   \   00000064   0xE8BD 0x4010      POP      {R4,LR}
   \   00000068   0x....             B.N      continueImageDownload
    462              break;
    463            case BOOTLOAD_STATE_VERIFY_IMAGE:
    464              continueImageVerification(EMBER_AF_IMAGE_VERIFY_IN_PROGRESS);
   \                     ??otaClientTick_8: (+1)
   \   0000006A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000006E   0x2002             MOVS     R0,#+2
   \   00000070   0x....             B.N      continueImageVerification
    465              break;
    466            case BOOTLOAD_STATE_WAITING_FOR_UPGRADE_MESSAGE:
    467              askServerToRunUpgrade(TIMEOUT_REACHED);
   \                     ??otaClientTick_9: (+1)
   \   00000072   0xE8BD 0x4010      POP      {R4,LR}
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x....             B.N      askServerToRunUpgrade
    468              break;
    469            case BOOTLOAD_STATE_COUNTDOWN_TO_UPGRADE:
    470              runUpgrade();
   \                     ??otaClientTick_10: (+1)
   \   0000007A   0x.... 0x....      B.W      ?Subroutine0
    471            default:
    472              // Do nothing.  Invalid state
    473              break;
    474            }
    475          }
   \                     ??otaClientTick_2: (+1)
   \   0000007E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xE8BD 0x4010      POP      {R4,LR}
   \   00000004   0x....             B.N      runUpgrade
    476          

   \                                 In section .text, align 2, keep-with-next
    477          void emberAfPluginOtaStorageSimpleEepromEraseCompleteCallback(boolean success)
    478          {
    479            if (!success) {
   \                     emberAfPluginOtaStorageSimpleEepromEraseCompleteCallback: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xBF04             ITT      EQ 
    480              downloadAndVerifyFinish(EMBER_AF_OTA_ERASE_FAILED);
   \   00000004   0x2005             MOVEQ    R0,#+5
   \   00000006   0x.... 0x....      BEQ.W    downloadAndVerifyFinish
    481          
    482            } else if (currentBootloadState == BOOTLOAD_STATE_DOWNLOAD) {
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2806             CMP      R0,#+6
   \   00000012   0xBF08             IT       EQ 
    483              // If an erase was triggered for some other reason besides preparing
    484              // to start a download, we don't want to trigger the OTA client state
    485              // machine.
    486              otaClientTick();
   \   00000014   0x.... 0x....      BEQ.W    otaClientTick
    487            }
    488          }
   \   00000018   0x4770             BX       LR               ;; return
    489          

   \                                 In section .text, align 2, keep-with-next
    490          void emberAfOtaBootloadClusterClientTickCallback(int8u endpoint)
    491          {
    492            // Since there is only one instance of the OTA bootload cluster allowed,
    493            // we don't care about the endpoint value.
    494            otaClientTick();
   \                     emberAfOtaBootloadClusterClientTickCallback: (+1)
   \   00000000   0x....             B.N      otaClientTick
    495          }
    496          

   \                                 In section .text, align 2, keep-with-next
    497          static void restartServerDiscoveryAfterDelay(void)
    498          {
   \                     restartServerDiscoveryAfterDelay: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    499            setTimer(EMBER_AF_OTA_SERVER_DISCOVERY_DELAY_MS);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable35_2  ;; 0x927c0
   \   00000006   0x.... 0x....      BL       setTimer
    500            recordUpgradeStatus(BOOTLOAD_STATE_DISCOVER_SERVER);
   \   0000000A   0xE8BD 0x4002      POP      {R1,LR}
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x....             B.N      recordUpgradeStatus
    501          }
    502          
    503          #if defined(EMBER_AF_HAS_SECURITY_PROFILE_SE)
    504          static void otaClientPartnerLinkKeyCallback(boolean success)
    505          {
    506            if (success) {
    507              determineNextState();
    508              return;
    509            } 
    510          
    511            restartServerDiscoveryAfterDelay();
    512          }
    513          #endif
    514          
    515          static void getPartnerLinkKey(void)
    516          {
    517          #if defined(EMBER_AF_HAS_SECURITY_PROFILE_SE)
    518            EmberEUI64 serverEui64;
    519            int8u i;
    520          
    521            if (!emberAfIsCurrentSecurityProfileSmartEnergy()
    522                || serverNodeId == EMBER_TRUST_CENTER_NODE_ID) {
    523              goto partnerLinkKeyDone;
    524            }
    525          
    526            emberAfReadClientAttribute(myEndpoint,
    527                                       ZCL_OTA_BOOTLOAD_CLUSTER_ID,
    528                                       ZCL_UPGRADE_SERVER_ID_ATTRIBUTE_ID,
    529                                       serverEui64,
    530                                       EUI64_SIZE);
    531          
    532            for (i = 0; i < emberAfGetKeyTableSize(); i++) {
    533              EmberKeyStruct keyStruct;
    534              if (EMBER_SUCCESS == emberGetKeyTableEntry(i, &keyStruct)
    535                  && EMBER_APPLICATION_LINK_KEY == keyStruct.type
    536                  && 0 == MEMCOMPARE(keyStruct.partnerEUI64, serverEui64, EUI64_SIZE)) {
    537                goto partnerLinkKeyDone;
    538              }
    539            }
    540          
    541            // Spec is not clear whether the actual key establishment endpoint 
    542            // needs to be used, so we just use 1.
    543            if (EMBER_SUCCESS
    544                == emberAfInitiatePartnerLinkKeyExchange(serverNodeId,
    545                                                         1,
    546                                                         otaClientPartnerLinkKeyCallback)) {
    547              return;
    548            }
    549            
    550            // If we fail to initiate partner link key, it could be because 
    551            // we don't have any link key spots or the server is no longer online.
    552            // We just retry the entire operation again.
    553            restartServerDiscoveryAfterDelay();
    554            return;
    555          
    556           partnerLinkKeyDone:
    557          #endif
    558          
    559            determineNextState();
    560            return;
    561          }
    562          

   \                                 In section .text, align 2, keep-with-next
    563          static int32u getCurrentOffset(void)
    564          {
   \                     getCurrentOffset: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    565            int32u offset;
    566            int8u dataType = ZCL_INT32U_ATTRIBUTE_TYPE;
   \   00000004   0x2023             MOVS     R0,#+35
   \   00000006   0xF88D 0x000C      STRB     R0,[SP, #+12]
    567            emberAfReadAttribute(myEndpoint, 
    568                                 ZCL_OTA_BOOTLOAD_CLUSTER_ID,
    569                                 ZCL_FILE_OFFSET_ATTRIBUTE_ID,
    570                                 CLUSTER_MASK_CLIENT,
    571                                 (int8u*)&offset,
    572                                 4,
    573                                 &dataType);
   \   0000000A   0x2380             MOVS     R3,#+128
   \   0000000C   0xA803             ADD      R0,SP,#+12
   \   0000000E   0x9002             STR      R0,[SP, #+8]
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x2004             MOVS     R0,#+4
   \   00000014   0x9001             STR      R0,[SP, #+4]
   \   00000016   0x2119             MOVS     R1,#+25
   \   00000018   0xA804             ADD      R0,SP,#+16
   \   0000001A   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000001E   0x.... 0x....      BL       emberAfReadAttribute
    574            return offset;
   \   00000022   0x9804             LDR      R0,[SP, #+16]
   \   00000024   0xB005             ADD      SP,SP,#+20
   \   00000026   0xBD00             POP      {PC}             ;; return
    575          }
    576          

   \                                 In section .text, align 2, keep-with-next
    577          static int32u updateCurrentOffset(int32u currentOffset)
    578          {
   \                     updateCurrentOffset: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    579            emberAfWriteAttribute(myEndpoint,
    580                                  ZCL_OTA_BOOTLOAD_CLUSTER_ID, 
    581                                  ZCL_FILE_OFFSET_ATTRIBUTE_ID, 
    582                                  CLUSTER_MASK_CLIENT,
    583                                  (int8u*)&currentOffset,
    584                                  ZCL_INT32U_ATTRIBUTE_TYPE);
   \   00000004   0x2023             MOVS     R0,#+35
   \   00000006   0x9001             STR      R0,[SP, #+4]
   \   00000008   0x2380             MOVS     R3,#+128
   \   0000000A   0xA802             ADD      R0,SP,#+8
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000014   0x2119             MOVS     R1,#+25
   \   00000016   0x.... 0x....      BL       emberAfWriteAttribute
    585            return currentOffset;
   \   0000001A   0x9802             LDR      R0,[SP, #+8]
   \   0000001C   0xBD0E             POP      {R1-R3,PC}       ;; return
    586          }
    587          

   \                                 In section .text, align 2, keep-with-next
    588          static void updateDownloadFileVersion(int32u version)
    589          {
    590          #if defined(ZCL_USING_OTA_BOOTLOAD_CLUSTER_DOWNLOADED_FILE_VERSION_ATTRIBUTE)
    591            emberAfWriteAttribute(myEndpoint,
    592                                  ZCL_OTA_BOOTLOAD_CLUSTER_ID, 
    593                                  ZCL_DOWNLOADED_FILE_VERSION_ATTRIBUTE_ID, 
    594                                  CLUSTER_MASK_CLIENT,
    595                                  (int8u*)(&version),
    596                                  ZCL_INT32U_ATTRIBUTE_TYPE);
    597          #endif
    598            currentDownloadFile.firmwareVersion = version;
   \                     updateDownloadFileVersion: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \   00000004   0x60C8             STR      R0,[R1, #+12]
    599          }
   \   00000006   0x4770             BX       LR               ;; return
    600          
    601          // It is expected this is called when registration has successfully
    602          // completed.

   \                                 In section .text, align 2, keep-with-next
    603          void emberAfOtaClientStartCallback(void)
    604          {
    605            // If we are already delaying we allow jumping immediately
    606            // to discovery and skipping the delay.  This benefits the
    607            // CLI as well as applications that might expect behavior
    608            // as in previous releases where discovery started as soon
    609            // as this API is called.
    610            if (currentBootloadState == BOOTLOAD_STATE_NONE
    611                || currentBootloadState == BOOTLOAD_STATE_DELAY) {
   \                     emberAfOtaClientStartCallback: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xBF14             ITE      NE 
   \   0000000A   0x2801             CMPNE    R0,#+1
    612              startServerDiscovery();
   \   0000000C   0x.... 0x....      BEQ.W    startServerDiscovery
    613            }
    614          }
   \   00000010   0x4770             BX       LR               ;; return
    615          

   \                                 In section .text, align 2, keep-with-next
    616          void emAfOtaClientStop(void)
    617          {
   \                     emAfOtaClientStop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    618            downloadAndVerifyFinish(EMBER_AF_OTA_CLIENT_ABORTED);
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    619            recordUpgradeStatus(BOOTLOAD_STATE_NONE);
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       recordUpgradeStatus
    620            waitingForResponse = FALSE;
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x7088             STRB     R0,[R1, #+2]
    621          
    622            emberAfDeactivateClientTick(myEndpoint, ZCL_OTA_BOOTLOAD_CLUSTER_ID);
   \   00000014   0x2119             MOVS     R1,#+25
   \   00000016   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000001A   0xE8BD 0x4004      POP      {R2,LR}
   \   0000001E   0x.... 0x....      B.W      emberAfDeactivateClientTick
    623          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x2004             MOVS     R0,#+4
   \   00000002   0x....             B.N      downloadAndVerifyFinish
    624          

   \                                 In section .text, align 2, keep-with-next
    625          void emAfOtaClientPrintState(void)
    626          {
    627            otaPrintln(" State:   %p",
    628                       bootloadStateNames[currentBootloadState]);
    629            otaPrintln(" Waiting for response: %p",
    630                       (waitingForResponse ? "yes" : "no"));
    631            if (waitingForResponse) {
    632              otaPrintln(" Next Event Timer: %d ms", nextEventTimer);
    633            }
    634            otaPrintln(" Current Download Offset: 0x%4X (%d%%)", 
    635                       getCurrentOffset(),
    636                       emAfCalculatePercentage(getCurrentOffset(),
    637                                               totalImageSize));
    638          }
   \                     emAfOtaClientPrintState: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    639          

   \                                 In section .text, align 2, keep-with-next
    640          static void recordServerEuiAndGoToNextState(EmberEUI64 eui64)
    641          {
   \                     recordServerEuiAndGoToNextState: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    642            emberAfWriteAttribute(myEndpoint,
    643                                  ZCL_OTA_BOOTLOAD_CLUSTER_ID, 
    644                                  ZCL_UPGRADE_SERVER_ID_ATTRIBUTE_ID, 
    645                                  CLUSTER_MASK_CLIENT,
    646                                  eui64,
    647                                  ZCL_IEEE_ADDRESS_ATTRIBUTE_TYPE);
   \   00000004   0x21F0             MOVS     R1,#+240
   \   00000006   0x9000             STR      R0,[SP, #+0]
   \   00000008   0x9101             STR      R1,[SP, #+4]
   \   0000000A   0x2380             MOVS     R3,#+128
   \   0000000C   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2119             MOVS     R1,#+25
   \   00000014   0x.... 0x....      BL       emberAfWriteAttribute
    648            otaPrintln("OTA Cluster: setting IEEE address of OTA cluster");
    649            getPartnerLinkKey();;
   \   00000018   0x.... 0x....      LDR.W    R4,??DataTable35_1
   \   0000001C   0xF104 0x0208      ADD      R2,R4,#+8
   \   00000020   0xF104 0x011C      ADD      R1,R4,#+28
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x.... 0x....      BL       emberAfOtaStorageCheckTempDataCallback
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xD10B             BNE.N    ??recordServerEuiAndGoToNextState_0
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x.... 0x....      BL       updateCurrentOffset
   \   00000034   0x68E0             LDR      R0,[R4, #+12]
   \   00000036   0x.... 0x....      BL       updateDownloadFileVersion
   \   0000003A   0x69E1             LDR      R1,[R4, #+28]
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      BL       emAfPrintPercentageSetStartAndEnd
   \   00000042   0x2006             MOVS     R0,#+6
   \   00000044   0xE00B             B.N      ??recordServerEuiAndGoToNextState_1
   \                     ??recordServerEuiAndGoToNextState_0: (+1)
   \   00000046   0xB948             CBNZ.N   R0,??recordServerEuiAndGoToNextState_2
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xA801             ADD      R0,SP,#+4
   \   0000004C   0x.... 0x....      BL       emberAfOtaClientVersionInfoCallback
   \   00000050   0x9802             LDR      R0,[SP, #+8]
   \   00000052   0x68E1             LDR      R1,[R4, #+12]
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xBF18             IT       NE 
   \   00000058   0x2007             MOVNE    R0,#+7
   \   0000005A   0xD100             BNE.N    ??recordServerEuiAndGoToNextState_1
   \                     ??recordServerEuiAndGoToNextState_2: (+1)
   \   0000005C   0x2005             MOVS     R0,#+5
   \                     ??recordServerEuiAndGoToNextState_1: (+1)
   \   0000005E   0x7020             STRB     R0,[R4, #+0]
   \   00000060   0x7820             LDRB     R0,[R4, #+0]
   \   00000062   0x2805             CMP      R0,#+5
   \   00000064   0xD019             BEQ.N    ??recordServerEuiAndGoToNextState_3
   \   00000066   0xD31C             BCC.N    ??recordServerEuiAndGoToNextState_4
   \   00000068   0x2807             CMP      R0,#+7
   \   0000006A   0xD001             BEQ.N    ??recordServerEuiAndGoToNextState_5
   \   0000006C   0xD304             BCC.N    ??recordServerEuiAndGoToNextState_6
   \   0000006E   0xE018             B.N      ??recordServerEuiAndGoToNextState_4
   \                     ??recordServerEuiAndGoToNextState_5: (+1)
   \   00000070   0x2005             MOVS     R0,#+5
   \   00000072   0x.... 0x....      BL       continueImageVerification
   \   00000076   0xE014             B.N      ??recordServerEuiAndGoToNextState_4
   \                     ??recordServerEuiAndGoToNextState_6: (+1)
   \   00000078   0x.... 0x....      BL       emberAfOtaStorageDriverPrepareToResumeDownloadCallback
   \   0000007C   0x4605             MOV      R5,R0
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x7060             STRB     R0,[R4, #+1]
   \   00000082   0x2006             MOVS     R0,#+6
   \   00000084   0x.... 0x....      BL       recordUpgradeStatus
   \   00000088   0xB915             CBNZ.N   R5,??recordServerEuiAndGoToNextState_7
   \   0000008A   0x.... 0x....      BL       continueImageDownload
   \   0000008E   0xE008             B.N      ??recordServerEuiAndGoToNextState_4
   \                     ??recordServerEuiAndGoToNextState_7: (+1)
   \   00000090   0x2D04             CMP      R5,#+4
   \   00000092   0xD006             BEQ.N    ??recordServerEuiAndGoToNextState_4
   \   00000094   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000098   0xE003             B.N      ??recordServerEuiAndGoToNextState_4
   \                     ??recordServerEuiAndGoToNextState_3: (+1)
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0x.... 0x....      BL       queryNextImage
    650          }
   \                     ??recordServerEuiAndGoToNextState_4: (+1)
   \   000000A2   0xB005             ADD      SP,SP,#+20
   \   000000A4   0xBD30             POP      {R4,R5,PC}       ;; return
    651          

   \                                 In section .text, align 2, keep-with-next
    652          void emAfOtaClientServiceDiscoveryCallback(const EmberAfServiceDiscoveryResult *result)
    653          {
   \                     emAfOtaClientServiceDiscoveryCallback: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    654            // We only look at the first result.  How multiple OTA servers are handled
    655            // has not been spelled out by the spec yet.
    656            const EmberAfEndpointList* epList =
    657              (const EmberAfEndpointList*)result->responseData;
   \   00000004   0x6881             LDR      R1,[R0, #+8]
    658           
    659            waitingForResponse = FALSE;
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable35_1
    660          
    661            // Since the OTA cluster only uses broadcast discoveries for Match descriptor
    662            // and Unicast discoveries for the IEEE, we can differentiate the request
    663            // type based on the result.
    664          
    665            if (result->status == EMBER_AF_BROADCAST_SERVICE_DISCOVERY_COMPLETE) {
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable35
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x70AA             STRB     R2,[R5, #+2]
   \   00000012   0x7802             LDRB     R2,[R0, #+0]
   \   00000014   0xB9E2             CBNZ.N   R2,??emAfOtaClientServiceDiscoveryCallback_0
    666              if (serverEndpoint == UNDEFINED_ENDPOINT) {
   \   00000016   0x7860             LDRB     R0,[R4, #+1]
   \   00000018   0x28FF             CMP      R0,#+255
   \   0000001A   0xD102             BNE.N    ??emAfOtaClientServiceDiscoveryCallback_1
    667                // We did not find an OTA server yet, so wait a while before trying
    668                // again.  Hopefully one will appear on the network later.
    669                restartServerDiscoveryAfterDelay();
   \   0000001C   0x.... 0x....      BL       restartServerDiscoveryAfterDelay
   \   00000020   0xBD37             POP      {R0-R2,R4,R5,PC}
    670              } else {
    671                euiLookup();
   \                     ??emAfOtaClientServiceDiscoveryCallback_1: (+1)
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0x.... 0x....      BL       recordUpgradeStatus
   \   00000028   0x8860             LDRH     R0,[R4, #+2]
   \   0000002A   0xA900             ADD      R1,SP,#+0
   \   0000002C   0x.... 0x....      BL       emberLookupEui64ByNodeId
   \   00000030   0xB1F8             CBZ.N    R0,??emAfOtaClientServiceDiscoveryCallback_2
   \   00000032   0x8860             LDRH     R0,[R4, #+2]
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable35_3
   \   00000038   0x.... 0x....      BL       emberAfFindIeeeAddress
   \   0000003C   0xB110             CBZ.N    R0,??emAfOtaClientServiceDiscoveryCallback_3
   \   0000003E   0x.... 0x....      BL       euiLookupErrorOccurred
   \   00000042   0xBD37             POP      {R0-R2,R4,R5,PC}
   \                     ??emAfOtaClientServiceDiscoveryCallback_3: (+1)
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0x.... 0x....      BL       recordUpgradeStatus
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x70A8             STRB     R0,[R5, #+2]
   \   0000004E   0xE010             B.N      ??emAfOtaClientServiceDiscoveryCallback_2
    672              }
    673              return;
    674            } else if (result->status
    675                       == EMBER_AF_BROADCAST_SERVICE_DISCOVERY_RESPONSE_RECEIVED) {
   \                     ??emAfOtaClientServiceDiscoveryCallback_0: (+1)
   \   00000050   0x2A01             CMP      R2,#+1
   \   00000052   0xD107             BNE.N    ??emAfOtaClientServiceDiscoveryCallback_4
    676              if (epList->count > 0) {
   \   00000054   0x780A             LDRB     R2,[R1, #+0]
   \   00000056   0xB192             CBZ.N    R2,??emAfOtaClientServiceDiscoveryCallback_5
    677                serverEndpoint = epList->list[0];
   \   00000058   0x6849             LDR      R1,[R1, #+4]
   \   0000005A   0x7809             LDRB     R1,[R1, #+0]
   \   0000005C   0x7061             STRB     R1,[R4, #+1]
    678                serverNodeId = result->matchAddress;
   \   0000005E   0x8880             LDRH     R0,[R0, #+4]
   \   00000060   0x8060             STRH     R0,[R4, #+2]
   \   00000062   0xBD37             POP      {R0-R2,R4,R5,PC}
    679                otaPrintln("Setting OTA Server to 0x%2X", serverNodeId);
    680              }
    681          
    682            } else if (result->status
    683                       == EMBER_AF_UNICAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE) {
   \                     ??emAfOtaClientServiceDiscoveryCallback_4: (+1)
   \   00000064   0x2A03             CMP      R2,#+3
   \   00000066   0xD108             BNE.N    ??emAfOtaClientServiceDiscoveryCallback_6
    684              // Assumed IEEE address request
    685              EmberEUI64 eui64;
    686              MEMMOVE(eui64, result->responseData, EUI64_SIZE);
   \   00000068   0x2208             MOVS     R2,#+8
   \   0000006A   0x6881             LDR      R1,[R0, #+8]
   \   0000006C   0xA800             ADD      R0,SP,#+0
   \   0000006E   0x.... 0x....      BL       halCommonMemMove
    687              recordServerEuiAndGoToNextState(eui64);
   \                     ??emAfOtaClientServiceDiscoveryCallback_2: (+1)
   \   00000072   0xA800             ADD      R0,SP,#+0
   \   00000074   0x.... 0x....      BL       recordServerEuiAndGoToNextState
   \   00000078   0xBD37             POP      {R0-R2,R4,R5,PC}
    688          
    689            } else { // Assume Unicast timeout of IEEE address request
    690              euiLookupErrorOccurred();
   \                     ??emAfOtaClientServiceDiscoveryCallback_6: (+1)
   \   0000007A   0x.... 0x....      BL       euiLookupErrorOccurred
    691            }
    692          }
   \                     ??emAfOtaClientServiceDiscoveryCallback_5: (+1)
   \   0000007E   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    693          

   \                                 In section .text, align 2, keep-with-next
    694          static void startServerDiscovery(void)
    695          {
   \                     startServerDiscovery: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    696            EmberStatus status;
    697            EmberAfProfileId appProfile;
    698          
    699            recordUpgradeStatus(BOOTLOAD_STATE_DISCOVER_SERVER);
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x.... 0x....      BL       recordUpgradeStatus
    700            serverEndpoint = UNDEFINED_ENDPOINT;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable35
   \   0000000C   0x21FF             MOVS     R1,#+255
   \   0000000E   0x7041             STRB     R1,[R0, #+1]
    701            
    702            // Figure out the right app profile ID based on the endpoint descriptor
    703            appProfile = emberAfProfileIdFromIndex( 
    704                           emberAfIndexFromEndpoint(myEndpoint) );
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x.... 0x....      BL       emberAfIndexFromEndpoint
    705          
    706            status = 
    707              emberAfFindDevicesByProfileAndCluster(
    708                EMBER_RX_ON_WHEN_IDLE_BROADCAST_ADDRESS,
    709                appProfile,
    710                ZCL_OTA_BOOTLOAD_CLUSTER_ID,
    711                EMBER_AF_SERVER_CLUSTER_DISCOVERY,
    712                emAfOtaClientServiceDiscoveryCallback);
    713          
    714            if (status != EMBER_SUCCESS) {
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable35_3
   \   0000001A   0x9100             STR      R1,[SP, #+0]
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable35_4
   \   00000022   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   00000026   0x2219             MOVS     R2,#+25
   \   00000028   0x8841             LDRH     R1,[R0, #+2]
   \   0000002A   0xF64F 0x70FD      MOVW     R0,#+65533
   \   0000002E   0x.... 0x....      BL       emberAfFindDevicesByProfileAndCluster
   \   00000032   0x1E40             SUBS     R0,R0,#+1
   \   00000034   0x4180             SBCS     R0,R0,R0
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \   0000003A   0x0FC0             LSRS     R0,R0,#+31
   \   0000003C   0x7088             STRB     R0,[R1, #+2]
    715              otaPrintln("Failed to initiate service discovery.");
    716              waitingForResponse = FALSE;
    717            } else {
    718              waitingForResponse = TRUE;
    719            }
    720          
    721            errors = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7048             STRB     R0,[R1, #+1]
    722            setTimer(EMBER_AF_OTA_SERVER_DISCOVERY_DELAY_MS);
   \   00000042   0xE8BD 0x4002      POP      {R1,LR}
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable35_2  ;; 0x927c0
   \   0000004A   0x....             B.N      setTimer
    723          }
    724          

   \                                 In section .text, align 2, keep-with-next
    725          static void euiLookupErrorOccurred(void)
    726          {
    727            // The timer has expired and we don't know the server's EUI. 
    728            // We treat the server discovery + EUI lookup as a single operation
    729            // and if either fails we delay a long time to allow any potential network
    730            // issues to be resolved.
    731            waitingForResponse = FALSE;
   \                     euiLookupErrorOccurred: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7088             STRB     R0,[R1, #+2]
    732            restartServerDiscoveryAfterDelay();
   \   00000008   0x....             B.N      restartServerDiscoveryAfterDelay
    733            return;
    734          }
    735          
    736          static void euiLookup(void)
    737          {
    738            EmberEUI64 eui64;
    739            EmberStatus status;
    740          
    741            recordUpgradeStatus(BOOTLOAD_STATE_GET_SERVER_EUI);
    742            status = emberLookupEui64ByNodeId(serverNodeId, eui64);
    743          
    744            if (status != EMBER_SUCCESS) { 
    745              // New discovery of the Server's EUI
    746              status = emberAfFindIeeeAddress(serverNodeId,
    747                                              emAfOtaClientServiceDiscoveryCallback);
    748              if (status != EMBER_SUCCESS) {
    749                // Discovery was never initiated.
    750                euiLookupErrorOccurred();
    751                return;
    752              }
    753              recordUpgradeStatus(BOOTLOAD_STATE_GET_SERVER_EUI);
    754              waitingForResponse = TRUE;
    755          
    756            } // Else
    757              // We happen to know the server's EUI without discovery, keep going.
    758          
    759            recordServerEuiAndGoToNextState(eui64);
    760          }
    761          

   \                                 In section .text, align 2, keep-with-next
    762          static void putImageInfoInMessage(void)
    763          {
   \                     putImageInfoInMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    764            emberAfPutInt16uInResp(currentDownloadFile.manufacturerId);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable35_1
   \   00000006   0x8920             LDRH     R0,[R4, #+8]
   \   00000008   0x.... 0x....      BL       emberAfPutInt16uInResp
    765            emberAfPutInt16uInResp(currentDownloadFile.imageTypeId);
   \   0000000C   0x8960             LDRH     R0,[R4, #+10]
   \   0000000E   0x.... 0x....      BL       emberAfPutInt16uInResp
    766            emberAfPutInt32uInResp(currentDownloadFile.firmwareVersion);
   \   00000012   0x68E0             LDR      R0,[R4, #+12]
   \   00000014   0xE8BD 0x4010      POP      {R4,LR}
   \   00000018   0x.... 0x....      B.W      emberAfPutInt32uInResp
    767          }
    768          
    769          static BootloadState determineDownloadFileStatus(void)
    770          {
    771            int32u currentOffset;
    772            EmberAfOtaStorageStatus 
    773              status = emberAfOtaStorageCheckTempDataCallback(&currentOffset, 
    774                                                              &totalImageSize,
    775                                                              &currentDownloadFile);
    776          
    777            if (status == EMBER_AF_OTA_STORAGE_PARTIAL_FILE_FOUND) {
    778              otaPrintFlush();
    779              otaPrintln("Partial file download found, continuing from offset 0x%4X",
    780                         currentOffset);
    781              otaPrintFlush();
    782              updateCurrentOffset(currentOffset);
    783              updateDownloadFileVersion(currentDownloadFile.firmwareVersion);
    784              emAfPrintPercentageSetStartAndEnd(0, totalImageSize);
    785              return BOOTLOAD_STATE_DOWNLOAD;
    786            } else if (status == EMBER_AF_OTA_STORAGE_SUCCESS) {
    787              EmberAfOtaImageId currentVersionInfo;
    788              otaPrintln("Found fully downloaded file in storage (version 0x%4X).", 
    789                         currentDownloadFile.firmwareVersion);
    790              emberAfOtaClientVersionInfoCallback(&currentVersionInfo, NULL);
    791              if (currentVersionInfo.firmwareVersion != currentDownloadFile.firmwareVersion) {
    792                otaPrintln("Found file in storage with different version (0x%4X) than current version (0x%4X)",
    793                           currentDownloadFile.firmwareVersion,
    794                           currentVersionInfo.firmwareVersion);
    795                return BOOTLOAD_STATE_VERIFY_IMAGE;
    796              } else {
    797                otaPrintln("File in storage is same as current running version (0x%4X)",
    798                           currentVersionInfo.firmwareVersion);
    799              }
    800            } else {
    801              otaPrintln("No image found in storage.");    
    802            }
    803          
    804            emberAfAppFlush();
    805          
    806            return BOOTLOAD_STATE_QUERY_NEXT_IMAGE;
    807          }
    808          
    809          static void determineNextState(void)
    810          {
    811            currentBootloadState = determineDownloadFileStatus();
    812          
    813            switch (currentBootloadState) {
    814            case BOOTLOAD_STATE_QUERY_NEXT_IMAGE:
    815              queryNextImage(SEND_QUERY_NOW,
    816                             FALSE);   // query error?
    817              break;
    818            case BOOTLOAD_STATE_DOWNLOAD: 
    819              {
    820                EmberAfOtaStorageStatus status = emberAfOtaStorageDriverPrepareToResumeDownloadCallback();
    821                errors = 0;
    822                recordUpgradeStatus(BOOTLOAD_STATE_DOWNLOAD);
    823                if (status == EMBER_AF_OTA_STORAGE_SUCCESS) {
    824                  continueImageDownload();
    825                } else if (status != EMBER_AF_OTA_STORAGE_OPERATION_IN_PROGRESS) {
    826                  downloadAndVerifyFinish(EMBER_AF_OTA_CLIENT_ABORTED);
    827          
    828                } // For operation-in-progress we fall-through and wait for the callback 
    829                  // later.
    830              }
    831              break;
    832            case BOOTLOAD_STATE_VERIFY_IMAGE:
    833              continueImageVerification(EMBER_AF_IMAGE_UNKNOWN);
    834              break;
    835            case BOOTLOAD_STATE_WAITING_FOR_UPGRADE_MESSAGE:
    836              askServerToRunUpgrade(START_NEW_TIMER);
    837              break;
    838            default:
    839              // Do nothing.  No other states should reach here.
    840              break;
    841            }
    842          }
    843          

   \                                 In section .text, align 2, keep-with-next
    844          static void recordUpgradeStatus(BootloadState state)
    845          {
   \                     recordUpgradeStatus: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    846            int8u upgradeStatus = bootloadStateToExternalState[state];
   \   00000002   0x.... 0x....      ADR.W    R1,bootloadStateToExternalState
   \   00000006   0x5C41             LDRB     R1,[R0, R1]
   \   00000008   0xF88D 0x1008      STRB     R1,[SP, #+8]
    847            if (currentBootloadState != state) {
    848              emberAfCoreFlush();
    849              otaPrintln("Bootload state: %p", 
    850                         bootloadStateNames[state]);
    851              emberAfCoreFlush();
    852            }
    853            currentBootloadState = state;
    854          
    855            emberAfWriteAttribute(myEndpoint,
    856                                  ZCL_OTA_BOOTLOAD_CLUSTER_ID, 
    857                                  ZCL_IMAGE_UPGRADE_STATUS_ATTRIBUTE_ID, 
    858                                  CLUSTER_MASK_CLIENT,
    859                                  (int8u*)&upgradeStatus,
    860                                  ZCL_ENUM8_ATTRIBUTE_TYPE);
   \   0000000C   0x2380             MOVS     R3,#+128
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   \   00000014   0x2206             MOVS     R2,#+6
   \   00000016   0x2030             MOVS     R0,#+48
   \   00000018   0x9001             STR      R0,[SP, #+4]
   \   0000001A   0x2119             MOVS     R1,#+25
   \   0000001C   0xA802             ADD      R0,SP,#+8
   \   0000001E   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000022   0x.... 0x....      BL       emberAfWriteAttribute
    861          }
   \   00000026   0xBD07             POP      {R0-R2,PC}       ;; return
    862          

   \                                 In section .text, align 4, keep-with-next
    863          static EmberAfStatus commandParse(boolean defaultResponse,
    864                                            EmberAfClusterCommand* message)
    865          {
   \                     commandParse: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    866            int8u commandId = (message->buffer[(ZCL_COMMAND_ID_INDEX
    867                                                + (int8u)defaultResponse)]);
   \   00000004   0x68A1             LDR      R1,[R4, #+8]
   \   00000006   0x1841             ADDS     R1,R0,R1
   \   00000008   0x788A             LDRB     R2,[R1, #+2]
    868            int8u index = EMBER_AF_ZCL_OVERHEAD;
    869          
    870            if (commandId > EM_AF_OTA_MAX_COMMAND_ID) {
   \   0000000A   0x2A0A             CMP      R2,#+10
   \   0000000C   0xDB01             BLT.N    ??commandParse_1
    871              otaPrintln("Bad OTA command: 0x%X", commandId);
    872              return EMBER_ZCL_STATUS_INVALID_FIELD;
   \   0000000E   0x2085             MOVS     R0,#+133
   \   00000010   0xBD10             POP      {R4,PC}
    873            }
    874          
    875            if (!defaultResponse && message->bufLen < emAfOtaMinMessageLengths[commandId]) {
   \                     ??commandParse_1: (+1)
   \   00000012   0xB938             CBNZ.N   R0,??commandParse_2
   \   00000014   0x.... 0x....      LDR.W    R3,??DataTable35_5
   \   00000018   0x89A1             LDRH     R1,[R4, #+12]
   \   0000001A   0x5CD3             LDRB     R3,[R2, R3]
   \   0000001C   0x4299             CMP      R1,R3
   \   0000001E   0xD201             BCS.N    ??commandParse_2
    876              otaPrintln("OTA command 0x%X too short (len %d < min %d)",
    877                         commandId,
    878                         message->bufLen,
    879                         emAfOtaMinMessageLengths[commandId]);
    880              return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
   \   00000020   0x2080             MOVS     R0,#+128
   \   00000022   0xBD10             POP      {R4,PC}
    881            }
    882          
    883            if (message->source != serverNodeId) {
   \                     ??commandParse_2: (+1)
   \   00000024   0x.... 0x....      LDR.W    R3,??DataTable35
   \   00000028   0x88E1             LDRH     R1,[R4, #+6]
   \   0000002A   0x885B             LDRH     R3,[R3, #+2]
   \   0000002C   0x4299             CMP      R1,R3
   \   0000002E   0xD001             BEQ.N    ??commandParse_3
    884              otaPrintln("OTA command from unrecognized server 0x%2X.  My OTA server: 0x%2X",
    885                         message->source,
    886                         serverNodeId);
    887              return EMBER_ZCL_STATUS_NOT_AUTHORIZED;
   \   00000030   0x207E             MOVS     R0,#+126
   \   00000032   0xBD10             POP      {R4,PC}
    888            }
    889          
    890            // While not all command validation has taken place at this point, we 
    891            // flag that we are not waiting for a response anymore.  We want to make sure
    892            // that our sleepy can go to sleep if it wants.  The likelihood of an
    893            // invalid command followed by a properly formatted one is extremely low.
    894            // Either the server knows the correct format or it doesn't.
    895            waitingForResponse = FALSE;
   \                     ??commandParse_3: (+1)
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \   00000038   0x2300             MOVS     R3,#+0
   \   0000003A   0x708B             STRB     R3,[R1, #+2]
   \   0000003C   0x780B             LDRB     R3,[R1, #+0]
   \   0000003E   0x1CC1             ADDS     R1,R0,#+3
   \   00000040   0x2A07             CMP      R2,#+7
   \   00000042   0xD82F             BHI.N    ??commandParse_4
   \   00000044   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??commandParse_0:
   \   00000048   0x04 0x10          DC8      0x4,0x10,0x10,0x19
   \              0x10 0x19    
   \   0000004C   0x19 0x19          DC8      0x19,0x19,0x22,0x22
   \              0x22 0x22    
    896          
    897            // NOTE:  In order to support Default Response, we list the CLIENT commands here
    898            // as well in case the server used that to respond.
    899            switch (commandId) {
    900            case ZCL_IMAGE_NOTIFY_COMMAND_ID: {
    901              boolean broadcast = (EMBER_INCOMING_UNICAST != message->type);
   \                     ??commandParse_5: (+1)
   \   00000050   0x7920             LDRB     R0,[R4, #+4]
   \   00000052   0xB100             CBZ.N    R0,??commandParse_6
   \   00000054   0x2001             MOVS     R0,#+1
    902              if (currentBootloadState != BOOTLOAD_STATE_QUERY_NEXT_IMAGE) {
   \                     ??commandParse_6: (+1)
   \   00000056   0x2B05             CMP      R3,#+5
   \   00000058   0xD11A             BNE.N    ??commandParse_7
    903                otaPrintln("Got unexpected %p.  Ignored.",
    904                           "Image notify");
    905                return EMBER_ZCL_STATUS_FAILURE;
    906              }
    907              return imageNotifyParse(broadcast, message->buffer, index, message->bufLen);
   \   0000005A   0x89A3             LDRH     R3,[R4, #+12]
   \   0000005C   0x68A1             LDR      R1,[R4, #+8]
   \   0000005E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000062   0xB2DB             UXTB     R3,R3
   \   00000064   0x2203             MOVS     R2,#+3
   \   00000066   0x....             B.N      imageNotifyParse
    908            }
    909            case ZCL_QUERY_NEXT_IMAGE_RESPONSE_COMMAND_ID: 
    910            case ZCL_QUERY_NEXT_IMAGE_REQUEST_COMMAND_ID: {
    911              if (currentBootloadState != BOOTLOAD_STATE_QUERY_NEXT_IMAGE) {
   \                     ??commandParse_8: (+1)
   \   00000068   0x2B05             CMP      R3,#+5
   \   0000006A   0xD111             BNE.N    ??commandParse_7
    912                otaPrintln("Got unexpected %p.  Ignored.",
    913                           "Query next image response");
    914                return EMBER_ZCL_STATUS_FAILURE;
    915              }
    916              return queryNextImageResponseParse(message->buffer, 
    917                                                 index + defaultResponse,
    918                                                 message->bufLen);
   \   0000006C   0x89A2             LDRH     R2,[R4, #+12]
   \   0000006E   0x68A0             LDR      R0,[R4, #+8]
   \   00000070   0xE8BD 0x4010      POP      {R4,LR}
   \   00000074   0xB2D2             UXTB     R2,R2
   \   00000076   0xB2C9             UXTB     R1,R1
   \   00000078   0x....             B.N      queryNextImageResponseParse
    919            }
    920            case ZCL_IMAGE_PAGE_REQUEST_COMMAND_ID: 
    921            case ZCL_IMAGE_BLOCK_REQUEST_COMMAND_ID:
    922            case ZCL_IMAGE_BLOCK_RESPONSE_COMMAND_ID: {
    923              if (currentBootloadState != BOOTLOAD_STATE_DOWNLOAD) {
   \                     ??commandParse_9: (+1)
   \   0000007A   0x2B06             CMP      R3,#+6
   \   0000007C   0xD108             BNE.N    ??commandParse_7
    924                otaPrintln("Got unexpected %p.  Ignored.",
    925                           "Image block response");
    926                return EMBER_ZCL_STATUS_FAILURE;
    927              }
    928              return imageBlockResponseParse(message->buffer, 
    929                                             index + defaultResponse,
    930                                             message->bufLen);
   \   0000007E   0x89A2             LDRH     R2,[R4, #+12]
   \   00000080   0x68A0             LDR      R0,[R4, #+8]
   \   00000082   0xE8BD 0x4010      POP      {R4,LR}
   \   00000086   0xB2D2             UXTB     R2,R2
   \   00000088   0xB2C9             UXTB     R1,R1
   \   0000008A   0x....             B.N      imageBlockResponseParse
    931            }
    932            case ZCL_UPGRADE_END_RESPONSE_COMMAND_ID:
    933            case ZCL_UPGRADE_END_REQUEST_COMMAND_ID: {
    934              if (currentBootloadState != BOOTLOAD_STATE_WAITING_FOR_UPGRADE_MESSAGE) {
   \                     ??commandParse_10: (+1)
   \   0000008C   0x2B08             CMP      R3,#+8
   \   0000008E   0xD001             BEQ.N    ??commandParse_11
    935                otaPrintln("Got unexpected %p.  Ignored.",
    936                           "Upgrade end response");
    937                return EMBER_ZCL_STATUS_FAILURE;
   \                     ??commandParse_7: (+1)
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xBD10             POP      {R4,PC}
    938              }
    939              return upgradeEndResponseParse((defaultResponse
    940                                              ? message->buffer[index]
    941                                              : EMBER_ZCL_STATUS_SUCCESS),
    942                                             message->buffer, 
    943                                             message->bufLen);
   \                     ??commandParse_11: (+1)
   \   00000094   0x68A1             LDR      R1,[R4, #+8]
   \   00000096   0xB100             CBZ.N    R0,??commandParse_12
   \   00000098   0x78C8             LDRB     R0,[R1, #+3]
   \                     ??commandParse_12: (+1)
   \   0000009A   0x89A2             LDRH     R2,[R4, #+12]
   \   0000009C   0xE8BD 0x4010      POP      {R4,LR}
   \   000000A0   0xB2D2             UXTB     R2,R2
   \   000000A2   0x....             B.N      upgradeEndResponseParse
    944            }
    945            default:
    946              // Fall through. Already printed info about the bad command ID.
    947              break;
    948            }
    949            return EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??commandParse_4: (+1)
   \   000000A4   0x2081             MOVS     R0,#+129
   \   000000A6   0xBD10             POP      {R4,PC}          ;; return
    950          }
    951          

   \                                 In section .text, align 2, keep-with-next
    952          boolean emberAfOtaClientIncomingMessageRawCallback(EmberAfClusterCommand* message)
    953          {
   \                     emberAfOtaClientIncomingMessageRawCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    954            EmberAfStatus zclStatus = commandParse(FALSE,   // default response?
    955                                                   message); 
   \   00000004   0x4621             MOV      R1,R4
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       commandParse
    956            if (zclStatus) {
   \   0000000C   0xB138             CBZ.N    R0,??emberAfOtaClientIncomingMessageRawCallback_0
    957              emberAfOtaBootloadClusterFlush();
    958              emberAfOtaBootloadClusterPrintln("%p: failed parsing OTA cmd 0x%x", 
    959                                               "Error",
    960                                               message->commandId);
    961              if (message->type == EMBER_INCOMING_UNICAST) {
   \   0000000E   0x7921             LDRB     R1,[R4, #+4]
   \   00000010   0xB909             CBNZ.N   R1,??emberAfOtaClientIncomingMessageRawCallback_1
    962                // We don't want to respond to invalid broadcast messages with
    963                // a default response.
    964                return EMBER_ZCL_STATUS_SUCCESS;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD10             POP      {R4,PC}
    965              }
    966              emberAfSendDefaultResponse(message, zclStatus);
   \                     ??emberAfOtaClientIncomingMessageRawCallback_1: (+1)
   \   00000016   0x4601             MOV      R1,R0
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       emberAfSendDefaultResponse
    967            }
    968          
    969            return TRUE;
   \                     ??emberAfOtaClientIncomingMessageRawCallback_0: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    970          }
    971          

   \                                 In section .text, align 2, keep-with-next
    972          void emberAfOtaBootloadClusterClientDefaultResponseCallback(int8u endpoint, 
    973                                                                      int8u commandId, 
    974                                                                      EmberAfStatus status)
    975          {
    976            EmberAfClusterCommand* command = emberAfCurrentCommand();
    977          
    978            if (endpoint != myEndpoint) {
   \                     emberAfOtaBootloadClusterClientDefaultResponseCallback: (+1)
   \   00000000   0x.... 0x....      LDR.W    R3,??DataTable35
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable35_6
   \   00000008   0x781B             LDRB     R3,[R3, #+0]
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x4298             CMP      R0,R3
   \   0000000E   0xD104             BNE.N    ??emberAfOtaBootloadClusterClientDefaultRespons_0
    979              return;
    980            }
    981            if (status == EMBER_ZCL_STATUS_SUCCESS) {
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xBF1C             ITT      NE 
    982              // The only default response we care about is non-success values.
    983              // That will mean the server failed processing for some reason,
    984              // or wants to abort.  Successful responses will send a non-default
    985              // response message.
    986              return;
    987            }
    988            otaPrintln("OTA Default response to command ID 0x%X, status 0x%X",
    989                       commandId,
    990                       status);
    991          
    992            commandParse(TRUE, // default response?
    993                         command);
   \   00000014   0x2001             MOVNE    R0,#+1
   \   00000016   0x.... 0x....      BNE.W    commandParse
    994          }
   \                     ??emberAfOtaBootloadClusterClientDefaultRespons_0: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    995          
    996          // The buffer must point to the start of the image notify command,
    997          // not the start of the ZCL frame.  It is assumed that the length
    998          // of the buffer is minimum for image notify command.

   \                                 In section .text, align 2, keep-with-next
    999          static EmberAfStatus imageNotifyParse(boolean broadcast, 
   1000                                                int8u* buffer, 
   1001                                                int8u index, 
   1002                                                int8u length)
   1003          {
   \                     imageNotifyParse: (+1)
   \   00000000   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \   00000004   0x460D             MOV      R5,R1
   1004            int16u manufacturerId;
   1005            int16u imageTypeId;
   1006            EmberAfOtaImageId myId;
   1007            int8u payloadType = emberAfGetInt8u(buffer, index, length);
   1008            int8u queryJitter = emberAfGetInt8u(buffer, index + 1, length);
   \   00000006   0x1951             ADDS     R1,R2,R5
   \   00000008   0x5D57             LDRB     R7,[R2, R5]
   \   0000000A   0x784C             LDRB     R4,[R1, #+1]
   1009            index += 2;
   \   0000000C   0x1C96             ADDS     R6,R2,#+2
   \   0000000E   0x4698             MOV      R8,R3
   1010          
   1011            if (!broadcast) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD03B             BEQ.N    ??imageNotifyParse_0
   1012              // Spec says to always respond to unicasts regardless of the parameters.
   1013              otaPrintln("%p unicast, querying",
   1014                         "Image notify command");
   1015              goto sendQuery;
   1016            }
   1017          
   1018            emberAfOtaClientVersionInfoCallback(&myId, NULL);
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xA800             ADD      R0,SP,#+0
   \   00000018   0x.... 0x....      BL       emberAfOtaClientVersionInfoCallback
   1019          
   1020            // We assume that if the message is broadcast then our ZCL
   1021            // code will NOT send the default response.
   1022              
   1023            if (payloadType > IMAGE_NOTIFY_LAST_VALID_TYPE) {
   \   0000001C   0x2F04             CMP      R7,#+4
   \   0000001E   0xDA31             BGE.N    ??imageNotifyParse_1
   1024              otaPrintln("%p %p payload type 0x%X", 
   1025                         "Invalid",
   1026                         "Image notify command",
   1027                         payloadType);
   1028              return EMBER_ZCL_STATUS_SUCCESS;
   1029            }
   1030            if (queryJitter < 1 || queryJitter > 100) {
   \   00000020   0xB384             CBZ.N    R4,??imageNotifyParse_1
   \   00000022   0x2C65             CMP      R4,#+101
   \   00000024   0xDA2E             BGE.N    ??imageNotifyParse_1
   1031              otaPrintln("%p %p: out of range jitter %d", 
   1032                         "Invalid",
   1033                         "Image notify command",
   1034                         queryJitter);
   1035              return EMBER_ZCL_STATUS_SUCCESS;
   1036            }
   1037            if (length != imageNotifyPayloadLengths[payloadType]) {
   \   00000026   0x.... 0x....      ADR.W    R0,imageNotifyPayloadLengths
   \   0000002A   0x5C38             LDRB     R0,[R7, R0]
   \   0000002C   0x4580             CMP      R8,R0
   \   0000002E   0xD129             BNE.N    ??imageNotifyParse_1
   1038              otaPrintln("%p %p: payload length doesn't match type 0x%X (%d < %d)",
   1039                         "Invalid",
   1040                         "Image notify command",
   1041                         payloadType,
   1042                         length,
   1043                         imageNotifyPayloadLengths[payloadType]);
   1044              // Although this truly is an error, we don't send a response because it could
   1045              // be a broadcast.
   1046              return EMBER_ZCL_STATUS_SUCCESS;
   1047            }
   1048            
   1049            if (payloadType >= IMAGE_NOTIFY_MANUFACTURER_ONLY_TYPE) {
   \   00000030   0xB137             CBZ.N    R7,??imageNotifyParse_2
   1050              manufacturerId = emberAfGetInt16u(buffer, index, length);
   \   00000032   0x.... 0x....      BL       ?Subroutine3
   1051              index += 2;
   1052              if (manufacturerId != myId.manufacturerId) {
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000036   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   0000003A   0x1CB6             ADDS     R6,R6,#+2
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD121             BNE.N    ??imageNotifyParse_1
   1053                otaPrintln("%p %p due to non-matching manufacturer ID",
   1054                           "Ignoring",
   1055                           "Image notify command");
   1056                return EMBER_ZCL_STATUS_SUCCESS;
   1057              }
   1058            }
   1059          
   1060            if (payloadType >= IMAGE_NOTIFY_MFG_AND_IMAGE_TYPE) {
   \                     ??imageNotifyParse_2: (+1)
   \   00000040   0x2F02             CMP      R7,#+2
   \   00000042   0xDB06             BLT.N    ??imageNotifyParse_3
   1061              imageTypeId = emberAfGetInt16u(buffer, index, length);
   \   00000044   0x.... 0x....      BL       ?Subroutine3
   1062              index += 2;
   1063              if (imageTypeId != myId.imageTypeId) {
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000048   0xF8BD 0x1002      LDRH     R1,[SP, #+2]
   \   0000004C   0x1CB6             ADDS     R6,R6,#+2
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xD118             BNE.N    ??imageNotifyParse_1
   1064                otaPrintln("%p %p due to non-matching image type ID",
   1065                           "Ignoring",
   1066                           "Image notify command");
   1067                return EMBER_ZCL_STATUS_SUCCESS;
   1068              }
   1069            }
   1070          
   1071            if (payloadType >= IMAGE_NOTIFY_FULL_VERSION_TYPE) {
   \                     ??imageNotifyParse_3: (+1)
   \   00000052   0x2F03             CMP      R7,#+3
   \   00000054   0xDB07             BLT.N    ??imageNotifyParse_4
   1072              // Could add some additional checking about the minimum allowed version
   1073              // number, but it can still be caught after the download.
   1074              int32u version = emberAfGetInt32u(buffer, index, length);
   \   00000056   0x4642             MOV      R2,R8
   \   00000058   0xB2F1             UXTB     R1,R6
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0x.... 0x....      BL       emberAfGetInt32u
   1075              index += 4;
   1076              if (version == myId.firmwareVersion) {
   \   00000060   0x9901             LDR      R1,[SP, #+4]
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD00E             BEQ.N    ??imageNotifyParse_1
   1077                // Spec. says that if the firmware version matches, we should ignore.
   1078                // A matching version number would be a re-install, which can only
   1079                // be done via image notify by a unicast.  The server can force
   1080                // a mass upgrade or downgrade by sending out a different version
   1081                // than what devices have.
   1082                otaPrintln("%p %p due to matching firmware version",
   1083                           "Ignoring",
   1084                           "Image notify command");
   1085                return EMBER_ZCL_STATUS_SUCCESS;
   1086              }
   1087            }
   1088          
   1089            // Check QueryJitter value.  For QueryJitter value less than a 'must response'
   1090            // value (value of 100), we need to introduce jitter in our reply by picking
   1091            // a random number between 1 and 100.  We only send reply if the value picked
   1092            // is less than or equal to the QueryJitter value.
   1093            if (queryJitter < 100) {
   \                     ??imageNotifyParse_4: (+1)
   \   00000066   0x2C64             CMP      R4,#+100
   \   00000068   0xDA10             BGE.N    ??imageNotifyParse_0
   1094              int8u random = (((int8u)halCommonGetRandom())%100) + 1;
   \   0000006A   0x.... 0x....      BL       halCommonGetRandom
   \   0000006E   0xB2C0             UXTB     R0,R0
   1095              if(random > queryJitter) {
   \   00000070   0x2164             MOVS     R1,#+100
   \   00000072   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   00000076   0x2264             MOVS     R2,#+100
   \   00000078   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
   \   0000007E   0xB2C0             UXTB     R0,R0
   \   00000080   0x4284             CMP      R4,R0
   \   00000082   0xD203             BCS.N    ??imageNotifyParse_0
   1096                otaPrintln("%p %p, Rx'd Jitter (0x%x), Picked Jitter (0x%x)",
   1097                           "Ignoring",
   1098                           "Image notify command",
   1099                           queryJitter, 
   1100                           random);
   1101                return EMBER_ZCL_STATUS_SUCCESS;
   \                     ??imageNotifyParse_1: (+1)
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xB004             ADD      SP,SP,#+16
   \   00000088   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1102              }
   1103            }
   1104          
   1105           sendQuery:
   1106            // By saying "timeout reached" we want to indicate that a new query should kick off
   1107            // immediately.
   1108            queryNextImage(SEND_QUERY_NOW,
   1109                           FALSE);  // query error occurred?
   \                     ??imageNotifyParse_0: (+1)
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x.... 0x....      BL       queryNextImage
   \   00000094   0xE7F6             B.N      ??imageNotifyParse_1
   1110            return EMBER_ZCL_STATUS_SUCCESS;
   1111          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0xB2F6             UXTB     R6,R6
   \   00000002   0x4642             MOV      R2,R8
   \   00000004   0x4631             MOV      R1,R6
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0x.... 0x....      B.W      emberAfGetInt16u
   1112          
   1113          static void startDownload(int32u newVersion)
   1114          {
   1115            EmberAfOtaStorageStatus status;
   1116            otaPrintln("Starting download, Version 0x%4X",
   1117                       newVersion);
   1118            emAfPrintPercentageSetStartAndEnd(0, totalImageSize);
   1119            updateDownloadFileVersion(newVersion);
   1120            updateCurrentOffset(0);
   1121            updateMinBlockRequestPeriodAttribute(0);
   1122          
   1123            recordUpgradeStatus(BOOTLOAD_STATE_DOWNLOAD);
   1124          
   1125            errors = 0;
   1126          
   1127            status = emberAfOtaStorageClearTempDataCallback();
   1128          
   1129            if (status == EMBER_AF_OTA_STORAGE_SUCCESS) {
   1130          
   1131              // For the "OTA Storage Simple" plugin, there is only one image.
   1132              // A call to clear the temp data (above) will also wipe out a fully
   1133              // downloaded image.  So we don't actually have to call 
   1134              // emberAfOtaStorageDeleteImageCallback() as well.  We only worry
   1135              // about a result of EMBER_AF_OPERATION_IN_PROGRESS returned from the first
   1136              // delete.
   1137          
   1138              // For the "OTA POSIX Filesystem" plugin there may be multiple
   1139              // images, so we may have to delete the temp data AND another image
   1140              // on disk.  However we assume that delete operations are extremely
   1141              // fast and thus won't return EMBER_AF_OPERATION_IN_PROGRESS.
   1142          
   1143              EmberAfOtaImageId oldImageId = emberAfOtaStorageSearchCallback(currentDownloadFile.manufacturerId,
   1144                                                                             currentDownloadFile.imageTypeId,
   1145                                                                             (hardwareVersion == 0xFFFF
   1146                                                                              ? NULL
   1147                                                                              : &hardwareVersion));
   1148          
   1149              if (emberAfIsOtaImageIdValid(&oldImageId)) { 
   1150                // Wipe out any existing file matching the same values as the one we 
   1151                // are going to download.
   1152          
   1153                emberAfOtaStorageDeleteImageCallback(&oldImageId);
   1154              }
   1155              continueImageDownload();
   1156          
   1157            } else if (status == EMBER_AF_OTA_STORAGE_OPERATION_IN_PROGRESS) {
   1158              // Disable the timer since we are waiting for the erase event to complete
   1159              // and execute our callback, not the timer to expire.
   1160              emberAfDeactivateClientTick(myEndpoint, ZCL_OTA_BOOTLOAD_CLUSTER_ID);
   1161          
   1162            } else {
   1163              otaPrintln("Error: Failed to erase old temp data.");
   1164              downloadAndVerifyFinish(EMBER_AF_OTA_CLIENT_ABORTED);
   1165            }
   1166          }
   1167          
   1168          // We expect that the minimum length for this command has already been checked.

   \                                 In section .text, align 2, keep-with-next
   1169          static EmberAfStatus queryNextImageResponseParse(int8u* buffer, 
   1170                                                           int8u index, 
   1171                                                           int8u length)
   1172          {
   \                     queryNextImageResponseParse: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB08C             SUB      SP,SP,#+48
   \   00000006   0x4615             MOV      R5,R2
   1173            int8u status;
   1174            EmberAfStatus zclStatus;
   1175            EmberAfOtaImageId imageId;
   1176            boolean isError = FALSE;
   1177          
   1178            status = emberAfGetInt8u(buffer, index, length);
   \   00000008   0x5D0A             LDRB     R2,[R1, R4]
   \   0000000A   0x2000             MOVS     R0,#+0
   1179            index++;
   \   0000000C   0x1C4E             ADDS     R6,R1,#+1
   1180            
   1181            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \   0000000E   0xB13A             CBZ.N    R2,??queryNextImageResponseParse_0
   1182              otaPrintln("%p returned 0x%X.  No new image to download.", 
   1183                         "Query next image response",
   1184                         status);
   1185              zclStatus = EMBER_ZCL_STATUS_SUCCESS;
   \   00000010   0x2400             MOVS     R4,#+0
   1186              goto queryNextImageResponseDone;
   1187            }
   1188            if (length < QUERY_NEXT_IMAGE_SUCCESS_RESPONSE_MIN_LENGTH) {
   1189              otaPrintln("%p too short (%d < %d)",
   1190                         "Query next image response",
   1191                         length,
   1192                         QUERY_NEXT_IMAGE_SUCCESS_RESPONSE_MIN_LENGTH);
   1193              zclStatus = EMBER_ZCL_STATUS_MALFORMED_COMMAND;
   1194              isError = TRUE;
   1195              goto queryNextImageResponseDone;
   1196            }
   1197            otaPrintln("%p: New image is available for download.",
   1198                       "Query next image response");
   1199            
   1200            index += emAfOtaParseImageIdFromMessage(&imageId,
   1201                                                    &(buffer[index]),
   1202                                                    length - index);
   1203            totalImageSize = emberAfGetInt32u(buffer, index, length);
   1204          
   1205            if (imageId.manufacturerId != currentDownloadFile.manufacturerId
   1206                || imageId.imageTypeId != currentDownloadFile.imageTypeId
   1207                || totalImageSize == 0) {
   1208              otaPrintln("%p is not using my image info.",
   1209                         "Query next image response");
   1210              isError = TRUE;
   1211              zclStatus = EMBER_ZCL_STATUS_INVALID_FIELD;
   1212              goto queryNextImageResponseDone;
   1213          
   1214            } else if (totalImageSize > emberAfOtaStorageDriverMaxDownloadSizeCallback()) {
   1215              otaPrintln("ERROR: Next Image is too big to store (0x%4X > 0x%4X)",
   1216                         totalImageSize,
   1217                         emberAfOtaStorageDriverMaxDownloadSizeCallback());
   1218              isError = TRUE;
   1219              zclStatus = EMBER_ZCL_STATUS_INSUFFICIENT_SPACE;
   1220              goto queryNextImageResponseDone;
   1221            } else {
   1222              startDownload(imageId.firmwareVersion);
   1223              return EMBER_ZCL_STATUS_SUCCESS;
   1224            }
   1225          
   1226           queryNextImageResponseDone:
   1227            queryNextImage(DELAY_BEFORE_SEND_QUERY,
   1228                           isError);
   \                     ??queryNextImageResponseParse_1: (+1)
   \   00000012   0x4601             MOV      R1,R0
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       queryNextImage
   1229            return zclStatus;
   \   0000001A   0x4620             MOV      R0,R4
   \                     ??queryNextImageResponseParse_2: (+1)
   \   0000001C   0xB00C             ADD      SP,SP,#+48
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??queryNextImageResponseParse_0: (+1)
   \   00000020   0x2D10             CMP      R5,#+16
   \   00000022   0xDA02             BGE.N    ??queryNextImageResponseParse_3
   \   00000024   0x2480             MOVS     R4,#+128
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE7F3             B.N      ??queryNextImageResponseParse_1
   \                     ??queryNextImageResponseParse_3: (+1)
   \   0000002A   0x1BAA             SUBS     R2,R5,R6
   \   0000002C   0xB2F6             UXTB     R6,R6
   \   0000002E   0xB2D2             UXTB     R2,R2
   \   00000030   0x1931             ADDS     R1,R6,R4
   \   00000032   0xA804             ADD      R0,SP,#+16
   \   00000034   0x.... 0x....      BL       emAfOtaParseImageIdFromMessage
   \   00000038   0x1981             ADDS     R1,R0,R6
   \   0000003A   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_16: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R4,??DataTable35_1
   \   00000042   0xF8BD 0x1010      LDRH     R1,[SP, #+16]
   \   00000046   0x8922             LDRH     R2,[R4, #+8]
   \   00000048   0x61E0             STR      R0,[R4, #+28]
   \   0000004A   0x4291             CMP      R1,R2
   \   0000004C   0xBF02             ITTT     EQ 
   \   0000004E   0xF8BD 0x1012      LDRHEQ   R1,[SP, #+18]
   \   00000052   0x8962             LDRHEQ   R2,[R4, #+10]
   \   00000054   0x4291             CMPEQ    R1,R2
   \   00000056   0xD100             BNE.N    ??queryNextImageResponseParse_4
   \   00000058   0xB910             CBNZ.N   R0,??queryNextImageResponseParse_5
   \                     ??queryNextImageResponseParse_4: (+1)
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x2485             MOVS     R4,#+133
   \   0000005E   0xE7D8             B.N      ??queryNextImageResponseParse_1
   \                     ??queryNextImageResponseParse_5: (+1)
   \   00000060   0x.... 0x....      BL       emberAfOtaStorageDriverMaxDownloadSizeCallback
   \   00000064   0x69E1             LDR      R1,[R4, #+28]
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xD202             BCS.N    ??queryNextImageResponseParse_6
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x2489             MOVS     R4,#+137
   \   0000006E   0xE7D0             B.N      ??queryNextImageResponseParse_1
   \                     ??queryNextImageResponseParse_6: (+1)
   \   00000070   0x9D05             LDR      R5,[SP, #+20]
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x.... 0x....      BL       emAfPrintPercentageSetStartAndEnd
   \   00000078   0x4628             MOV      R0,R5
   \   0000007A   0x.... 0x....      BL       updateDownloadFileVersion
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x.... 0x....      BL       updateCurrentOffset
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x8360             STRH     R0,[R4, #+26]
   \   00000088   0x2006             MOVS     R0,#+6
   \   0000008A   0x.... 0x....      BL       recordUpgradeStatus
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x7060             STRB     R0,[R4, #+1]
   \   00000092   0x.... 0x....      BL       emberAfOtaStorageClearTempDataCallback
   \   00000096   0xB9D8             CBNZ.N   R0,??queryNextImageResponseParse_7
   \   00000098   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000009C   0x8B20             LDRH     R0,[R4, #+24]
   \   0000009E   0x4288             CMP      R0,R1
   \   000000A0   0xBF0C             ITE      EQ 
   \   000000A2   0x2300             MOVEQ    R3,#+0
   \   000000A4   0xF104 0x0318      ADDNE    R3,R4,#+24
   \   000000A8   0x8962             LDRH     R2,[R4, #+10]
   \   000000AA   0x8921             LDRH     R1,[R4, #+8]
   \   000000AC   0xA808             ADD      R0,SP,#+32
   \   000000AE   0x.... 0x....      BL       emberAfOtaStorageSearchCallback
   \   000000B2   0xA800             ADD      R0,SP,#+0
   \   000000B4   0xA908             ADD      R1,SP,#+32
   \   000000B6   0x2210             MOVS     R2,#+16
   \   000000B8   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000BC   0xA800             ADD      R0,SP,#+0
   \   000000BE   0x.... 0x....      BL       emberAfIsOtaImageIdValid
   \   000000C2   0xB110             CBZ.N    R0,??queryNextImageResponseParse_8
   \   000000C4   0xA800             ADD      R0,SP,#+0
   \   000000C6   0x.... 0x....      BL       emberAfOtaStorageDeleteImageCallback
   \                     ??queryNextImageResponseParse_8: (+1)
   \   000000CA   0x.... 0x....      BL       continueImageDownload
   \   000000CE   0xE009             B.N      ??CrossCallReturnLabel_9
   \                     ??queryNextImageResponseParse_7: (+1)
   \   000000D0   0x2804             CMP      R0,#+4
   \   000000D2   0xD105             BNE.N    ??queryNextImageResponseParse_9
   \   000000D4   0x.... 0x....      BL       ??Subroutine1_0
   \                     ??CrossCallReturnLabel_7: (+1)
   \   000000D8   0x2119             MOVS     R1,#+25
   \   000000DA   0x.... 0x....      BL       emberAfDeactivateClientTick
   \   000000DE   0xE001             B.N      ??CrossCallReturnLabel_9
   \                     ??queryNextImageResponseParse_9: (+1)
   \   000000E0   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_9: (+1)
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0xE799             B.N      ??queryNextImageResponseParse_2
   1230          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x462A             MOV      R2,R5
   \   00000002   0xB2C9             UXTB     R1,R1
   \                     ??Subroutine4_0: (+1)
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      B.W      emberAfGetInt32u
   1231          

   \                                 In section .text, align 2, keep-with-next
   1232          static void sendMessage(int8u cmdId, int8u upgradeEndStatus, int32u timer)
   1233          {
   \                     sendMessage: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   1234            int8u fieldControl = 0;
   1235            EmberAfProfileId appProfile;
   1236          
   1237            // Figure out the right app profile ID based on the endpoint descriptor
   1238            appProfile = emberAfProfileIdFromIndex(emberAfIndexFromEndpoint(myEndpoint));
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable35
   \   00000008   0x4607             MOV      R7,R0
   \   0000000A   0x7828             LDRB     R0,[R5, #+0]
   \   0000000C   0x4688             MOV      R8,R1
   \   0000000E   0x4692             MOV      R10,R2
   \   00000010   0xF04F 0x0900      MOV      R9,#+0
   \   00000014   0x.... 0x....      BL       emberAfIndexFromEndpoint
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable35_4
   1239          
   1240            // Basic ZCL header information
   1241            appResponseLength = 0;
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable35_7
   1242            emberAfResponseApsFrame.profileId = appProfile;
   \   00000020   0x.... 0x....      LDR.W    R6,??DataTable35_8
   \   00000024   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   00000028   0x8840             LDRH     R0,[R0, #+2]
   \   0000002A   0x8030             STRH     R0,[R6, #+0]
   \   0000002C   0xF8A2 0x9000      STRH     R9,[R2, #+0]
   1243            emberAfResponseApsFrame.sourceEndpoint = myEndpoint;
   \   00000030   0x7828             LDRB     R0,[R5, #+0]
   \   00000032   0x7130             STRB     R0,[R6, #+4]
   1244            emberAfPutInt8uInResp(ZCL_CLUSTER_SPECIFIC_COMMAND
   1245                                  | ZCL_FRAME_CONTROL_CLIENT_TO_SERVER);
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x.... 0x....      BL       emberAfPutInt8uInResp
   1246            emberAfPutInt8uInResp(emberAfNextSequence());
   \   0000003A   0x.... 0x....      BL       emberAfNextSequence
   \   0000003E   0x.... 0x....      BL       emberAfPutInt8uInResp
   1247            emberAfPutInt8uInResp(cmdId);
   \   00000042   0x4638             MOV      R0,R7
   \   00000044   0x.... 0x....      BL       emberAfPutInt8uInResp
   1248            waitingForResponse = TRUE;
   \   00000048   0x.... 0x....      LDR.W    R4,??DataTable35_1
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x70A0             STRB     R0,[R4, #+2]
   1249            switch(cmdId) {
   \   00000050   0x2F01             CMP      R7,#+1
   \   00000052   0xD008             BEQ.N    ??sendMessage_0
   \   00000054   0x2F03             CMP      R7,#+3
   \   00000056   0xBF18             IT       NE 
   \   00000058   0x2F04             CMPNE    R7,#+4
   \   0000005A   0xD028             BEQ.N    ??sendMessage_1
   \   0000005C   0x2F06             CMP      R7,#+6
   \   0000005E   0xD03E             BEQ.N    ??sendMessage_2
   \   00000060   0x2F08             CMP      R7,#+8
   \   00000062   0xD047             BEQ.N    ??sendMessage_3
   \   00000064   0xE021             B.N      ??sendMessage_4
   1250              case ZCL_QUERY_NEXT_IMAGE_REQUEST_COMMAND_ID: {
   1251                if (hardwareVersion != EMBER_AF_INVALID_HARDWARE_VERSION) {
   \                     ??sendMessage_0: (+1)
   \   00000066   0x8B20             LDRH     R0,[R4, #+24]
   \   00000068   0xF64F 0x77FF      MOVW     R7,#+65535
   \   0000006C   0x42B8             CMP      R0,R7
   \   0000006E   0xBF18             IT       NE 
   1252                  fieldControl |= OTA_HW_VERSION_BIT_MASK;
   \   00000070   0xF04F 0x0901      MOVNE    R9,#+1
   1253                }
   1254                emberAfPutInt8uInResp(fieldControl);
   \   00000074   0x4648             MOV      R0,R9
   \   00000076   0x.... 0x....      BL       emberAfPutInt8uInResp
   1255                putImageInfoInMessage();
   \   0000007A   0x.... 0x....      BL       putImageInfoInMessage
   1256                if (hardwareVersion != EMBER_AF_INVALID_HARDWARE_VERSION) {
   \   0000007E   0x8B20             LDRH     R0,[R4, #+24]
   \   00000080   0x42B8             CMP      R0,R7
   \   00000082   0xD001             BEQ.N    ??sendMessage_5
   1257                  emberAfPutInt16uInResp(hardwareVersion);
   \                     ??sendMessage_6: (+1)
   \   00000084   0x.... 0x....      BL       emberAfPutInt16uInResp
   1258                }
   1259              }
   1260              break;
   1261          
   1262              case ZCL_IMAGE_BLOCK_REQUEST_COMMAND_ID:
   1263              case ZCL_IMAGE_PAGE_REQUEST_COMMAND_ID: 
   1264          #if defined(ZCL_USING_OTA_BOOTLOAD_CLUSTER_MINIMUM_BLOCK_REQUEST_PERIOD_ATTRIBUTE)
   1265              if(cmdId == ZCL_IMAGE_BLOCK_REQUEST_COMMAND_ID){
   1266                fieldControl |= OTA_MINIUM_BLOCK_REQUEST_PERIOD_ATTRIBUTE_MASK;
   1267              }
   1268          #endif
   1269                emberAfPutInt8uInResp(fieldControl);
   1270                putImageInfoInMessage();
   1271                emberAfPutInt32uInResp(getCurrentOffset());
   1272                emberAfPutInt8uInResp(usePageRequest
   1273                                      ? EM_AF_PAGE_REQUEST_BLOCK_SIZE
   1274                                      : MAX_CLIENT_DATA_SIZE);
   1275          
   1276                if (cmdId == ZCL_IMAGE_PAGE_REQUEST_COMMAND_ID) {
   1277                  emberAfPutInt16uInResp(EMBER_AF_PLUGIN_OTA_CLIENT_PAGE_REQUEST_SIZE);        
   1278                  emberAfPutInt16uInResp(EMBER_AF_OTA_CLIENT_PAGE_REQUEST_SPACING_MS);
   1279                } else {
   1280          #if defined(ZCL_USING_OTA_BOOTLOAD_CLUSTER_MINIMUM_BLOCK_REQUEST_PERIOD_ATTRIBUTE)
   1281                  emberAfPutInt16uInResp(minBlockRequestPeriodMs);
   1282          #endif
   1283                }
   1284                break;
   1285          
   1286              case ZCL_UPGRADE_END_REQUEST_COMMAND_ID:
   1287                otaPrintln("Sending Upgrade End request.");
   1288                emberAfCoreFlush();
   1289                emberAfPutInt8uInResp(upgradeEndStatus);
   1290                putImageInfoInMessage();
   1291                if (upgradeEndStatus != 0) {
   1292                  waitingForResponse = FALSE;
   1293                }
   1294                break;
   1295          
   1296              case ZCL_QUERY_SPECIFIC_FILE_REQUEST_COMMAND_ID: {
   1297                EmberEUI64 myEui64;
   1298                emberAfGetEui64(myEui64);
   1299                emberAfPutBlockInResp(myEui64, EUI64_SIZE);
   1300                putImageInfoInMessage();
   1301                emberAfPutInt16uInResp(ZIGBEE_PRO_STACK_VERSION);
   1302                }
   1303                break;
   1304          
   1305              default:
   1306                otaPrintln("%p: invalid cmdId 0x%x", "Error", cmdId);
   1307                return;
   1308            } //end switch statement
   1309          
   1310            emberAfResponseApsFrame.clusterId = ZCL_OTA_BOOTLOAD_CLUSTER_ID;
   \                     ??sendMessage_5: (+1)
   \   00000088   0x2019             MOVS     R0,#+25
   \   0000008A   0x8070             STRH     R0,[R6, #+2]
   1311            emberAfResponseApsFrame.sourceEndpoint = myEndpoint;
   \   0000008C   0x7828             LDRB     R0,[R5, #+0]
   1312            emberAfResponseApsFrame.destinationEndpoint = serverEndpoint;
   1313            emberAfResponseApsFrame.options |= EMBER_APS_OPTION_RETRY;
   1314            {
   1315              EmberStatus status = emberAfSendCommandUnicast(EMBER_OUTGOING_DIRECT, serverNodeId);
   \   0000008E   0x8869             LDRH     R1,[R5, #+2]
   \   00000090   0x7130             STRB     R0,[R6, #+4]
   \   00000092   0x7868             LDRB     R0,[R5, #+1]
   \   00000094   0x7170             STRB     R0,[R6, #+5]
   \   00000096   0x88F0             LDRH     R0,[R6, #+6]
   \   00000098   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000009C   0x80F0             STRH     R0,[R6, #+6]
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x.... 0x....      BL       emberAfSendCommandUnicast
   1316              if (status != EMBER_SUCCESS) {
   1317                otaPrintln("Error:  Failed to send OTA command 0x%X, status: 0x%X", 
   1318                           cmdId, status);
   1319              }
   1320            }
   1321            setTimer(timer);
   \   000000A4   0x4650             MOV      R0,R10
   \   000000A6   0x.... 0x....      BL       setTimer
   1322          }
   \                     ??sendMessage_4: (+1)
   \   000000AA   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
   \                     ??sendMessage_1: (+1)
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x.... 0x....      BL       emberAfPutInt8uInResp
   \   000000B4   0x.... 0x....      BL       putImageInfoInMessage
   \   000000B8   0x.... 0x....      BL       getCurrentOffset
   \   000000BC   0x.... 0x....      BL       emberAfPutInt32uInResp
   \   000000C0   0x78E0             LDRB     R0,[R4, #+3]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xBF14             ITE      NE 
   \   000000C6   0x2020             MOVNE    R0,#+32
   \   000000C8   0x203F             MOVEQ    R0,#+63
   \   000000CA   0x.... 0x....      BL       emberAfPutInt8uInResp
   \   000000CE   0x2F04             CMP      R7,#+4
   \   000000D0   0xD1DA             BNE.N    ??sendMessage_5
   \   000000D2   0xF44F 0x6080      MOV      R0,#+1024
   \   000000D6   0x.... 0x....      BL       emberAfPutInt16uInResp
   \   000000DA   0x2032             MOVS     R0,#+50
   \   000000DC   0xE7D2             B.N      ??sendMessage_6
   \                     ??sendMessage_2: (+1)
   \   000000DE   0x4640             MOV      R0,R8
   \   000000E0   0x.... 0x....      BL       emberAfPutInt8uInResp
   \   000000E4   0x.... 0x....      BL       putImageInfoInMessage
   \   000000E8   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000EC   0xD0CC             BEQ.N    ??sendMessage_5
   \   000000EE   0xF884 0x9002      STRB     R9,[R4, #+2]
   \   000000F2   0xE7C9             B.N      ??sendMessage_5
   \                     ??sendMessage_3: (+1)
   \   000000F4   0xA800             ADD      R0,SP,#+0
   \   000000F6   0x.... 0x....      BL       emberAfGetEui64
   \   000000FA   0x2108             MOVS     R1,#+8
   \   000000FC   0xA800             ADD      R0,SP,#+0
   \   000000FE   0x.... 0x....      BL       emberAfPutBlockInResp
   \   00000102   0x.... 0x....      BL       putImageInfoInMessage
   \   00000106   0x2002             MOVS     R0,#+2
   \   00000108   0xE7BC             B.N      ??sendMessage_6
   1323          

   \                                 In section .text, align 2, keep-with-next
   1324          static void queryNextImage(SendNextQueryState sendQuery, 
   1325                                     boolean queryErrorOccurred)
   1326          {
   \                     queryNextImage: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1327            recordUpgradeStatus(BOOTLOAD_STATE_QUERY_NEXT_IMAGE);
   \   00000006   0x2005             MOVS     R0,#+5
   \   00000008   0x.... 0x....      BL       recordUpgradeStatus
   1328          
   1329            if (serverNodeId == EMBER_UNKNOWN_NODE_ID) {
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable35
   \   00000010   0x8840             LDRH     R0,[R0, #+2]
   \   00000012   0xF64F 0x71FD      MOVW     R1,#+65533
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD008             BEQ.N    ??queryNextImage_0
   1330              otaPrintln("Server unknown, falling back to discovery.");
   1331              restartServerDiscoveryAfterDelay();
   1332              return;
   1333            }
   1334          
   1335            if (queryErrorOccurred) {
   \   0000001A   0x.... 0x....      LDR.W    R6,??DataTable35_1
   \   0000001E   0xB145             CBZ.N    R5,??queryNextImage_1
   1336              errors++;
   \   00000020   0x7870             LDRB     R0,[R6, #+1]
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0x7070             STRB     R0,[R6, #+1]
   1337              if (errors >= EMBER_AF_PLUGIN_OTA_CLIENT_QUERY_ERROR_THRESHOLD) {
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0x280A             CMP      R0,#+10
   \   0000002A   0xDB02             BLT.N    ??queryNextImage_1
   1338                otaPrintln("Maximum query errors hit (%d), starting search for new OTA server.\n",
   1339                           EMBER_AF_PLUGIN_OTA_CLIENT_QUERY_ERROR_THRESHOLD);
   1340                restartServerDiscoveryAfterDelay();
   \                     ??queryNextImage_0: (+1)
   \   0000002C   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000030   0x....             B.N      restartServerDiscoveryAfterDelay
   1341                return;
   1342              }
   1343            }
   1344          
   1345            if (sendQuery == SEND_QUERY_NOW) {
   \                     ??queryNextImage_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R7,??DataTable35_9  ;; 0x493e0
   \   00000036   0x2C01             CMP      R4,#+1
   \   00000038   0xD112             BNE.N    ??queryNextImage_2
   1346              if (!queryErrorOccurred) {
   \   0000003A   0xB90D             CBNZ.N   R5,??queryNextImage_3
   1347                errors = 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x7070             STRB     R0,[R6, #+1]
   1348              }
   1349          
   1350              // Ask the client what image info to use in the query and
   1351              // subsequent download.
   1352              emberAfOtaClientVersionInfoCallback(&currentDownloadFile, 
   1353                                                  &hardwareVersion);
   \                     ??queryNextImage_3: (+1)
   \   00000040   0xF106 0x0118      ADD      R1,R6,#+24
   \   00000044   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000048   0x.... 0x....      BL       emberAfOtaClientVersionInfoCallback
   1354              updateCurrentImageAttributes(&currentDownloadFile);
   \   0000004C   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000050   0x.... 0x....      BL       updateCurrentImageAttributes
   1355          
   1356              sendMessage(ZCL_QUERY_NEXT_IMAGE_REQUEST_COMMAND_ID,
   1357                          0,                            // upgrade end status (ignored)
   1358                          EMBER_AF_OTA_QUERY_DELAY_MS);
   \   00000054   0x463A             MOV      R2,R7
   \   00000056   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x....             B.N      sendMessage
   1359            } else {
   1360              setTimer(EMBER_AF_OTA_QUERY_DELAY_MS);
   \                     ??queryNextImage_2: (+1)
   \   00000060   0x4638             MOV      R0,R7
   \   00000062   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000066   0x....             B.N      setTimer
   1361            }
   1362          }
   1363          

   \                                 In section .text, align 2, keep-with-next
   1364          static void continueImageDownload(void)
   1365          {
   \                     continueImageDownload: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1366            int8u commandId = ZCL_IMAGE_BLOCK_REQUEST_COMMAND_ID;
   \   00000004   0x2403             MOVS     R4,#+3
   1367            int32u timer = EMBER_AF_PLUGIN_OTA_CLIENT_DOWNLOAD_DELAY_MS;
   \   00000006   0x2500             MOVS     R5,#+0
   1368            boolean send = TRUE;
   1369          
   1370            recordUpgradeStatus(BOOTLOAD_STATE_DOWNLOAD);
   \   00000008   0x2006             MOVS     R0,#+6
   \   0000000A   0x.... 0x....      BL       recordUpgradeStatus
   1371          
   1372            if (errors >= EMBER_AF_PLUGIN_OTA_CLIENT_DOWNLOAD_ERROR_THRESHOLD) {
   \   0000000E   0x.... 0x....      LDR.W    R6,??DataTable35_1
   \   00000012   0x7870             LDRB     R0,[R6, #+1]
   \   00000014   0x280A             CMP      R0,#+10
   \   00000016   0xDB02             BLT.N    ??continueImageDownload_0
   1373              otaPrintln("Maximum number of download errors reach (%d), aborting.",
   1374                         errors);
   1375              downloadAndVerifyFinish(EMBER_AF_OTA_CLIENT_ABORTED);
   \   00000018   0x.... 0x....      BL       ?Subroutine2
   1376              return;
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000001C   0xBD73             POP      {R0,R1,R4-R6,PC}
   1377            }
   1378          
   1379            if (usePageRequest) {
   \                     ??continueImageDownload_0: (+1)
   \   0000001E   0x78F0             LDRB     R0,[R6, #+3]
   \   00000020   0xB1C8             CBZ.N    R0,??continueImageDownload_1
   1380              // Set the current offset for page request
   1381              // or, Get the current offset if retrying image blocks
   1382              EmAfPageRequestClientStatus status = emAfGetCurrentPageRequestStatus();
   1383              if (status == EM_AF_NO_PAGE_REQUEST) {
   \   00000022   0x.... 0x....      BL       emAfGetCurrentPageRequestStatus
   \   00000026   0xB938             CBNZ.N   R0,??continueImageDownload_2
   1384                timer = emAfInitPageRequestClient(getCurrentOffset(),
   1385                                                  totalImageSize);
   \   00000028   0x.... 0x....      BL       getCurrentOffset
   \   0000002C   0x69F1             LDR      R1,[R6, #+28]
   \   0000002E   0x.... 0x....      BL       emAfInitPageRequestClient
   \   00000032   0x4605             MOV      R5,R0
   1386                commandId = ZCL_IMAGE_PAGE_REQUEST_COMMAND_ID;
   \   00000034   0x2404             MOVS     R4,#+4
   \   00000036   0xE00E             B.N      ??continueImageDownload_1
   1387              } else {
   1388                int32u offset;
   1389                if (EM_AF_PAGE_REQUEST_ERROR
   1390                    == emAfNextMissedBlockRequestOffset(&offset)) {
   \                     ??continueImageDownload_2: (+1)
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0x.... 0x....      BL       emAfNextMissedBlockRequestOffset
   \   0000003E   0x28FF             CMP      R0,#+255
   \   00000040   0xD106             BNE.N    ??continueImageDownload_3
   1391                  // Server is unreachable because page request caused us to get 0
   1392                  // response packets from the server when we should have received
   1393                  // a lot.
   1394                  errors++;
   \   00000042   0x7870             LDRB     R0,[R6, #+1]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0x7070             STRB     R0,[R6, #+1]
   1395                  send = FALSE;
   1396                } else {
   1397                  updateCurrentOffset(offset);
   1398                }
   1399              }
   1400            }
   1401          
   1402            if (send) {
   1403              sendMessage(commandId,
   1404                          0,         // upgrade end status (ignored)
   1405                          timer);
   1406            } else {
   1407              setTimer(timer);
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      BL       setTimer
   \   0000004E   0xBD73             POP      {R0,R1,R4-R6,PC}
   1408            }
   \                     ??continueImageDownload_3: (+1)
   \   00000050   0x9800             LDR      R0,[SP, #+0]
   \   00000052   0x.... 0x....      BL       updateCurrentOffset
   \                     ??continueImageDownload_1: (+1)
   \   00000056   0x462A             MOV      R2,R5
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       sendMessage
   1409          }
   \   00000060   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1410          
   1411          // A callback fired by the verification code.

   \                                 In section .text, align 2, keep-with-next
   1412          void emAfOtaVerifyStoredDataFinish(EmberAfImageVerifyStatus status)
   1413          {
   1414            if (currentBootloadState == BOOTLOAD_STATE_VERIFY_IMAGE) {
   \                     emAfOtaVerifyStoredDataFinish: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0x2907             CMP      R1,#+7
   \   00000008   0xBF08             IT       EQ 
   1415              continueImageVerification(status);
   \   0000000A   0x.... 0x....      BEQ.W    continueImageVerification
   1416            }
   1417          }
   \   0000000E   0x4770             BX       LR               ;; return
   1418          

   \                                 In section .text, align 2, keep-with-next
   1419          static boolean downloadAndVerifyFinish(EmberAfOtaDownloadResult result)
   1420          {
   \                     downloadAndVerifyFinish: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1421            static PGM int8u zclStatusFromResult[] = {
   1422              EMBER_ZCL_STATUS_SUCCESS,
   1423              EMBER_ZCL_STATUS_ABORT,
   1424              EMBER_ZCL_STATUS_INVALID_IMAGE,
   1425              EMBER_ZCL_STATUS_ABORT,
   1426              EMBER_ZCL_STATUS_ABORT,
   1427              EMBER_ZCL_STATUS_ABORT,
   1428            };
   1429            int8u zclStatus;
   1430            boolean goAhead;
   1431          
   1432            if (currentBootloadState <= BOOTLOAD_STATE_QUERY_NEXT_IMAGE) {
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable35_1
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2806             CMP      R0,#+6
   \   0000000C   0xDA01             BGE.N    ??downloadAndVerifyFinish_0
   1433              // We don't really care about the return code here.  
   1434              // The important thing is that we don't call the client's download
   1435              // complete handler.
   1436              return TRUE;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   1437            }
   1438          
   1439            goAhead = emberAfOtaClientDownloadCompleteCallback(result,
   1440                                                               &currentDownloadFile);
   1441          
   1442            if (result == EMBER_AF_OTA_DOWNLOAD_AND_VERIFY_SUCCESS
   1443                && !goAhead) {
   \                     ??downloadAndVerifyFinish_0: (+1)
   \   00000012   0xF105 0x0108      ADD      R1,R5,#+8
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       emberAfOtaClientDownloadCompleteCallback
   \   0000001C   0x4320             ORRS     R0,R0,R4
   \   0000001E   0xBF08             IT       EQ 
   1444              otaPrintln("Client verification failed.");
   1445              result = EMBER_AF_OTA_CLIENT_ABORTED;
   \   00000020   0x2404             MOVEQ    R4,#+4
   1446            }
   1447            zclStatus = zclStatusFromResult[result];
   \   00000022   0x.... 0x....      ADR.W    R1,??zclStatusFromResult
   \   00000026   0x5C61             LDRB     R1,[R4, R1]
   1448          
   1449            // We could automatically invalidate the image in temporary storage
   1450            // when it is declared a bad image.
   1451            // This can be done by the download complete callback instead.
   1452          
   1453            if (zclStatus == EMBER_ZCL_STATUS_SUCCESS) {
   \   00000028   0xB919             CBNZ.N   R1,??downloadAndVerifyFinish_1
   1454              askServerToRunUpgrade(START_NEW_TIMER);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       askServerToRunUpgrade
   \   00000030   0xE00E             B.N      ??downloadAndVerifyFinish_2
   1455            } else if (result != EMBER_AF_OTA_SERVER_ABORTED
   1456                       && currentBootloadState != BOOTLOAD_STATE_QUERY_NEXT_IMAGE) {
   \                     ??downloadAndVerifyFinish_1: (+1)
   \   00000032   0x2C03             CMP      R4,#+3
   \   00000034   0xBF1C             ITT      NE 
   \   00000036   0x7828             LDRBNE   R0,[R5, #+0]
   \   00000038   0x2805             CMPNE    R0,#+5
   \   0000003A   0xD004             BEQ.N    ??downloadAndVerifyFinish_3
   1457              // Report to the server that the download has failed.
   1458              sendMessage(ZCL_UPGRADE_END_REQUEST_COMMAND_ID, 
   1459                          zclStatus,
   1460                          EMBER_AF_RUN_UPGRADE_REQUEST_DELAY_MS);
   \   0000003C   0x.... 0x....      LDR.W    R2,??DataTable35_2  ;; 0x927c0
   \   00000040   0x2006             MOVS     R0,#+6
   \   00000042   0x.... 0x....      BL       sendMessage
   1461            }
   1462            
   1463            if (zclStatus != EMBER_ZCL_STATUS_SUCCESS) {
   1464              waitingForResponse = FALSE;
   \                     ??downloadAndVerifyFinish_3: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x70A8             STRB     R0,[R5, #+2]
   1465              queryNextImage(DELAY_BEFORE_SEND_QUERY,
   1466                             FALSE);  // query error?
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x.... 0x....      BL       queryNextImage
   1467            }
   1468            return (result == EMBER_ZCL_STATUS_SUCCESS);
   \                     ??downloadAndVerifyFinish_2: (+1)
   \   00000050   0x1E60             SUBS     R0,R4,#+1
   \   00000052   0x4180             SBCS     R0,R0,R0
   \   00000054   0x0FC0             LSRS     R0,R0,#+31
   \   00000056   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1469          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??zclStatusFromResult:
   \   00000000   0x00 0x95          DC8 0, 149, 150, 149, 149, 149, 0, 0
   \              0x96 0x95    
   \              0x95 0x95    
   \              0x00 0x00    
   1470          

   \                                 In section .text, align 2, keep-with-next
   1471          static void continueImageVerification(EmberAfImageVerifyStatus status)
   1472          {
   \                     continueImageVerification: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0xB087             SUB      SP,SP,#+28
   1473            recordUpgradeStatus(BOOTLOAD_STATE_VERIFY_IMAGE);
   \   00000006   0x2007             MOVS     R0,#+7
   \   00000008   0x.... 0x....      BL       recordUpgradeStatus
   1474          
   1475            if (status == EMBER_AF_IMAGE_UNKNOWN) {
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable35_1
   \   00000010   0x2D05             CMP      R5,#+5
   \   00000012   0xD102             BNE.N    ??continueImageVerification_0
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x7120             STRB     R0,[R4, #+4]
   \   00000018   0xE006             B.N      ??continueImageVerification_1
   1476              customVerifyStatus = NO_CUSTOM_VERIFY;
   1477          
   1478            } else if (status == EMBER_AF_IMAGE_GOOD) {
   \                     ??continueImageVerification_0: (+1)
   \   0000001A   0xB91D             CBNZ.N   R5,??continueImageVerification_2
   1479              // This is only called with status == GOOD when signature
   1480              // verification has completed.  It is not called when
   1481              // custom verification is done.
   1482              customVerifyStatus = NEW_CUSTOM_VERIFY;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x7120             STRB     R0,[R4, #+4]
   1483              status = EMBER_AF_IMAGE_VERIFY_IN_PROGRESS;
   \   00000020   0x2502             MOVS     R5,#+2
   \   00000022   0xE001             B.N      ??continueImageVerification_1
   1484            }
   \                     ??continueImageVerification_2: (+1)
   \   00000024   0x2D02             CMP      R5,#+2
   \   00000026   0xD12E             BNE.N    ??continueImageVerification_3
   1485          
   1486            if (status == EMBER_AF_IMAGE_UNKNOWN
   1487                || status == EMBER_AF_IMAGE_VERIFY_IN_PROGRESS) {
   1488              int32u offset;
   1489              int32u totalSize;
   1490              EmberAfOtaImageId id;
   1491          
   1492              // First a basic sanity check of the image to insure
   1493              // the file has completely downloaded and the file format
   1494              // is correct.
   1495              if (status == EMBER_AF_IMAGE_UNKNOWN
   1496                  && (EMBER_AF_OTA_STORAGE_SUCCESS
   1497                      != emberAfOtaStorageCheckTempDataCallback(&offset,
   1498                                                                &totalSize,
   1499                                                                &id))) {
   \                     ??continueImageVerification_1: (+1)
   \   00000028   0x2D05             CMP      R5,#+5
   \   0000002A   0xD105             BNE.N    ??continueImageVerification_4
   \   0000002C   0xAA02             ADD      R2,SP,#+8
   \   0000002E   0xA900             ADD      R1,SP,#+0
   \   00000030   0xA801             ADD      R0,SP,#+4
   \   00000032   0x.... 0x....      BL       emberAfOtaStorageCheckTempDataCallback
   \   00000036   0xBB30             CBNZ.N   R0,??continueImageVerification_3
   1500                status = EMBER_AF_IMAGE_VERIFY_ERROR;
   1501          //      otaPrintln("emberAfOtaStorageCheckTempDataCallback() failed.");
   1502                goto imageVerifyDone;
   1503              }
   1504          
   1505              if (customVerifyStatus != NO_CUSTOM_VERIFY) {
   \                     ??continueImageVerification_4: (+1)
   \   00000038   0x7920             LDRB     R0,[R4, #+4]
   \   0000003A   0xB150             CBZ.N    R0,??continueImageVerification_5
   1506                status = emberAfOtaClientCustomVerifyCallback((customVerifyStatus 
   1507                                                               == NEW_CUSTOM_VERIFY),
   1508                                                              &currentDownloadFile);
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xBF18             IT       NE 
   \   00000040   0x2000             MOVNE    R0,#+0
   \   00000042   0xF104 0x0108      ADD      R1,R4,#+8
   \   00000046   0x.... 0x....      BL       emberAfOtaClientCustomVerifyCallback
   \   0000004A   0x4605             MOV      R5,R0
   1509                customVerifyStatus = CUSTOM_VERIFY_IN_PROGRESS;
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0x7120             STRB     R0,[R4, #+4]
   \   00000050   0xE009             B.N      ??continueImageVerification_6
   1510              } else {
   1511                status = emAfOtaImageSignatureVerify(MAX_DIGEST_CALCULATIONS_PER_CALL,
   1512                                                     &currentDownloadFile,
   1513                                                     (status == EMBER_AF_IMAGE_UNKNOWN
   1514                                                      ? EMBER_AF_NEW_IMAGE_VERIFICATION
   1515                                                      : EMBER_AF_CONTINUE_IMAGE_VERIFY));
   \                     ??continueImageVerification_5: (+1)
   \   00000052   0x2D05             CMP      R5,#+5
   \   00000054   0xBF0C             ITE      EQ 
   \   00000056   0x2201             MOVEQ    R2,#+1
   \   00000058   0x2200             MOVNE    R2,#+0
   \   0000005A   0xF104 0x0108      ADD      R1,R4,#+8
   \   0000005E   0x2005             MOVS     R0,#+5
   \   00000060   0x.... 0x....      BL       emAfOtaImageSignatureVerify
   \   00000064   0x4605             MOV      R5,R0
   1516              }
   1517          
   1518              if (status == EMBER_AF_IMAGE_VERIFY_IN_PROGRESS) {
   \                     ??continueImageVerification_6: (+1)
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x2D02             CMP      R5,#+2
   \   0000006A   0xD007             BEQ.N    ??continueImageVerification_7
   1519                setTimer(EMBER_AF_PLUGIN_OTA_CLIENT_VERIFY_DELAY_MS);
   1520                return;
   1521              } else if (status == EMBER_AF_IMAGE_VERIFY_WAIT) {
   \   0000006C   0x2D03             CMP      R5,#+3
   \   0000006E   0xBF08             IT       EQ 
   1522                setTimer(0);
   \   00000070   0x2000             MOVEQ    R0,#+0
   \   00000072   0xD004             BEQ.N    ??continueImageVerification_8
   1523                return;
   1524              } else if (status == EMBER_AF_NO_IMAGE_VERIFY_SUPPORT) {
   \   00000074   0x2D06             CMP      R5,#+6
   \   00000076   0xD105             BNE.N    ??continueImageVerification_9
   1525                otaPrintln("No signature verification support, assuming image is okay.");
   1526                customVerifyStatus = NEW_CUSTOM_VERIFY;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x7120             STRB     R0,[R4, #+4]
   1527                setTimer(EMBER_AF_PLUGIN_OTA_CLIENT_VERIFY_DELAY_MS);
   \                     ??continueImageVerification_7: (+1)
   \   0000007C   0x200A             MOVS     R0,#+10
   \                     ??continueImageVerification_8: (+1)
   \   0000007E   0x.... 0x....      BL       setTimer
   1528                return;
   \   00000082   0xE003             B.N      ??continueImageVerification_10
   1529              } else {
   1530                otaPrintln("%p verification %p: 0x%X", 
   1531                           (customVerifyStatus == NO_CUSTOM_VERIFY
   1532                            ? "Signature"
   1533                            : "Custom"),
   1534                           (status == EMBER_AF_IMAGE_GOOD
   1535                            ? "passed" 
   1536                            : "FAILED"),
   1537                           status);
   1538              }
   1539            }
   1540          
   1541           imageVerifyDone:
   1542            downloadAndVerifyFinish((status == EMBER_AF_IMAGE_GOOD
   1543                                     ? EMBER_AF_OTA_DOWNLOAD_AND_VERIFY_SUCCESS
   1544                                     : EMBER_AF_OTA_VERIFY_FAILED));
   \                     ??continueImageVerification_9: (+1)
   \   00000084   0xB105             CBZ.N    R5,??continueImageVerification_11
   \                     ??continueImageVerification_3: (+1)
   \   00000086   0x2002             MOVS     R0,#+2
   \                     ??continueImageVerification_11: (+1)
   \   00000088   0x.... 0x....      BL       downloadAndVerifyFinish
   1545          }
   \                     ??continueImageVerification_10: (+1)
   \   0000008C   0xB007             ADD      SP,SP,#+28
   \   0000008E   0xBD30             POP      {R4,R5,PC}       ;; return
   1546          

   \                                 In section .text, align 2, keep-with-next
   1547          static void askServerToRunUpgrade(boolean timeout)
   1548          {
   \                     askServerToRunUpgrade: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1549            recordUpgradeStatus(BOOTLOAD_STATE_WAITING_FOR_UPGRADE_MESSAGE);
   \   00000004   0x2008             MOVS     R0,#+8
   \   00000006   0x.... 0x....      BL       recordUpgradeStatus
   1550          
   1551            if (!timeout) {
   \   0000000A   0x....             LDR.N    R0,??DataTable35_1
   \   0000000C   0xB93C             CBNZ.N   R4,??askServerToRunUpgrade_0
   1552              errors = 0;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7041             STRB     R1,[R0, #+1]
   1553            }
   1554          
   1555            if (errors >= EMBER_AF_PLUGIN_OTA_CLIENT_UPGRADE_WAIT_THRESHOLD) {
   1556              otaPrintln("Maximum upgrade requests made (%d) without response from server.");
   1557              otaPrintln("Upgrading anyway");
   1558              runUpgrade();
   1559              return;
   1560            }
   1561            sendMessage(ZCL_UPGRADE_END_REQUEST_COMMAND_ID, 
   1562                        EMBER_ZCL_STATUS_SUCCESS,
   1563                        EMBER_AF_RUN_UPGRADE_REQUEST_DELAY_MS);
   \                     ??askServerToRunUpgrade_1: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xE8BD 0x4010      POP      {R4,LR}
   \   00000018   0x....             LDR.N    R2,??DataTable35_2  ;; 0x927c0
   \   0000001A   0x2006             MOVS     R0,#+6
   \   0000001C   0x....             B.N      sendMessage
   \                     ??askServerToRunUpgrade_0: (+1)
   \   0000001E   0x7840             LDRB     R0,[R0, #+1]
   \   00000020   0x280A             CMP      R0,#+10
   \   00000022   0xDBF6             BLT.N    ??askServerToRunUpgrade_1
   \   00000024                      REQUIRE ?Subroutine0
   \   00000024                      ;; // Fall through to label ?Subroutine0
   1564          }
   1565          
   1566          static boolean storeData(int32u offset, int32u length, const int8u* data)
   1567          {
   1568            return (EMBER_AF_OTA_STORAGE_SUCCESS
   1569                    == emberAfOtaStorageWriteTempDataCallback(offset, length, data));
   1570          }
   1571          

   \                                 In section .text, align 2, keep-with-next
   1572          static EmberAfStatus imageBlockResponseParse(int8u* buffer, int8u index, int8u length)
   1573          {
   \                     imageBlockResponseParse: (+1)
   \   00000000   0xE92D 0x4BF0      PUSH     {R4-R9,R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   1574            EmberAfOtaImageId imageId;
   1575            int32u offset;
   1576            int32u currentOffset;
   1577            int8u dataSize;
   1578            int32u timerMs = (EMBER_AF_PLUGIN_OTA_CLIENT_DOWNLOAD_DELAY_MS >= minBlockRequestPeriodMs
   1579                              ? EMBER_AF_PLUGIN_OTA_CLIENT_DOWNLOAD_DELAY_MS
   1580                              : (minBlockRequestPeriodMs));
   \   00000006   0x....             LDR.N    R5,??DataTable35_1
   \   00000008   0xF8B5 0xB01A      LDRH     R11,[R5, #+26]
   \   0000000C   0xB086             SUB      SP,SP,#+24
   1581            int8u status = emberAfGetInt8u(buffer, index, length);
   \   0000000E   0xF811 0x0008      LDRB     R0,[R1, R8]
   1582            int32u nextOffset;
   1583            const int8u* imageData;
   1584            EmAfPageRequestClientStatus pageRequestStatus;
   1585          
   1586            index++;
   \   00000012   0x1C4E             ADDS     R6,R1,#+1
   1587          
   1588            if (buffer != NULL && status == EMBER_ZCL_STATUS_WAIT_FOR_DATA) {
   \   00000014   0x4691             MOV      R9,R2
   \   00000016   0x4614             MOV      R4,R2
   \   00000018   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001C   0xD023             BEQ.N    ??imageBlockResponseParse_0
   \   0000001E   0x2897             CMP      R0,#+151
   \   00000020   0xD121             BNE.N    ??imageBlockResponseParse_0
   1589              int32u currentTime;
   1590              int32u requestTime;
   1591              int32u calculatedTimer;
   1592          
   1593              if (length < IMAGE_BLOCK_RESPONSE_WAIT_FOR_DATA_LENGTH_MIN) {
   \   00000022   0x2C0B             CMP      R4,#+11
   \   00000024   0xDB4A             BLT.N    ??imageBlockResponseParse_1
   1594                return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
   1595              }
   1596              currentTime = emberAfGetInt32u(buffer, index, length);
   \   00000026   0xB2F6             UXTB     R6,R6
   \   00000028   0x.... 0x....      BL       ?Subroutine5
   1597              index += 4;
   \                     ??CrossCallReturnLabel_19: (+1)
   \   0000002C   0x1D37             ADDS     R7,R6,#+4
   \   0000002E   0x4683             MOV      R11,R0
   1598              requestTime = emberAfGetInt32u(buffer, index, length);
   \   00000030   0xB2FF             UXTB     R7,R7
   \   00000032   0x464A             MOV      R2,R9
   \   00000034   0x4639             MOV      R1,R7
   \   00000036   0x.... 0x....      BL       ??Subroutine5_0
   1599              index += 4;
   1600          
   1601              if (!calculateTimer(currentTime, requestTime, &calculatedTimer)) {
   \                     ??CrossCallReturnLabel_17: (+1)
   \   0000003A   0x4601             MOV      R1,R0
   \   0000003C   0x1D3F             ADDS     R7,R7,#+4
   \   0000003E   0xAA00             ADD      R2,SP,#+0
   \   00000040   0x4658             MOV      R0,R11
   \   00000042   0x.... 0x....      BL       calculateTimer
   \   00000046   0xB908             CBNZ.N   R0,??imageBlockResponseParse_2
   1602                // Error printed by above function.
   1603                calculatedTimer = CALCULATE_TIME_ERROR_IMAGE_BLOCK_DELAY_MS; 
   \   00000048   0x....             LDR.N    R0,??DataTable35_9  ;; 0x493e0
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   1604              }
   1605          
   1606              if (length >= IMAGE_BLOCK_RESPONSE_WAIT_FOR_DATA_MIN_BLOCK_RESPONSE_LENGTH) {
   \                     ??imageBlockResponseParse_2: (+1)
   \   0000004C   0x2C0D             CMP      R4,#+13
   \   0000004E   0xDB06             BLT.N    ??imageBlockResponseParse_3
   1607                int16u temp = emberAfGetInt16u(buffer, 
   1608                                               index, 
   1609                                               length);
   \   00000050   0x464A             MOV      R2,R9
   \   00000052   0xB2F9             UXTB     R1,R7
   \   00000054   0x4640             MOV      R0,R8
   \   00000056   0x.... 0x....      BL       emberAfGetInt16u
   1610                emberAfCoreFlush();
   1611                otaPrintln("Updating Min Block Request Period to %d milliseconds",
   1612                           temp);
   1613                updateMinBlockRequestPeriodAttribute(temp);
   \   0000005A   0x8368             STRH     R0,[R5, #+26]
   1614                calculatedTimer = temp;
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   1615              }
   1616          
   1617              emberAfCoreFlush();
   1618              otaPrintln("Download delay by server %d ms", calculatedTimer);
   1619              emberAfCoreFlush();
   1620              setTimer(calculatedTimer);
   \                     ??imageBlockResponseParse_3: (+1)
   \   0000005E   0x9800             LDR      R0,[SP, #+0]
   \   00000060   0x.... 0x....      BL       setTimer
   \   00000064   0xE085             B.N      ??imageBlockResponseParse_4
   1621              return EMBER_ZCL_STATUS_SUCCESS;
   1622            } else if (status == EMBER_ZCL_STATUS_ABORT
   1623                       || status == EMBER_ZCL_STATUS_NO_IMAGE_AVAILABLE) {
   \                     ??imageBlockResponseParse_0: (+1)
   \   00000066   0x2895             CMP      R0,#+149
   \   00000068   0xBF18             IT       NE 
   \   0000006A   0x2898             CMPNE    R0,#+152
   \   0000006C   0xD00B             BEQ.N    ??imageBlockResponseParse_5
   1624              otaPrintln("Download aborted by server.");
   1625              downloadAndVerifyFinish(EMBER_AF_OTA_SERVER_ABORTED);
   1626              return EMBER_ZCL_STATUS_SUCCESS;
   1627            } else if (status == EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND) {
   \   0000006E   0x2881             CMP      R0,#+129
   \   00000070   0xD10B             BNE.N    ??imageBlockResponseParse_6
   1628              if (usePageRequest && emAfHandlingPageRequestClient()) {
   \   00000072   0x78E8             LDRB     R0,[R5, #+3]
   \   00000074   0xB138             CBZ.N    R0,??imageBlockResponseParse_5
   \   00000076   0x.... 0x....      BL       emAfHandlingPageRequestClient
   \   0000007A   0xB120             CBZ.N    R0,??imageBlockResponseParse_5
   1629                otaPrintln("Server doesn't support page request, only using block request.");
   1630                usePageRequest = FALSE;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x70E8             STRB     R0,[R5, #+3]
   1631                emAfAbortPageRequest();
   \   00000080   0x.... 0x....      BL       emAfAbortPageRequest
   1632                continueImageDownload();
   \   00000084   0xE073             B.N      ??imageBlockResponseParse_7
   1633                return EMBER_ZCL_STATUS_SUCCESS;
   1634              } else {
   1635                otaPrintln("Server returned 'unsupported cluster command'.");
   1636                downloadAndVerifyFinish(EMBER_AF_OTA_SERVER_ABORTED);
   \                     ??imageBlockResponseParse_5: (+1)
   \   00000086   0x2003             MOVS     R0,#+3
   \   00000088   0xE04B             B.N      ??imageBlockResponseParse_8
   1637                return EMBER_ZCL_STATUS_SUCCESS;
   1638              }
   1639            } else if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \                     ??imageBlockResponseParse_6: (+1)
   \   0000008A   0xBB60             CBNZ.N   R0,??imageBlockResponseParse_9
   1640              otaPrintln("Unknown %p status code 0x%X", 
   1641                         "Image block response", 
   1642                         status);
   1643              return EMBER_ZCL_STATUS_INVALID_VALUE;
   1644            } // Else status == success.  Keep going
   1645          
   1646            if (length < IMAGE_BLOCK_RESPONSE_SUCCESS_MIN_LENGTH) {
   \   0000008C   0x2C11             CMP      R4,#+17
   \   0000008E   0xDB15             BLT.N    ??imageBlockResponseParse_1
   1647              return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
   1648            }
   1649          
   1650            index += emAfOtaParseImageIdFromMessage(&imageId,
   1651                                                    &(buffer[index]), 
   1652                                                    length);
   \   00000090   0xB2F0             UXTB     R0,R6
   \   00000092   0xEB00 0x0108      ADD      R1,R0,R8
   \   00000096   0xA801             ADD      R0,SP,#+4
   \   00000098   0x.... 0x....      BL       emAfOtaParseImageIdFromMessage
   \   0000009C   0x1980             ADDS     R0,R0,R6
   1653            offset = emberAfGetInt32u(buffer, index, length);
   \   0000009E   0xB2C6             UXTB     R6,R0
   \   000000A0   0x464A             MOV      R2,R9
   \   000000A2   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_18: (+1)
   \   000000A6   0x4681             MOV      R9,R0
   1654            index += 4;
   \   000000A8   0x1D30             ADDS     R0,R6,#+4
   1655            dataSize = emberAfGetInt8u(buffer, index, length);
   \   000000AA   0xB2C0             UXTB     R0,R0
   \   000000AC   0xF810 0x6008      LDRB     R6,[R0, R8]
   1656            index += 1;
   \   000000B0   0x1C40             ADDS     R0,R0,#+1
   1657            imageData = buffer + index;
   \   000000B2   0xB2C1             UXTB     R1,R0
   1658            
   1659            if ((length - index) < dataSize) {
   \   000000B4   0x1A60             SUBS     R0,R4,R1
   \   000000B6   0x4488             ADD      R8,R1,R8
   \   000000B8   0x42B0             CMP      R0,R6
   \   000000BA   0xDA01             BGE.N    ??imageBlockResponseParse_10
   1660              otaPrintln("%p has data size (%d) smaller than actual packet size (%d).",
   1661                         "Image block response",
   1662                         dataSize,
   1663                         length - index);
   1664              return EMBER_ZCL_STATUS_MALFORMED_COMMAND;
   \                     ??imageBlockResponseParse_1: (+1)
   \   000000BC   0x2080             MOVS     R0,#+128
   \   000000BE   0xE059             B.N      ??imageBlockResponseParse_11
   1665            }
   1666            
   1667            if (!usePageRequest 
   1668                || emAfGetCurrentPageRequestStatus() != EM_AF_WAITING_PAGE_REQUEST_REPLIES) {
   \                     ??imageBlockResponseParse_10: (+1)
   \   000000C0   0x78E8             LDRB     R0,[R5, #+3]
   \   000000C2   0xB118             CBZ.N    R0,??imageBlockResponseParse_12
   \   000000C4   0x.... 0x....      BL       emAfGetCurrentPageRequestStatus
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xD003             BEQ.N    ??imageBlockResponseParse_13
   1669              // For normal image block request transactions, all blocks should be in order.
   1670              // For page request, we may receive them out of order, or just miss packets.
   1671              currentOffset = getCurrentOffset();
   1672              if (offset != currentOffset) {
   \                     ??imageBlockResponseParse_12: (+1)
   \   000000CC   0x.... 0x....      BL       getCurrentOffset
   \   000000D0   0x4581             CMP      R9,R0
   \   000000D2   0xD14E             BNE.N    ??imageBlockResponseParse_4
   1673                otaPrintln("%p error: Expected offset 0x%4X, but got 0x%4X.  Ignoring", 
   1674                           "Image block response",
   1675                           currentOffset, 
   1676                           offset);
   1677                return EMBER_ZCL_STATUS_SUCCESS;
   1678              }
   1679            }
   1680            
   1681            if (0 != MEMCOMPARE(&currentDownloadFile, 
   1682                                &imageId, 
   1683                                sizeof(EmberAfOtaImageId))
   1684                       || dataSize > MAX_CLIENT_DATA_SIZE) {
   \                     ??imageBlockResponseParse_13: (+1)
   \   000000D4   0x2210             MOVS     R2,#+16
   \   000000D6   0xA901             ADD      R1,SP,#+4
   \   000000D8   0xF105 0x0008      ADD      R0,R5,#+8
   \   000000DC   0x.... 0x....      BL       halCommonMemCompare
   \   000000E0   0xB908             CBNZ.N   R0,??imageBlockResponseParse_9
   \   000000E2   0x2E40             CMP      R6,#+64
   \   000000E4   0xDB01             BLT.N    ??imageBlockResponseParse_14
   1685              otaPrintln("%p info did not match my expected info.  Dropping.",
   1686                         "Image block response");
   1687              return EMBER_ZCL_STATUS_INVALID_VALUE;
   \                     ??imageBlockResponseParse_9: (+1)
   \   000000E6   0x2087             MOVS     R0,#+135
   \   000000E8   0xE044             B.N      ??imageBlockResponseParse_11
   1688            }
   1689          
   1690            errors = 0;
   \                     ??imageBlockResponseParse_14: (+1)
   \   000000EA   0x7068             STRB     R0,[R5, #+1]
   1691          
   1692            // We want to make sure we don't write the same block twice.  For
   1693            // page-erase-required EEPROM parts this won't work.
   1694            if (usePageRequest && emAfHandlingPageRequestClient()) {
   \   000000EC   0x78E8             LDRB     R0,[R5, #+3]
   \   000000EE   0xB140             CBZ.N    R0,??imageBlockResponseParse_15
   \   000000F0   0x.... 0x....      BL       emAfHandlingPageRequestClient
   \   000000F4   0xB128             CBZ.N    R0,??imageBlockResponseParse_15
   1695              pageRequestStatus = emAfNoteReceivedBlockForPageRequestClient(offset);
   \   000000F6   0x4648             MOV      R0,R9
   \   000000F8   0x.... 0x....      BL       emAfNoteReceivedBlockForPageRequestClient
   \   000000FC   0x4607             MOV      R7,R0
   1696              if (pageRequestStatus == EM_AF_BLOCK_ALREADY_RECEIVED) {
   \   000000FE   0x2F04             CMP      R7,#+4
   \   00000100   0xD037             BEQ.N    ??imageBlockResponseParse_4
   1697                return EMBER_ZCL_STATUS_SUCCESS;
   1698              }
   1699            }
   1700          
   1701            if (!storeData(offset, dataSize, imageData)) {
   \                     ??imageBlockResponseParse_15: (+1)
   \   00000102   0x4642             MOV      R2,R8
   \   00000104   0x4631             MOV      R1,R6
   \   00000106   0x4648             MOV      R0,R9
   \   00000108   0x.... 0x....      BL       emberAfOtaStorageWriteTempDataCallback
   \   0000010C   0xB940             CBNZ.N   R0,??imageBlockResponseParse_16
   1702              otaPrintln("Failed to write to storage device!");
   1703              downloadAndVerifyFinish(EMBER_AF_OTA_CLIENT_ABORTED);
   1704              // The downloadAndVerifyFinish() function will return it's only status
   1705              // to the message.  No need to send ours.
   1706              return EMBER_ZCL_STATUS_SUCCESS;
   1707            }
   1708          
   1709            nextOffset = offset + dataSize;
   1710          
   1711            if (usePageRequest && emAfHandlingPageRequestClient()) {
   \   0000010E   0x78E8             LDRB     R0,[R5, #+3]
   \   00000110   0xEB06 0x0809      ADD      R8,R6,R9
   \   00000114   0xB198             CBZ.N    R0,??imageBlockResponseParse_17
   \   00000116   0x.... 0x....      BL       emAfHandlingPageRequestClient
   \   0000011A   0xB180             CBZ.N    R0,??imageBlockResponseParse_17
   1712              if (pageRequestStatus == EM_AF_PAGE_REQUEST_ERROR) {
   \   0000011C   0x2FFF             CMP      R7,#+255
   \   0000011E   0xD103             BNE.N    ??imageBlockResponseParse_18
   1713                downloadAndVerifyFinish(EMBER_AF_OTA_CLIENT_ABORTED);
   \                     ??imageBlockResponseParse_16: (+1)
   \   00000120   0x2004             MOVS     R0,#+4
   \                     ??imageBlockResponseParse_8: (+1)
   \   00000122   0x.... 0x....      BL       downloadAndVerifyFinish
   \   00000126   0xE024             B.N      ??imageBlockResponseParse_4
   1714                // We still return success to indicate we processed the message correctly.
   1715                return EMBER_ZCL_STATUS_SUCCESS;
   1716          
   1717              } else if (pageRequestStatus == EM_AF_WAITING_PAGE_REQUEST_REPLIES) {
   \                     ??imageBlockResponseParse_18: (+1)
   \   00000128   0x2F01             CMP      R7,#+1
   \   0000012A   0xD022             BEQ.N    ??imageBlockResponseParse_4
   1718                return EMBER_ZCL_STATUS_SUCCESS;
   1719          
   1720              } else if (pageRequestStatus == EM_AF_PAGE_REQUEST_COMPLETE) {
   \   0000012C   0x2F03             CMP      R7,#+3
   \   0000012E   0xD103             BNE.N    ??imageBlockResponseParse_19
   1721                nextOffset = emAfGetFinishedPageRequestOffset();
   \   00000130   0x.... 0x....      BL       emAfGetFinishedPageRequestOffset
   \   00000134   0x4680             MOV      R8,R0
   \   00000136   0xE002             B.N      ??imageBlockResponseParse_17
   1722          
   1723              } else { // EM_AF_RETRY_MISSED_PACKETS 
   1724                timerMs = emAfGetPageRequestMissedPacketDelayMs();
   \                     ??imageBlockResponseParse_19: (+1)
   \   00000138   0x.... 0x....      BL       emAfGetPageRequestMissedPacketDelayMs
   \   0000013C   0x4683             MOV      R11,R0
   1725              }
   1726            }
   1727          
   1728            offset = updateCurrentOffset(nextOffset);
   \                     ??imageBlockResponseParse_17: (+1)
   \   0000013E   0x4640             MOV      R0,R8
   \   00000140   0x.... 0x....      BL       updateCurrentOffset
   \   00000144   0x4604             MOV      R4,R0
   1729          
   1730          #if defined(EMBER_TEST)
   1731            {
   1732              int8u percentageComplete = 
   1733                emAfPrintPercentageUpdate("Download", 
   1734                                          DOWNLOAD_PERCENTAGE_UPDATE_RATE, 
   1735                                          offset);
   1736              if (percentageComplete != 100 && percentageComplete >= emAfOtaClientStopDownloadPercentage) {
   1737                otaPrintln("Artificially stopping download at %d%%", emAfOtaClientStopDownloadPercentage);
   1738                return EMBER_ZCL_STATUS_SUCCESS;
   1739              }
   1740            }
   1741          #else
   1742            emAfPrintPercentageUpdate("Download", 
   1743                                      DOWNLOAD_PERCENTAGE_UPDATE_RATE, 
   1744                                      offset);
   \   00000146   0x4622             MOV      R2,R4
   \   00000148   0x2105             MOVS     R1,#+5
   \   0000014A   0x.... 0x....      ADR.W    R0,`?<Constant "Download">`
   \   0000014E   0x.... 0x....      BL       emAfPrintPercentageUpdate
   1745          #endif
   1746          
   1747            if (offset >= totalImageSize) {
   \   00000152   0x69E8             LDR      R0,[R5, #+28]
   \   00000154   0x4284             CMP      R4,R0
   \   00000156   0xD306             BCC.N    ??imageBlockResponseParse_20
   1748              emberAfOtaStorageFinishDownloadCallback(offset);
   \   00000158   0x4620             MOV      R0,R4
   \   0000015A   0x.... 0x....      BL       emberAfOtaStorageFinishDownloadCallback
   1749              continueImageVerification(EMBER_AF_IMAGE_UNKNOWN);  
   \   0000015E   0x2005             MOVS     R0,#+5
   \   00000160   0x.... 0x....      BL       continueImageVerification
   \   00000164   0xE005             B.N      ??imageBlockResponseParse_4
   1750              return EMBER_ZCL_STATUS_SUCCESS;
   1751            } else {
   1752              if (!setTimer(timerMs)) {
   \                     ??imageBlockResponseParse_20: (+1)
   \   00000166   0x4658             MOV      R0,R11
   \   00000168   0x.... 0x....      BL       setTimer
   \   0000016C   0xB908             CBNZ.N   R0,??imageBlockResponseParse_4
   1753                // Continue download right now
   1754                continueImageDownload();
   \                     ??imageBlockResponseParse_7: (+1)
   \   0000016E   0x.... 0x....      BL       continueImageDownload
   1755              } // else (fall through)
   1756                // timer set, wait for next event to fire
   1757            }
   1758            return EMBER_ZCL_STATUS_SUCCESS;
   \                     ??imageBlockResponseParse_4: (+1)
   \   00000172   0x2000             MOVS     R0,#+0
   \                     ??imageBlockResponseParse_11: (+1)
   \   00000174   0xB006             ADD      SP,SP,#+24
   \   00000176   0xE8BD 0x8BF0      POP      {R4-R9,R11,PC}   ;; return
   1759          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x4631             MOV      R1,R6
   \                     ??Subroutine5_0: (+1)
   \   00000002   0x4640             MOV      R0,R8
   \   00000004   0x.... 0x....      B.W      emberAfGetInt32u
   1760          

   \                                 In section .text, align 2, keep-with-next
   1761          static EmberAfStatus upgradeEndResponseParse(int8u status,
   1762                                                       int8u* buffer, 
   1763                                                       int8u length)
   1764          {
   \                     upgradeEndResponseParse: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4615             MOV      R5,R2
   1765            EmberAfOtaImageId serverSentId;
   1766            int32u waitTime;
   1767            int32u currentTime, upgradeTime;
   1768            int8u index = EMBER_AF_ZCL_OVERHEAD;
   1769          
   1770            if (status) {
   \   00000008   0xB118             CBZ.N    R0,??upgradeEndResponseParse_0
   1771              otaPrintln("Server aborted upgrade, status: 0x%X",
   1772                         status);
   1773              downloadAndVerifyFinish(EMBER_AF_OTA_SERVER_ABORTED);
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0x.... 0x....      BL       downloadAndVerifyFinish
   1774              return EMBER_ZCL_STATUS_SUCCESS;
   \   00000010   0xE046             B.N      ??upgradeEndResponseParse_1
   1775            }
   1776          
   1777            index += emAfOtaParseImageIdFromMessage(&serverSentId, 
   1778                                                    &(buffer[index]),
   1779                                                    length);
   \                     ??upgradeEndResponseParse_0: (+1)
   \   00000012   0x1CE1             ADDS     R1,R4,#+3
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      BL       emAfOtaParseImageIdFromMessage
   1780          
   1781            if ((serverSentId.manufacturerId != currentDownloadFile.manufacturerId)
   1782                && (serverSentId.manufacturerId != MFG_ID_WILD_CARD)) {
   \   0000001A   0x....             LDR.N    R1,??DataTable35_1
   \   0000001C   0xF8BD 0x2004      LDRH     R2,[SP, #+4]
   \   00000020   0x890B             LDRH     R3,[R1, #+8]
   \   00000022   0x1CC6             ADDS     R6,R0,#+3
   \   00000024   0xB2F6             UXTB     R6,R6
   \   00000026   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000002A   0x429A             CMP      R2,R3
   \   0000002C   0xBF18             IT       NE 
   \   0000002E   0x4282             CMPNE    R2,R0
   \   00000030   0xD10D             BNE.N    ??upgradeEndResponseParse_2
   1783              emberAfOtaBootloadClusterPrint("Error: %p had invalid %p: ",
   1784                                             "Upgrade end response",
   1785                                             "manufacturer ID");
   1786              otaPrintln("0x%2X", serverSentId.manufacturerId);
   1787              return EMBER_ZCL_STATUS_INVALID_VALUE;
   1788            }
   1789            if ((serverSentId.imageTypeId != currentDownloadFile.imageTypeId) 
   1790                && (serverSentId.imageTypeId != IMAGE_TYPE_WILD_CARD)) {
   \   00000032   0xF8BD 0x2006      LDRH     R2,[SP, #+6]
   \   00000036   0x894B             LDRH     R3,[R1, #+10]
   \   00000038   0x429A             CMP      R2,R3
   \   0000003A   0xBF18             IT       NE 
   \   0000003C   0x4282             CMPNE    R2,R0
   \   0000003E   0xD106             BNE.N    ??upgradeEndResponseParse_2
   1791              emberAfOtaBootloadClusterPrint("Error: %p had invalid %p: ",
   1792                                             "Upgrade end response",
   1793                                             "image type ID");
   1794              otaPrintln("0x%2X", serverSentId.imageTypeId);
   1795              return EMBER_ZCL_STATUS_INVALID_VALUE;
   1796            }
   1797            if ((serverSentId.firmwareVersion != currentDownloadFile.firmwareVersion
   1798                 && serverSentId.firmwareVersion != FILE_VERSION_WILD_CARD)) {
   \   00000040   0x9802             LDR      R0,[SP, #+8]
   \   00000042   0x68C9             LDR      R1,[R1, #+12]
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xBF18             IT       NE 
   \   00000048   0xF110 0x0F01      CMNNE    R0,#+1
   \   0000004C   0xD001             BEQ.N    ??upgradeEndResponseParse_3
   1799              emberAfOtaBootloadClusterPrint("Error: %p had invalid %p: ",
   1800                                             "Upgrade end response",
   1801                                             "file version");
   1802              otaPrintln("0x%4X", serverSentId.firmwareVersion);
   1803              return EMBER_ZCL_STATUS_INVALID_VALUE;
   \                     ??upgradeEndResponseParse_2: (+1)
   \   0000004E   0x2087             MOVS     R0,#+135
   \   00000050   0xE027             B.N      ??upgradeEndResponseParse_4
   1804            }
   1805            currentTime = emberAfGetInt32u(buffer, index, length);
   \                     ??upgradeEndResponseParse_3: (+1)
   \   00000052   0x462A             MOV      R2,R5
   \   00000054   0x4631             MOV      R1,R6
   \   00000056   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_14: (+1)
   \   0000005A   0x4607             MOV      R7,R0
   1806            index += 4;
   1807            upgradeTime = emberAfGetInt32u(buffer, index, length);
   \   0000005C   0x1D31             ADDS     R1,R6,#+4
   \   0000005E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000062   0x4601             MOV      R1,R0
   1808            
   1809            if (WAIT_FOR_UPGRADE_MESSAGE == upgradeTime) {
   \   00000064   0x....             LDR.N    R4,??DataTable35_10  ;; 0x36ee80
   \   00000066   0xF111 0x0F01      CMN      R1,#+1
   \   0000006A   0xD106             BNE.N    ??upgradeEndResponseParse_5
   1810              recordUpgradeStatus(BOOTLOAD_STATE_WAITING_FOR_UPGRADE_MESSAGE);
   \   0000006C   0x2008             MOVS     R0,#+8
   \   0000006E   0x.... 0x....      BL       recordUpgradeStatus
   1811              setTimer(WAIT_FOR_UPGRADE_DELAY_MS);
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       setTimer
   1812              return EMBER_ZCL_STATUS_SUCCESS;
   \   00000078   0xE012             B.N      ??upgradeEndResponseParse_1
   1813            }
   1814          
   1815            // NOTE:  Current Time and Upgrade Time are in SECONDS since epoch.
   1816            // Our timer uses MILISECONDS.  calculateTimer() will give us the MS delay.
   1817          
   1818            if (!calculateTimer(currentTime, upgradeTime, &waitTime)) {
   \                     ??upgradeEndResponseParse_5: (+1)
   \   0000007A   0xAA00             ADD      R2,SP,#+0
   \   0000007C   0x4638             MOV      R0,R7
   \   0000007E   0x.... 0x....      BL       calculateTimer
   \   00000082   0xB908             CBNZ.N   R0,??upgradeEndResponseParse_6
   1819              waitTime = CALCULATE_TIME_ERROR_UPGRADE_END_RESPONSE_DELAY_MS;
   \   00000084   0x9400             STR      R4,[SP, #+0]
   \   00000086   0xE005             B.N      ??upgradeEndResponseParse_7
   1820            } else {
   1821              // Even when we are told to upgrade immediately, we want to insure there
   1822              // is a chance for the APS retries and ZCL response to get back to their 
   1823              // senders.
   1824              if (waitTime < IMMEDIATE_UPGRADE_DELAY_MS) {
   \                     ??upgradeEndResponseParse_6: (+1)
   \   00000088   0x9900             LDR      R1,[SP, #+0]
   \   0000008A   0xF640 0x30B8      MOVW     R0,#+3000
   \   0000008E   0x4281             CMP      R1,R0
   \   00000090   0xBF38             IT       CC 
   1825                otaPrintln("Adding %d ms. delay for immediate upgrade.", 
   1826                           IMMEDIATE_UPGRADE_DELAY_MS);
   1827                waitTime = IMMEDIATE_UPGRADE_DELAY_MS;
   \   00000092   0x9000             STRCC    R0,[SP, #+0]
   1828              }
   1829            }
   1830            // Expect at this point waitTime != 0
   1831            setTimer(waitTime);
   \                     ??upgradeEndResponseParse_7: (+1)
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   \   00000096   0x.... 0x....      BL       setTimer
   1832            emberAfCoreFlush();
   1833            otaPrintln("Countdown to upgrade: %d ms", waitTime);
   1834            emberAfCoreFlush();
   1835            recordUpgradeStatus(BOOTLOAD_STATE_COUNTDOWN_TO_UPGRADE);
   \   0000009A   0x2009             MOVS     R0,#+9
   \   0000009C   0x.... 0x....      BL       recordUpgradeStatus
   1836            return EMBER_ZCL_STATUS_SUCCESS;
   \                     ??upgradeEndResponseParse_1: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \                     ??upgradeEndResponseParse_4: (+1)
   \   000000A2   0xB005             ADD      SP,SP,#+20
   \   000000A4   0xBDF0             POP      {R4-R7,PC}       ;; return
   1837          }
   1838          

   \                                 In section .text, align 2, keep-with-next
   1839          static boolean calculateTimer(int32u currentTime, 
   1840                                        int32u targetTime, 
   1841                                        int32u* returnTimeMs)
   1842          {
   1843            int32u timeOut = 0;
   1844            boolean validWaitTime = TRUE; 
   1845          
   1846            if (targetTime < currentTime) {
   \                     calculateTimer: (+1)
   \   00000000   0x4281             CMP      R1,R0
   \   00000002   0xD201             BCS.N    ??calculateTimer_0
   1847              otaPrintln("%p: invalid offset currentTime(0x%4X) > upgradeTime(0x%4X)",
   1848                         "Error",
   1849                         currentTime, 
   1850                         targetTime);
   1851              return FALSE;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x4770             BX       LR
   1852            } else {
   1853              timeOut = targetTime - currentTime;
   1854              otaPrintln("OTA Cluster: wait for %d s", timeOut);
   1855            }
   1856            otaPrintln("RXed timeOut 0x%4X s, MAX timeOut 0x%4X s",
   1857                       timeOut, 
   1858                       TIMEOUT_MAX_WAIT_TIME_MS >> 10);   // divide by ~1000
   1859                                                          // save flash by doing a bit shift
   1860            timeOut *= 1000;
   \                     ??calculateTimer_0: (+1)
   \   00000008   0x1A08             SUBS     R0,R1,R0
   \   0000000A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000000E   0x4348             MULS     R0,R1,R0
   1861          
   1862            if (timeOut > TIMEOUT_MAX_WAIT_TIME_MS) {
   \   00000010   0x....             LDR.N    R1,??DataTable35_11  ;; 0x36ee81
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xBF28             IT       CS 
   1863              timeOut = TIMEOUT_MAX_WAIT_TIME_MS;
   \   00000016   0x....             LDRCS.N  R0,??DataTable35_10  ;; 0x36ee80
   1864            }
   1865            *returnTimeMs = timeOut;    
   \   00000018   0x6010             STR      R0,[R2, #+0]
   1866            return validWaitTime;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x4770             BX       LR               ;; return
   1867          }
   1868          

   \                                 In section .text, align 2, keep-with-next
   1869          static void runUpgrade(void)
   1870          {
   \                     runUpgrade: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1871            emberAfCoreFlush();
   1872            otaPrintln("Applying upgrade");
   1873            emberAfCoreFlush();
   1874            
   1875            emberAfOtaClientBootloadCallback(&currentDownloadFile);
   \   00000002   0x....             LDR.N    R0,??DataTable35_12
   \   00000004   0x.... 0x....      BL       emberAfOtaClientBootloadCallback
   1876          
   1877            // If we returned, then something is wrong with the upgrade.  
   1878            // It is expected that an invalid image file is deleted to prevent it
   1879            // from being used a subsequent time.
   1880            queryNextImage(START_NEW_TIMER, 
                                  ^
Warning[Pe188]: enumerated type mixed with another type

  static PGM_P bootloadStateNames[] = {
               ^
"E:\Zigbee\EmberZNet5.6.0-GA\app\framework\plugin\ota-client\ota-client.c",60  Warning[Pe177]: 
          variable "bootloadStateNames" was declared but never referenced
   1881                           FALSE);  // query error?
   \   00000008   0xE8BD 0x4004      POP      {R2,LR}
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             B.N      queryNextImage
   1882          }
   1883          
   1884          // Sends an image block request for a file the server should 
   1885          // not have.  Test harness only (test case 9.5.6 - Missing File)

   \                                 In section .text, align 2, keep-with-next
   1886          void emAfSendImageBlockRequestTest(void)
   1887          {
   \                     emAfSendImageBlockRequestTest: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1888            if (currentBootloadState != BOOTLOAD_STATE_NONE) {
   \   00000002   0x....             LDR.N    R4,??DataTable35_1
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xB980             CBNZ.N   R0,??emAfSendImageBlockRequestTest_0
   1889              otaPrintln("Image block request test only works when state is BOOTLOAD_STATE_NONE");
   1890              return;
   1891            }
   1892          
   1893            updateCurrentOffset(100);
   \   00000008   0x2064             MOVS     R0,#+100
   \   0000000A   0x.... 0x....      BL       updateCurrentOffset
   1894          
   1895            // Values from the test spec.
   1896            currentDownloadFile.manufacturerId = 0xFFF0;
   \   0000000E   0xF64F 0x70F0      MOVW     R0,#+65520
   \   00000012   0x8120             STRH     R0,[R4, #+8]
   1897            currentDownloadFile.imageTypeId    = 0x0000;
   1898            currentDownloadFile.firmwareVersion = 0xFFFFFFF0;
   1899            sendMessage(ZCL_IMAGE_BLOCK_REQUEST_COMMAND_ID, 
   1900                        0,   // upgrade end status (ignored)
   1901                        0);  // timer
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x8160             STRH     R0,[R4, #+10]
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xF06F 0x000F      MVN      R0,#+15
   \   00000020   0x60E0             STR      R0,[R4, #+12]
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xE8BD 0x4010      POP      {R4,LR}
   \   00000028   0x....             B.N      sendMessage
   \                     ??emAfSendImageBlockRequestTest_0: (+1)
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
   1902          }
   1903          

   \                                 In section .text, align 2, keep-with-next
   1904          void emAfSetPageRequest(boolean pageRequestOn)
   1905          {
   1906            usePageRequest = pageRequestOn;
   \                     emAfSetPageRequest: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable35_1
   \   00000002   0x70C8             STRB     R0,[R1, #+3]
   1907          }
   \   00000004   0x4770             BX       LR               ;; return
   1908          

   \                                 In section .text, align 2, keep-with-next
   1909          boolean emAfUsingPageRequest(void)
   1910          {
   1911            return usePageRequest;
   \                     emAfUsingPageRequest: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable35_1
   \   00000002   0x78C0             LDRB     R0,[R0, #+3]
   \   00000004   0x4770             BX       LR               ;; return
   1912          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x........         DC32     myEndpoint

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \   00000000   0x........         DC32     currentBootloadState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_2:
   \   00000000   0x000927C0         DC32     0x927c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_3:
   \   00000000   0x........         DC32     emAfOtaClientServiceDiscoveryCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_4:
   \   00000000   0x........         DC32     emAfEndpoints

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_5:
   \   00000000   0x........         DC32     emAfOtaMinMessageLengths

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_6:
   \   00000000   0x........         DC32     emAfCurrentCommand

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_7:
   \   00000000   0x........         DC32     appResponseLength

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_8:
   \   00000000   0x........         DC32     emberAfResponseApsFrame

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_9:
   \   00000000   0x000493E0         DC32     0x493e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_10:
   \   00000000   0x0036EE80         DC32     0x36ee80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_11:
   \   00000000   0x0036EE81         DC32     0x36ee81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_12:
   \   00000000   0x........         DC32     currentBootloadState+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Download">`:
   \   00000000   0x44 0x6F          DC8 "Download"
   \              0x77 0x6E    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   askServerToRunUpgrade
         8   -> recordUpgradeStatus
         0   -> runUpgrade
         0   -> sendMessage
       0   calculateTimer
       8   commandParse
         0   -> imageBlockResponseParse
         0   -> imageNotifyParse
         0   -> queryNextImageResponseParse
         0   -> upgradeEndResponseParse
      24   continueImageDownload
        24   -> downloadAndVerifyFinish
        24   -> emAfGetCurrentPageRequestStatus
        24   -> emAfInitPageRequestClient
        24   -> emAfNextMissedBlockRequestOffset
        24   -> getCurrentOffset
        24   -> recordUpgradeStatus
        24   -> sendMessage
        24   -> setTimer
        24   -> updateCurrentOffset
      40   continueImageVerification
        40   -> downloadAndVerifyFinish
        40   -> emAfOtaImageSignatureVerify
        40   -> emberAfOtaClientCustomVerifyCallback
        40   -> emberAfOtaStorageCheckTempDataCallback
        40   -> recordUpgradeStatus
        40   -> setTimer
      16   downloadAndVerifyFinish
        16   -> askServerToRunUpgrade
        16   -> emberAfOtaClientDownloadCompleteCallback
        16   -> queryNextImage
        16   -> sendMessage
       0   emAfOtaClientPrintState
      24   emAfOtaClientServiceDiscoveryCallback
        24   -> emberAfFindIeeeAddress
        24   -> emberLookupEui64ByNodeId
        24   -> euiLookupErrorOccurred
        24   -> halCommonMemMove
        24   -> recordServerEuiAndGoToNextState
        24   -> recordUpgradeStatus
        24   -> restartServerDiscoveryAfterDelay
       8   emAfOtaClientStop
         8   -> downloadAndVerifyFinish
         0   -> emberAfDeactivateClientTick
         8   -> recordUpgradeStatus
       0   emAfOtaVerifyStoredDataFinish
         0   -> continueImageVerification
       8   emAfSendImageBlockRequestTest
         0   -> sendMessage
         8   -> updateCurrentOffset
       0   emAfSetPageRequest
       0   emAfUsingPageRequest
       0   emberAfOtaBootloadClusterClientDefaultResponseCallback
         0   -> commandParse
      24   emberAfOtaBootloadClusterClientInitCallback
        24   -> emberAfOtaClientVersionInfoCallback
        24   -> emberAfOtaStorageInitCallback
        24   -> updateCurrentImageAttributes
       0   emberAfOtaBootloadClusterClientTickCallback
         0   -> otaClientTick
       8   emberAfOtaClientIncomingMessageRawCallback
         8   -> commandParse
         8   -> emberAfSendDefaultResponse
       0   emberAfOtaClientStartCallback
         0   -> startServerDiscovery
       8   emberAfPluginOtaClientStackStatusCallback
         8   -> halCommonGetRandom
         8   -> recordUpgradeStatus
         0   -> setTimer
       0   emberAfPluginOtaStorageSimpleEepromEraseCompleteCallback
         0   -> downloadAndVerifyFinish
         0   -> otaClientTick
       0   euiLookupErrorOccurred
         0   -> restartServerDiscoveryAfterDelay
      24   getCurrentOffset
        24   -> emberAfReadAttribute
      56   imageBlockResponseParse
        56   -> calculateTimer
        56   -> continueImageDownload
        56   -> continueImageVerification
        56   -> downloadAndVerifyFinish
        56   -> emAfAbortPageRequest
        56   -> emAfGetCurrentPageRequestStatus
        56   -> emAfGetFinishedPageRequestOffset
        56   -> emAfGetPageRequestMissedPacketDelayMs
        56   -> emAfHandlingPageRequestClient
        56   -> emAfNoteReceivedBlockForPageRequestClient
        56   -> emAfOtaParseImageIdFromMessage
        56   -> emAfPrintPercentageUpdate
        56   -> emberAfGetInt16u
        56   -> emberAfGetInt32u
        56   -> emberAfOtaStorageFinishDownloadCallback
        56   -> emberAfOtaStorageWriteTempDataCallback
        56   -> getCurrentOffset
        56   -> halCommonMemCompare
        56   -> setTimer
        56   -> updateCurrentOffset
      40   imageNotifyParse
        40   -> emberAfGetInt16u
        40   -> emberAfGetInt32u
        40   -> emberAfOtaClientVersionInfoCallback
        40   -> halCommonGetRandom
        40   -> queryNextImage
       8   otaClientTick
         0   -> askServerToRunUpgrade
         0   -> continueImageDownload
         0   -> continueImageVerification
         8   -> emAfPageRequestTimerExpired
         0   -> emberAfOtaClientStartCallback
         0   -> euiLookupErrorOccurred
         0   -> queryNextImage
         0   -> runUpgrade
         0   -> setTimer
         0   -> startServerDiscovery
       8   putImageInfoInMessage
         8   -> emberAfPutInt16uInResp
         0   -> emberAfPutInt32uInResp
      24   queryNextImage
        24   -> emberAfOtaClientVersionInfoCallback
        24   -> recordUpgradeStatus
         0   -> restartServerDiscoveryAfterDelay
         0   -> sendMessage
         0   -> setTimer
        24   -> updateCurrentImageAttributes
      64   queryNextImageResponseParse
        64   -> __aeabi_memcpy4
        64   -> continueImageDownload
        64   -> downloadAndVerifyFinish
        64   -> emAfOtaParseImageIdFromMessage
        64   -> emAfPrintPercentageSetStartAndEnd
        64   -> emberAfDeactivateClientTick
        64   -> emberAfGetInt32u
        64   -> emberAfIsOtaImageIdValid
        64   -> emberAfOtaStorageClearTempDataCallback
        64   -> emberAfOtaStorageDeleteImageCallback
        64   -> emberAfOtaStorageDriverMaxDownloadSizeCallback
        64   -> emberAfOtaStorageSearchCallback
        64   -> queryNextImage
        64   -> recordUpgradeStatus
        64   -> updateCurrentOffset
        64   -> updateDownloadFileVersion
      32   recordServerEuiAndGoToNextState
        32   -> continueImageDownload
        32   -> continueImageVerification
        32   -> downloadAndVerifyFinish
        32   -> emAfPrintPercentageSetStartAndEnd
        32   -> emberAfOtaClientVersionInfoCallback
        32   -> emberAfOtaStorageCheckTempDataCallback
        32   -> emberAfOtaStorageDriverPrepareToResumeDownloadCallback
        32   -> emberAfWriteAttribute
        32   -> queryNextImage
        32   -> recordUpgradeStatus
        32   -> updateCurrentOffset
        32   -> updateDownloadFileVersion
      16   recordUpgradeStatus
        16   -> emberAfWriteAttribute
       8   restartServerDiscoveryAfterDelay
         0   -> recordUpgradeStatus
         8   -> setTimer
       8   runUpgrade
         8   -> emberAfOtaClientBootloadCallback
         0   -> queryNextImage
      40   sendMessage
        40   -> emberAfGetEui64
        40   -> emberAfIndexFromEndpoint
        40   -> emberAfNextSequence
        40   -> emberAfPutBlockInResp
        40   -> emberAfPutInt16uInResp
        40   -> emberAfPutInt32uInResp
        40   -> emberAfPutInt8uInResp
        40   -> emberAfSendCommandUnicast
        40   -> getCurrentOffset
        40   -> putImageInfoInMessage
        40   -> setTimer
      24   setTimer
        24   -> emAfGetCurrentPageRequestStatus
        24   -> emberAfScheduleClientTickExtended
       8   startServerDiscovery
         8   -> emberAfFindDevicesByProfileAndCluster
         8   -> emberAfIndexFromEndpoint
         8   -> recordUpgradeStatus
         0   -> setTimer
      16   updateCurrentImageAttributes
        16   -> emberAfWriteAttribute
      16   updateCurrentOffset
        16   -> emberAfWriteAttribute
       0   updateDownloadFileVersion
      40   upgradeEndResponseParse
        40   -> calculateTimer
        40   -> downloadAndVerifyFinish
        40   -> emAfOtaParseImageIdFromMessage
        40   -> emberAfGetInt32u
        40   -> recordUpgradeStatus
        40   -> setTimer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "Download">
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable35_10
       4  ??DataTable35_11
       4  ??DataTable35_12
       4  ??DataTable35_2
       4  ??DataTable35_3
       4  ??DataTable35_4
       4  ??DataTable35_5
       4  ??DataTable35_6
       4  ??DataTable35_7
       4  ??DataTable35_8
       4  ??DataTable35_9
       6  ?Subroutine0
      10  ?Subroutine1
       4  ?Subroutine2
      12  ?Subroutine3
      10  ?Subroutine4
       8  ?Subroutine5
      36  askServerToRunUpgrade
      12  bootloadStateToExternalState
      30  calculateTimer
     168  commandParse
      98  continueImageDownload
     144  continueImageVerification
      36  currentBootloadState
          errors
          waitingForResponse
          usePageRequest
          customVerifyStatus
          currentDownloadFile
          hardwareVersion
          minBlockRequestPeriodMs
          totalImageSize
          nextEventTimer
      88  downloadAndVerifyFinish
       2  emAfOtaClientPrintState
     128  emAfOtaClientServiceDiscoveryCallback
      34  emAfOtaClientStop
       1  emAfOtaClientStopDownloadPercentage
      16  emAfOtaVerifyStoredDataFinish
      44  emAfSendImageBlockRequestTest
       6  emAfSetPageRequest
       6  emAfUsingPageRequest
      28  emberAfOtaBootloadClusterClientDefaultResponseCallback
      48  emberAfOtaBootloadClusterClientInitCallback
       2  emberAfOtaBootloadClusterClientTickCallback
      34  emberAfOtaClientIncomingMessageRawCallback
      18  emberAfOtaClientStartCallback
      40  emberAfPluginOtaClientStackStatusCallback
      26  emberAfPluginOtaStorageSimpleEepromEraseCompleteCallback
      10  euiLookupErrorOccurred
      40  getCurrentOffset
     378  imageBlockResponseParse
     150  imageNotifyParse
       4  imageNotifyPayloadLengths
       4  myEndpoint
          serverEndpoint
          serverNodeId
     128  otaClientTick
      28  putImageInfoInMessage
     104  queryNextImage
     232  queryNextImageResponseParse
     166  recordServerEuiAndGoToNextState
      40  recordUpgradeStatus
      18  restartServerDiscoveryAfterDelay
      18  runUpgrade
     266  sendMessage
      82  setTimer
      76  startServerDiscovery
      28  updateCurrentImageAttributes
      30  updateCurrentOffset
       8  updateDownloadFileVersion
     166  upgradeEndResponseParse
       8  zclStatusFromResult

 
    36 bytes in section .bss
     5 bytes in section .data
 3 102 bytes in section .text
 
 3 102 bytes of CODE memory
    41 bytes of DATA memory

Errors: none
Warnings: 2

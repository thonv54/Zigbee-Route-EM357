###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        22/Oct/2015  09:33:36
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\framework\plugin\level-control\level-control.c
#    Command line =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\framework\plugin\level-control\level-control.c
#        -D DIMMER -D NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D
#        CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"level-control.c\"" -lC
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\List\
#        --diag_suppress Pa050 -o
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\Obj\ --debug
#        --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\framework\plugin\level-control\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\List\level-control.lst
#    Object file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\Obj\level-control.o
#
###############################################################################

E:\Zigbee\EmberZNet5.6.0-GA\app\framework\plugin\level-control\level-control.c
      1          // *******************************************************************
      2          // * level-control.c
      3          // *                                  +
      4          // *
      5          // * Copyright 2014 Silicon Laboratories, Inc.                              *80*
      6          // *******************************************************************
      7          
      8          // this file contains all the common includes for clusters in the util
      9          #include "app/framework/include/af.h"
     10          
     11          // clusters specific header
     12          #include "level-control.h"
     13          #include "UART_task.h"
     14          
     15          #ifdef EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER
     16            #include "app/framework/plugin/zll-level-control-server/zll-level-control-server.h"
     17          #endif //EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER
     18          
     19          #if (EMBER_AF_PLUGIN_LEVEL_CONTROL_RATE == 0)
     20            #define FASTEST_TRANSITION_TIME_MS 30
     21          #else
     22            #define FASTEST_TRANSITION_TIME_MS (MILLISECOND_TICKS_PER_SECOND / EMBER_AF_PLUGIN_LEVEL_CONTROL_RATE)
     23          #endif
     24          
     25          #ifdef EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER
     26            #define MIN_LEVEL EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER_MINIMUM_LEVEL
     27            #define MAX_LEVEL EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER_MAXIMUM_LEVEL
     28          #else
     29            #define MIN_LEVEL EMBER_AF_PLUGIN_LEVEL_CONTROL_MINIMUM_LEVEL
     30            #define MAX_LEVEL EMBER_AF_PLUGIN_LEVEL_CONTROL_MAXIMUM_LEVEL
     31          #endif
     32          
     33          #define INVALID_STORED_LEVEL 0xFF
     34          
     35          typedef struct {
     36            int8u commandId;
     37            int8u moveToLevel;
     38            boolean increasing;
     39            boolean useOnLevel;
     40            int8u onLevel;
     41            int8u storedLevel;
     42            int32u eventDurationMs;
     43            int32u transitionTimeMs;
     44            int32u elapsedTimeMs;
     45          } EmberAfLevelControlState;
     46          

   \                                 In section .bss, align 4
     47          static EmberAfLevelControlState stateTable[EMBER_AF_LEVEL_CONTROL_CLUSTER_SERVER_ENDPOINT_COUNT];
   \                     stateTable:
   \   00000000                      DS8 20
     48          
     49          static EmberAfLevelControlState *getState(int8u endpoint);
     50          
     51          static void moveToLevelHandler(int8u commandId,
     52                                         int8u level,
     53                                         int16u transitionTimeDs,
     54                                         int8u storedLevel);
     55          static void moveHandler(int8u commandId, int8u moveMode, int8u rate);
     56          static void stepHandler(int8u commandId,
     57                                  int8u stepMode,
     58                                  int8u stepSize,
     59                                  int16u transitionTimeDs);
     60          static void stopHandler(int8u commandId);
     61          
     62          static void setOnOffValue(int8u endpoint, boolean onOff);
     63          static void writeRemainingTime(int8u endpoint, int16u remainingTimeMs);
     64          

   \                                 In section .text, align 2, keep-with-next
     65          static void schedule(int8u endpoint, int32u delayMs)
     66          {
   \                     schedule: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     67            emberAfScheduleServerTickExtended(endpoint,
     68                                              ZCL_LEVEL_CONTROL_CLUSTER_ID,
     69                                              delayMs,
     70                                              EMBER_AF_LONG_POLL,
     71                                              EMBER_AF_OK_TO_SLEEP);
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x9200             STR      R2,[SP, #+0]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x460A             MOV      R2,R1
   \   0000000A   0x2108             MOVS     R1,#+8
   \   0000000C   0x.... 0x....      BL       emberAfScheduleServerTickExtended
     72          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
     73          

   \                                 In section .text, align 2, keep-with-next
     74          static void deactivate(int8u endpoint)
     75          {
     76            emberAfDeactivateServerTick(endpoint, ZCL_LEVEL_CONTROL_CLUSTER_ID);
   \                     deactivate: (+1)
   \   00000000   0x2108             MOVS     R1,#+8
   \   00000002   0x.... 0x....      B.W      emberAfDeactivateServerTick
     77          }
     78          

   \                                 In section .text, align 2, keep-with-next
     79          static EmberAfLevelControlState *getState(int8u endpoint)
     80          {
   \                     getState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     81            int8u ep = emberAfFindClusterServerEndpointIndex(endpoint,
     82                                                             ZCL_LEVEL_CONTROL_CLUSTER_ID);
   \   00000002   0x2108             MOVS     R1,#+8
   \   00000004   0x.... 0x....      BL       emberAfFindClusterServerEndpointIndex
     83            return (ep == 0xFF ? NULL : &stateTable[ep]);
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xD101             BNE.N    ??getState_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD02             POP      {R1,PC}
   \                     ??getState_0: (+1)
   \   00000010   0x2114             MOVS     R1,#+20
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable5
   \   00000016   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return
     84          }
     85          

   \                                 In section .text, align 2, keep-with-next
     86          void emberAfLevelControlClusterServerInitCallback(int8u endpoint)
     87          {
     88          }
   \                     emberAfLevelControlClusterServerInitCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     89          

   \                                 In section .text, align 2, keep-with-next
     90          void emberAfLevelControlClusterServerTickCallback(int8u endpoint)
     91          {
   \                     emberAfLevelControlClusterServerTickCallback: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
     92            EmberAfLevelControlState *state = getState(endpoint);
   \   00000004   0x.... 0x....      BL       getState
   \   00000008   0x0005             MOVS     R5,R0
     93            EmberAfStatus status;
     94            int8u currentLevel;
     95          
     96            if (state == NULL) {
   \   0000000A   0xD07A             BEQ.N    ??emberAfLevelControlClusterServerTickCallback_0
     97              return;
     98            }
     99          
    100            state->elapsedTimeMs += state->eventDurationMs;
   \   0000000C   0x6928             LDR      R0,[R5, #+16]
   \   0000000E   0x68A9             LDR      R1,[R5, #+8]
   \   00000010   0x1808             ADDS     R0,R1,R0
   \   00000012   0x6128             STR      R0,[R5, #+16]
    101          
    102          #ifdef EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER
    103            if (emberAfPluginZllLevelControlServerIgnoreMoveToLevelMoveStepStop(endpoint,
    104                                                                                state->commandId)) {
    105              return;
    106            }
    107          #endif
    108          
    109            // Read the attribute; print error message and return if it can't be read
    110            status = emberAfReadServerAttribute(endpoint,
    111                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    112                                                ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    113                                                (int8u *)&currentLevel,
    114                                                sizeof(currentLevel));
    115            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \   00000014   0xAB01             ADD      R3,SP,#+4
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x2108             MOVS     R1,#+8
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       emberAfReadServerAttribute
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD171             BNE.N    ??emberAfLevelControlClusterServerTickCallback_1
    116              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    117              writeRemainingTime(endpoint, 0);
    118              return;
    119            }
    120          
    121            emberAfLevelControlClusterPrint("Event: move from %d", currentLevel);
    122          
    123            // adjust by the proper amount, either up or down
    124            if (state->increasing) {
   \   00000028   0x78A8             LDRB     R0,[R5, #+2]
   \   0000002A   0x.... 0x....      ADR.W    R6,`?<Constant "level-control.c">`
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000034   0xD010             BEQ.N    ??emberAfLevelControlClusterServerTickCallback_2
    125              assert(currentLevel < MAX_LEVEL);
   \   00000036   0x28FF             CMP      R0,#+255
   \   00000038   0xD102             BNE.N    ??CrossCallReturnLabel_8
   \   0000003A   0x217D             MOVS     R1,#+125
   \   0000003C   0x.... 0x....      BL       ?Subroutine6
    126              assert(currentLevel < state->moveToLevel);
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000040   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000044   0x7869             LDRB     R1,[R5, #+1]
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD302             BCC.N    ??CrossCallReturnLabel_7
   \   0000004A   0x217E             MOVS     R1,#+126
   \   0000004C   0x.... 0x....      BL       ?Subroutine6
    127              currentLevel++;
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000050   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000054   0x1C40             ADDS     R0,R0,#+1
   \   00000056   0xE00E             B.N      ??emberAfLevelControlClusterServerTickCallback_3
    128          
    129          
    130          #ifdef DIMMER
    131          	#ifndef CURTAIN
    132          	  	//		Send to Level Change to MC
    133          
    134          
    135          				int8u OnOffValue;
    136          				emberAfReadServerAttribute(DimmerInClusterEndpoint,
    137          										   ZCL_ON_OFF_CLUSTER_ID,
    138          										   ZCL_ON_OFF_ATTRIBUTE_ID,
    139          										   (int8u *)&OnOffValue,
    140          										   sizeof(OnOffValue));
    141          				if(OnOffValue == 1){
    142          					UartSendDimLevel(currentLevel);
    143          				}
    144          		//		UartSendCommand();
    145          	#endif
    146          #endif
    147          
    148            } else {
    149              assert(MIN_LEVEL < currentLevel);
   \                     ??emberAfLevelControlClusterServerTickCallback_2: (+1)
   \   00000058   0xB910             CBNZ.N   R0,??CrossCallReturnLabel_6
   \   0000005A   0x2195             MOVS     R1,#+149
   \   0000005C   0x.... 0x....      BL       ?Subroutine6
    150              assert(state->moveToLevel < currentLevel);
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000060   0x7868             LDRB     R0,[R5, #+1]
   \   00000062   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xD302             BCC.N    ??CrossCallReturnLabel_5
   \   0000006A   0x2196             MOVS     R1,#+150
   \   0000006C   0x.... 0x....      BL       ?Subroutine6
    151              currentLevel--;
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000070   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \                     ??emberAfLevelControlClusterServerTickCallback_3: (+1)
   \   00000076   0xF88D 0x0004      STRB     R0,[SP, #+4]
    152          #ifdef DIMMER
    153          	#ifndef CURTAIN
    154          		//		Send to Level Change to MC
    155          			int8u OnOffValue;
    156          			emberAfReadServerAttribute(DimmerInClusterEndpoint,
    157          									   ZCL_ON_OFF_CLUSTER_ID,
    158          									   ZCL_ON_OFF_ATTRIBUTE_ID,
    159          									   (int8u *)&OnOffValue,
    160          									   sizeof(OnOffValue));
   \   0000007A   0xF10D 0x0305      ADD      R3,SP,#+5
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x9000             STR      R0,[SP, #+0]
   \   00000082   0x2200             MOVS     R2,#+0
   \   00000084   0x2106             MOVS     R1,#+6
   \   00000086   0x.... 0x....      BL       emberAfReadServerAttribute
    161          			if(OnOffValue == 1){
   \   0000008A   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000008E   0x2801             CMP      R0,#+1
   \   00000090   0xBF04             ITT      EQ 
    162          				UartSendDimLevel(currentLevel);
   \   00000092   0xF89D 0x0004      LDRBEQ   R0,[SP, #+4]
   \   00000096   0x.... 0x....      BLEQ     UartSendDimLevel
    163          			}
    164          		//			UartSendCommand();
    165          	#endif
    166          #endif
    167            }
    168          
    169            emberAfLevelControlClusterPrint(" to %d ", currentLevel);
    170            emberAfLevelControlClusterPrintln("(diff %c1)",
    171                                              state->increasing ? '+' : '-');
    172          
    173            status = emberAfWriteServerAttribute(endpoint,
    174                                                 ZCL_LEVEL_CONTROL_CLUSTER_ID,
    175                                                 ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    176                                                 (int8u *)&currentLevel,
    177                                                 ZCL_INT8U_ATTRIBUTE_TYPE);
    178          
    179          
    180          
    181          
    182          
    183            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \   0000009A   0x2020             MOVS     R0,#+32
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   \   0000009E   0xAB01             ADD      R3,SP,#+4
   \   000000A0   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_4: (+1)
   \   000000A4   0xBB90             CBNZ.N   R0,??emberAfLevelControlClusterServerTickCallback_1
    184              emberAfLevelControlClusterPrintln("ERR: writing current level %x", status);
    185              writeRemainingTime(endpoint, 0);
    186              return;
    187            }
    188          
    189            // The level has changed, so the scene is no longer valid.
    190            if (emberAfContainsServer(endpoint, ZCL_SCENES_CLUSTER_ID)) {
   \   000000A6   0x2105             MOVS     R1,#+5
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0x.... 0x....      BL       emberAfContainsServer
   \   000000AE   0xB110             CBZ.N    R0,??emberAfLevelControlClusterServerTickCallback_4
    191              emberAfScenesClusterMakeInvalidCallback(endpoint);
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       emberAfScenesClusterMakeInvalidCallback
    192            }
    193          
    194            // Are we at the requested level?
    195            if (currentLevel == state->moveToLevel) {
   \                     ??emberAfLevelControlClusterServerTickCallback_4: (+1)
   \   000000B6   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000BA   0x7869             LDRB     R1,[R5, #+1]
   \   000000BC   0x4288             CMP      R0,R1
   \   000000BE   0xD121             BNE.N    ??emberAfLevelControlClusterServerTickCallback_5
    196              if (state->commandId == ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID
    197                  || state->commandId == ZCL_MOVE_WITH_ON_OFF_COMMAND_ID
    198                  || state->commandId == ZCL_STEP_WITH_ON_OFF_COMMAND_ID) {
   \   000000C0   0x7828             LDRB     R0,[R5, #+0]
   \   000000C2   0x2804             CMP      R0,#+4
   \   000000C4   0xBF1C             ITT      NE 
   \   000000C6   0x2805             CMPNE    R0,#+5
   \   000000C8   0x2806             CMPNE    R0,#+6
   \   000000CA   0xD10F             BNE.N    ??emberAfLevelControlClusterServerTickCallback_6
    199                setOnOffValue(endpoint, (currentLevel != MIN_LEVEL));
   \   000000CC   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   000000D0   0xB101             CBZ.N    R1,??emberAfLevelControlClusterServerTickCallback_7
   \   000000D2   0x2101             MOVS     R1,#+1
   \                     ??emberAfLevelControlClusterServerTickCallback_7: (+1)
   \   000000D4   0x4620             MOV      R0,R4
   \   000000D6   0x.... 0x....      BL       setOnOffValue
    200                if (currentLevel == MIN_LEVEL && state->useOnLevel) {
   \   000000DA   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000DE   0xB9A8             CBNZ.N   R0,??emberAfLevelControlClusterServerTickCallback_1
   \   000000E0   0x78E8             LDRB     R0,[R5, #+3]
   \   000000E2   0xB198             CBZ.N    R0,??emberAfLevelControlClusterServerTickCallback_1
    201                  status = emberAfWriteServerAttribute(endpoint,
    202                                                       ZCL_LEVEL_CONTROL_CLUSTER_ID,
    203                                                       ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    204                                                       (int8u *)&state->onLevel,
    205                                                       ZCL_INT8U_ATTRIBUTE_TYPE);
   \   000000E4   0x2020             MOVS     R0,#+32
   \   000000E6   0x9000             STR      R0,[SP, #+0]
   \   000000E8   0x1D2B             ADDS     R3,R5,#+4
   \   000000EA   0xE005             B.N      ??emberAfLevelControlClusterServerTickCallback_8
    206                  if (status != EMBER_ZCL_STATUS_SUCCESS) {
    207                    emberAfLevelControlClusterPrintln("ERR: writing current level %x",
    208                                                      status);
    209                  }
    210                }
    211              } else {
    212                if (state->storedLevel != INVALID_STORED_LEVEL) {
   \                     ??emberAfLevelControlClusterServerTickCallback_6: (+1)
   \   000000EC   0x7968             LDRB     R0,[R5, #+5]
   \   000000EE   0x28FF             CMP      R0,#+255
   \   000000F0   0xD00C             BEQ.N    ??emberAfLevelControlClusterServerTickCallback_1
    213                  status = emberAfWriteServerAttribute(endpoint,
    214                                                       ZCL_LEVEL_CONTROL_CLUSTER_ID,
    215                                                       ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    216                                                       (int8u *)&state->storedLevel,
    217                                                       ZCL_INT8U_ATTRIBUTE_TYPE);
   \   000000F2   0x2020             MOVS     R0,#+32
   \   000000F4   0x9000             STR      R0,[SP, #+0]
   \   000000F6   0x1D6B             ADDS     R3,R5,#+5
   \                     ??emberAfLevelControlClusterServerTickCallback_8: (+1)
   \   000000F8   0x2200             MOVS     R2,#+0
   \   000000FA   0x2108             MOVS     R1,#+8
   \   000000FC   0x4620             MOV      R0,R4
   \   000000FE   0x.... 0x....      BL       emberAfWriteServerAttribute
    218                if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \                     ??emberAfLevelControlClusterServerTickCallback_0: (+1)
   \   00000102   0xBD73             POP      {R0,R1,R4-R6,PC}
    219                  emberAfLevelControlClusterPrintln("ERR: writing current level %x",
    220                                                    status);
    221                  }
    222                }
    223              }
    224              writeRemainingTime(endpoint, 0);
    225            } else {
    226              writeRemainingTime(endpoint,
    227                                 state->transitionTimeMs - state->elapsedTimeMs);
    228              schedule(endpoint, state->eventDurationMs);
   \                     ??emberAfLevelControlClusterServerTickCallback_5: (+1)
   \   00000104   0x68A9             LDR      R1,[R5, #+8]
   \   00000106   0x4620             MOV      R0,R4
   \   00000108   0x.... 0x....      BL       schedule
    229            }
    230          }
   \                     ??emberAfLevelControlClusterServerTickCallback_1: (+1)
   \   0000010C   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x4630             MOV      R0,R6
   \   00000002   0x.... 0x....      B.W      halInternalAssertFailed

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x2108             MOVS     R1,#+8
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      B.W      emberAfWriteServerAttribute
    231          
    232          static void writeRemainingTime(int8u endpoint, int16u remainingTimeMs)
    233          {
    234          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_LEVEL_CONTROL_REMAINING_TIME_ATTRIBUTE
    235            // Convert milliseconds to tenths of a second, rounding any fractional value
    236            // up to the nearest whole value.  This means:
    237            //
    238            //   0 ms = 0.00 ds = 0 ds
    239            //   1 ms = 0.01 ds = 1 ds
    240            //   ...
    241            //   100 ms = 1.00 ds = 1 ds
    242            //   101 ms = 1.01 ds = 2 ds
    243            //   ...
    244            //   200 ms = 2.00 ds = 2 ds
    245            //   201 ms = 2.01 ds = 3 ds
    246            //   ...
    247            //
    248            // This is done to ensure that the attribute, in tenths of a second, only
    249            // goes to zero when the remaining time in milliseconds is actually zero.
    250            int16u remainingTimeDs = (remainingTimeMs + 99) / 100;
    251            EmberAfStatus status = emberAfWriteServerAttribute(endpoint,
    252                                                             ZCL_LEVEL_CONTROL_CLUSTER_ID,
    253                                                             ZCL_LEVEL_CONTROL_REMAINING_TIME_ATTRIBUTE_ID,
    254                                                             (int8u *)&remainingTimeDs,
    255                                                             sizeof(remainingTimeDs));
    256            if (status != EMBER_ZCL_STATUS_SUCCESS) {
    257              emberAfLevelControlClusterPrintln("ERR: writing remaining time %x", status);
    258            }
    259          #endif
    260          }
    261          

   \                                 In section .text, align 2, keep-with-next
    262          static void setOnOffValue(int8u endpoint, boolean onOff)
    263          {
   \                     setOnOffValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
    264            if (emberAfContainsServer(endpoint, ZCL_ON_OFF_CLUSTER_ID)) {
   \   00000006   0x2106             MOVS     R1,#+6
   \   00000008   0x.... 0x....      BL       emberAfContainsServer
   \   0000000C   0xB140             CBZ.N    R0,??setOnOffValue_0
    265              emberAfLevelControlClusterPrintln("Setting on/off to %p due to level change",
    266                                                onOff ? "ON" : "OFF");
    267              emberAfOnOffClusterSetValueCallback(endpoint,
    268                                   (onOff ? ZCL_ON_COMMAND_ID : ZCL_OFF_COMMAND_ID),
    269                                   TRUE);
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xBF18             IT       NE 
   \   00000012   0x2101             MOVNE    R1,#+1
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x.... 0x....      B.W      emberAfOnOffClusterSetValueCallback
    270            }
    271          }
   \                     ??setOnOffValue_0: (+1)
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    272          

   \                                 In section .text, align 2, keep-with-next
    273          boolean emberAfLevelControlClusterMoveToLevelCallback(int8u level,
    274                                                                int16u transitionTime)
    275          {
   \                     emberAfLevelControlClusterMoveToLevelCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    276            emberAfLevelControlClusterPrintln("%pMOVE_TO_LEVEL %x %2x",
    277                                              "RX level-control:",
    278                                              level,
    279                                              transitionTime);
    280            moveToLevelHandler(ZCL_MOVE_TO_LEVEL_COMMAND_ID,
    281                               level,
    282                               transitionTime,
    283                               INVALID_STORED_LEVEL); // Don't revert to the stored level
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0x23FF             MOVS     R3,#+255
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             B.N      ?Subroutine0
    284            return TRUE;
    285          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      BL       moveToLevelHandler
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    286          

   \                                 In section .text, align 2, keep-with-next
    287          boolean emberAfLevelControlClusterMoveToLevelWithOnOffCallback(int8u level,
    288                                                                         int16u transitionTime)
    289          {
   \                     emberAfLevelControlClusterMoveToLevelWithOnOffCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    290            emberAfLevelControlClusterPrintln("%pMOVE_TO_LEVEL_WITH_ON_OFF %x %2x",
    291                                              "RX level-control:",
    292                                              level,
    293                                              transitionTime);
    294            moveToLevelHandler(ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID,
    295                               level,
    296                               transitionTime,
    297                               INVALID_STORED_LEVEL); // Don't revert to the stored level
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0x23FF             MOVS     R3,#+255
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A                      REQUIRE ?Subroutine0
   \   0000000A                      ;; // Fall through to label ?Subroutine0
    298            return TRUE;
    299          }
    300          

   \                                 In section .text, align 2, keep-with-next
    301          boolean emberAfLevelControlClusterMoveCallback(int8u moveMode, int8u rate)
    302          {
   \                     emberAfLevelControlClusterMoveCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    303            emberAfLevelControlClusterPrintln("%pMOVE %x %x",
    304                                              "RX level-control:",
    305                                              moveMode,
    306                                              rate);
    307            moveHandler(ZCL_MOVE_COMMAND_ID, moveMode, rate);
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x....             B.N      ?Subroutine1
    308            return TRUE;
    309          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x.... 0x....      BL       moveHandler
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    310          

   \                                 In section .text, align 2, keep-with-next
    311          boolean emberAfLevelControlClusterMoveWithOnOffCallback(int8u moveMode, int8u rate)
    312          {
   \                     emberAfLevelControlClusterMoveWithOnOffCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    313            emberAfLevelControlClusterPrintln("%pMOVE_WITH_ON_OFF %x %x",
    314                                              "RX level-control:",
    315                                              moveMode,
    316                                              rate);
    317            moveHandler(ZCL_MOVE_WITH_ON_OFF_COMMAND_ID, moveMode, rate);
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0x2005             MOVS     R0,#+5
   \   00000008                      REQUIRE ?Subroutine1
   \   00000008                      ;; // Fall through to label ?Subroutine1
    318            return TRUE;
    319          }
    320          

   \                                 In section .text, align 2, keep-with-next
    321          boolean emberAfLevelControlClusterStepCallback(int8u stepMode,
    322                                                         int8u stepSize,
    323                                                         int16u transitionTime)
    324          {
    325            emberAfLevelControlClusterPrintln("%pSTEP %x %x %2x",
    326                                              "RX level-control:",
    327                                              stepMode,
    328                                              stepSize,
    329                                              transitionTime);
    330            stepHandler(ZCL_STEP_COMMAND_ID, stepMode, stepSize, transitionTime);
   \                     emberAfLevelControlClusterStepCallback: (+1)
   \   00000000   0x4613             MOV      R3,R2
   \   00000002   0xB580             PUSH     {R7,LR}
   \   00000004   0x460A             MOV      R2,R1
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x....             B.N      ?Subroutine2
    331            return TRUE;
    332          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x.... 0x....      BL       stepHandler
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    333          

   \                                 In section .text, align 2, keep-with-next
    334          boolean emberAfLevelControlClusterStepWithOnOffCallback(int8u stepMode,
    335                                                                  int8u stepSize,
    336                                                                  int16u transitionTime)
    337          {
    338            emberAfLevelControlClusterPrintln("%pSTEP_WITH_ON_OFF %x %x %2x",
    339                                              "RX level-control:",
    340                                              stepMode,
    341                                              stepSize,
    342                                              transitionTime);
    343            stepHandler(ZCL_STEP_WITH_ON_OFF_COMMAND_ID,
    344                        stepMode,
    345                        stepSize,
    346                        transitionTime);
   \                     emberAfLevelControlClusterStepWithOnOffCallback: (+1)
   \   00000000   0x4613             MOV      R3,R2
   \   00000002   0xB580             PUSH     {R7,LR}
   \   00000004   0x460A             MOV      R2,R1
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0x2006             MOVS     R0,#+6
   \   0000000A                      REQUIRE ?Subroutine2
   \   0000000A                      ;; // Fall through to label ?Subroutine2
    347            return TRUE;
    348          }
    349          

   \                                 In section .text, align 2, keep-with-next
    350          boolean emberAfLevelControlClusterStopCallback(void)
    351          {
   \                     emberAfLevelControlClusterStopCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    352            emberAfLevelControlClusterPrintln("%pSTOP", "RX level-control:");
    353            stopHandler(ZCL_STOP_COMMAND_ID);
   \   00000002   0x2003             MOVS     R0,#+3
   \   00000004   0x....             B.N      ?Subroutine3
    354            return TRUE;
    355          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x.... 0x....      BL       stopHandler
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    356          

   \                                 In section .text, align 2, keep-with-next
    357          boolean emberAfLevelControlClusterStopWithOnOffCallback(void)
    358          {
   \                     emberAfLevelControlClusterStopWithOnOffCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    359            emberAfLevelControlClusterPrintln("%pSTOP_WITH_ON_OFF", "RX level-control:");
    360            stopHandler(ZCL_STOP_WITH_ON_OFF_COMMAND_ID);
   \   00000002   0x2007             MOVS     R0,#+7
   \   00000004                      REQUIRE ?Subroutine3
   \   00000004                      ;; // Fall through to label ?Subroutine3
    361            return TRUE;
    362          }
    363          

   \                                 In section .text, align 2, keep-with-next
    364          static void moveToLevelHandler(int8u commandId,
    365                                         int8u level,
    366                                         int16u transitionTimeDs,
    367                                         int8u storedLevel)
    368          {
   \                     moveToLevelHandler: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
    369            int8u endpoint = emberAfCurrentEndpoint();
   \   00000004   0x....             LDR.N    R4,??DataTable5_1
   \   00000006   0x4605             MOV      R5,R0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0xB083             SUB      SP,SP,#+12
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF890 0x8005      LDRB     R8,[R0, #+5]
   \   00000012   0x460F             MOV      R7,R1
   \   00000014   0x4691             MOV      R9,R2
   \   00000016   0x469B             MOV      R11,R3
    370            EmberAfLevelControlState *state = getState(endpoint);
   \   00000018   0x4640             MOV      R0,R8
   \   0000001A   0x.... 0x....      BL       getState
   \   0000001E   0x0006             MOVS     R6,R0
    371            EmberAfStatus status;
    372            int8u currentLevel;
    373            int8u actualStepSize;
    374          
    375            if (state == NULL) {
   \   00000020   0xBF08             IT       EQ 
    376              status = EMBER_ZCL_STATUS_FAILURE;
   \   00000022   0xF04F 0x0A01      MOVEQ    R10,#+1
    377              goto send_default_response;
   \   00000026   0xD044             BEQ.N    ??moveToLevelHandler_0
    378            }
    379          
    380            // Cancel any currently active command before fiddling with the state.
    381            deactivate(endpoint);
   \   00000028   0x4640             MOV      R0,R8
   \   0000002A   0x.... 0x....      BL       deactivate
    382          
    383            status = emberAfReadServerAttribute(endpoint,
    384                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    385                                                ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    386                                                (int8u *)&currentLevel,
    387                                                sizeof(currentLevel));
   \   0000002E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000032   0x4640             MOV      R0,R8
   \   00000034   0x.... 0x....      BL       emberAfReadServerAttribute
   \   00000038   0xEA5F 0x0A00      MOVS     R10,R0
    388            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \   0000003C   0xD139             BNE.N    ??moveToLevelHandler_0
    389              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    390              goto send_default_response;
    391            }
    392          
    393            state->commandId = commandId;
   \   0000003E   0x7035             STRB     R5,[R6, #+0]
    394          
    395            // Move To Level commands cause the device to move from its current level to
    396            // the specified level at the specified rate.
    397            if (MAX_LEVEL < level) {
                                 ^
Warning[Pa084]: pointless integer comparison, the result is always false
    398              state->moveToLevel = MAX_LEVEL;
    399            } else if (level < MIN_LEVEL) {
                                    ^
Warning[Pe186]: pointless comparison of unsigned integer with zero
    400              state->moveToLevel = MIN_LEVEL;
    401            } else {
    402              state->moveToLevel = level;
   \   00000040   0x7077             STRB     R7,[R6, #+1]
    403            }
    404          
    405            // If the level is decreasing, the On/Off attribute is left unchanged.  This
    406            // logic is to prevent a light from transitioning from off to bright to dim.
    407            // Instead, a light that is off will stay off until the target level is
    408            // reached.
    409            if (currentLevel <= state->moveToLevel) {
   \   00000042   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000046   0x428F             CMP      R7,R1
   \   00000048   0xD312             BCC.N    ??moveToLevelHandler_1
    410              if (commandId == ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID) {
   \   0000004A   0x2D04             CMP      R5,#+4
   \   0000004C   0xD105             BNE.N    ??moveToLevelHandler_2
    411                setOnOffValue(endpoint, (state->moveToLevel != MIN_LEVEL));
   \   0000004E   0x0039             MOVS     R1,R7
   \   00000050   0xBF18             IT       NE 
   \   00000052   0x2101             MOVNE    R1,#+1
   \   00000054   0x4640             MOV      R0,R8
   \   00000056   0x.... 0x....      BL       setOnOffValue
    412              }
    413              if (currentLevel == state->moveToLevel) {
   \                     ??moveToLevelHandler_2: (+1)
   \   0000005A   0x7870             LDRB     R0,[R6, #+1]
   \   0000005C   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000060   0x4281             CMP      R1,R0
   \   00000062   0xD026             BEQ.N    ??moveToLevelHandler_0
    414                status = EMBER_ZCL_STATUS_SUCCESS;
    415                goto send_default_response;
    416              }
    417              state->increasing = TRUE;
   \   00000064   0x2101             MOVS     R1,#+1
   \   00000066   0x70B1             STRB     R1,[R6, #+2]
    418              actualStepSize = state->moveToLevel - currentLevel;
   \   00000068   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000006C   0x1A40             SUBS     R0,R0,R1
   \   0000006E   0xE004             B.N      ??moveToLevelHandler_3
    419            } else {
    420              state->increasing = FALSE;
   \                     ??moveToLevelHandler_1: (+1)
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x70B1             STRB     R1,[R6, #+2]
    421              actualStepSize = currentLevel - state->moveToLevel;
   \   00000074   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000078   0x1BC8             SUBS     R0,R1,R7
   \                     ??moveToLevelHandler_3: (+1)
   \   0000007A   0xB2C0             UXTB     R0,R0
    422            }
    423          
    424            // If the Transition time field takes the value 0xFFFF, then the time taken
    425            // to move to the new level shall instead be determined by the On/Off
    426            // Transition Time attribute.  If On/Off Transition Time, which is an
    427            // optional attribute, is not present, the device shall move to its new level
    428            // as fast as it is able.
    429            if (transitionTimeDs == 0xFFFF) {
   \   0000007C   0x211E             MOVS     R1,#+30
   \   0000007E   0x4341             MULS     R1,R1,R0
   \   00000080   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000084   0x4591             CMP      R9,R2
   \   00000086   0xD006             BEQ.N    ??moveToLevelHandler_4
    430          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_ON_OFF_TRANSITION_TIME_ATTRIBUTE
    431              status = emberAfReadServerAttribute(endpoint,
    432                                                  ZCL_LEVEL_CONTROL_CLUSTER_ID,
    433                                                  ZCL_ON_OFF_TRANSITION_TIME_ATTRIBUTE_ID,
    434                                                  (int8u *)&transitionTimeDs,
    435                                                  sizeof(transitionTimeDs));
    436              if (status != EMBER_ZCL_STATUS_SUCCESS) {
    437                emberAfLevelControlClusterPrintln("ERR: reading on/off transition time %x",
    438                                                  status);
    439                goto send_default_response;
    440              }
    441          
    442              // Transition time comes in (or is stored, in the case of On/Off Transition
    443              // Time) as tenths of a second, but we work in milliseconds.
    444              state->transitionTimeMs = (transitionTimeDs
    445                                         * MILLISECOND_TICKS_PER_SECOND
    446                                         / 10);
    447          #else //ZCL_USING_LEVEL_CONTROL_CLUSTER_ON_OFF_TRANSITION_TIME_ATTRIBUTE
    448              // If the Transition Time field is 0xFFFF and On/Off Transition Time,
    449              // which is an optional attribute, is not present, the device shall move to
    450              // its new level as fast as it is able.
    451              state->transitionTimeMs = FASTEST_TRANSITION_TIME_MS * actualStepSize;
    452          #endif //ZCL_USING_LEVEL_CONTROL_CLUSTER_ON_OFF_TRANSITION_TIME_ATTRIBUTE
    453            } else {
    454              // Transition time comes in (or is stored, in the case of On/Off Transition
    455              // Time) as tenths of a second, but we work in milliseconds.
    456              state->transitionTimeMs = (transitionTimeDs
    457                                         * MILLISECOND_TICKS_PER_SECOND
    458                                         / 10);
   \   00000088   0xEA4F 0x2289      LSL      R2,R9,#+10
   \   0000008C   0x230A             MOVS     R3,#+10
   \   0000008E   0xFBB2 0xF2F3      UDIV     R2,R2,R3
    459          	if(state->transitionTimeMs < (FASTEST_TRANSITION_TIME_MS * actualStepSize)){
   \   00000092   0x428A             CMP      R2,R1
   \   00000094   0xD200             BCS.N    ??moveToLevelHandler_5
    460          	   state->transitionTimeMs =  FASTEST_TRANSITION_TIME_MS * actualStepSize;
   \                     ??moveToLevelHandler_4: (+1)
   \   00000096   0x460A             MOV      R2,R1
   \                     ??moveToLevelHandler_5: (+1)
   \   00000098   0x60F2             STR      R2,[R6, #+12]
    461          	}
    462            }
    463          
    464            // The duration between events will be the transition time divided by the
    465            // distance we must move.
    466            state->eventDurationMs = state->transitionTimeMs / actualStepSize;
   \   0000009A   0xFBB2 0xF0F0      UDIV     R0,R2,R0
   \   0000009E   0x60B0             STR      R0,[R6, #+8]
    467            state->elapsedTimeMs = 0;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x6130             STR      R0,[R6, #+16]
    468          
    469            // OnLevel is not used for Move commands.
    470            state->useOnLevel = FALSE;
   \   000000A4   0x70F0             STRB     R0,[R6, #+3]
    471          
    472            state->storedLevel = storedLevel;
   \   000000A6   0xF886 0xB005      STRB     R11,[R6, #+5]
    473          
    474            // The setup was successful, so mark the new state as active and return.
    475            schedule(endpoint, state->eventDurationMs);
   \   000000AA   0x4640             MOV      R0,R8
   \   000000AC   0x68B1             LDR      R1,[R6, #+8]
   \   000000AE   0x.... 0x....      BL       schedule
    476            status = EMBER_ZCL_STATUS_SUCCESS;
    477          
    478          #ifdef EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER
    479            if (commandId == ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID) {
    480              emberAfPluginZllLevelControlServerMoveToLevelWithOnOffZllExtensions(emberAfCurrentCommand());
    481            }
    482          #endif
    483          
    484          send_default_response:
    485          if (emberAfCurrentCommand()->apsFrame->clusterId
    486              == ZCL_LEVEL_CONTROL_CLUSTER_ID)
   \                     ??moveToLevelHandler_0: (+1)
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x8840             LDRH     R0,[R0, #+2]
   \   000000B8   0x2808             CMP      R0,#+8
   \   000000BA   0xBF04             ITT      EQ 
    487            emberAfSendImmediateDefaultResponse(status);
   \   000000BC   0x4650             MOVEQ    R0,R10
   \   000000BE   0x.... 0x....      BLEQ     emberAfSendImmediateDefaultResponse
    488          }
   \   000000C2   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x9000             STR      R0,[SP, #+0]
   \   00000004   0xAB01             ADD      R3,SP,#+4
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2108             MOVS     R1,#+8
   \   0000000A   0x4770             BX       LR
    489          

   \                                 In section .text, align 2, keep-with-next
    490          static void moveHandler(int8u commandId, int8u moveMode, int8u rate)
    491          {
   \                     moveHandler: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4607             MOV      R7,R0
    492            int8u endpoint = emberAfCurrentEndpoint();
   \   00000006   0x....             LDR.N    R0,??DataTable5_1
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xB083             SUB      SP,SP,#+12
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF890 0x9005      LDRB     R9,[R0, #+5]
   \   00000012   0x460C             MOV      R4,R1
   \   00000014   0x4690             MOV      R8,R2
    493            EmberAfLevelControlState *state = getState(endpoint);
   \   00000016   0x4648             MOV      R0,R9
   \   00000018   0x.... 0x....      BL       getState
   \   0000001C   0x0005             MOVS     R5,R0
    494            EmberAfStatus status;
    495            int8u currentLevel;
    496            int8u difference;
    497          
    498            if (state == NULL) {
   \   0000001E   0xBF08             IT       EQ 
    499              status = EMBER_ZCL_STATUS_FAILURE;
   \   00000020   0x2601             MOVEQ    R6,#+1
    500              goto send_default_response;
   \   00000022   0xD046             BEQ.N    ??moveHandler_0
    501            }
    502          
    503            // Cancel any currently active command before fiddling with the state.
    504            deactivate(endpoint);
   \   00000024   0x4648             MOV      R0,R9
   \   00000026   0x.... 0x....      BL       deactivate
    505          
    506            status = emberAfReadServerAttribute(endpoint,
    507                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    508                                                ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    509                                                (int8u *)&currentLevel,
    510                                                sizeof(currentLevel));
   \   0000002A   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000002E   0x4648             MOV      R0,R9
   \   00000030   0x.... 0x....      BL       emberAfReadServerAttribute
   \   00000034   0x0006             MOVS     R6,R0
    511            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \   00000036   0xD13C             BNE.N    ??moveHandler_0
    512              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    513              goto send_default_response;
    514            }
    515          
    516            state->commandId = commandId;
   \   00000038   0x702F             STRB     R7,[R5, #+0]
    517          
    518            // Move commands cause the device to move from its current level to either
    519            // the maximum or minimum level at the specified rate.
    520            switch (moveMode) {
   \   0000003A   0xB114             CBZ.N    R4,??moveHandler_1
   \   0000003C   0x2C01             CMP      R4,#+1
   \   0000003E   0xD01E             BEQ.N    ??moveHandler_2
   \   00000040   0xE023             B.N      ??moveHandler_3
    521            case EMBER_ZCL_MOVE_MODE_UP:
    522              state->increasing = TRUE;
   \                     ??moveHandler_1: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x70A8             STRB     R0,[R5, #+2]
    523              state->moveToLevel = MAX_LEVEL;
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0x7068             STRB     R0,[R5, #+1]
    524              difference = MAX_LEVEL - currentLevel;
   \   0000004A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000004E   0xF1C0 0x04FF      RSB      R4,R0,#+255
    525              break;
    526            case EMBER_ZCL_MOVE_MODE_DOWN:
    527              state->increasing = FALSE;
    528              state->moveToLevel = MIN_LEVEL;
    529              difference = currentLevel - MIN_LEVEL;
    530              break;
    531            default:
    532              status = EMBER_ZCL_STATUS_INVALID_FIELD;
    533              goto send_default_response;
    534            }
    535          
    536            // If the level is decreasing, the On/Off attribute is left unchanged.  This
    537            // logic is to prevent a light from transitioning from off to bright to dim.
    538            // Instead, a light that is off will stay off until the target level is
    539            // reached.
    540            if (currentLevel <= state->moveToLevel) {
   \                     ??moveHandler_4: (+1)
   \   00000052   0x7868             LDRB     R0,[R5, #+1]
   \   00000054   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD30C             BCC.N    ??moveHandler_5
    541              if (commandId == ZCL_MOVE_WITH_ON_OFF_COMMAND_ID) {
   \   0000005C   0x2F05             CMP      R7,#+5
   \   0000005E   0xD105             BNE.N    ??moveHandler_6
    542                setOnOffValue(endpoint, (state->moveToLevel != MIN_LEVEL));
   \   00000060   0x0001             MOVS     R1,R0
   \   00000062   0xBF18             IT       NE 
   \   00000064   0x2101             MOVNE    R1,#+1
   \   00000066   0x4648             MOV      R0,R9
   \   00000068   0x.... 0x....      BL       setOnOffValue
    543              }
    544              if (currentLevel == state->moveToLevel) {
   \                     ??moveHandler_6: (+1)
   \   0000006C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000070   0x7869             LDRB     R1,[R5, #+1]
   \   00000072   0x4288             CMP      R0,R1
   \   00000074   0xD01D             BEQ.N    ??moveHandler_0
    545                status = EMBER_ZCL_STATUS_SUCCESS;
    546                goto send_default_response;
    547              }
    548            }
    549          
    550            // If the Rate field is 0xFF, the device should move as fast as it is able.
    551            // Otherwise, the rate is in units per second.
    552            if (rate == 0xFF) {
   \                     ??moveHandler_5: (+1)
   \   00000076   0xF1B8 0x0FFF      CMP      R8,#+255
   \   0000007A   0xD108             BNE.N    ??moveHandler_7
    553              state->eventDurationMs = FASTEST_TRANSITION_TIME_MS;
   \   0000007C   0xE00D             B.N      ??moveHandler_8
    554            } else {
   \                     ??moveHandler_2: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x70A8             STRB     R0,[R5, #+2]
   \   00000082   0x7068             STRB     R0,[R5, #+1]
   \   00000084   0xF89D 0x4004      LDRB     R4,[SP, #+4]
   \   00000088   0xE7E3             B.N      ??moveHandler_4
   \                     ??moveHandler_3: (+1)
   \   0000008A   0x2685             MOVS     R6,#+133
   \   0000008C   0xE011             B.N      ??moveHandler_0
    555              state->eventDurationMs = MILLISECOND_TICKS_PER_SECOND / rate;
   \                     ??moveHandler_7: (+1)
   \   0000008E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000092   0xFBB0 0xF0F8      UDIV     R0,R0,R8
    556          
    557          
    558          
    559          	if(state->eventDurationMs < FASTEST_TRANSITION_TIME_MS){
   \   00000096   0x281E             CMP      R0,#+30
   \   00000098   0xD200             BCS.N    ??moveHandler_9
    560          		state->eventDurationMs = FASTEST_TRANSITION_TIME_MS;
   \                     ??moveHandler_8: (+1)
   \   0000009A   0x201E             MOVS     R0,#+30
   \                     ??moveHandler_9: (+1)
   \   0000009C   0x60A8             STR      R0,[R5, #+8]
    561          	}
    562          
    563          
    564          
    565          
    566            }
    567            state->transitionTimeMs = difference * state->eventDurationMs;
   \   0000009E   0xB2E1             UXTB     R1,R4
   \   000000A0   0x4348             MULS     R0,R0,R1
   \   000000A2   0x60E8             STR      R0,[R5, #+12]
    568            state->elapsedTimeMs = 0;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x6128             STR      R0,[R5, #+16]
    569          
    570            // OnLevel is not used for Move commands.
    571            state->useOnLevel = FALSE;
   \   000000A8   0x70E8             STRB     R0,[R5, #+3]
    572          
    573            // The setup was successful, so mark the new state as active and return.
    574            schedule(endpoint, state->eventDurationMs);
   \   000000AA   0x4648             MOV      R0,R9
   \   000000AC   0x68A9             LDR      R1,[R5, #+8]
   \   000000AE   0x.... 0x....      BL       schedule
    575            status = EMBER_ZCL_STATUS_SUCCESS;
    576          
    577          send_default_response:
    578            emberAfSendImmediateDefaultResponse(status);
   \                     ??moveHandler_0: (+1)
   \   000000B2   0x4630             MOV      R0,R6
   \   000000B4   0x.... 0x....      BL       emberAfSendImmediateDefaultResponse
    579          }
   \   000000B8   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    580          

   \                                 In section .text, align 2, keep-with-next
    581          static void stepHandler(int8u commandId,
    582                                  int8u stepMode,
    583                                  int8u stepSize,
    584                                  int16u transitionTimeDs)
    585          {
   \                     stepHandler: (+1)
   \   00000000   0xE92D 0x4DFA      PUSH     {R1,R3-R8,R10,R11,LR}
   \   00000004   0x4604             MOV      R4,R0
    586            int8u endpoint = emberAfCurrentEndpoint();
   \   00000006   0x....             LDR.N    R0,??DataTable5_1
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xB082             SUB      SP,SP,#+8
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x7940             LDRB     R0,[R0, #+5]
   \   00000010   0xF88D 0x0005      STRB     R0,[SP, #+5]
   \   00000014   0x4693             MOV      R11,R2
   \   00000016   0x469A             MOV      R10,R3
    587            EmberAfLevelControlState *state = getState(endpoint);
   \   00000018   0x.... 0x....      BL       getState
   \   0000001C   0x0007             MOVS     R7,R0
   \   0000001E   0x465E             MOV      R6,R11
    588            EmberAfStatus status;
    589            int8u currentLevel;
    590            int8u actualStepSize = stepSize;
    591          
    592            if (state == NULL) {
   \   00000020   0xBF08             IT       EQ 
    593              status = EMBER_ZCL_STATUS_FAILURE;
   \   00000022   0xF04F 0x0801      MOVEQ    R8,#+1
    594              goto send_default_response;
   \   00000026   0xD072             BEQ.N    ??stepHandler_0
    595            }
    596          
    597            // Cancel any currently active command before fiddling with the state.
    598            deactivate(endpoint);
   \   00000028   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000002C   0x.... 0x....      BL       deactivate
    599          
    600            status = emberAfReadServerAttribute(endpoint,
    601                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    602                                                ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    603                                                (int8u *)&currentLevel,
    604                                                sizeof(currentLevel));
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x9000             STR      R0,[SP, #+0]
   \   00000034   0xAB01             ADD      R3,SP,#+4
   \   00000036   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0x2108             MOVS     R1,#+8
   \   0000003E   0x.... 0x....      BL       emberAfReadServerAttribute
   \   00000042   0xEA5F 0x0800      MOVS     R8,R0
    605            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \   00000046   0xD162             BNE.N    ??stepHandler_0
    606              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    607              goto send_default_response;
    608            }
    609          
    610            state->commandId = commandId;
   \   00000048   0x703C             STRB     R4,[R7, #+0]
    611          
    612            // Step commands cause the device to move from its current level to a new
    613            // level over the specified transition time.
    614            switch (stepMode) {
   \   0000004A   0x25FF             MOVS     R5,#+255
   \   0000004C   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000050   0xB110             CBZ.N    R0,??stepHandler_1
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD033             BEQ.N    ??stepHandler_2
   \   00000056   0xE040             B.N      ??stepHandler_3
    615            case EMBER_ZCL_STEP_MODE_UP:
    616              state->increasing = TRUE;
   \                     ??stepHandler_1: (+1)
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x70B8             STRB     R0,[R7, #+2]
    617              if (MAX_LEVEL - currentLevel < stepSize) {
   \   0000005C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000060   0xF1C0 0x00FF      RSB      R0,R0,#+255
   \   00000064   0x4558             CMP      R0,R11
   \   00000066   0xDA25             BGE.N    ??stepHandler_4
    618                state->moveToLevel = MAX_LEVEL;
   \   00000068   0x707D             STRB     R5,[R7, #+1]
    619                actualStepSize = (MAX_LEVEL - currentLevel);
   \   0000006A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000006E   0xF1C0 0x06FF      RSB      R6,R0,#+255
   \   00000072   0xB2F6             UXTB     R6,R6
    620              } else {
    621                state->moveToLevel = currentLevel + stepSize;
    622              }
    623              break;
    624            case EMBER_ZCL_STEP_MODE_DOWN:
    625              state->increasing = FALSE;
    626              if (currentLevel - MIN_LEVEL < stepSize) {
    627                state->moveToLevel = MIN_LEVEL;
    628                actualStepSize = (currentLevel - MIN_LEVEL);
    629              } else {
    630                state->moveToLevel = currentLevel - stepSize;
    631              }
    632              break;
    633            default:
    634              status = EMBER_ZCL_STATUS_INVALID_FIELD;
    635              goto send_default_response;
    636            }
    637          
    638            // If the level is decreasing, the On/Off attribute is left unchanged.  This
    639            // logic is to prevent a light from transitioning from off to bright to dim.
    640            // Instead, a light that is off will stay off until the target level is
    641            // reached.
    642            if (currentLevel <= state->moveToLevel) {
   \                     ??stepHandler_5: (+1)
   \   00000074   0x7878             LDRB     R0,[R7, #+1]
   \   00000076   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xD30D             BCC.N    ??stepHandler_6
    643              if (commandId == ZCL_STEP_WITH_ON_OFF_COMMAND_ID) {
   \   0000007E   0x2C06             CMP      R4,#+6
   \   00000080   0xD106             BNE.N    ??stepHandler_7
    644                setOnOffValue(endpoint, (state->moveToLevel != MIN_LEVEL));
   \   00000082   0x0001             MOVS     R1,R0
   \   00000084   0xBF18             IT       NE 
   \   00000086   0x2101             MOVNE    R1,#+1
   \   00000088   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000008C   0x.... 0x....      BL       setOnOffValue
    645              }
    646              if (currentLevel == state->moveToLevel) {
   \                     ??stepHandler_7: (+1)
   \   00000090   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000094   0x7879             LDRB     R1,[R7, #+1]
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xD039             BEQ.N    ??stepHandler_0
    647                status = EMBER_ZCL_STATUS_SUCCESS;
    648                goto send_default_response;
    649              }
    650            }
    651          
    652            // If the Transition Time field is 0xFFFF, the device should move as fast as
    653            // it is able.
    654            if (transitionTimeDs == 0xFFFF) {
   \                     ??stepHandler_6: (+1)
   \   0000009A   0xEA4F 0x208A      LSL      R0,R10,#+10
   \   0000009E   0x210A             MOVS     R1,#+10
   \   000000A0   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000A4   0x211E             MOVS     R1,#+30
   \   000000A6   0x4371             MULS     R1,R1,R6
   \   000000A8   0xF64F 0x72FF      MOVW     R2,#+65535
   \   000000AC   0x4592             CMP      R10,R2
   \   000000AE   0xD117             BNE.N    ??stepHandler_8
    655              state->transitionTimeMs = FASTEST_TRANSITION_TIME_MS * actualStepSize;
   \   000000B0   0x460A             MOV      R2,R1
   \   000000B2   0xE01B             B.N      ??stepHandler_9
    656            } else {
   \                     ??stepHandler_4: (+1)
   \   000000B4   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000B8   0x4458             ADD      R0,R11,R0
   \                     ??stepHandler_10: (+1)
   \   000000BA   0x7078             STRB     R0,[R7, #+1]
   \   000000BC   0xE7DA             B.N      ??stepHandler_5
   \                     ??stepHandler_2: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x70B8             STRB     R0,[R7, #+2]
   \   000000C2   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000C6   0x4558             CMP      R0,R11
   \   000000C8   0xD204             BCS.N    ??stepHandler_11
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x7078             STRB     R0,[R7, #+1]
   \   000000CE   0xF89D 0x6004      LDRB     R6,[SP, #+4]
   \   000000D2   0xE7CF             B.N      ??stepHandler_5
   \                     ??stepHandler_11: (+1)
   \   000000D4   0xEBA0 0x000B      SUB      R0,R0,R11
   \   000000D8   0xE7EF             B.N      ??stepHandler_10
   \                     ??stepHandler_3: (+1)
   \   000000DA   0xF04F 0x0885      MOV      R8,#+133
   \   000000DE   0xE016             B.N      ??stepHandler_0
    657              // Transition time comes in as tenths of a second, but we work in
    658              // milliseconds.
    659              state->transitionTimeMs = (transitionTimeDs
    660                                         * MILLISECOND_TICKS_PER_SECOND
    661                                         / 10);
   \                     ??stepHandler_8: (+1)
   \   000000E0   0x4602             MOV      R2,R0
    662          
    663          
    664              // If the new level was pegged at the minimum level, the transition time
    665              // shall be proportionally reduced.  This is done after the conversion to
    666              // milliseconds to reduce rounding errors in integer division.
    667              if (stepSize != actualStepSize) {
   \   000000E2   0x45B3             CMP      R11,R6
   \   000000E4   0xBF1C             ITT      NE 
    668                state->transitionTimeMs = (state->transitionTimeMs
    669                                           * actualStepSize
    670                                           / stepSize);
   \   000000E6   0x4372             MULNE    R2,R2,R6
   \   000000E8   0xFBB2 0xF2FB      UDIVNE   R2,R2,R11
    671              }
    672            }
    673          
    674          
    675          
    676          
    677          	if((transitionTimeDs* MILLISECOND_TICKS_PER_SECOND/ 10) <
    678          		(FASTEST_TRANSITION_TIME_MS * actualStepSize)){
   \                     ??stepHandler_9: (+1)
   \   000000EC   0x4288             CMP      R0,R1
   \   000000EE   0xBF38             IT       CC 
    679          		state->transitionTimeMs = FASTEST_TRANSITION_TIME_MS * actualStepSize;
   \   000000F0   0x460A             MOVCC    R2,R1
   \   000000F2   0x60FA             STR      R2,[R7, #+12]
    680          	}
    681          
    682          
    683          
    684          
    685            state-> storedLevel = INVALID_STORED_LEVEL;
   \   000000F4   0x717D             STRB     R5,[R7, #+5]
    686            // The duration between events will be the transition time divided by the
    687            // distance we must move.
    688            state->eventDurationMs = state->transitionTimeMs / actualStepSize;
   \   000000F6   0x68F8             LDR      R0,[R7, #+12]
   \   000000F8   0xFBB0 0xF0F6      UDIV     R0,R0,R6
   \   000000FC   0x60B8             STR      R0,[R7, #+8]
    689            state->elapsedTimeMs = 0;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x6138             STR      R0,[R7, #+16]
    690          
    691            // OnLevel is not used for Step commands.
    692            state->useOnLevel = FALSE;
   \   00000102   0x70F8             STRB     R0,[R7, #+3]
    693          
    694            // The setup was successful, so mark the new state as active and return.
    695            schedule(endpoint, state->eventDurationMs);
   \   00000104   0x68B9             LDR      R1,[R7, #+8]
   \   00000106   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000010A   0x.... 0x....      BL       schedule
    696            status = EMBER_ZCL_STATUS_SUCCESS;
    697          
    698          send_default_response:
    699            emberAfSendImmediateDefaultResponse(status);
   \                     ??stepHandler_0: (+1)
   \   0000010E   0x4640             MOV      R0,R8
   \   00000110   0x.... 0x....      BL       emberAfSendImmediateDefaultResponse
    700          }
   \   00000114   0xE8BD 0x8DFF      POP      {R0-R8,R10,R11,PC}  ;; return
    701          

   \                                 In section .text, align 2, keep-with-next
    702          static void stopHandler(int8u commandId)
    703          {
   \                     stopHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    704            int8u endpoint = emberAfCurrentEndpoint();
   \   00000002   0x....             LDR.N    R0,??DataTable5_1
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x7944             LDRB     R4,[R0, #+5]
    705            EmberAfLevelControlState *state = getState(endpoint);
    706            EmberAfStatus status;
    707          
    708            if (state == NULL) {
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       getState
   \   00000010   0xB908             CBNZ.N   R0,??stopHandler_0
    709              status = EMBER_ZCL_STATUS_FAILURE;
   \   00000012   0x2001             MOVS     R0,#+1
    710              goto send_default_response;
   \   00000014   0xE003             B.N      ??stopHandler_1
    711            }
    712          
    713            // Cancel any currently active command.
    714            deactivate(endpoint);
   \                     ??stopHandler_0: (+1)
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       deactivate
    715            writeRemainingTime(endpoint, 0);
    716            status = EMBER_ZCL_STATUS_SUCCESS;
   \   0000001C   0x2000             MOVS     R0,#+0
    717          
    718          send_default_response:
    719            emberAfSendImmediateDefaultResponse(status);
   \                     ??stopHandler_1: (+1)
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      emberAfSendImmediateDefaultResponse
    720          }
    721          
    722          // Follows 07-5123-04 (ZigBee Cluster Library doc), section 3.10.2.1.1.
    723          // Quotes are from table 3.46.

   \                                 In section .text, align 2, keep-with-next
    724          void emberAfOnOffClusterLevelControlEffectCallback(int8u endpoint,
    725                                                             boolean newValue)
    726          {
   \                     emberAfOnOffClusterLevelControlEffectCallback: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    727            int8u temporaryCurrentLevelCache;
    728            int16u currentOnOffTransitionTime;
    729            int8u currentOnLevel;
    730            int8u minimumLevelAllowedForTheDevice = MIN_LEVEL;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0005      STRB     R0,[SP, #+5]
   \   0000000A   0x460D             MOV      R5,R1
    731            EmberAfStatus status;
    732          
    733            // "Temporarilty store CurrentLevel."
    734            status = emberAfReadServerAttribute(endpoint,
    735                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    736                                                ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    737                                                (int8u *)&temporaryCurrentLevelCache,
    738                                                sizeof(temporaryCurrentLevelCache));
    739            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \   0000000C   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       emberAfReadServerAttribute
   \   00000016   0xB9A0             CBNZ.N   R0,??emberAfOnOffClusterLevelControlEffectCallback_0
    740              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    741              return;
    742            }
    743          
    744            // Read the OnLevel attribute.
    745          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_ON_LEVEL_ATTRIBUTE
    746            status = emberAfReadServerAttribute(endpoint,
    747                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    748                                                ZCL_ON_LEVEL_ATTRIBUTE_ID,
    749                                                (int8u *)&currentOnLevel,
    750                                                sizeof(currentOnLevel));
    751            if (status != EMBER_ZCL_STATUS_SUCCESS) {
    752              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    753              return;
    754            }
    755          #else
    756            currentOnLevel = 0xFF;
    757          #endif
    758          
    759            // Read the OnOffTransitionTime attribute.
    760          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_ON_OFF_TRANSITION_TIME_ATTRIBUTE
    761            status = emberAfReadServerAttribute(endpoint,
    762                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    763                                                ZCL_ON_OFF_TRANSITION_TIME_ATTRIBUTE_ID,
    764                                                (int8u *)&currentOnOffTransitionTime,
    765                                                sizeof(currentOnOffTransitionTime));
    766            if (status != EMBER_ZCL_STATUS_SUCCESS) {
    767              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    768              return;
    769            }
    770          #else
    771            currentOnOffTransitionTime = 0xFFFF;
    772          #endif
    773          
    774            if (newValue) {
   \   00000018   0xF64F 0x76FF      MOVW     R6,#+65535
   \   0000001C   0xB155             CBZ.N    R5,??emberAfOnOffClusterLevelControlEffectCallback_1
    775              // If newValue is ZCL_ON_COMMAND_ID...
    776              // "Set CurrentLevel to minimum level allowed for the device."
    777              status = emberAfWriteServerAttribute(endpoint,
    778                                                   ZCL_LEVEL_CONTROL_CLUSTER_ID,
    779                                                   ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    780                                                   (int8u *)&minimumLevelAllowedForTheDevice,
    781                                                   ZCL_INT8U_ATTRIBUTE_TYPE);
    782              if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \   0000001E   0x2020             MOVS     R0,#+32
   \   00000020   0x9000             STR      R0,[SP, #+0]
   \   00000022   0xF10D 0x0305      ADD      R3,SP,#+5
   \   00000026   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000002A   0xB950             CBNZ.N   R0,??emberAfOnOffClusterLevelControlEffectCallback_0
    783                emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    784                return;
    785              }
    786          
    787              // "Move CurrentLevel to OnLevel, or to the stored level if OnLevel is not
    788              // defined, over the time period OnOffTransitionTime."
    789              moveToLevelHandler(ZCL_MOVE_TO_LEVEL_COMMAND_ID,
    790                                 (currentOnLevel == 0xFF
    791                                  ? temporaryCurrentLevelCache
    792                                  : currentOnLevel),
    793                                 currentOnOffTransitionTime,
    794                                 INVALID_STORED_LEVEL); // Don't revert to stored level
   \   0000002C   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000030   0x23FF             MOVS     R3,#+255
   \   00000032   0xE003             B.N      ??emberAfOnOffClusterLevelControlEffectCallback_2
    795            } else {
    796              // ...else if newValue is ZCL_OFF_COMMAND_ID...
    797              // "Move CurrentLevel to the minimum level allowed for the device over the
    798              // time period OnOffTransitionTime."
    799              moveToLevelHandler(ZCL_MOVE_TO_LEVEL_COMMAND_ID,
    800                                 minimumLevelAllowedForTheDevice,
    801                                 currentOnOffTransitionTime,
    802                                 temporaryCurrentLevelCache);
   \                     ??emberAfOnOffClusterLevelControlEffectCallback_1: (+1)
   \   00000034   0xF89D 0x3004      LDRB     R3,[SP, #+4]
   \   00000038   0xF89D 0x1005      LDRB     R1,[SP, #+5]
   \                     ??emberAfOnOffClusterLevelControlEffectCallback_2: (+1)
   \   0000003C   0x4632             MOV      R2,R6
   \   0000003E   0x.... 0x....      BL       moveToLevelHandler
    803          
    804              // "If OnLevel is not defined, set the CurrentLevel to the stored level."
    805              // The emberAfLevelControlClusterServerTickCallback implementation handles
    806              // this.
    807            }
    808          }
   \                     ??emberAfOnOffClusterLevelControlEffectCallback_0: (+1)
   \   00000042   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     stateTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     emAfCurrentCommand

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "level-control.c">`:
   \   00000000   0x6C 0x65          DC8 "level-control.c"
   \              0x76 0x65    
   \              0x6C 0x2D    
   \              0x63 0x6F    
   \              0x6E 0x74    
   \              0x72 0x6F    
   \              0x6C 0x2E    
   \              0x63 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   deactivate
         0   -> emberAfDeactivateServerTick
       8   emberAfLevelControlClusterMoveCallback
         8   -> moveHandler
       8   emberAfLevelControlClusterMoveToLevelCallback
         8   -> moveToLevelHandler
       8   emberAfLevelControlClusterMoveToLevelWithOnOffCallback
         8   -> moveToLevelHandler
       8   emberAfLevelControlClusterMoveWithOnOffCallback
         8   -> moveHandler
       0   emberAfLevelControlClusterServerInitCallback
      24   emberAfLevelControlClusterServerTickCallback
        24   -> UartSendDimLevel
        24   -> emberAfContainsServer
        24   -> emberAfReadServerAttribute
        24   -> emberAfScenesClusterMakeInvalidCallback
        24   -> emberAfWriteServerAttribute
        24   -> getState
        24   -> halInternalAssertFailed
        24   -> schedule
        24   -> setOnOffValue
       8   emberAfLevelControlClusterStepCallback
         8   -> stepHandler
       8   emberAfLevelControlClusterStepWithOnOffCallback
         8   -> stepHandler
       8   emberAfLevelControlClusterStopCallback
         8   -> stopHandler
       8   emberAfLevelControlClusterStopWithOnOffCallback
         8   -> stopHandler
      24   emberAfOnOffClusterLevelControlEffectCallback
        24   -> emberAfReadServerAttribute
        24   -> emberAfWriteServerAttribute
        24   -> moveToLevelHandler
       8   getState
         8   -> emberAfFindClusterServerEndpointIndex
      40   moveHandler
        40   -> deactivate
        40   -> emberAfReadServerAttribute
        40   -> emberAfSendImmediateDefaultResponse
        40   -> getState
        40   -> schedule
        40   -> setOnOffValue
      48   moveToLevelHandler
        48   -> deactivate
        48   -> emberAfReadServerAttribute
        48   -> emberAfSendImmediateDefaultResponse
        48   -> getState
        48   -> schedule
        48   -> setOnOffValue
       8   schedule
         8   -> emberAfScheduleServerTickExtended
      16   setOnOffValue
        16   -> emberAfContainsServer
         0   -> emberAfOnOffClusterSetValueCallback
      48   stepHandler
        48   -> deactivate
        48   -> emberAfReadServerAttribute
        48   -> emberAfSendImmediateDefaultResponse
        48   -> getState
        48   -> schedule
        48   -> setOnOffValue
       8   stopHandler
         8   -> deactivate
         0   -> emberAfSendImmediateDefaultResponse
         8   -> getState


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant "level-control.c">
       4  ??DataTable5
       4  ??DataTable5_1
       8  ?Subroutine0
       8  ?Subroutine1
       8  ?Subroutine2
       8  ?Subroutine3
      12  ?Subroutine4
      10  ?Subroutine5
       6  ?Subroutine6
       6  deactivate
      10  emberAfLevelControlClusterMoveCallback
      12  emberAfLevelControlClusterMoveToLevelCallback
      10  emberAfLevelControlClusterMoveToLevelWithOnOffCallback
       8  emberAfLevelControlClusterMoveWithOnOffCallback
       2  emberAfLevelControlClusterServerInitCallback
     270  emberAfLevelControlClusterServerTickCallback
      12  emberAfLevelControlClusterStepCallback
      10  emberAfLevelControlClusterStepWithOnOffCallback
       6  emberAfLevelControlClusterStopCallback
       4  emberAfLevelControlClusterStopWithOnOffCallback
      68  emberAfOnOffClusterLevelControlEffectCallback
      28  getState
     188  moveHandler
     198  moveToLevelHandler
      18  schedule
      34  setOnOffValue
      20  stateTable
     280  stepHandler
      38  stopHandler

 
    20 bytes in section .bss
 1 286 bytes in section .text
 
 1 286 bytes of CODE memory
    20 bytes of DATA memory

Errors: none
Warnings: 2

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        22/Oct/2015  09:33:03
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\util\serial\command-interpreter2.c
#    Command line =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\util\serial\command-interpreter2.c -D
#        DIMMER -D NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D
#        CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"command-interpreter2.c\"" -lC
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\List\
#        --diag_suppress Pa050 -o
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\Obj\ --debug
#        --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\util\serial\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\List\command-interpreter2.lst
#    Object file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\Obj\command-interpreter2.o
#
###############################################################################

E:\Zigbee\EmberZNet5.6.0-GA\app\util\serial\command-interpreter2.c
      1          /**
      2           * File: command-interpreter.c
      3           * Description: processes commands incoming over the serial port.
      4           *
      5           * Culprit(s): Richard Kelsey, Matteo Paris
      6           *
      7           * Copyright 2008 by Ember Corporation.  All rights reserved.               *80*
      8           */
      9          
     10          #include PLATFORM_HEADER
     11          
     12          #ifdef EZSP_HOST
     13            // Includes needed for ember related functions for the EZSP host
     14            #include "stack/include/error.h"
     15            #include "stack/include/ember-types.h"
     16            #include "app/util/ezsp/ezsp-protocol.h"
     17            #include "app/util/ezsp/ezsp.h"
     18            #include "app/util/ezsp/serial-interface.h"
     19            extern int8u emberEndpointCount;
     20          #else
     21            #include "stack/include/ember.h"
     22          #endif
     23          
     24          #include "hal/hal.h"
     25          #include "app/util/serial/serial.h"
     26          #include "app/util/serial/command-interpreter2.h"
     27          
     28          #if defined(EMBER_REQUIRE_FULL_COMMAND_NAME) \
     29            || defined(EMBER_REQUIRE_EXACT_COMMAND_NAME)
     30            #undef EMBER_REQUIRE_EXACT_COMMAND_NAME
     31            #define EMBER_REQUIRE_EXACT_COMMAND_NAME TRUE
     32          #else
     33            #define EMBER_REQUIRE_EXACT_COMMAND_NAME FALSE
     34          #endif
     35          
     36          #if !defined APP_SERIAL
     37            extern int8u serialPort;
     38            #define APP_SERIAL serialPort
     39          #endif
     40          
     41          #if defined EMBER_COMMAND_INTEPRETER_HAS_DESCRIPTION_FIELD
     42            #define printIfEntryHasDescription(entry, ...) \
     43            if ((entry)->description != NULL) {            \
     44              emberSerialPrintf(APP_SERIAL,                \
     45                                __VA_ARGS__);              \
     46              }
     47            #define printIfEntryHasArgumentDescriptions(entry, ...) \
     48            if ((entry)->argumentDescriptions != NULL) {            \
     49              emberSerialPrintf(APP_SERIAL,                         \
     50                                __VA_ARGS__);                       \
     51            }
     52          #else
     53            #define printIfEntryHasDescription(entry, ...) 
     54            #define printIfEntryHasArgumentDescriptions(entry, ...)
     55          #endif
     56          
     57          //------------------------------------------------------------------------------
     58          // Forward declarations.
     59          static void callCommandAction(void);
     60          static int32u stringToUnsignedInt(int8u argNum, boolean swallowLeadingSign);
     61          static int8u charDowncase(int8u c);
     62          
     63          //------------------------------------------------------------------------------
     64          // Command parsing state
     65          
     66          typedef struct {
     67          
     68            // Finite-state machine's current state. 
     69            int8u state;
     70          
     71            // The command line is stored in this buffer.
     72            // Spaces and trailing '"' and '}' characters are removed,
     73            // and hex strings are converted to bytes. 
     74            int8u buffer[EMBER_COMMAND_BUFFER_LENGTH];
     75          
     76            // Indices of the tokens (command(s) and arguments) in the above buffer.
     77            // The (+ 1) lets us store the ending index.
     78            int8u tokenIndices[MAX_TOKEN_COUNT + 1];
     79          
     80            // The number of tokens read in, including the command(s). 
     81            int8u tokenCount;
     82          
     83            // Used while reading in the command line. 
     84            int8u index;
     85          
     86            // First error found in this command. 
     87            int8u error;
     88          
     89            // Storage for reading in a hex string. A value of 0xFF means unused. 
     90            int8u hexHighNibble;
     91          
     92            // The token number of the first true argument after possible nested commands.
     93            int8u argOffset;
     94          
     95          } EmberCommandState;
     96          
     97          static EmberCommandState commandState;
     98          

   \                                 In section .data, align 1
     99          static int8u defaultBase = 10;
   \                     defaultBase:
   \   00000000   0x0A               DC8 10

   \                                 In section .bss, align 4
   \                     commandState:
   \   00000000                      DS8 124
    100          
    101          // Remember the previous character seen by emberProcessCommandString() to ignore
    102          // an LF following a CR.
    103          static int8u previousCharacter = 0;
    104          
    105          EmberCommandEntry *emberCurrentCommand;
   \                     emberCurrentCommand:
   \   0000007C                      DS8 4

   \                                 In section .bss, align 1
   \                     previousCharacter:
   \   00000000                      DS8 1
    106          
    107          enum {
    108            CMD_AWAITING_ARGUMENT,
    109            CMD_READING_ARGUMENT,
    110            CMD_READING_STRING,                  // have read opening " but not closing "
    111            CMD_READING_HEX_STRING,              // have read opening { but not closing }
    112            CMD_READING_TO_EOL                   // clean up after error
    113          };
    114          
    115          // This byte is used to toggle certain internal features on or off.
    116          // By default all are off.

   \                                 In section .bss, align 1
    117          int8u emberCommandInterpreter2Configuration = 0x00;
   \                     emberCommandInterpreter2Configuration:
   \   00000000                      DS8 1
    118          
    119          #ifdef EMBER_TEST
    120          char *stateNames[] =
    121            {
    122              "awaiting argument",
    123              "reading argument",
    124              "reading string",
    125              "reading hex string",
    126              "reading to eol"
    127            };
    128          #endif
    129          
    130          // We provide a way of overriding the default base for numbers on the
    131          // command line for backwards compatibility.
    132          // This function is intentionally NOT documented in the .h file so it
    133          // isn't used anywhere it shouldn't be.

   \                                 In section .text, align 2, keep-with-next
    134          void emberCommandReaderSetDefaultBase(int8u base)
    135          {
    136            defaultBase = base;
   \                     emberCommandReaderSetDefaultBase: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable43_8
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    137          }
   \   00000006   0x4770             BX       LR               ;; return
    138          
    139          // Some users of command-interpreter2 need the command buffer to be set to 0
    140          // so the command arg is NULL terminated when a pointer is returned.
    141          // It might be better to always zero out the buffer when we reset 
    142          // commandState.state to CMD_AWAITING_ARGUMENT, but I don't want to break any
    143          // other existing apps, so I'm letting the app decide if it wants to zero out
    144          // the buffer.

   \                                 In section .text, align 2, keep-with-next
    145          void emberCommandClearBuffer(void)
    146          {
    147            MEMSET(commandState.buffer, 0, EMBER_COMMAND_BUFFER_LENGTH);
   \                     emberCommandClearBuffer: (+1)
   \   00000000   0x2264             MOVS     R2,#+100
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable43_9
   \   00000008   0x.... 0x....      B.W      halCommonMemSet
    148          }
    149          

   \                                 In section .text, align 2, keep-with-next
    150          const char *emberCommandName(void)
    151          {
    152            return emberCurrentCommand->name;
   \                     emberCommandName: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable43_10
   \   00000004   0x6FC0             LDR      R0,[R0, #+124]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4770             BX       LR               ;; return
    153          }
    154          
    155          //----------------------------------------------------------------
    156          // Initialize the state maachine.
    157          

   \                                 In section .text, align 2, keep-with-next
    158          void emberCommandReaderInit(void)
    159          {
    160            commandState.state = CMD_AWAITING_ARGUMENT;
   \                     emberCommandReaderInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable43_10
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    161            commandState.index = 0;
   \   00000008   0xF880 0x1078      STRB     R1,[R0, #+120]
    162            commandState.tokenIndices[0] = 0;
   \   0000000C   0xF880 0x1065      STRB     R1,[R0, #+101]
    163            commandState.tokenCount = 0;
   \   00000010   0xF880 0x1077      STRB     R1,[R0, #+119]
    164            commandState.error = EMBER_CMD_SUCCESS;
   \   00000014   0xF880 0x1079      STRB     R1,[R0, #+121]
    165            commandState.hexHighNibble = 0xFF;
   \   00000018   0x21FF             MOVS     R1,#+255
   \   0000001A   0xF880 0x107A      STRB     R1,[R0, #+122]
    166            commandState.argOffset = 0;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xF880 0x107B      STRB     R1,[R0, #+123]
    167            emberCurrentCommand = NULL;
   \   00000024   0x67C1             STR      R1,[R0, #+124]
    168          }
   \   00000026   0x4770             BX       LR               ;; return
    169          
    170          // Returns a value > 15 if ch is not a hex digit.

   \                                 In section .text, align 2, keep-with-next
    171          static int8u hexToInt(int8u ch)
    172          {
    173            return ch - (ch >= 'a' ? 'a' - 10
    174                         : (ch >= 'A' ? 'A' - 10
    175                            : (ch <= '9' ? '0'
    176                               : 0)));
   \                     hexToInt: (+1)
   \   00000000   0x2861             CMP      R0,#+97
   \   00000002   0xBFA8             IT       GE 
   \   00000004   0x2157             MOVGE    R1,#+87
   \   00000006   0xDA07             BGE.N    ??hexToInt_0
   \   00000008   0x2841             CMP      R0,#+65
   \   0000000A   0xBFA8             IT       GE 
   \   0000000C   0x2137             MOVGE    R1,#+55
   \   0000000E   0xDA03             BGE.N    ??hexToInt_0
   \   00000010   0x283A             CMP      R0,#+58
   \   00000012   0xBFB4             ITE      LT 
   \   00000014   0x2130             MOVLT    R1,#+48
   \   00000016   0x2100             MOVGE    R1,#+0
   \                     ??hexToInt_0: (+1)
   \   00000018   0x1A40             SUBS     R0,R0,R1
   \   0000001A   0xB2C0             UXTB     R0,R0
   \   0000001C   0x4770             BX       LR               ;; return
    177          }
    178          

   \                                 In section .text, align 2, keep-with-next
    179          static int8u tokenLength(int8u num)
    180          {
    181            return (commandState.tokenIndices[num + 1] 
    182                    - commandState.tokenIndices[num]);
   \                     tokenLength: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable43_10
   \   00000004   0x1840             ADDS     R0,R0,R1
   \   00000006   0xF890 0x1066      LDRB     R1,[R0, #+102]
   \   0000000A   0xF890 0x0065      LDRB     R0,[R0, #+101]
   \   0000000E   0x....             B.N      ?Subroutine0
    183          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x1A08             SUBS     R0,R1,R0
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x4770             BX       LR               ;; return
    184          

   \                                 In section .text, align 2, keep-with-next
    185          static int8u *tokenPointer(int8s tokenNum)
    186          {
    187            return commandState.buffer + commandState.tokenIndices[tokenNum];
   \                     tokenPointer: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable43_10
   \   00000004   0x1840             ADDS     R0,R0,R1
   \   00000006   0xF890 0x0065      LDRB     R0,[R0, #+101]
   \   0000000A   0x1840             ADDS     R0,R0,R1
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x4770             BX       LR               ;; return
    188          }
    189          
    190          
    191          //----------------------------------------------------------------
    192          // This is a state machine for parsing commands.  If 'input' is NULL
    193          // 'sizeOrPort' is treated as a port and characters are read from there.
    194          // 
    195          // Goto's are used where one parse state naturally falls into another,
    196          // and to save flash.
    197          

   \                                 In section .text, align 2, keep-with-next
    198          boolean emberProcessCommandString(int8u *input, int8u sizeOrPort)
    199          {
   \                     emberProcessCommandString: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x460F             MOV      R7,R1
    200            boolean isEol = FALSE;
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x.... 0x....      LDR.W    R9,??DataTable43_11
   \   0000000E   0x.... 0x....      LDR.W    R6,??DataTable43_10
   \   00000012   0xE001             B.N      ??emberProcessCommandString_0
    201            boolean isSpace, isQuote;
    202          
    203            while (TRUE) {
    204              int8u next;
    205              
    206              if (input == NULL) {
    207                switch (emberSerialReadByte(sizeOrPort, &next)) {
    208                case EMBER_SUCCESS:
    209                  break;
    210                case EMBER_SERIAL_RX_EMPTY:
    211                  return isEol;
    212                default:
    213                  commandState.error = EMBER_CMD_ERR_PORT_PROBLEM;
    214                  goto READING_TO_EOL;
    215                }
    216              } else if (sizeOrPort == 0) {
    217                return isEol;
    218              } else {
    219                next = *input;
    220                input += 1;
    221                sizeOrPort -= 1;
    222              }
    223          
    224              //   fprintf(stderr, "[processing '%c' (%s)]\n", next, stateNames[commandState.state]);
    225          
    226              if (previousCharacter == '\r' && next == '\n') {
    227                previousCharacter = next;
   \                     ??emberProcessCommandString_1: (+1)
   \   00000014   0xF889 0x0000      STRB     R0,[R9, #+0]
    228                continue;
    229              }
   \                     ??emberProcessCommandString_0: (+1)
   \   00000018   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001C   0xD109             BNE.N    ??emberProcessCommandString_2
   \   0000001E   0xA900             ADD      R1,SP,#+0
   \   00000020   0xB2F8             UXTB     R0,R7
   \   00000022   0x.... 0x....      BL       emberSerialReadByte
   \   00000026   0xB170             CBZ.N    R0,??emberProcessCommandString_3
   \   00000028   0x2826             CMP      R0,#+38
   \   0000002A   0xBF18             IT       NE 
   \   0000002C   0x2001             MOVNE    R0,#+1
   \   0000002E   0xD173             BNE.N    ??emberProcessCommandString_4
   \   00000030   0xE001             B.N      ??emberProcessCommandString_5
   \                     ??emberProcessCommandString_2: (+1)
   \   00000032   0xB2FF             UXTB     R7,R7
   \   00000034   0xB917             CBNZ.N   R7,??emberProcessCommandString_6
   \                     ??emberProcessCommandString_5: (+1)
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??emberProcessCommandString_6: (+1)
   \   0000003C   0xF818 0x0B01      LDRB     R0,[R8], #+1
   \   00000040   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000044   0x1E7F             SUBS     R7,R7,#+1
   \                     ??emberProcessCommandString_3: (+1)
   \   00000046   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \   0000004A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004E   0x290D             CMP      R1,#+13
   \   00000050   0xBF08             IT       EQ 
   \   00000052   0x280A             CMPEQ    R0,#+10
   \   00000054   0xD0DE             BEQ.N    ??emberProcessCommandString_1
    230              previousCharacter = next;
   \   00000056   0xF889 0x0000      STRB     R0,[R9, #+0]
    231              isEol = ((next == '\r') || (next == '\n'));
   \   0000005A   0x280D             CMP      R0,#+13
   \   0000005C   0xD105             BNE.N    ??emberProcessCommandString_7
   \                     ??emberProcessCommandString_8: (+1)
   \   0000005E   0x2401             MOVS     R4,#+1
   \                     ??emberProcessCommandString_9: (+1)
   \   00000060   0x2500             MOVS     R5,#+0
    232              isSpace = (next == ' ');
    233              isQuote = (next == '"');
   \   00000062   0x2822             CMP      R0,#+34
   \   00000064   0xD107             BNE.N    ??emberProcessCommandString_10
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0xE006             B.N      ??emberProcessCommandString_11
   \                     ??emberProcessCommandString_7: (+1)
   \   0000006A   0x280A             CMP      R0,#+10
   \   0000006C   0xD0F7             BEQ.N    ??emberProcessCommandString_8
   \   0000006E   0x2400             MOVS     R4,#+0
   \   00000070   0x2820             CMP      R0,#+32
   \   00000072   0xD1F5             BNE.N    ??emberProcessCommandString_9
   \   00000074   0x2501             MOVS     R5,#+1
   \                     ??emberProcessCommandString_10: (+1)
   \   00000076   0x2100             MOVS     R1,#+0
    234          
    235          
    236              switch (commandState.state) {
   \                     ??emberProcessCommandString_11: (+1)
   \   00000078   0x7832             LDRB     R2,[R6, #+0]
   \   0000007A   0xB132             CBZ.N    R2,??emberProcessCommandString_12
   \   0000007C   0x2A02             CMP      R2,#+2
   \   0000007E   0xD021             BEQ.N    ??emberProcessCommandString_13
   \   00000080   0xD317             BCC.N    ??emberProcessCommandString_14
   \   00000082   0x2A04             CMP      R2,#+4
   \   00000084   0xD04C             BEQ.N    ??emberProcessCommandString_15
   \   00000086   0xD321             BCC.N    ??emberProcessCommandString_16
   \   00000088   0xE7C6             B.N      ??emberProcessCommandString_0
    237          
    238              case CMD_AWAITING_ARGUMENT:
    239                if (isEol) {
   \                     ??emberProcessCommandString_12: (+1)
   \   0000008A   0xB114             CBZ.N    R4,??emberProcessCommandString_17
    240                  callCommandAction();
   \                     ??emberProcessCommandString_18: (+1)
   \   0000008C   0x.... 0x....      BL       callCommandAction
   \   00000090   0xE7C2             B.N      ??emberProcessCommandString_0
    241                } else if (! isSpace) {
   \                     ??emberProcessCommandString_17: (+1)
   \   00000092   0x2D00             CMP      R5,#+0
   \   00000094   0xD1C0             BNE.N    ??emberProcessCommandString_0
    242                  if (isQuote) {
   \   00000096   0xB139             CBZ.N    R1,??emberProcessCommandString_19
    243                    commandState.state = CMD_READING_STRING;
   \   00000098   0x2002             MOVS     R0,#+2
   \                     ??emberProcessCommandString_20: (+1)
   \   0000009A   0x7030             STRB     R0,[R6, #+0]
    244                  } else if (next == '{') {
    245                    commandState.state = CMD_READING_HEX_STRING;
    246                  } else {
    247                    commandState.state = CMD_READING_ARGUMENT;
    248                  }
    249                  goto WRITE_TO_BUFFER;
    250                }
    251                break;
    252          
    253              case CMD_READING_ARGUMENT:
    254                if (isEol || isSpace) {
    255                  goto END_ARGUMENT;
    256                } else {
    257                  goto WRITE_TO_BUFFER;
    258                }
    259          
    260              case CMD_READING_STRING:
    261                if (isQuote) {
    262                  goto END_ARGUMENT;
    263                } else if (isEol) {
    264                  commandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
    265                  goto READING_TO_EOL;
    266                } else {
    267                  goto WRITE_TO_BUFFER;
    268                }
    269          
    270              case CMD_READING_HEX_STRING: {
    271                boolean waitingForLowNibble = (commandState.hexHighNibble != 0xFF);
    272                if (next == '}') {
    273                  if (waitingForLowNibble) {
    274                    commandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
    275                    goto READING_TO_EOL;
    276                  }
    277                  goto END_ARGUMENT;
    278                } else {
    279                  int8u value = hexToInt(next);
    280                  if (value < 16) {
    281                    if (waitingForLowNibble) {
    282                      next = (commandState.hexHighNibble << 4) + value;
    283                      commandState.hexHighNibble = 0xFF;
    284                      goto WRITE_TO_BUFFER;
    285                    } else {
    286                      commandState.hexHighNibble = value;
    287                    }
    288                  } else if (! isSpace) {
    289                    commandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
    290                    goto READING_TO_EOL;
    291                  }
    292                }
    293                break;
    294              }
    295          
    296              READING_TO_EOL:
    297                commandState.state = CMD_READING_TO_EOL;
    298                //lint -fallthrough
    299                
    300              case CMD_READING_TO_EOL:
    301                if (isEol) {
    302                  if (commandState.error != EMBER_CMD_SUCCESS) {
    303                    emberCommandErrorHandler(commandState.error);
    304                  }
    305                  emberCommandReaderInit();
    306                }
    307                break;
    308          
    309              END_ARGUMENT:
    310                if (commandState.tokenCount == MAX_TOKEN_COUNT) {
    311                  commandState.error = EMBER_CMD_ERR_WRONG_NUMBER_OF_ARGUMENTS;
    312                  goto READING_TO_EOL;
    313                }
    314                commandState.tokenCount += 1;
    315                commandState.tokenIndices[commandState.tokenCount] = commandState.index;
    316                commandState.state = CMD_AWAITING_ARGUMENT;
    317                if (isEol) {
    318                  callCommandAction();
    319                }
    320                break;
    321          
    322              WRITE_TO_BUFFER:
    323                if (commandState.index == EMBER_COMMAND_BUFFER_LENGTH) {
   \                     ??emberProcessCommandString_21: (+1)
   \   0000009C   0xF896 0x5078      LDRB     R5,[R6, #+120]
   \   000000A0   0x2D64             CMP      R5,#+100
   \   000000A2   0xD155             BNE.N    ??emberProcessCommandString_22
    324                  commandState.error = EMBER_CMD_ERR_STRING_TOO_LONG;
   \   000000A4   0x2006             MOVS     R0,#+6
   \   000000A6   0xE037             B.N      ??emberProcessCommandString_4
    325                  goto READING_TO_EOL;
    326                }
   \                     ??emberProcessCommandString_19: (+1)
   \   000000A8   0x287B             CMP      R0,#+123
   \   000000AA   0xBF14             ITE      NE 
   \   000000AC   0x2001             MOVNE    R0,#+1
   \   000000AE   0x2003             MOVEQ    R0,#+3
   \   000000B0   0xE7F3             B.N      ??emberProcessCommandString_20
   \                     ??emberProcessCommandString_14: (+1)
   \   000000B2   0xEA55 0x0004      ORRS     R0,R5,R4
   \   000000B6   0xD0F1             BEQ.N    ??emberProcessCommandString_21
   \                     ??emberProcessCommandString_23: (+1)
   \   000000B8   0xF896 0x0077      LDRB     R0,[R6, #+119]
   \   000000BC   0x2811             CMP      R0,#+17
   \   000000BE   0xD139             BNE.N    ??emberProcessCommandString_24
   \   000000C0   0x2003             MOVS     R0,#+3
   \   000000C2   0xE029             B.N      ??emberProcessCommandString_4
   \                     ??emberProcessCommandString_13: (+1)
   \   000000C4   0x2900             CMP      R1,#+0
   \   000000C6   0xD1F7             BNE.N    ??emberProcessCommandString_23
   \   000000C8   0xBB2C             CBNZ.N   R4,??emberProcessCommandString_25
   \   000000CA   0xE7E7             B.N      ??emberProcessCommandString_21
   \                     ??emberProcessCommandString_16: (+1)
   \   000000CC   0xF896 0xA07A      LDRB     R10,[R6, #+122]
   \   000000D0   0xF1BA 0x0FFF      CMP      R10,#+255
   \   000000D4   0xBF14             ITE      NE 
   \   000000D6   0xF04F 0x0B01      MOVNE    R11,#+1
   \   000000DA   0xF04F 0x0B00      MOVEQ    R11,#+0
   \   000000DE   0x287D             CMP      R0,#+125
   \   000000E0   0xD103             BNE.N    ??emberProcessCommandString_26
   \   000000E2   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000E6   0xD116             BNE.N    ??emberProcessCommandString_25
   \   000000E8   0xE7E6             B.N      ??emberProcessCommandString_23
   \                     ??emberProcessCommandString_26: (+1)
   \   000000EA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000EE   0x.... 0x....      BL       hexToInt
   \   000000F2   0x2810             CMP      R0,#+16
   \   000000F4   0xDA0D             BGE.N    ??emberProcessCommandString_27
   \   000000F6   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000FA   0xD007             BEQ.N    ??emberProcessCommandString_28
   \   000000FC   0xEB00 0x100A      ADD      R0,R0,R10, LSL #+4
   \   00000100   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000104   0x20FF             MOVS     R0,#+255
   \   00000106   0xF886 0x007A      STRB     R0,[R6, #+122]
   \   0000010A   0xE7C7             B.N      ??emberProcessCommandString_21
   \                     ??emberProcessCommandString_28: (+1)
   \   0000010C   0xF886 0x007A      STRB     R0,[R6, #+122]
   \                     ??emberProcessCommandString_29: (+1)
   \   00000110   0xE782             B.N      ??emberProcessCommandString_0
   \                     ??emberProcessCommandString_27: (+1)
   \   00000112   0x2D00             CMP      R5,#+0
   \   00000114   0xD1FC             BNE.N    ??emberProcessCommandString_29
   \                     ??emberProcessCommandString_25: (+1)
   \   00000116   0x2005             MOVS     R0,#+5
   \                     ??emberProcessCommandString_4: (+1)
   \   00000118   0xF886 0x0079      STRB     R0,[R6, #+121]
   \   0000011C   0x2004             MOVS     R0,#+4
   \   0000011E   0x7030             STRB     R0,[R6, #+0]
   \                     ??emberProcessCommandString_15: (+1)
   \   00000120   0x2C00             CMP      R4,#+0
   \   00000122   0xD006             BEQ.N    ??emberProcessCommandString_30
   \   00000124   0xF896 0x0079      LDRB     R0,[R6, #+121]
   \   00000128   0xB108             CBZ.N    R0,??emberProcessCommandString_31
   \   0000012A   0x.... 0x....      BL       emberCommandErrorHandler
   \                     ??emberProcessCommandString_31: (+1)
   \   0000012E   0x.... 0x....      BL       emberCommandReaderInit
   \                     ??emberProcessCommandString_30: (+1)
   \   00000132   0xE771             B.N      ??emberProcessCommandString_0
   \                     ??emberProcessCommandString_24: (+1)
   \   00000134   0x1C40             ADDS     R0,R0,#+1
   \   00000136   0xF886 0x0077      STRB     R0,[R6, #+119]
   \   0000013A   0xB2C0             UXTB     R0,R0
   \   0000013C   0xF896 0x1078      LDRB     R1,[R6, #+120]
   \   00000140   0x1980             ADDS     R0,R0,R6
   \   00000142   0xF880 0x1065      STRB     R1,[R0, #+101]
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0x7030             STRB     R0,[R6, #+0]
   \   0000014A   0x2C00             CMP      R4,#+0
   \   0000014C   0xD0F1             BEQ.N    ??emberProcessCommandString_30
   \   0000014E   0xE79D             B.N      ??emberProcessCommandString_18
    327                if (commandState.state == CMD_READING_ARGUMENT) {
   \                     ??emberProcessCommandString_22: (+1)
   \   00000150   0x7830             LDRB     R0,[R6, #+0]
   \   00000152   0x2801             CMP      R0,#+1
   \   00000154   0xD105             BNE.N    ??emberProcessCommandString_32
    328                  next = charDowncase(next);
   \   00000156   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000015A   0x.... 0x....      BL       charDowncase
   \   0000015E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    329                }
    330                commandState.buffer[commandState.index] = next;
   \                     ??emberProcessCommandString_32: (+1)
   \   00000162   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000166   0x19A9             ADDS     R1,R5,R6
   \   00000168   0x7048             STRB     R0,[R1, #+1]
    331                commandState.index += 1;
   \   0000016A   0xF896 0x0078      LDRB     R0,[R6, #+120]
   \   0000016E   0x1C40             ADDS     R0,R0,#+1
   \   00000170   0xF886 0x0078      STRB     R0,[R6, #+120]
    332                break;
   \   00000174   0xE750             B.N      ??emberProcessCommandString_0
    333          
    334              default: {
    335              }
    336              } //close switch.
    337            }
    338          }
    339          
    340          //----------------------------------------------------------------
    341          // Command lookup and processing
    342          
    343          // Returs true if entry is a nested command, and in this case
    344          // it populates the nestedCommand pointer.
    345          // Otherwise it returns false, and does nothing with nestedCommand
    346          //
    347          // Nested commands are implemented by setting the action
    348          // field to NULL, and the argumentTypes field is a pointer
    349          // to a nested EmberCommandEntry array. The older mechanism is
    350          // to set argumentTypes to "n" and then the action field
    351          // contains the EmberCommandEntry, but that approach has a problem
    352          // on AVR128, therefore it is technically deprecated. If you have 
    353          // a choice, put NULL for action and a table under argumentTypes.

   \                                 In section .text, align 2, keep-with-next
    354          static boolean getNestedCommand(EmberCommandEntry *entry,
    355                                          EmberCommandEntry **nestedCommand) {
    356            if ( entry -> action == NULL ) {
   \                     getNestedCommand: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
   \   00000002   0x6840             LDR      R0,[R0, #+4]
   \   00000004   0x0003             MOVS     R3,R0
   \   00000006   0xBF08             IT       EQ 
    357              *nestedCommand = (EmberCommandEntry*)entry->argumentTypes;
   \   00000008   0x600A             STREQ    R2,[R1, #+0]
    358              return TRUE;
   \   0000000A   0xD003             BEQ.N    ??getNestedCommand_0
    359            } else if ( entry -> argumentTypes[0] == 'n' ) {
   \   0000000C   0x7812             LDRB     R2,[R2, #+0]
   \   0000000E   0x2A6E             CMP      R2,#+110
   \   00000010   0xD102             BNE.N    ??getNestedCommand_1
    360              *nestedCommand = (EmberCommandEntry*)(void*)entry->action;
   \   00000012   0x6008             STR      R0,[R1, #+0]
    361              return TRUE;
   \                     ??getNestedCommand_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR
    362            } else {
    363              return FALSE;
   \                     ??getNestedCommand_1: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    364            }
    365          }
    366          

   \                                 In section .text, align 2, keep-with-next
    367          static int8u charDowncase(int8u c)
    368          {
    369            if ('A' <= c && c <= 'Z')
   \                     charDowncase: (+1)
   \   00000000   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   00000004   0x291A             CMP      R1,#+26
   \   00000006   0xBF3C             ITT      CC 
    370              return c + 'a' - 'A';
   \   00000008   0x3020             ADDCC    R0,R0,#+32
   \   0000000A   0xB2C0             UXTBCC   R0,R0
    371            else
    372              return c;
   \   0000000C   0x4770             BX       LR               ;; return
    373          }
    374          

   \                                 In section .text, align 2, keep-with-next
    375          static int8u firstByteOfArg(int8u argNum)
    376          {
    377            int8u tokenNum = argNum + commandState.argOffset;
    378            return commandState.buffer[commandState.tokenIndices[tokenNum]];
   \                     firstByteOfArg: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable43_10
   \   00000004   0xF891 0x207B      LDRB     R2,[R1, #+123]
   \   00000008   0x1810             ADDS     R0,R2,R0
   \   0000000A   0xB2C0             UXTB     R0,R0
   \   0000000C   0x1840             ADDS     R0,R0,R1
   \   0000000E   0xF890 0x0065      LDRB     R0,[R0, #+101]
   \   00000012   0x1840             ADDS     R0,R0,R1
   \   00000014   0x7840             LDRB     R0,[R0, #+1]
   \   00000016   0x4770             BX       LR               ;; return
    379          }
    380          
    381          // To support existing lazy-typer functionality in the app framework, 
    382          // we allow the user to shorten the entered command so long as the
    383          // substring matches no more than one command in the table.
    384          //
    385          // To allow CONST savings by storing abbreviated command names, we also
    386          // allow matching if the input command is longer than the stored command.
    387          // To reduce complexity, we do not handle multiple inexact matches.  
    388          // For example, if there are commands 'A' and 'AB', and the user enters 
    389          // 'ABC', nothing will match.
    390          
    391          static EmberCommandEntry *commandLookup(EmberCommandEntry *commandFinger, 
    392                                                  int8u tokenNum)
    393          {
    394            EmberCommandEntry *inexactMatch = NULL;
    395            int8u *inputCommand = tokenPointer(tokenNum);
    396            int8u inputLength = tokenLength(tokenNum);
    397            boolean multipleMatches = FALSE;
    398          
    399            for (; commandFinger->name != NULL; commandFinger++) {
    400              PGM_P entryFinger = commandFinger->name;
    401              int8u *inputFinger = inputCommand;
    402              for (;; entryFinger++, inputFinger++) {
    403                boolean endInput = (inputFinger - inputCommand == inputLength);
    404                boolean endEntry = (*entryFinger == 0);
    405                if (endInput && endEntry) {
    406                  return commandFinger;  // Exact match.
    407                } else if (endInput || endEntry) {
    408                  if (inexactMatch != NULL) {
    409                    multipleMatches = TRUE;  // Multiple matches.
    410                    break;
    411                  } else {
    412                    inexactMatch = commandFinger;
    413                    break;
    414                  }
    415                } else if (charDowncase(*inputFinger) != charDowncase(*entryFinger)) {
    416                  break;
    417                }
    418              }
    419            }
    420            return (multipleMatches || EMBER_REQUIRE_EXACT_COMMAND_NAME ? NULL : inexactMatch);
    421          }
    422          
    423          static void echoPrint(void)
    424          {
    425            int8u tokenNum = 0;
    426            for ( ; tokenNum < commandState.tokenCount; tokenNum++ ) {
    427              int8u *ptr = tokenPointer(tokenNum);
    428              int8u len = tokenLength(tokenNum);
    429              emberSerialWriteData(APP_SERIAL, ptr, len);
    430              emberSerialPrintf(APP_SERIAL, " ");
    431            }
    432            emberSerialPrintf(APP_SERIAL, "\r\n");
    433          }
    434          

   \                                 In section .text, align 2, keep-with-next
    435          static void callCommandAction(void)
    436          {
   \                     callCommandAction: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
    437            EmberCommandEntry *commandFinger = emberCommandTable;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable43_12
   \   0000000A   0x9001             STR      R0,[SP, #+4]
    438            int8u tokenNum = 0;
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43_10
   \   00000012   0xF890 0x0077      LDRB     R0,[R0, #+119]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD063             BEQ.N    ??callCommandAction_0
    439            // We need a separate argTypeNum index because of the '*' arg type.
    440            int8u argTypeNum, argNum; 
    441          
    442            if (commandState.tokenCount == 0) {
    443              goto kickout2;
    444            }
    445          
    446            // If we have echo, we echo here.
    447            if ( emberCommandInterpreterIsEchoOn() ) {
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable43_13
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x07C0             LSLS     R0,R0,#+31
   \   00000022   0xD51B             BPL.N    ??CrossCallReturnLabel_6
    448              echoPrint();
   \   00000024   0x2500             MOVS     R5,#+0
   \   00000026   0x....             ADR.N    R6,??DataTable39  ;; " "
   \   00000028   0xE00E             B.N      ??callCommandAction_1
   \                     ??callCommandAction_2: (+1)
   \   0000002A   0xB268             SXTB     R0,R5
   \   0000002C   0x.... 0x....      BL       tokenPointer
   \   00000030   0x4607             MOV      R7,R0
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       tokenLength
   \   00000038   0x4602             MOV      R2,R0
   \   0000003A   0x4639             MOV      R1,R7
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x.... 0x....      BL       emberSerialWriteData
   \   00000042   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000046   0x1C6D             ADDS     R5,R5,#+1
   \                     ??callCommandAction_1: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable43_10
   \   0000004C   0xF890 0x0077      LDRB     R0,[R0, #+119]
   \   00000050   0xB2ED             UXTB     R5,R5
   \   00000052   0x4285             CMP      R5,R0
   \   00000054   0xD3E9             BCC.N    ??callCommandAction_2
   \   00000056   0x....             ADR.N    R1,??DataTable39_1  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000058   0x.... 0x....      BL       ??Subroutine3_0
    449            }
    450          
    451            // Lookup the command.
    452            while (TRUE) {
    453              commandFinger = commandLookup(commandFinger, tokenNum);
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000005C   0x9D01             LDR      R5,[SP, #+4]
   \   0000005E   0x2600             MOVS     R6,#+0
   \   00000060   0xB260             SXTB     R0,R4
   \   00000062   0x.... 0x....      BL       tokenPointer
   \   00000066   0x4680             MOV      R8,R0
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       tokenLength
   \   0000006E   0x4683             MOV      R11,R0
   \   00000070   0x2700             MOVS     R7,#+0
   \   00000072   0xE00D             B.N      ??callCommandAction_3
   \                     ??callCommandAction_4: (+1)
   \   00000074   0xF819 0x0B01      LDRB     R0,[R9], #+1
   \   00000078   0x.... 0x....      BL       charDowncase
   \   0000007C   0x9000             STR      R0,[SP, #+0]
   \   0000007E   0xF81A 0x0B01      LDRB     R0,[R10], #+1
   \   00000082   0x.... 0x....      BL       charDowncase
   \   00000086   0x9900             LDR      R1,[SP, #+0]
   \   00000088   0xB2C9             UXTB     R1,R1
   \   0000008A   0x4281             CMP      R1,R0
   \   0000008C   0xD006             BEQ.N    ??callCommandAction_5
   \                     ??callCommandAction_6: (+1)
   \   0000008E   0x350C             ADDS     R5,R5,#+12
   \                     ??callCommandAction_3: (+1)
   \   00000090   0xF8D5 0xA000      LDR      R10,[R5, #+0]
   \   00000094   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000098   0xD015             BEQ.N    ??callCommandAction_7
   \   0000009A   0x46C1             MOV      R9,R8
   \                     ??callCommandAction_5: (+1)
   \   0000009C   0xEBA9 0x0008      SUB      R0,R9,R8
   \   000000A0   0x4558             CMP      R0,R11
   \   000000A2   0xBF0C             ITE      EQ 
   \   000000A4   0x2101             MOVEQ    R1,#+1
   \   000000A6   0x2100             MOVNE    R1,#+0
   \   000000A8   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   000000AC   0x1E42             SUBS     R2,R0,#+1
   \   000000AE   0x4192             SBCS     R2,R2,R2
   \   000000B0   0xEA11 0x7FD2      TST      R1,R2, LSR #+31
   \   000000B4   0xD10B             BNE.N    ??callCommandAction_8
   \   000000B6   0xEA51 0x70D2      ORRS     R0,R1,R2, LSR #+31
   \   000000BA   0xD0DB             BEQ.N    ??callCommandAction_4
   \   000000BC   0x2E00             CMP      R6,#+0
   \   000000BE   0xBF0C             ITE      EQ 
   \   000000C0   0x462E             MOVEQ    R6,R5
   \   000000C2   0x2701             MOVNE    R7,#+1
   \   000000C4   0xE7E3             B.N      ??callCommandAction_6
   \                     ??callCommandAction_7: (+1)
   \   000000C6   0x2F00             CMP      R7,#+0
   \   000000C8   0xBF14             ITE      NE 
   \   000000CA   0x2500             MOVNE    R5,#+0
   \   000000CC   0x4635             MOVEQ    R5,R6
   \                     ??callCommandAction_8: (+1)
   \   000000CE   0x9501             STR      R5,[SP, #+4]
    454              if (commandFinger == NULL) {
   \   000000D0   0x9801             LDR      R0,[SP, #+4]
   \   000000D2   0x.... 0x....      LDR.W    R5,??DataTable43_14
   \   000000D6   0xB940             CBNZ.N   R0,??callCommandAction_9
    455                commandState.error = EMBER_CMD_ERR_NO_SUCH_COMMAND;
   \   000000D8   0x2002             MOVS     R0,#+2
   \                     ??callCommandAction_10: (+1)
   \   000000DA   0x70A8             STRB     R0,[R5, #+2]
    456                goto kickout;
    457              } else {
    458                emberCurrentCommand = commandFinger;
    459                tokenNum += 1;
    460                commandState.argOffset += 1;
    461          
    462                if ( getNestedCommand(commandFinger, &commandFinger) ) {
    463                  if (tokenNum >= commandState.tokenCount) {
    464                    commandState.error = EMBER_CMD_ERR_WRONG_NUMBER_OF_ARGUMENTS;
    465                    goto kickout;
    466                  }
    467                } else {
    468                  break;
    469                }
    470              }
    471            }
    472          
    473            // If you put '?' as the first character
    474            // of the argument format string, then you effectivelly
    475            // prevent the argument validation, and the command gets executed.
    476            // At that point it is down to the command to deal with whatever
    477            // arguments it got.
    478            if ( commandFinger->argumentTypes[0] == '?' ) 
    479              goto kickout;
    480            
    481            // Validate the arguments.
    482            for(argTypeNum = 0, argNum = 0; 
    483                tokenNum < commandState.tokenCount; 
    484                tokenNum++, argNum++) {
    485              int8u type = commandFinger->argumentTypes[argTypeNum];
    486              int8u firstChar = firstByteOfArg(argNum);
    487              switch(type) {
    488          
    489              // Integers
    490              case 'u':
    491              case 'v':
    492              case 'w':
    493              case 's': {
    494                int32u limit = (type == 'u' ? 0xFF
    495                                : (type == 'v' ? 0xFFFF
    496                                   : (type =='s' ? 0x7F : 0xFFFFFFFFUL)));
    497                if (stringToUnsignedInt(argNum, TRUE) > limit) {
    498                  commandState.error = EMBER_CMD_ERR_ARGUMENT_OUT_OF_RANGE;
    499                }
    500                break;
    501              }
    502          
    503              // String
    504              case 'b':
    505                if (firstChar != '"' && firstChar != '{') {
    506                  commandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
    507                }
    508                break;
    509          
    510              case 0:
    511                commandState.error = EMBER_CMD_ERR_WRONG_NUMBER_OF_ARGUMENTS;
    512                break;
    513          
    514              default:
    515                commandState.error = EMBER_CMD_ERR_INVALID_ARGUMENT_TYPE;
    516                break;
    517              }
    518          
    519              if (commandFinger->argumentTypes[argTypeNum + 1] != '*') {
    520                argTypeNum += 1;
    521              }
    522          
    523              if (commandState.error != EMBER_CMD_SUCCESS) {
    524                goto kickout;
    525              }
    526            }
    527          
    528            if (! (commandFinger->argumentTypes[argTypeNum] == 0
    529                   || commandFinger->argumentTypes[argTypeNum + 1] == '*')) {
    530              commandState.error = EMBER_CMD_ERR_WRONG_NUMBER_OF_ARGUMENTS;
    531            }
    532          
    533           kickout:
    534          
    535            if (commandState.error == EMBER_CMD_SUCCESS) {
    536              emberCommandActionHandler(commandFinger->action);
    537            } else {
    538              emberCommandErrorHandler(commandState.error);
   \                     ??callCommandAction_11: (+1)
   \   000000DC   0x78A8             LDRB     R0,[R5, #+2]
   \   000000DE   0x.... 0x....      BL       emberCommandErrorHandler
    539            }
    540          
    541           kickout2:
    542          
    543            emberCommandReaderInit();
   \                     ??callCommandAction_0: (+1)
   \   000000E2   0x.... 0x....      BL       emberCommandReaderInit
    544          }
   \   000000E6   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   \                     ??callCommandAction_9: (+1)
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable43_10
   \   000000EE   0x67C8             STR      R0,[R1, #+124]
   \   000000F0   0x1C64             ADDS     R4,R4,#+1
   \   000000F2   0x7928             LDRB     R0,[R5, #+4]
   \   000000F4   0x1C40             ADDS     R0,R0,#+1
   \   000000F6   0x7128             STRB     R0,[R5, #+4]
   \   000000F8   0xA901             ADD      R1,SP,#+4
   \   000000FA   0x9801             LDR      R0,[SP, #+4]
   \   000000FC   0x.... 0x....      BL       getNestedCommand
   \   00000100   0xB118             CBZ.N    R0,??callCommandAction_12
   \   00000102   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000106   0xD3A9             BCC.N    ??CrossCallReturnLabel_6
   \   00000108   0xE050             B.N      ??callCommandAction_13
   \                     ??callCommandAction_12: (+1)
   \   0000010A   0x9801             LDR      R0,[SP, #+4]
   \   0000010C   0x6880             LDR      R0,[R0, #+8]
   \   0000010E   0x7800             LDRB     R0,[R0, #+0]
   \   00000110   0x283F             CMP      R0,#+63
   \   00000112   0xD04D             BEQ.N    ??callCommandAction_14
   \   00000114   0x2600             MOVS     R6,#+0
   \   00000116   0x46B0             MOV      R8,R6
   \   00000118   0xE00F             B.N      ??callCommandAction_15
   \                     ??callCommandAction_16: (+1)
   \   0000011A   0x2007             MOVS     R0,#+7
   \                     ??callCommandAction_17: (+1)
   \   0000011C   0x70A8             STRB     R0,[R5, #+2]
   \                     ??callCommandAction_18: (+1)
   \   0000011E   0x9801             LDR      R0,[SP, #+4]
   \   00000120   0x6880             LDR      R0,[R0, #+8]
   \   00000122   0x1830             ADDS     R0,R6,R0
   \   00000124   0x7840             LDRB     R0,[R0, #+1]
   \   00000126   0x282A             CMP      R0,#+42
   \   00000128   0xBF1C             ITT      NE 
   \   0000012A   0x1C76             ADDNE    R6,R6,#+1
   \   0000012C   0xB2F6             UXTBNE   R6,R6
   \   0000012E   0x78A8             LDRB     R0,[R5, #+2]
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD13D             BNE.N    ??callCommandAction_14
   \   00000134   0x1C64             ADDS     R4,R4,#+1
   \   00000136   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??callCommandAction_15: (+1)
   \   0000013A   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000013E   0x9801             LDR      R0,[SP, #+4]
   \   00000140   0x6880             LDR      R0,[R0, #+8]
   \   00000142   0xD22C             BCS.N    ??callCommandAction_19
   \   00000144   0x5C37             LDRB     R7,[R6, R0]
   \   00000146   0xFA5F 0xF088      UXTB     R0,R8
   \   0000014A   0x.... 0x....      BL       firstByteOfArg
   \   0000014E   0xB327             CBZ.N    R7,??callCommandAction_20
   \   00000150   0xF1B7 0x0162      SUBS     R1,R7,#+98
   \   00000154   0xD01B             BEQ.N    ??callCommandAction_21
   \   00000156   0x3911             SUBS     R1,R1,#+17
   \   00000158   0xD002             BEQ.N    ??callCommandAction_22
   \   0000015A   0x1E89             SUBS     R1,R1,#+2
   \   0000015C   0x2902             CMP      R1,#+2
   \   0000015E   0xD8DC             BHI.N    ??callCommandAction_16
   \                     ??callCommandAction_22: (+1)
   \   00000160   0x2F75             CMP      R7,#+117
   \   00000162   0xBF08             IT       EQ 
   \   00000164   0x27FF             MOVEQ    R7,#+255
   \   00000166   0xD009             BEQ.N    ??callCommandAction_23
   \   00000168   0x2F76             CMP      R7,#+118
   \   0000016A   0xBF08             IT       EQ 
   \   0000016C   0xF64F 0x77FF      MOVWEQ   R7,#+65535
   \   00000170   0xD004             BEQ.N    ??callCommandAction_23
   \   00000172   0x2F73             CMP      R7,#+115
   \   00000174   0xBF0C             ITE      EQ 
   \   00000176   0x277F             MOVEQ    R7,#+127
   \   00000178   0xF04F 0x37FF      MOVNE    R7,#-1
   \                     ??callCommandAction_23: (+1)
   \   0000017C   0x2101             MOVS     R1,#+1
   \   0000017E   0xFA5F 0xF088      UXTB     R0,R8
   \   00000182   0x.... 0x....      BL       stringToUnsignedInt
   \   00000186   0x4287             CMP      R7,R0
   \   00000188   0xD2C9             BCS.N    ??callCommandAction_18
   \   0000018A   0x2004             MOVS     R0,#+4
   \   0000018C   0xE7C6             B.N      ??callCommandAction_17
   \                     ??callCommandAction_21: (+1)
   \   0000018E   0x2822             CMP      R0,#+34
   \   00000190   0xBF18             IT       NE 
   \   00000192   0x287B             CMPNE    R0,#+123
   \   00000194   0xD0C3             BEQ.N    ??callCommandAction_18
   \   00000196   0x2005             MOVS     R0,#+5
   \   00000198   0xE7C0             B.N      ??callCommandAction_17
   \                     ??callCommandAction_20: (+1)
   \   0000019A   0x2003             MOVS     R0,#+3
   \   0000019C   0xE7BE             B.N      ??callCommandAction_17
   \                     ??callCommandAction_19: (+1)
   \   0000019E   0x5C31             LDRB     R1,[R6, R0]
   \   000001A0   0x2900             CMP      R1,#+0
   \   000001A2   0xBF1E             ITTT     NE 
   \   000001A4   0x1830             ADDNE    R0,R6,R0
   \   000001A6   0x7840             LDRBNE   R0,[R0, #+1]
   \   000001A8   0x282A             CMPNE    R0,#+42
   \   000001AA   0xD001             BEQ.N    ??callCommandAction_14
   \                     ??callCommandAction_13: (+1)
   \   000001AC   0x2003             MOVS     R0,#+3
   \   000001AE   0xE794             B.N      ??callCommandAction_10
   \                     ??callCommandAction_14: (+1)
   \   000001B0   0x78A8             LDRB     R0,[R5, #+2]
   \   000001B2   0x2800             CMP      R0,#+0
   \   000001B4   0xD192             BNE.N    ??callCommandAction_11
   \   000001B6   0x9801             LDR      R0,[SP, #+4]
   \   000001B8   0x6840             LDR      R0,[R0, #+4]
   \   000001BA   0x.... 0x....      BL       emberCommandActionHandler
   \   000001BE   0xE790             B.N      ??callCommandAction_0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable43_10
   \   00000004   0xF890 0x0077      LDRB     R0,[R0, #+119]
   \   00000008   0xB2E4             UXTB     R4,R4
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0x4770             BX       LR
    545          
    546          
    547          //----------------------------------------------------------------
    548          // Retrieving arguments
    549          

   \                                 In section .text, align 2, keep-with-next
    550          int8u emberCommandArgumentCount(void)
    551          {
    552            return (commandState.tokenCount - commandState.argOffset);
   \                     emberCommandArgumentCount: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable43_10
   \   00000004   0xF890 0x1077      LDRB     R1,[R0, #+119]
   \   00000008   0xF890 0x007B      LDRB     R0,[R0, #+123]
   \   0000000C                      REQUIRE ?Subroutine0
   \   0000000C                      ;; // Fall through to label ?Subroutine0
    553          }
    554          

   \                                 In section .text, align 2, keep-with-next
    555          static int32u stringToUnsignedInt(int8u argNum, boolean swallowLeadingSign)
    556          {
   \                     stringToUnsignedInt: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    557            int8u tokenNum = argNum + commandState.argOffset;
   \   00000004   0x.... 0x....      LDR.W    R9,??DataTable43_10
   \   00000008   0x4688             MOV      R8,R1
   \   0000000A   0xF899 0x107B      LDRB     R1,[R9, #+123]
   \   0000000E   0x1808             ADDS     R0,R1,R0
    558            int8u *string = commandState.buffer + commandState.tokenIndices[tokenNum];
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0xEB00 0x0109      ADD      R1,R0,R9
   \   00000016   0xF891 0x1065      LDRB     R1,[R1, #+101]
   \   0000001A   0x4449             ADD      R1,R1,R9
   \   0000001C   0x1C4E             ADDS     R6,R1,#+1
    559            int8u length = tokenLength(tokenNum);
   \   0000001E   0x.... 0x....      BL       tokenLength
   \   00000022   0x4682             MOV      R10,R0
    560            int32u result = 0;
    561            int8u base = defaultBase;
   \   00000024   0x....             LDR.N    R0,??DataTable43_8
   \   00000026   0x7805             LDRB     R5,[R0, #+0]
   \   00000028   0x2400             MOVS     R4,#+0
    562            int8u i;
    563            for (i = 0; i < length; i++) {
   \   0000002A   0x2700             MOVS     R7,#+0
   \   0000002C   0xE007             B.N      ??stringToUnsignedInt_0
    564              int8u next = string[i];
    565              if (swallowLeadingSign && i == 0 && next == '-') {
    566                // do nothing
    567              } else if ((next == 'x' || next == 'X')
    568                         && result == 0
    569                         && (i == 1 || i == 2)) {
   \                     ??stringToUnsignedInt_1: (+1)
   \   0000002E   0xB9A4             CBNZ.N   R4,??stringToUnsignedInt_2
   \   00000030   0x2F01             CMP      R7,#+1
   \   00000032   0xBF18             IT       NE 
   \   00000034   0x2F02             CMPNE    R7,#+2
   \   00000036   0xD110             BNE.N    ??stringToUnsignedInt_2
    570                base = 16;
   \   00000038   0x2510             MOVS     R5,#+16
    571              } else {
   \                     ??stringToUnsignedInt_3: (+1)
   \   0000003A   0x1C78             ADDS     R0,R7,#+1
   \   0000003C   0xB2C7             UXTB     R7,R0
   \                     ??stringToUnsignedInt_0: (+1)
   \   0000003E   0x4557             CMP      R7,R10
   \   00000040   0xDA17             BGE.N    ??stringToUnsignedInt_4
   \   00000042   0x5DB8             LDRB     R0,[R7, R6]
   \   00000044   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000048   0xD003             BEQ.N    ??stringToUnsignedInt_5
   \   0000004A   0x2F00             CMP      R7,#+0
   \   0000004C   0xBF08             IT       EQ 
   \   0000004E   0x282D             CMPEQ    R0,#+45
   \   00000050   0xD0F3             BEQ.N    ??stringToUnsignedInt_3
   \                     ??stringToUnsignedInt_5: (+1)
   \   00000052   0x2878             CMP      R0,#+120
   \   00000054   0xBF18             IT       NE 
   \   00000056   0x2858             CMPNE    R0,#+88
   \   00000058   0xD0E9             BEQ.N    ??stringToUnsignedInt_1
    572                int8u value = hexToInt(next);
   \                     ??stringToUnsignedInt_2: (+1)
   \   0000005A   0x.... 0x....      BL       hexToInt
    573                if (value < base) {
   \   0000005E   0x42A8             CMP      R0,R5
   \   00000060   0xBFB8             IT       LT 
    574                  result = result * base + value;
   \   00000062   0xFB05 0x0404      MLALT    R4,R5,R4,R0
   \   00000066   0xDBE8             BLT.N    ??stringToUnsignedInt_3
    575                } else {
    576                  commandState.error = EMBER_CMD_ERR_ARGUMENT_SYNTAX_ERROR;
   \   00000068   0x2005             MOVS     R0,#+5
   \   0000006A   0xF889 0x0079      STRB     R0,[R9, #+121]
    577                  return 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE000             B.N      ??stringToUnsignedInt_6
    578                }
    579              }
    580            }
    581            return result;
   \                     ??stringToUnsignedInt_4: (+1)
   \   00000072   0x4620             MOV      R0,R4
   \                     ??stringToUnsignedInt_6: (+1)
   \   00000074   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    582          }
    583          

   \                                 In section .text, align 2, keep-with-next
    584          int32u emberUnsignedCommandArgument(int8u argNum) 
    585          {
    586            return stringToUnsignedInt(argNum, FALSE);
   \                     emberUnsignedCommandArgument: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      stringToUnsignedInt
    587          }
    588          

   \                                 In section .text, align 2, keep-with-next
    589          int16s emberSignedCommandArgument(int8u argNum)
    590          {
   \                     emberSignedCommandArgument: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    591            boolean negative = (firstByteOfArg(argNum) == '-');
   \   00000004   0x.... 0x....      BL       firstByteOfArg
   \   00000008   0x282D             CMP      R0,#+45
   \   0000000A   0xBF0C             ITE      EQ 
   \   0000000C   0x2501             MOVEQ    R5,#+1
   \   0000000E   0x2500             MOVNE    R5,#+0
    592            int16s result = (int16s) stringToUnsignedInt(argNum, negative);
   \   00000010   0x4629             MOV      R1,R5
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       stringToUnsignedInt
    593            return (negative ? -result : result);
   \   00000018   0xB10D             CBZ.N    R5,??emberSignedCommandArgument_0
   \   0000001A   0xB200             SXTH     R0,R0
   \   0000001C   0x4240             RSBS     R0,R0,#+0
   \                     ??emberSignedCommandArgument_0: (+1)
   \   0000001E   0xB200             SXTH     R0,R0
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    594          }
    595          

   \                                 In section .text, align 2, keep-with-next
    596          int8u *emberStringCommandArgument(int8s argNum, int8u *length)
    597          {
   \                     emberStringCommandArgument: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
    598            int8u tokenNum = argNum + commandState.argOffset;
   \   00000004   0x....             LDR.N    R1,??DataTable43_10
   \   00000006   0xF891 0x107B      LDRB     R1,[R1, #+123]
   \   0000000A   0x180D             ADDS     R5,R1,R0
    599            int8u leadingQuote = (argNum < 0 ? 0 : 1);
   \   0000000C   0x43C6             MVNS     R6,R0
    600            if (length != NULL) {
   \   0000000E   0xB12C             CBZ.N    R4,??emberStringCommandArgument_0
    601              *length = tokenLength(tokenNum) - leadingQuote;
   \   00000010   0xB2E8             UXTB     R0,R5
   \   00000012   0x.... 0x....      BL       tokenLength
   \   00000016   0xEBA0 0x70D6      SUB      R0,R0,R6, LSR #+31
   \   0000001A   0x7020             STRB     R0,[R4, #+0]
    602            }
    603            return tokenPointer(tokenNum) + leadingQuote;
   \                     ??emberStringCommandArgument_0: (+1)
   \   0000001C   0xB268             SXTB     R0,R5
   \   0000001E   0x.... 0x....      BL       tokenPointer
   \   00000022   0xEB00 0x70D6      ADD      R0,R0,R6, LSR #+31
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
    604          }
    605          

   \                                 In section .text, align 2, keep-with-next
    606          boolean emberStringToHostOrderIpv4Address(const int8u* string, int32u* hostOrderIpv4Address)
    607          {
   \                     emberStringToHostOrderIpv4Address: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
    608            int8u quadCount = 0;
    609            int16u quad = 0;  // 16-bit so we can catch errors where quad > 255.
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2300             MOVS     R3,#+0
    610            boolean valueFound = FALSE;
   \   00000006   0x4614             MOV      R4,R2
    611            *hostOrderIpv4Address = 0;
   \   00000008   0x600A             STR      R2,[R1, #+0]
   \   0000000A   0xE00F             B.N      ??emberStringToHostOrderIpv4Address_0
    612            while (*string != '\0' && *string != '"') {
    613              if (*string == '.') {
    614                if (!valueFound) {
   \                     ??emberStringToHostOrderIpv4Address_1: (+1)
   \   0000000C   0xB92C             CBNZ.N   R4,??emberStringToHostOrderIpv4Address_2
    615                  emberSerialPrintfLine(APP_SERIAL, "Error: No value found before '.'");
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      ADR.W    R1,`?<Constant "Error: No value found...">`
   \   00000014   0x.... 0x....      BL       emberSerialPrintfLine
    616                  return FALSE;
   \   00000018   0xE02D             B.N      ??emberStringToHostOrderIpv4Address_3
    617                }
    618                *hostOrderIpv4Address += (int8u)quad;
    619                *hostOrderIpv4Address <<= 8;
   \                     ??emberStringToHostOrderIpv4Address_2: (+1)
   \   0000001A   0x680B             LDR      R3,[R1, #+0]
   \   0000001C   0xB2D2             UXTB     R2,R2
   \   0000001E   0x18D2             ADDS     R2,R2,R3
   \   00000020   0x0212             LSLS     R2,R2,#+8
   \   00000022   0x600A             STR      R2,[R1, #+0]
    620          //      emberSerialPrintfLine(APP_SERIAL, "Debug: Finished quad %d. IP: 0x%4X", quad, *hostOrderIpv4Address);
    621                quad = 0;
    622                quadCount++;
   \   00000024   0x462B             MOV      R3,R5
   \   00000026   0x2200             MOVS     R2,#+0
    623                valueFound = FALSE;
   \   00000028   0x2400             MOVS     R4,#+0
    624              } else if (*string < '0' || *string > '9') {
    625                emberSerialPrintfLine(APP_SERIAL, "Error: Invalid char '%c' in IP address", *string);
    626                return FALSE;   
    627              } else {
    628                valueFound = TRUE;
    629                quad *= 10;
    630                quad += (*string - '0');
    631          //      emberSerialPrintfLine(APP_SERIAL, "Debug: Quad is %d", quad);
    632                if (quad > 255) {
    633                  emberSerialPrintfLine(APP_SERIAL, "Error: Invalid value of %d in IP address", quad);
    634                  return FALSE;
    635                }
    636              }
    637              string++;
   \                     ??emberStringToHostOrderIpv4Address_4: (+1)
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \                     ??emberStringToHostOrderIpv4Address_0: (+1)
   \   0000002C   0x7806             LDRB     R6,[R0, #+0]
   \   0000002E   0x1C5D             ADDS     R5,R3,#+1
   \   00000030   0xB1B6             CBZ.N    R6,??emberStringToHostOrderIpv4Address_5
   \   00000032   0x2E22             CMP      R6,#+34
   \   00000034   0xD014             BEQ.N    ??emberStringToHostOrderIpv4Address_5
   \   00000036   0x2E2E             CMP      R6,#+46
   \   00000038   0xD0E8             BEQ.N    ??emberStringToHostOrderIpv4Address_1
   \   0000003A   0xF1A6 0x0430      SUB      R4,R6,#+48
   \   0000003E   0x2C0A             CMP      R4,#+10
   \   00000040   0xD303             BCC.N    ??emberStringToHostOrderIpv4Address_6
   \   00000042   0x.... 0x....      ADR.W    R1,`?<Constant "Error: Invalid char \\'...">`
   \   00000046   0x4632             MOV      R2,R6
   \   00000048   0xE012             B.N      ??emberStringToHostOrderIpv4Address_7
   \                     ??emberStringToHostOrderIpv4Address_6: (+1)
   \   0000004A   0x250A             MOVS     R5,#+10
   \   0000004C   0xFB05 0x6202      MLA      R2,R5,R2,R6
   \   00000050   0x3A30             SUBS     R2,R2,#+48
   \   00000052   0x2401             MOVS     R4,#+1
   \   00000054   0xB292             UXTH     R2,R2
   \   00000056   0x2AFF             CMP      R2,#+255
   \   00000058   0xDDE7             BLE.N    ??emberStringToHostOrderIpv4Address_4
   \   0000005A   0x.... 0x....      ADR.W    R1,`?<Constant "Error: Invalid value ...">`
   \   0000005E   0xE007             B.N      ??emberStringToHostOrderIpv4Address_7
    638            }
    639          
    640            if (valueFound) {
   \                     ??emberStringToHostOrderIpv4Address_5: (+1)
   \   00000060   0xB104             CBZ.N    R4,??emberStringToHostOrderIpv4Address_8
    641              quadCount++;
   \   00000062   0x462B             MOV      R3,R5
    642            }
    643          
    644            if (quadCount != 4) {
   \                     ??emberStringToHostOrderIpv4Address_8: (+1)
   \   00000064   0xB2DB             UXTB     R3,R3
   \   00000066   0x2B04             CMP      R3,#+4
   \   00000068   0xD007             BEQ.N    ??emberStringToHostOrderIpv4Address_9
    645              emberSerialPrintfLine(APP_SERIAL, "Error: Expected 4 quads, got %d.", quadCount);
   \   0000006A   0x461A             MOV      R2,R3
   \   0000006C   0x.... 0x....      ADR.W    R1,`?<Constant "Error: Expected 4 qua...">`
   \                     ??emberStringToHostOrderIpv4Address_7: (+1)
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x.... 0x....      BL       emberSerialPrintfLine
    646              return FALSE;
   \                     ??emberStringToHostOrderIpv4Address_3: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xBD76             POP      {R1,R2,R4-R6,PC}
    647            }
    648          //  emberSerialPrintfLine(APP_SERIAL, "Debug: Finished IP parsing.");
    649            *hostOrderIpv4Address += (int8u)quad;
   \                     ??emberStringToHostOrderIpv4Address_9: (+1)
   \   0000007A   0x6808             LDR      R0,[R1, #+0]
   \   0000007C   0xB2D2             UXTB     R2,R2
   \   0000007E   0x1810             ADDS     R0,R2,R0
   \   00000080   0x6008             STR      R0,[R1, #+0]
    650            return TRUE;
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    651          }
    652          

   \                                 In section .text, align 2, keep-with-next
    653          boolean emberStringArgumentToHostOrderIpv4Address(int8u argNum, int32u* hostOrderIpv4Address)
    654          {
   \                     emberStringArgumentToHostOrderIpv4Address: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x460C             MOV      R4,R1
    655            int8u argLength;
    656            int8u *contents = emberStringCommandArgument(argNum,
    657                                                         &argLength);
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0xB240             SXTB     R0,R0
   \   0000000A   0x.... 0x....      BL       emberStringCommandArgument
    658            return emberStringToHostOrderIpv4Address(contents, hostOrderIpv4Address);
   \   0000000E   0x4621             MOV      R1,R4
   \   00000010   0x.... 0x....      BL       emberStringToHostOrderIpv4Address
   \   00000014   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    659          }
    660          

   \                                 In section .text, align 2, keep-with-next
    661          int8u emberCopyStringArgument(int8s argNum, 
    662                                        int8u *destination, 
    663                                        int8u maxLength,
    664                                        boolean leftPad)
    665          {
   \                     emberCopyStringArgument: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4616             MOV      R6,R2
   \   00000006   0x461F             MOV      R7,R3
    666            int8u padLength;
    667            int8u argLength;
    668            int8u *contents = emberStringCommandArgument(argNum, &argLength);
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x.... 0x....      BL       emberStringCommandArgument
   \   0000000E   0x4605             MOV      R5,R0
    669            if (argLength > maxLength) {
   \   00000010   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000014   0x4286             CMP      R6,R0
   \   00000016   0xBF98             IT       LS 
   \   00000018   0x4630             MOVLS    R0,R6
   \   0000001A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    670              argLength = maxLength;
    671            }
    672            padLength = leftPad ? maxLength - argLength : 0;
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xBF1A             ITTE     NE 
   \   00000022   0xF89D 0x0000      LDRBNE   R0,[SP, #+0]
   \   00000026   0x1A36             SUBNE    R6,R6,R0
   \   00000028   0x2600             MOVEQ    R6,#+0
    673            MEMSET(destination, 0, padLength);
   \   0000002A   0xB2F6             UXTB     R6,R6
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       halCommonMemSet
    674            MEMMOVE(destination + padLength, contents, argLength);
   \   00000036   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   0000003A   0x4629             MOV      R1,R5
   \   0000003C   0x1930             ADDS     R0,R6,R4
   \   0000003E   0x.... 0x....      BL       halCommonMemMove
    675            return argLength;
   \   00000042   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    676          }
    677          

   \                                 In section .text, align 2, keep-with-next
    678          int8u emberCopyBigEndianEui64Argument(int8s index, EmberEUI64 destination)
    679          {
   \                     emberCopyBigEndianEui64Argument: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    680            // emberReverseMemCopy may not be available, so we have to do it ourselves.
    681            int8u i, length = emberCopyEui64Argument(index, destination);
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x2208             MOVS     R2,#+8
   \   00000008   0x.... 0x....      BL       emberCopyStringArgument
    682            for (i = 0; i < EUI64_SIZE / 2; i++) {
   \   0000000C   0x2100             MOVS     R1,#+0
    683              int8u tmp = destination[EUI64_SIZE - i - 1];
   \                     ??emberCopyBigEndianEui64Argument_0: (+1)
   \   0000000E   0x424A             RSBS     R2,R1,#+0
   \   00000010   0x1912             ADDS     R2,R2,R4
    684              destination[EUI64_SIZE - i - 1] = destination[i];
   \   00000012   0x5D0D             LDRB     R5,[R1, R4]
   \   00000014   0x79D3             LDRB     R3,[R2, #+7]
   \   00000016   0x71D5             STRB     R5,[R2, #+7]
    685              destination[i] = tmp;
   \   00000018   0x550B             STRB     R3,[R1, R4]
    686            }
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0x2904             CMP      R1,#+4
   \   0000001E   0xDBF6             BLT.N    ??emberCopyBigEndianEui64Argument_0
    687            return length;
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    688          }
    689          
    690          #if !defined(EMBER_APPLICATION_HAS_COMMAND_ACTION_HANDLER)
    691          void emberCommandActionHandler(const CommandAction action)
    692          {
    693            (*action)();
    694          }
    695          #endif
    696          
    697          #if !defined(EMBER_APPLICATION_HAS_COMMAND_ERROR_HANDLER)

   \                                 In section .data, align 4
    698          PGM_NO_CONST PGM_P emberCommandErrorNames[] =
   \                     emberCommandErrorNames:
   \   00000000   0x........         DC32 `?<Constant "">`, `?<Constant "Serial port error">`
   \              0x........   
   \   00000008   0x........         DC32 `?<Constant "No such command">`
   \   0000000C   0x........         DC32 `?<Constant "Wrong number of args">`
   \   00000010   0x........         DC32 `?<Constant "Arg out of range">`, `?<Constant "Arg syntax error">`
   \              0x........   
   \   00000018   0x........         DC32 `?<Constant "Too long">`, `?<Constant "Bad arg type">`
   \              0x........   
    699            {
    700              "",
    701              "Serial port error",
    702              "No such command",
    703              "Wrong number of args",
    704              "Arg out of range",
    705              "Arg syntax error",
    706              "Too long",
    707              "Bad arg type"
    708            };
    709          
    710          

   \                                 In section .text, align 2, keep-with-next
    711          static void printCommandUsage(boolean singleCommandUsage,
    712                                        EmberCommandEntry *entry) 
    713          {
   \                     printCommandUsage: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x4604             MOV      R4,R0
    714            PGM_P arg = entry->argumentTypes;
   \   00000006   0x68AE             LDR      R6,[R5, #+8]
    715            emberSerialPrintf(APP_SERIAL, "%p", entry->name);
   \   00000008   0x682A             LDR      R2,[R5, #+0]
   \   0000000A   0x....             ADR.N    R1,??DataTable43  ;; 0x25, 0x70, 0x00, 0x00
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       emberSerialPrintf
    716          
    717            if ( entry -> action == NULL ) {
   \   00000012   0x6868             LDR      R0,[R5, #+4]
   \   00000014   0x....             ADR.N    R7,??DataTable43_1  ;; ""
   \   00000016   0xB918             CBNZ.N   R0,??printCommandUsage_0
    718              emberSerialPrintf(APP_SERIAL, "...");
   \   00000018   0x....             ADR.N    R1,??DataTable43_2  ;; "..."
   \   0000001A   0x.... 0x....      BL       ??Subroutine3_0
    719            } else if (singleCommandUsage) {
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000001E   0xE02D             B.N      ??printCommandUsage_1
   \                     ??printCommandUsage_0: (+1)
   \   00000020   0xB91C             CBNZ.N   R4,??printCommandUsage_2
   \   00000022   0xE02B             B.N      ??printCommandUsage_1
    720              int8u argumentIndex = 0;
    721              printIfEntryHasDescription(entry, " (args) \n");
    722              while (*arg) {
    723                int8u c = *arg;
    724                printIfEntryHasArgumentDescriptions(entry,
    725                                                    "  ");
    726                emberSerialPrintf(APP_SERIAL,
    727                                  (c == 'u' ? " <int8u>"
    728                                   : c == 'v' ? " <int16u>"
    729                                   : c == 'w' ? " <int32u>"
    730                                   : c == 's' ? " <int8s>"
    731                                   : c == 'b' ? " <string>"
    732                                   : c == 'n' ? " ..."
    733                                   : c == '*' ? " *"
    734                                   : " ?"));
   \                     ??printCommandUsage_3: (+1)
   \   00000024   0x.... 0x....      BL       ??Subroutine3_0
    735                printIfEntryHasArgumentDescriptions(entry,
    736                                                    "  %p\n",
    737                                                    entry->argumentDescriptions[argumentIndex]);
    738                argumentIndex++;
    739                arg += 1;
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000028   0x1C76             ADDS     R6,R6,#+1
   \                     ??printCommandUsage_2: (+1)
   \   0000002A   0x7830             LDRB     R0,[R6, #+0]
   \   0000002C   0xB310             CBZ.N    R0,??printCommandUsage_4
   \   0000002E   0x2875             CMP      R0,#+117
   \   00000030   0xBF08             IT       EQ 
   \   00000032   0x.... 0x....      ADREQ.W  R1,`?<Constant " <int8u>">`
   \   00000036   0xD0F5             BEQ.N    ??printCommandUsage_3
   \   00000038   0x2876             CMP      R0,#+118
   \   0000003A   0xBF08             IT       EQ 
   \   0000003C   0x.... 0x....      ADREQ.W  R1,`?<Constant " <int16u>">`
   \   00000040   0xD0F0             BEQ.N    ??printCommandUsage_3
   \   00000042   0x2877             CMP      R0,#+119
   \   00000044   0xBF08             IT       EQ 
   \   00000046   0x.... 0x....      ADREQ.W  R1,`?<Constant " <int32u>">`
   \   0000004A   0xD0EB             BEQ.N    ??printCommandUsage_3
   \   0000004C   0x2873             CMP      R0,#+115
   \   0000004E   0xBF08             IT       EQ 
   \   00000050   0x.... 0x....      ADREQ.W  R1,`?<Constant " <int8s>">`
   \   00000054   0xD0E6             BEQ.N    ??printCommandUsage_3
   \   00000056   0x2862             CMP      R0,#+98
   \   00000058   0xBF08             IT       EQ 
   \   0000005A   0x.... 0x....      ADREQ.W  R1,`?<Constant " <string>">`
   \   0000005E   0xD0E1             BEQ.N    ??printCommandUsage_3
   \   00000060   0x286E             CMP      R0,#+110
   \   00000062   0xBF08             IT       EQ 
   \   00000064   0x.... 0x....      ADREQ.W  R1,`?<Constant " ...">`
   \   00000068   0xD0DC             BEQ.N    ??printCommandUsage_3
   \   0000006A   0x282A             CMP      R0,#+42
   \   0000006C   0xBF0C             ITE      EQ 
   \   0000006E   0x....             ADREQ.N  R1,??DataTable43_3  ;; 0x20, 0x2A, 0x00, 0x00
   \   00000070   0x....             ADRNE.N  R1,??DataTable43_4  ;; 0x20, 0x3F, 0x00, 0x00
   \   00000072   0xE7D7             B.N      ??printCommandUsage_3
    740              }
    741              emberSerialPrintfLine(APP_SERIAL, "");
   \                     ??printCommandUsage_4: (+1)
   \   00000074   0x4639             MOV      R1,R7
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x.... 0x....      BL       emberSerialPrintfLine
    742            }
    743            emberSerialWaitSend(APP_SERIAL);
   \                     ??printCommandUsage_1: (+1)
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0x.... 0x....      BL       emberSerialWaitSend
    744            printIfEntryHasDescription(entry, " - %p", entry->description);
    745            
    746            emberSerialPrintfLine(APP_SERIAL, "");
   \   00000082   0x4639             MOV      R1,R7
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x.... 0x....      BL       emberSerialPrintfLine
    747            emberSerialWaitSend(APP_SERIAL);
   \   0000008A   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   0000008E   0x....             B.N      ?Subroutine1
    748          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x4631             MOV      R1,R6
   \                     ??Subroutine3_0: (+1)
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      B.W      emberSerialPrintf

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      B.W      emberSerialWaitSend
    749          

   \                                 In section .text, align 2, keep-with-next
    750          void emberPrintCommandUsage(EmberCommandEntry *entry)
    751          {
   \                     emberPrintCommandUsage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
    752            EmberCommandEntry *commandFinger;
    753            printCommandUsage(TRUE,
    754                              entry);
   \   00000006   0x4621             MOV      R1,R4
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       printCommandUsage
    755          
    756            if ( getNestedCommand(entry, &commandFinger) ) {
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       getNestedCommand
   \   00000016   0xB950             CBNZ.N   R0,??emberPrintCommandUsage_0
   \   00000018   0xBD13             POP      {R0,R1,R4,PC}
    757              for (; commandFinger->name != NULL; commandFinger++) {
    758                emberSerialPrintf(APP_SERIAL, "  ");
   \                     ??emberPrintCommandUsage_1: (+1)
   \   0000001A   0x....             ADR.N    R1,??DataTable43_5  ;; 0x20, 0x20, 0x00, 0x00
   \   0000001C   0x.... 0x....      BL       ??Subroutine3_0
    759                printCommandUsage(FALSE,
    760                                  commandFinger);
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000020   0x9900             LDR      R1,[SP, #+0]
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       printCommandUsage
    761              }   
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x300C             ADDS     R0,R0,#+12
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \                     ??emberPrintCommandUsage_0: (+1)
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD1F1             BNE.N    ??emberPrintCommandUsage_1
    762            }
    763          }
   \   00000036   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    764          

   \                                 In section .text, align 2, keep-with-next
    765          void emberPrintCommandUsageNotes(void)
    766          {
   \                     emberPrintCommandUsageNotes: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    767            emberSerialPrintf(APP_SERIAL, 
    768                              "Usage:\r\n"
    769                              "<int>: 123 or 0x1ABC\r\n"
    770                              "<string>: \"foo\" or {0A 1B 2C}\r\n\r\n");
   \   00000002   0x.... 0x....      ADR.W    R1,`?<Constant "Usage:\\r\\n<int>: 123 or...">`
   \   00000006   0x.... 0x....      BL       ??Subroutine3_0
    771            emberSerialWaitSend(APP_SERIAL);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000000A   0xE8BD 0x4002      POP      {R1,LR}
   \   0000000E                      REQUIRE ?Subroutine1
   \   0000000E                      ;; // Fall through to label ?Subroutine1
    772          }
    773          

   \                                 In section .text, align 2, keep-with-next
    774          void emberPrintCommandTable(void)
    775          {
   \                     emberPrintCommandTable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    776            EmberCommandEntry *commandFinger = emberCommandTable;
   \   00000002   0x....             LDR.N    R4,??DataTable43_12
    777            emberPrintCommandUsageNotes();
   \   00000004   0x.... 0x....      BL       emberPrintCommandUsageNotes
   \   00000008   0xE004             B.N      ??emberPrintCommandTable_0
    778            for (; commandFinger->name != NULL; commandFinger++) {
    779              printCommandUsage(FALSE, commandFinger);
   \                     ??emberPrintCommandTable_1: (+1)
   \   0000000A   0x4621             MOV      R1,R4
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       printCommandUsage
    780            }
   \   00000012   0x340C             ADDS     R4,R4,#+12
   \                     ??emberPrintCommandTable_0: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD1F7             BNE.N    ??emberPrintCommandTable_1
    781          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    782          

   \                                 In section .text, align 2, keep-with-next
    783          void emberCommandErrorHandler(EmberCommandStatus status)
    784          {
   \                     emberCommandErrorHandler: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    785            emberSerialPrintf(APP_SERIAL, "%p\r\n", emberCommandErrorNames[status]);
   \   00000004   0x....             LDR.N    R1,??DataTable43_15
   \   00000006   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
   \   0000000A   0x.... 0x....      ADR.W    R1,`?<Constant "%p\\r\\n">`
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       emberSerialPrintf
    786          
    787            if (emberCurrentCommand == NULL) {
   \   00000014   0x....             LDR.N    R4,??DataTable43_10
   \   00000016   0x6FE0             LDR      R0,[R4, #+124]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xBF04             ITT      EQ 
    788              emberPrintCommandTable();
   \   0000001C   0xE8BD 0x43F1      POPEQ    {R0,R4-R9,LR}
   \   00000020   0x.... 0x....      BEQ.W    emberPrintCommandTable
    789            } else {
    790              int8u *finger;
    791              int8u tokenNum, i;
    792              emberPrintCommandUsageNotes();
   \   00000024   0x.... 0x....      BL       emberPrintCommandUsageNotes
    793              // Reconstruct any parent commands from the buffer.
    794              for (tokenNum = 0; tokenNum < commandState.argOffset - 1; tokenNum++) {
   \   00000028   0x2500             MOVS     R5,#+0
   \   0000002A   0x....             ADR.N    R6,??DataTable43_6  ;; " "
   \   0000002C   0x.... 0x....      ADR.W    R9,??DataTable43_7  ;; 0x25, 0x63, 0x00, 0x00
   \   00000030   0xE00F             B.N      ??emberCommandErrorHandler_0
    795                finger = tokenPointer(tokenNum);
    796                for (i = 0; i < tokenLength(tokenNum); i++) {
    797                  emberSerialPrintf(APP_SERIAL, "%c", finger[i]);
   \                     ??emberCommandErrorHandler_1: (+1)
   \   00000032   0xF817 0x2008      LDRB     R2,[R7, R8]
   \   00000036   0x4649             MOV      R1,R9
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x.... 0x....      BL       emberSerialPrintf
    798                }
   \   0000003E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??emberCommandErrorHandler_2: (+1)
   \   00000040   0x4628             MOV      R0,R5
   \   00000042   0x.... 0x....      BL       tokenLength
   \   00000046   0xB2FF             UXTB     R7,R7
   \   00000048   0x4287             CMP      R7,R0
   \   0000004A   0xD3F2             BCC.N    ??emberCommandErrorHandler_1
    799                emberSerialPrintf(APP_SERIAL, " ");
   \   0000004C   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000050   0x1C6D             ADDS     R5,R5,#+1
   \                     ??emberCommandErrorHandler_0: (+1)
   \   00000052   0xF894 0x007B      LDRB     R0,[R4, #+123]
   \   00000056   0xB2ED             UXTB     R5,R5
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x4285             CMP      R5,R0
   \   0000005C   0xDA05             BGE.N    ??emberCommandErrorHandler_3
   \   0000005E   0xB268             SXTB     R0,R5
   \   00000060   0x.... 0x....      BL       tokenPointer
   \   00000064   0x4680             MOV      R8,R0
   \   00000066   0x2700             MOVS     R7,#+0
   \   00000068   0xE7EA             B.N      ??emberCommandErrorHandler_2
    800              }
    801              emberPrintCommandUsage(emberCurrentCommand);
   \                     ??emberCommandErrorHandler_3: (+1)
   \   0000006A   0x6FE0             LDR      R0,[R4, #+124]
   \   0000006C   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   00000070   0x....             B.N      emberPrintCommandUsage
    802            }
    803          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_1:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \   00000000   0x25 0x70          DC8      0x25, 0x70, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_1:
   \   00000000   0x00 0x00          DC8      "",0x0,0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_2:
   \   00000000   0x2E 0x2E          DC8      "..."
   \              0x2E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_3:
   \   00000000   0x20 0x2A          DC8      0x20, 0x2A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_4:
   \   00000000   0x20 0x3F          DC8      0x20, 0x3F, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_5:
   \   00000000   0x20 0x20          DC8      0x20, 0x20, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_6:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_7:
   \   00000000   0x25 0x63          DC8      0x25, 0x63, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_8:
   \   00000000   0x........         DC32     defaultBase

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_9:
   \   00000000   0x........         DC32     commandState+0x1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_10:
   \   00000000   0x........         DC32     commandState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_11:
   \   00000000   0x........         DC32     previousCharacter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_12:
   \   00000000   0x........         DC32     emberCommandTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_13:
   \   00000000   0x........         DC32     emberCommandInterpreter2Configuration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_14:
   \   00000000   0x........         DC32     commandState+0x77

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_15:
   \   00000000   0x........         DC32     emberCommandErrorNames

   \                                 In section .rodata, align 1, keep-with-next
   \                     `?<Constant "">`:
   \   00000000   0x00               DC8 ""

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error: No value found...">`:
   \   00000000   0x45 0x72          DC8 "Error: No value found before '.'"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x76 0x61    
   \              0x6C 0x75    
   \              0x65 0x20    
   \              0x66 0x6F    
   \              0x75 0x6E    
   \              0x64 0x20    
   \              0x62 0x65    
   \              0x66 0x6F    
   \              0x72 0x65    
   \              0x20 0x27    
   \              0x2E 0x27    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error: Invalid char \\'...">`:
   \   00000000   0x45 0x72          DC8 "Error: Invalid char '%c' in IP address"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x63    
   \              0x68 0x61    
   \              0x72 0x20    
   \              0x27 0x25    
   \              0x63 0x27    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x49 0x50    
   \              0x20 0x61    
   \              0x64 0x64    
   \              0x72 0x65    
   \              0x73 0x73    
   \              0x00         
   \   00000027   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error: Invalid value ...">`:
   \   00000000   0x45 0x72          DC8 "Error: Invalid value of %d in IP address"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x76    
   \              0x61 0x6C    
   \              0x75 0x65    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x25 0x64    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x49 0x50    
   \              0x20 0x61    
   \              0x64 0x64    
   \              0x72 0x65    
   \              0x73 0x73    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error: Expected 4 qua...">`:
   \   00000000   0x45 0x72          DC8 "Error: Expected 4 quads, got %d."
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x45    
   \              0x78 0x70    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x20    
   \              0x34 0x20    
   \              0x71 0x75    
   \              0x61 0x64    
   \              0x73 0x2C    
   \              0x20 0x67    
   \              0x6F 0x74    
   \              0x20 0x25    
   \              0x64 0x2E    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " <int8u>">`:
   \   00000000   0x20 0x3C          DC8 " <int8u>"
   \              0x69 0x6E    
   \              0x74 0x38    
   \              0x75 0x3E    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " <int16u>">`:
   \   00000000   0x20 0x3C          DC8 " <int16u>"
   \              0x69 0x6E    
   \              0x74 0x31    
   \              0x36 0x75    
   \              0x3E 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " <int32u>">`:
   \   00000000   0x20 0x3C          DC8 " <int32u>"
   \              0x69 0x6E    
   \              0x74 0x33    
   \              0x32 0x75    
   \              0x3E 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " <int8s>">`:
   \   00000000   0x20 0x3C          DC8 " <int8s>"
   \              0x69 0x6E    
   \              0x74 0x38    
   \              0x73 0x3E    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " <string>">`:
   \   00000000   0x20 0x3C          DC8 " <string>"
   \              0x73 0x74    
   \              0x72 0x69    
   \              0x6E 0x67    
   \              0x3E 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " ...">`:
   \   00000000   0x20 0x2E          DC8 " ..."
   \              0x2E 0x2E    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Serial port error">`:
   \   00000000   0x53 0x65          DC8 "Serial port error"
   \              0x72 0x69    
   \              0x61 0x6C    
   \              0x20 0x70    
   \              0x6F 0x72    
   \              0x74 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "No such command">`:
   \   00000000   0x4E 0x6F          DC8 "No such command"
   \              0x20 0x73    
   \              0x75 0x63    
   \              0x68 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Usage:\\r\\n<int>: 123 or...">`:
   \   00000000   0x55 0x73          DC8 55H, 73H, 61H, 67H, 65H, 3AH, 0DH, 0AH
   \              0x61 0x67    
   \              0x65 0x3A    
   \              0x0D 0x0A    
   \   00000008   0x3C 0x69          DC8 3CH, 69H, 6EH, 74H, 3EH, 3AH, 20H, 31H
   \              0x6E 0x74    
   \              0x3E 0x3A    
   \              0x20 0x31    
   \   00000010   0x32 0x33          DC8 32H, 33H, 20H, 6FH, 72H, 20H, 30H, 78H
   \              0x20 0x6F    
   \              0x72 0x20    
   \              0x30 0x78    
   \   00000018   0x31 0x41          DC8 31H, 41H, 42H, 43H, 0DH, 0AH, 3CH, 73H
   \              0x42 0x43    
   \              0x0D 0x0A    
   \              0x3C 0x73    
   \   00000020   0x74 0x72          DC8 74H, 72H, 69H, 6EH, 67H, 3EH, 3AH, 20H
   \              0x69 0x6E    
   \              0x67 0x3E    
   \              0x3A 0x20    
   \   00000028   0x22 0x66          DC8 22H, 66H, 6FH, 6FH, 22H, 20H, 6FH, 72H
   \              0x6F 0x6F    
   \              0x22 0x20    
   \              0x6F 0x72    
   \   00000030   0x20 0x7B          DC8 20H, 7BH, 30H, 41H, 20H, 31H, 42H, 20H
   \              0x30 0x41    
   \              0x20 0x31    
   \              0x42 0x20    
   \   00000038   0x32 0x43          DC8 32H, 43H, 7DH, 0DH, 0AH, 0DH, 0AH, 0
   \              0x7D 0x0D    
   \              0x0A 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%p\\r\\n">`:
   \   00000000   0x25 0x70          DC8 "%p\015\012"
   \              0x0D 0x0A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Wrong number of args">`:
   \   00000000   0x57 0x72          DC8 "Wrong number of args"
   \              0x6F 0x6E    
   \              0x67 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x61 0x72    
   \              0x67 0x73    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Arg out of range">`:
   \   00000000   0x41 0x72          DC8 "Arg out of range"
   \              0x67 0x20    
   \              0x6F 0x75    
   \              0x74 0x20    
   \              0x6F 0x66    
   \              0x20 0x72    
   \              0x61 0x6E    
   \              0x67 0x65    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Arg syntax error">`:
   \   00000000   0x41 0x72          DC8 "Arg syntax error"
   \              0x67 0x20    
   \              0x73 0x79    
   \              0x6E 0x74    
   \              0x61 0x78    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Too long">`:
   \   00000000   0x54 0x6F          DC8 "Too long"
   \              0x6F 0x20    
   \              0x6C 0x6F    
   \              0x6E 0x67    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "Bad arg type">`:
   \   00000000   0x42 0x61          DC8 "Bad arg type"
   \              0x64 0x20    
   \              0x61 0x72    
   \              0x67 0x20    
   \              0x74 0x79    
   \              0x70 0x65    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant " ">`:
   \   00000000   0x20 0x00          DC8 " "

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "\\r\\n">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "%p">`:
   \   00000000   0x25 0x70          DC8 "%p"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "...">`:
   \   00000000   0x2E 0x2E          DC8 "..."
   \              0x2E 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " *">`:
   \   00000000   0x20 0x2A          DC8 " *"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " ?">`:
   \   00000000   0x20 0x3F          DC8 " ?"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "  ">`:
   \   00000000   0x20 0x20          DC8 "  "
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "%c">`:
   \   00000000   0x25 0x63          DC8 "%c"
   \              0x00         
   \   00000003   0x00               DC8 0
    804          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   callCommandAction
        48   -> charDowncase
        48   -> emberCommandActionHandler
        48   -> emberCommandErrorHandler
        48   -> emberCommandReaderInit
        48   -> emberSerialPrintf
        48   -> emberSerialWriteData
        48   -> firstByteOfArg
        48   -> getNestedCommand
        48   -> stringToUnsignedInt
        48   -> tokenLength
        48   -> tokenPointer
       0   charDowncase
       0   emberCommandArgumentCount
       0   emberCommandClearBuffer
         0   -> halCommonMemSet
      32   emberCommandErrorHandler
        32   -> emberPrintCommandTable
         0   -> emberPrintCommandUsage
        32   -> emberPrintCommandUsageNotes
        32   -> emberSerialPrintf
        32   -> tokenLength
        32   -> tokenPointer
       0   emberCommandName
       0   emberCommandReaderInit
       0   emberCommandReaderSetDefaultBase
      16   emberCopyBigEndianEui64Argument
        16   -> emberCopyStringArgument
      24   emberCopyStringArgument
        24   -> emberStringCommandArgument
        24   -> halCommonMemMove
        24   -> halCommonMemSet
       8   emberPrintCommandTable
         8   -> emberPrintCommandUsageNotes
         8   -> printCommandUsage
      16   emberPrintCommandUsage
        16   -> emberSerialPrintf
        16   -> getNestedCommand
        16   -> printCommandUsage
       8   emberPrintCommandUsageNotes
         8   -> emberSerialPrintf
         0   -> emberSerialWaitSend
      40   emberProcessCommandString
        40   -> callCommandAction
        40   -> charDowncase
        40   -> emberCommandErrorHandler
        40   -> emberCommandReaderInit
        40   -> emberSerialReadByte
        40   -> hexToInt
      16   emberSignedCommandArgument
        16   -> firstByteOfArg
        16   -> stringToUnsignedInt
      16   emberStringArgumentToHostOrderIpv4Address
        16   -> emberStringCommandArgument
        16   -> emberStringToHostOrderIpv4Address
      16   emberStringCommandArgument
        16   -> tokenLength
        16   -> tokenPointer
      24   emberStringToHostOrderIpv4Address
        24   -> emberSerialPrintfLine
       0   emberUnsignedCommandArgument
         0   -> stringToUnsignedInt
       0   firstByteOfArg
       0   getNestedCommand
       0   hexToInt
      24   printCommandUsage
        24   -> emberSerialPrintf
        24   -> emberSerialPrintfLine
         0   -> emberSerialWaitSend
        24   -> emberSerialWaitSend
      32   stringToUnsignedInt
        32   -> hexToInt
        32   -> tokenLength
       0   tokenLength
       0   tokenPointer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant "  ">
       2  ?<Constant " ">
       4  ?<Constant " *">
       8  ?<Constant " ...">
      12  ?<Constant " <int16u>">
      12  ?<Constant " <int32u>">
      12  ?<Constant " <int8s>">
      12  ?<Constant " <int8u>">
      12  ?<Constant " <string>">
       4  ?<Constant " ?">
       1  ?<Constant "">
       4  ?<Constant "%c">
       4  ?<Constant "%p">
       8  ?<Constant "%p\r\n">
       4  ?<Constant "...">
      20  ?<Constant "Arg out of range">
      20  ?<Constant "Arg syntax error">
      16  ?<Constant "Bad arg type">
      36  ?<Constant "Error: Expected 4 qua...">
      40  ?<Constant "Error: Invalid char \'...">
      44  ?<Constant "Error: Invalid value ...">
      36  ?<Constant "Error: No value found...">
      16  ?<Constant "No such command">
      20  ?<Constant "Serial port error">
      12  ?<Constant "Too long">
      64  ?<Constant "Usage:\r\n<int>: 123 or...">
      24  ?<Constant "Wrong number of args">
       4  ?<Constant "\r\n">
       4  ??DataTable39
       4  ??DataTable39_1
       4  ??DataTable43
       4  ??DataTable43_1
       4  ??DataTable43_10
       4  ??DataTable43_11
       4  ??DataTable43_12
       4  ??DataTable43_13
       4  ??DataTable43_14
       4  ??DataTable43_15
       4  ??DataTable43_2
       4  ??DataTable43_3
       4  ??DataTable43_4
       4  ??DataTable43_5
       4  ??DataTable43_6
       4  ??DataTable43_7
       4  ??DataTable43_8
       4  ??DataTable43_9
       6  ?Subroutine0
       6  ?Subroutine1
      14  ?Subroutine2
       8  ?Subroutine3
     448  callCommandAction
      14  charDowncase
     128  commandState
          emberCurrentCommand
       1  defaultBase
      12  emberCommandArgumentCount
      12  emberCommandClearBuffer
     114  emberCommandErrorHandler
      32  emberCommandErrorNames
       1  emberCommandInterpreter2Configuration
      10  emberCommandName
      40  emberCommandReaderInit
       8  emberCommandReaderSetDefaultBase
      34  emberCopyBigEndianEui64Argument
      72  emberCopyStringArgument
      28  emberPrintCommandTable
      56  emberPrintCommandUsage
      14  emberPrintCommandUsageNotes
     374  emberProcessCommandString
      34  emberSignedCommandArgument
      22  emberStringArgumentToHostOrderIpv4Address
      40  emberStringCommandArgument
     134  emberStringToHostOrderIpv4Address
       4  emberUnsignedCommandArgument
      24  firstByteOfArg
      28  getNestedCommand
      30  hexToInt
       1  previousCharacter
     144  printCommandUsage
     120  stringToUnsignedInt
      16  tokenLength
      16  tokenPointer

 
   130 bytes in section .bss
    33 bytes in section .data
   159 bytes in section .rodata
 2 250 bytes in section .text
 
 2 250 bytes of CODE  memory
   159 bytes of CONST memory
   163 bytes of DATA  memory

Errors: none
Warnings: none

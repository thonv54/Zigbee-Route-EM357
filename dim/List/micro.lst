###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        22/Oct/2015  09:33:43
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  E:\Zigbee\EmberZNet5.6.0-GA\hal\micro\cortexm3\micro.c
#    Command line =  
#        E:\Zigbee\EmberZNet5.6.0-GA\hal\micro\cortexm3\micro.c -D DIMMER -D
#        NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM357 -D
#        PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"micro.c\"" -lC
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\List\
#        --diag_suppress Pa050 -o
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\Obj\ --debug
#        --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\Zigbee\EmberZNet5.6.0-GA\hal\micro\cortexm3\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\List\micro.lst
#    Object file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\Obj\micro.o
#
###############################################################################

E:\Zigbee\EmberZNet5.6.0-GA\hal\micro\cortexm3\micro.c
      1          /*
      2           * File: micro.c
      3           * Description: EM3XX micro specific full HAL functions
      4           *
      5           *
      6           * Copyright 2008, 2009 by Ember Corporation. All rights reserved.          *80*
      7           */
      8          
      9          
     10          
     11          #include PLATFORM_HEADER
     12          #include "stack/include/ember.h"
     13          #include "include/error.h"
     14          
     15          #include "hal/hal.h"
     16          #include "app/util/serial/serial.h"
     17          #include "hal/micro/cortexm3/diagnostic.h"
     18          #include "hal/micro/cortexm3/memmap.h"
     19          #include "hal/micro/cortexm3/flash.h"
     20          #include "stack/platform/micro/debug-channel.h"
     21          
     22          #ifdef RTOS
     23            #include "rtos/rtos.h"
     24          #endif
     25          
     26          #ifdef  RHO_GPIO
     27            static void halStackRadioHoldOffPowerDown(void); // fwd ref
     28            static void halStackRadioHoldOffPowerUp(void);   // fwd ref
     29          #else //!RHO_GPIO
     30            #define     halStackRadioHoldOffPowerDown()      // no-op
     31            #define     halStackRadioHoldOffPowerUp()        // no-op
     32          #endif//RHO_GPIO
     33          
     34          // halInit is called on first initial boot, not on wakeup from sleep.

   \                                 In section .text, align 2, keep-with-next
     35          void halInit(void)
     36          {
   \                     halInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     37          
     38          
     39          
     40          
     41          
     42          
     43          
     44          
     45          
     46          
     47            halCommonStartXtal();
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       halCommonTryToSwitchToXtal
     48          
     49            halInternalSetRegTrim(FALSE);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       halInternalSetRegTrim
     50          
     51            GPIO_DBGCFG |= GPIO_DBGCFGRSVD;
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable25  ;; 0x4000bc00
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000018   0x6020             STR      R0,[R4, #+0]
     52          
     53          //#define DISABLE_WATCHDOG
     54          
     55            #ifndef DISABLE_WATCHDOG
     56              halInternalEnableWatchDog();
   \   0000001A   0x.... 0x....      BL       halInternalEnableWatchDog
     57            #endif
     58          
     59            halCommonCalibratePads();
   \   0000001E   0x.... 0x....      BL       halCommonCalibratePads
     60          
     61            halInternalInitBoard();
   \   00000022   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000026   0x788D             LDRB     R5,[R1, #+2]
   \   00000028   0x.... 0x....      LDR.W    R3,??DataTable25_1  ;; 0x4000b800
   \   0000002C   0x60DD             STR      R5,[R3, #+12]
   \   0000002E   0x890D             LDRH     R5,[R1, #+8]
   \   00000030   0x6005             STR      R5,[R0, #+0]
   \   00000032   0x894D             LDRH     R5,[R1, #+10]
   \   00000034   0x6045             STR      R5,[R0, #+4]
   \   00000036   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0xF020 0x0010      BIC      R0,R0,#0x10
   \   00000040   0x6020             STR      R0,[R4, #+0]
   \   00000042   0x.... 0x....      BL       halInternalInitAdc
   \   00000046   0x.... 0x....      BL       halInternalRestartUart
   \   0000004A   0x.... 0x....      BL       halInternalInitButton
     62          
     63            halCommonSwitchToXtal();
   \   0000004E   0x.... 0x....      BL       halCommonSwitchToXtal
     64          
     65            #ifndef DISABLE_RC_CALIBRATION
     66              halInternalCalibrateFastRc();
   \   00000052   0x.... 0x....      BL       halInternalCalibrateFastRc
     67            #endif//DISABLE_RC_CALIBRATION
     68          
     69            halInternalStartSystemTimer();
   \   00000056   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000005A   0x.... 0x....      B.W      halInternalStartSystemTimer
     70          
     71            #ifdef INTERRUPT_DEBUGGING
     72              //When debugging interrupts/ATOMIC, ensure that our
     73              //debug pin is properly enabled and idle low.
     74              I_OUT(I_PORT, I_PIN, I_CFG_HL);
     75              I_CLR(I_PORT, I_PIN);
     76            #endif //INTERRUPT_DEBUGGING
     77          
     78            #ifdef USB_CERT_TESTING
     79            halInternalPowerDownBoard();
     80            #endif
     81          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable25_2
   \   00000002   0x....             LDR.N    R0,??DataTable25_3  ;; 0x4000b000
   \   00000004   0x780A             LDRB     R2,[R1, #+0]
   \   00000006   0x60C2             STR      R2,[R0, #+12]
   \   00000008   0x784B             LDRB     R3,[R1, #+1]
   \   0000000A   0x....             LDR.N    R2,??DataTable25_4  ;; 0x4000b400
   \   0000000C   0x60D3             STR      R3,[R2, #+12]
   \   0000000E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x8988             LDRH     R0,[R1, #+12]
   \   00000002   0x6010             STR      R0,[R2, #+0]
   \   00000004   0x89C8             LDRH     R0,[R1, #+14]
   \   00000006   0x6050             STR      R0,[R2, #+4]
   \   00000008   0x8A08             LDRH     R0,[R1, #+16]
   \   0000000A   0x6018             STR      R0,[R3, #+0]
   \   0000000C   0x8A48             LDRH     R0,[R1, #+18]
   \   0000000E   0x6058             STR      R0,[R3, #+4]
   \   00000010   0x....             B.N      halStackRadioPowerDownBoard
     82          
     83          

   \                                 In section .text, align 2, keep-with-next
     84          void halReboot(void)
     85          {
     86            halInternalSysReset(RESET_SOFTWARE_REBOOT);
   \                     halReboot: (+1)
   \   00000000   0xF240 0x6001      MOVW     R0,#+1537
   \   00000004   0x.... 0x....      B.W      halInternalSysReset
     87          }
     88          

   \                                 In section .text, align 2, keep-with-next
     89          void halPowerDown(void)
     90          {
   \                     halPowerDown: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     91            emDebugPowerDown();
   \   00000002   0x.... 0x....      BL       emDebugPowerDown
     92          
     93            halInternalPowerDownUart();
   \   00000006   0x.... 0x....      BL       halInternalPowerDownUart
     94          
     95            halInternalPowerDownBoard();
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable25_3  ;; 0x4000b000
   \   00000012   0x790A             LDRB     R2,[R1, #+4]
   \   00000014   0x60C2             STR      R2,[R0, #+12]
   \   00000016   0x794B             LDRB     R3,[R1, #+5]
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable25_4  ;; 0x4000b400
   \   0000001C   0x60D3             STR      R3,[R2, #+12]
   \   0000001E   0x798C             LDRB     R4,[R1, #+6]
   \   00000020   0x.... 0x....      LDR.W    R3,??DataTable25_1  ;; 0x4000b800
   \   00000024   0x60DC             STR      R4,[R3, #+12]
   \   00000026   0x8A8C             LDRH     R4,[R1, #+20]
   \   00000028   0x6004             STR      R4,[R0, #+0]
   \   0000002A   0x8ACC             LDRH     R4,[R1, #+22]
   \   0000002C   0x6044             STR      R4,[R0, #+4]
   \   0000002E   0x8B08             LDRH     R0,[R1, #+24]
   \   00000030   0x6010             STR      R0,[R2, #+0]
   \   00000032   0x8B48             LDRH     R0,[R1, #+26]
   \   00000034   0x6050             STR      R0,[R2, #+4]
   \   00000036   0x8B88             LDRH     R0,[R1, #+28]
   \   00000038   0x6018             STR      R0,[R3, #+0]
   \   0000003A   0x8BC8             LDRH     R0,[R1, #+30]
   \   0000003C   0x6058             STR      R0,[R3, #+4]
     96          }
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
     97          
     98          // halPowerUp is called from sleep state, not from first initial boot.

   \                                 In section .text, align 2, keep-with-next
     99          void halPowerUp(void)
    100          {
   \                     halPowerUp: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    101          
    102          
    103          
    104          
    105          
    106          
    107          
    108          
    109          
    110          
    111            halInternalPowerUpKickXtal();
   \   00000002   0x.... 0x....      BL       halInternalPowerUpKickXtal
    112          
    113            halCommonCalibratePads();
   \   00000006   0x.... 0x....      BL       halCommonCalibratePads
    114          
    115            halInternalPowerUpBoard();
   \   0000000A   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000000E   0x788C             LDRB     R4,[R1, #+2]
   \   00000010   0x.... 0x....      LDR.W    R3,??DataTable25_1  ;; 0x4000b800
   \   00000014   0x60DC             STR      R4,[R3, #+12]
   \   00000016   0x890C             LDRH     R4,[R1, #+8]
   \   00000018   0x6004             STR      R4,[R0, #+0]
   \   0000001A   0x894C             LDRH     R4,[R1, #+10]
   \   0000001C   0x6044             STR      R4,[R0, #+4]
   \   0000001E   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable25  ;; 0x4000bc00
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0xF021 0x0110      BIC      R1,R1,#0x10
   \   0000002C   0x6001             STR      R1,[R0, #+0]
   \   0000002E   0x.... 0x....      BL       halInternalInitAdc
    116          
    117            halInternalBlockUntilXtal();
   \   00000032   0x.... 0x....      BL       halInternalBlockUntilXtal
    118          
    119            halInternalPowerUpUart();
   \   00000036   0x.... 0x....      BL       halInternalPowerUpUart
    120          
    121            emDebugPowerUp();
   \   0000003A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000003E   0x.... 0x....      B.W      emDebugPowerUp
    122          }
    123          
    124          // halSuspend suspends all board activity except for USB

   \                                 In section .text, align 2, keep-with-next
    125          void halSuspend(void)
    126          {
   \                     halSuspend: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    127            halInternalPowerDownUart();
   \   00000002   0x.... 0x....      BL       halInternalPowerDownUart
    128          
    129            halInternalSuspendBoard();
                   ^
Warning[Pe223]: function "halInternalSuspendBoard" declared implicitly
   \   00000006   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000A   0x.... 0x....      B.W      halInternalSuspendBoard
    130          }
    131          
    132          // halResume restores all board activity from a previous USB suspend

   \                                 In section .text, align 2, keep-with-next
    133          void halResume(void)
    134          {
   \                     halResume: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    135          
    136          
    137          
    138          
    139          
    140          
    141          
    142          
    143          
    144          
    145            halInternalPowerUpKickXtal();
   \   00000002   0x.... 0x....      BL       halInternalPowerUpKickXtal
    146          
    147            halCommonCalibratePads();
   \   00000006   0x.... 0x....      BL       halCommonCalibratePads
    148          
    149            halInternalResumeBoard();
                   ^
Warning[Pe223]: function "halInternalResumeBoard" declared implicitly
   \   0000000A   0x.... 0x....      BL       halInternalResumeBoard
    150          
    151            halInternalBlockUntilXtal();
   \   0000000E   0x.... 0x....      BL       halInternalBlockUntilXtal
    152          
    153            halInternalPowerUpUart();
   \   00000012   0xE8BD 0x4001      POP      {R0,LR}
   \   00000016   0x.... 0x....      B.W      halInternalPowerUpUart
    154          }
    155          
    156          //If the board file defines runtime powerup/powerdown GPIO configuration,
    157          //instantiate the variables and implement halStackRadioPowerDownBoard/
    158          //halStackRadioPowerUpBoard which the stack will use to control the
    159          //power state of radio specific GPIO.  If the board file does not define
    160          //runtime GPIO configuration, the compile time configuration will work as
    161          //it always has.
    162          #if defined(DEFINE_POWERUP_GPIO_CFG_VARIABLES)           && \
    163              defined(DEFINE_POWERUP_GPIO_OUTPUT_DATA_VARIABLES)   && \
    164              defined(DEFINE_POWERDOWN_GPIO_CFG_VARIABLES)         && \
    165              defined(DEFINE_POWERDOWN_GPIO_OUTPUT_DATA_VARIABLES) && \
    166              defined(DEFINE_GPIO_RADIO_POWER_BOARD_MASK_VARIABLE)
    167          
    168          

   \                                 In section .data, align 4
    169          DEFINE_POWERUP_GPIO_CFG_VARIABLES();
    170          DEFINE_POWERUP_GPIO_OUTPUT_DATA_VARIABLES();
   \                     gpioOutPowerUp:
   \   00000000   0xE8 0x4F          DC8 232, 79, 229, 0
   \              0xE5 0x00    
    171          DEFINE_POWERDOWN_GPIO_CFG_VARIABLES();
    172          DEFINE_POWERDOWN_GPIO_OUTPUT_DATA_VARIABLES();
   \                     gpioOutPowerDown:
   \   00000004   0xEF 0x56          DC8 239, 86, 101, 0
   \              0x65 0x00    
   \                     gpioCfgPowerUp:
   \   00000008   0x1949 0x1199      DC16 6473, 4505, 17553, 38920, 18841, 4372
   \              0x4491 0x9808
   \              0x4999 0x1114
   \                     gpioCfgPowerDown:
   \   00000014   0x1888 0x1188      DC16 6280, 4488, 34833, 34945, 33048, 6168
   \              0x8811 0x8881
   \              0x8118 0x1818
    173          DEFINE_GPIO_RADIO_POWER_BOARD_MASK_VARIABLE();
    174          
    175          

   \                                 In section .text, align 2, keep-with-next
    176          static void rmwRadioPowerCfgReg(int16u radioPowerCfg[],
    177                                          int32u volatile * cfgReg,
    178                                          int8u cfgVar)
    179          {
   \                     rmwRadioPowerCfgReg: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    180            int32u temp = *cfgReg;
   \   00000002   0x680B             LDR      R3,[R1, #+0]
   \   00000004   0x....             LDR.N    R4,??DataTable25_5
   \   00000006   0x250F             MOVS     R5,#+15
   \   00000008   0x6864             LDR      R4,[R4, #+4]
   \   0000000A   0x0096             LSLS     R6,R2,#+2
   \   0000000C   0xFA05 0xF606      LSL      R6,R5,R6
   \   00000010   0x4234             TST      R4,R6
   \   00000012   0xD015             BEQ.N    ??rmwRadioPowerCfgReg_0
    181            int8u i;
    182          
    183            //don't waste time with a register that doesn't have anything to be done
    184            if(gpioRadioPowerBoardMask&(0xF<<(4*cfgVar))) {
    185              //loop over the 4 pins of the cfgReg
    186              for(i=0; i<4; i++) {
   \   00000014   0x2600             MOVS     R6,#+0
    187                if((gpioRadioPowerBoardMask>>((4*cfgVar)+i))&1) {
   \                     ??rmwRadioPowerCfgReg_1: (+1)
   \   00000016   0xEB06 0x0782      ADD      R7,R6,R2, LSL #+2
   \   0000001A   0xFA24 0xF707      LSR      R7,R4,R7
   \   0000001E   0x07FF             LSLS     R7,R7,#+31
   \   00000020   0xD50B             BPL.N    ??rmwRadioPowerCfgReg_2
    188                  //read-modify-write the pin's cfg if the mask says it pertains
    189                  //to the radio's power state
    190                  temp &= ~(0xFu<<(4*i));
    191                  temp |= (radioPowerCfg[cfgVar]&(0xF<<(4*i)));
   \   00000022   0x00B7             LSLS     R7,R6,#+2
   \   00000024   0xFA05 0xFC07      LSL      R12,R5,R7
   \   00000028   0xEA23 0x030C      BIC      R3,R3,R12
   \   0000002C   0xF830 0xC012      LDRH     R12,[R0, R2, LSL #+1]
   \   00000030   0xFA05 0xF707      LSL      R7,R5,R7
   \   00000034   0xEA07 0x070C      AND      R7,R7,R12
   \   00000038   0x433B             ORRS     R3,R7,R3
    192                }
    193              }
   \                     ??rmwRadioPowerCfgReg_2: (+1)
   \   0000003A   0x1C76             ADDS     R6,R6,#+1
   \   0000003C   0x2E04             CMP      R6,#+4
   \   0000003E   0xDBEA             BLT.N    ??rmwRadioPowerCfgReg_1
    194            }
    195          
    196            *cfgReg = temp;
   \                     ??rmwRadioPowerCfgReg_0: (+1)
   \   00000040   0x600B             STR      R3,[R1, #+0]
    197          }
   \   00000042   0xBDF0             POP      {R4-R7,PC}       ;; return
    198          
    199          

   \                                 In section .text, align 2, keep-with-next
    200          static void rmwRadioPowerOutReg(int8u radioPowerOut[],
    201                                          int32u volatile * outReg,
    202                                          int8u outVar)
    203          {
   \                     rmwRadioPowerOutReg: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    204            int32u temp = *outReg;
   \   00000002   0x680B             LDR      R3,[R1, #+0]
   \   00000004   0x....             LDR.N    R4,??DataTable25_5
   \   00000006   0x25FF             MOVS     R5,#+255
   \   00000008   0x6864             LDR      R4,[R4, #+4]
   \   0000000A   0x00D6             LSLS     R6,R2,#+3
   \   0000000C   0x40B5             LSLS     R5,R5,R6
   \   0000000E   0x422C             TST      R4,R5
   \   00000010   0xD013             BEQ.N    ??rmwRadioPowerOutReg_0
    205            int8u i;
    206          
    207            //don't waste time with a register that doesn't have anything to be done
    208            if(gpioRadioPowerBoardMask&(0xFF<<(8*outVar))) {
    209              //loop over the 8 pins of the outReg
    210              for(i=0; i<8; i++) {
   \   00000012   0x2500             MOVS     R5,#+0
   \   00000014   0x2601             MOVS     R6,#+1
    211                if((gpioRadioPowerBoardMask>>((8*outVar)+i))&1) {
   \                     ??rmwRadioPowerOutReg_1: (+1)
   \   00000016   0xEB05 0x07C2      ADD      R7,R5,R2, LSL #+3
   \   0000001A   0xFA24 0xF707      LSR      R7,R4,R7
   \   0000001E   0x07FF             LSLS     R7,R7,#+31
   \   00000020   0xD508             BPL.N    ??rmwRadioPowerOutReg_2
    212                  //read-modify-write the pin's out if the mask says it pertains
    213                  //to the radio's power state
    214                  temp &= ~(0x1u<<(1*i));
    215                  temp |= (radioPowerOut[outVar]&(0x1<<(1*i)));
   \   00000022   0xFA06 0xF705      LSL      R7,R6,R5
   \   00000026   0x43BB             BICS     R3,R3,R7
   \   00000028   0x5C17             LDRB     R7,[R2, R0]
   \   0000002A   0xFA06 0xFC05      LSL      R12,R6,R5
   \   0000002E   0xEA0C 0x0707      AND      R7,R12,R7
   \   00000032   0x433B             ORRS     R3,R7,R3
    216                }
    217              }
   \                     ??rmwRadioPowerOutReg_2: (+1)
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
   \   00000036   0x2D08             CMP      R5,#+8
   \   00000038   0xDBED             BLT.N    ??rmwRadioPowerOutReg_1
    218            }
    219          
    220            *outReg = temp;
   \                     ??rmwRadioPowerOutReg_0: (+1)
   \   0000003A   0x600B             STR      R3,[R1, #+0]
    221          }
   \   0000003C   0xBDF0             POP      {R4-R7,PC}       ;; return
    222          
    223          

   \                                 In section .text, align 2, keep-with-next
    224          void halStackRadioPowerDownBoard(void)
    225          {
   \                     halStackRadioPowerDownBoard: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    226            halStackRadioHoldOffPowerDown();
   \   00000002   0x....             LDR.N    R0,??DataTable25_5
   \   00000004   0x7801             LDRB     R1,[R0, #+0]
   \   00000006   0xF001 0x01FD      AND      R1,R1,#0xFD
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
   \   0000000C   0x07C9             LSLS     R1,R1,#+31
   \   0000000E   0xD503             BPL.N    ??halStackRadioPowerDownBoard_0
   \   00000010   0x....             LDR.N    R2,??DataTable25_6  ;; 0xe000e180
   \   00000012   0xF44F 0x4100      MOV      R1,#+32768
   \   00000016   0x6011             STR      R1,[R2, #+0]
    227            if(gpioRadioPowerBoardMask == 0) {
   \                     ??halStackRadioPowerDownBoard_0: (+1)
   \   00000018   0x6840             LDR      R0,[R0, #+4]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD027             BEQ.N    ??halStackRadioPowerDownBoard_1
    228              //If the mask indicates there are no special GPIOs for the
    229              //radio that need their power state to be conrolled by the stack,
    230              //don't bother attempting to do anything.
    231              return;
    232            }
    233          
    234            rmwRadioPowerOutReg(gpioOutPowerDown, &GPIO_PAOUT, 0);
   \   0000001E   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000022   0x1D20             ADDS     R0,R4,#+4
   \   00000024   0x.... 0x....      BL       rmwRadioPowerOutReg
    235            rmwRadioPowerOutReg(gpioOutPowerDown, &GPIO_PBOUT, 1);
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x....             LDR.N    R1,??DataTable25_7  ;; 0x4000b40c
   \   0000002C   0x1D20             ADDS     R0,R4,#+4
   \   0000002E   0x.... 0x....      BL       rmwRadioPowerOutReg
    236            rmwRadioPowerOutReg(gpioOutPowerDown, &GPIO_PCOUT, 2);
   \   00000032   0x2202             MOVS     R2,#+2
   \   00000034   0x....             LDR.N    R1,??DataTable25_8  ;; 0x4000b80c
   \   00000036   0x1D20             ADDS     R0,R4,#+4
   \   00000038   0x.... 0x....      BL       rmwRadioPowerOutReg
    237          
    238            rmwRadioPowerCfgReg(gpioCfgPowerDown, &GPIO_PACFGL, 0);
   \   0000003C   0x2200             MOVS     R2,#+0
   \   0000003E   0x....             LDR.N    R1,??DataTable25_3  ;; 0x4000b000
   \   00000040   0x.... 0x....      BL       ?Subroutine2
    239            rmwRadioPowerCfgReg(gpioCfgPowerDown, &GPIO_PACFGH, 1);
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x....             LDR.N    R1,??DataTable25_9  ;; 0x4000b004
   \   00000048   0x.... 0x....      BL       ?Subroutine2
    240            rmwRadioPowerCfgReg(gpioCfgPowerDown, &GPIO_PBCFGL, 2);
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000004C   0x2202             MOVS     R2,#+2
   \   0000004E   0x....             LDR.N    R1,??DataTable25_4  ;; 0x4000b400
   \   00000050   0x.... 0x....      BL       ?Subroutine2
    241            rmwRadioPowerCfgReg(gpioCfgPowerDown, &GPIO_PBCFGH, 3);
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000054   0x2203             MOVS     R2,#+3
   \   00000056   0x....             LDR.N    R1,??DataTable25_10  ;; 0x4000b404
   \   00000058   0x.... 0x....      BL       ?Subroutine2
    242            rmwRadioPowerCfgReg(gpioCfgPowerDown, &GPIO_PCCFGL, 4);
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000005C   0x2204             MOVS     R2,#+4
   \   0000005E   0x....             LDR.N    R1,??DataTable25_1  ;; 0x4000b800
   \   00000060   0x.... 0x....      BL       ?Subroutine2
    243            rmwRadioPowerCfgReg(gpioCfgPowerDown, &GPIO_PCCFGH, 5);
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000064   0xF104 0x0014      ADD      R0,R4,#+20
   \   00000068   0xE8BD 0x4010      POP      {R4,LR}
   \   0000006C   0x....             B.N      ?Subroutine0
   \                     ??halStackRadioPowerDownBoard_1: (+1)
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
    244          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xF104 0x0014      ADD      R0,R4,#+20
   \   00000004   0x....             B.N      rmwRadioPowerCfgReg

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x....             LDR.N    R4,??DataTable25_2
   \   00000002   0x....             LDR.N    R1,??DataTable25_12  ;; 0x4000b00c
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2205             MOVS     R2,#+5
   \   00000002   0x....             LDR.N    R1,??DataTable25_13  ;; 0x4000b804
   \   00000004   0x....             B.N      rmwRadioPowerCfgReg
    245          
    246          

   \                                 In section .text, align 2, keep-with-next
    247          void halStackRadioPowerUpBoard(void)
    248          {
   \                     halStackRadioPowerUpBoard: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    249            halStackRadioHoldOffPowerUp();
   \   00000002   0x....             LDR.N    R4,??DataTable25_5
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000000A   0x7020             STRB     R0,[R4, #+0]
   \   0000000C   0x07C0             LSLS     R0,R0,#+31
   \   0000000E   0xD507             BPL.N    ??halStackRadioPowerUpBoard_0
   \   00000010   0x....             LDR.N    R0,??DataTable25_6  ;; 0xe000e180
   \   00000012   0xF44F 0x4500      MOV      R5,#+32768
   \   00000016   0x6005             STR      R5,[R0, #+0]
   \   00000018   0x.... 0x....      BL       halIrqDIsr
   \   0000001C   0x....             LDR.N    R0,??DataTable25_11  ;; 0xe000e100
   \   0000001E   0x6005             STR      R5,[R0, #+0]
    250            if(gpioRadioPowerBoardMask == 0) {
   \                     ??halStackRadioPowerUpBoard_0: (+1)
   \   00000020   0x6860             LDR      R0,[R4, #+4]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD027             BEQ.N    ??halStackRadioPowerUpBoard_1
    251              //If the mask indicates there are no special GPIOs for the
    252              //radio that need their power state to be conrolled by the stack,
    253              //don't bother attempting to do anything.
    254              return;
    255            }
    256          
    257            rmwRadioPowerOutReg(gpioOutPowerUp, &GPIO_PAOUT, 0);
   \   00000026   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       rmwRadioPowerOutReg
    258            rmwRadioPowerOutReg(gpioOutPowerUp, &GPIO_PBOUT, 1);
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x....             LDR.N    R1,??DataTable25_7  ;; 0x4000b40c
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       rmwRadioPowerOutReg
    259            rmwRadioPowerOutReg(gpioOutPowerUp, &GPIO_PCOUT, 2);
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0x....             LDR.N    R1,??DataTable25_8  ;; 0x4000b80c
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       rmwRadioPowerOutReg
    260          
    261            rmwRadioPowerCfgReg(gpioCfgPowerUp, &GPIO_PACFGL, 0);
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x....             LDR.N    R1,??DataTable25_3  ;; 0x4000b000
   \   00000048   0x.... 0x....      BL       ?Subroutine5
    262            rmwRadioPowerCfgReg(gpioCfgPowerUp, &GPIO_PACFGH, 1);
   \                     ??CrossCallReturnLabel_15: (+1)
   \   0000004C   0x2201             MOVS     R2,#+1
   \   0000004E   0x....             LDR.N    R1,??DataTable25_9  ;; 0x4000b004
   \   00000050   0x.... 0x....      BL       ?Subroutine5
    263            rmwRadioPowerCfgReg(gpioCfgPowerUp, &GPIO_PBCFGL, 2);
   \                     ??CrossCallReturnLabel_14: (+1)
   \   00000054   0x2202             MOVS     R2,#+2
   \   00000056   0x....             LDR.N    R1,??DataTable25_4  ;; 0x4000b400
   \   00000058   0x.... 0x....      BL       ?Subroutine5
    264            rmwRadioPowerCfgReg(gpioCfgPowerUp, &GPIO_PBCFGH, 3);
   \                     ??CrossCallReturnLabel_13: (+1)
   \   0000005C   0x2203             MOVS     R2,#+3
   \   0000005E   0x....             LDR.N    R1,??DataTable25_10  ;; 0x4000b404
   \   00000060   0x.... 0x....      BL       ?Subroutine5
    265            rmwRadioPowerCfgReg(gpioCfgPowerUp, &GPIO_PCCFGL, 4);
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000064   0x2204             MOVS     R2,#+4
   \   00000066   0x....             LDR.N    R1,??DataTable25_1  ;; 0x4000b800
   \   00000068   0x.... 0x....      BL       ?Subroutine5
    266            rmwRadioPowerCfgReg(gpioCfgPowerUp, &GPIO_PCCFGH, 5);
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000006C   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000070   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000074   0x....             B.N      ?Subroutine0
   \                     ??halStackRadioPowerUpBoard_1: (+1)
   \   00000076   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    267          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000004   0x....             B.N      rmwRadioPowerCfgReg
    268          
    269          #else
    270          
    271          //If the board file uses traditional compile time powerup/powerdown GPIO
    272          //configuration, stub halStackRadioPowerDownBoard/halStackRadioPowerUpBoard
    273          //which the stack would have used to control the power state of radio
    274          //relevant GPIO.  With compile time configuration, only the traditional
    275          //halInternalPowerDownBoard and halInternalPowerUpBoard funtions configure
    276          //the GPIO.  RHO powerdown/up still needs to be managed however.
    277          
    278          void halStackRadioPowerDownBoard(void)
    279          {
    280            halStackRadioHoldOffPowerDown();
    281          }
    282          void halStackRadioPowerUpBoard(void)
    283          {
    284            halStackRadioHoldOffPowerUp();
    285          }
    286          
    287          #endif
    288          

   \                                 In section .text, align 2, keep-with-next
    289          void halStackProcessBootCount(void)
    290          {
    291            //Note: Becuase this always counts up at every boot (called from emberInit),
    292            //and non-volatile storage has a finite number of write cycles, this will
    293            //eventually stop working.  Disable this token call if non-volatile write
    294            //cycles need to be used sparingly.
    295            halCommonIncrementCounterToken(TOKEN_STACK_BOOT_COUNTER);
   \                     halStackProcessBootCount: (+1)
   \   00000000   0x2003             MOVS     R0,#+3
   \   00000002   0x.... 0x....      B.W      halInternalIncrementCounterToken
    296          }
    297          
    298          

   \                                 In section .text, align 2, keep-with-next
    299          PGM_P halGetResetString(void)
    300          {
   \                     halGetResetString: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    301            // Table used to convert from reset types to reset strings.
    302            #define RESET_BASE_DEF(basename, value, string)  string,
    303            #define RESET_EXT_DEF(basename, extname, extvalue, string)  /*nothing*/
    304            static PGM char resetStringTable[][4] = {
    305              #include "reset-def.h"
    306            };
    307            #undef RESET_BASE_DEF
    308            #undef RESET_EXT_DEF
    309          
    310            return resetStringTable[halGetResetInfo()];
   \   00000002   0x.... 0x....      BL       halGetResetInfo
   \   00000006   0x.... 0x....      ADR.W    R1,??resetStringTable
   \   0000000A   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    311          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??resetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x46 0x49          DC8 "FIB"
   \              0x42 0x00    
   \   00000008   0x42 0x54          DC8 "BTL"
   \              0x4C 0x00    
   \   0000000C   0x45 0x58          DC8 "EXT"
   \              0x54 0x00    
   \   00000010   0x50 0x57          DC8 "PWR"
   \              0x52 0x00    
   \   00000014   0x57 0x44          DC8 "WDG"
   \              0x47 0x00    
   \   00000018   0x20 0x53          DC8 " SW"
   \              0x57 0x00    
   \   0000001C   0x43 0x52          DC8 "CRS"
   \              0x53 0x00    
   \   00000020   0x46 0x53          DC8 "FSH"
   \              0x48 0x00    
   \   00000024   0x42 0x41          DC8 "BAD"
   \              0x44 0x00    
   \   00000028   0x46 0x4C          DC8 "FLT"
   \              0x54 0x00    
    312          
    313          // Note that this API should be used in conjunction with halGetResetString
    314          //  to get the full information, as this API does not provide a string for
    315          //  the base reset type

   \                                 In section .text, align 2, keep-with-next
    316          PGM_P halGetExtendedResetString(void)
    317          {
   \                     halGetExtendedResetString: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    318            // Create a table of reset strings for each extended reset type
    319            typedef PGM char ResetStringTableType[][4];
    320            #define RESET_BASE_DEF(basename, value, string)   \
    321                                   }; static ResetStringTableType basename##ResetStringTable = {
    322            #define RESET_EXT_DEF(basename, extname, extvalue, string)  string,
    323            {
    324              #include "reset-def.h"
    325            };
    326            #undef RESET_BASE_DEF
    327            #undef RESET_EXT_DEF
    328          
    329            // Create a table of pointers to each of the above tables
    330            #define RESET_BASE_DEF(basename, value, string)  (ResetStringTableType *)basename##ResetStringTable,
    331            #define RESET_EXT_DEF(basename, extname, extvalue, string)  /*nothing*/
    332            static ResetStringTableType * PGM extendedResetStringTablePtrs[] = {
    333              #include "reset-def.h"
    334            };
    335            #undef RESET_BASE_DEF
    336            #undef RESET_EXT_DEF
    337          
    338            int16u extResetInfo = halGetExtendedResetInfo();
   \   00000002   0x.... 0x....      BL       halGetExtendedResetInfo
    339            // access the particular table of extended strings we are interested in
    340            ResetStringTableType *extendedResetStringTable =
    341                              extendedResetStringTablePtrs[RESET_BASE_TYPE(extResetInfo)];
    342          
    343            // return the string from within the proper table
    344            return (*extendedResetStringTable)[((extResetInfo)&0xFF)];
   \   00000006   0xB2C1             UXTB     R1,R0
   \   00000008   0x0400             LSLS     R0,R0,#+16
   \   0000000A   0x.... 0x....      ADR.W    R2,??extendedResetStringTablePtrs
   \   0000000E   0x0E00             LSRS     R0,R0,#+24
   \   00000010   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   00000014   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    345          
    346          }

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::UNKNOWNResetStringTable[1][4]
   \                     ??UNKNOWNResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::FIBResetStringTable[22][4]
   \                     ??FIBResetStringTable:
   \   00000000   0x47 0x4F          DC8 "GO "
   \              0x20 0x00    
   \   00000004   0x42 0x54          DC8 "BTL"
   \              0x4C 0x00    
   \   00000008   0x47 0x4F          DC8 "GO2"
   \              0x32 0x00    
   \   0000000C   0x47 0x4F          DC8 "GO3"
   \              0x33 0x00    
   \   00000010   0x47 0x4F          DC8 "GO4"
   \              0x34 0x00    
   \   00000014   0x47 0x4F          DC8 "GO5"
   \              0x35 0x00    
   \   00000018   0x47 0x4F          DC8 "GO6"
   \              0x36 0x00    
   \   0000001C   0x47 0x4F          DC8 "GO7"
   \              0x37 0x00    
   \   00000020   0x47 0x4F          DC8 "GO8"
   \              0x38 0x00    
   \   00000024   0x47 0x4F          DC8 "GO9"
   \              0x39 0x00    
   \   00000028   0x47 0x4F          DC8 "GOA"
   \              0x41 0x00    
   \   0000002C   0x47 0x4F          DC8 "GOB"
   \              0x42 0x00    
   \   00000030   0x47 0x4F          DC8 "GOC"
   \              0x43 0x00    
   \   00000034   0x47 0x4F          DC8 "GOD"
   \              0x44 0x00    
   \   00000038   0x47 0x4F          DC8 "GOE"
   \              0x45 0x00    
   \   0000003C   0x47 0x4F          DC8 "GOF"
   \              0x46 0x00    
   \   00000040   0x4A 0x4D          DC8 "JMP"
   \              0x50 0x00    
   \   00000044   0x42 0x44          DC8 "BDR"
   \              0x52 0x00    
   \   00000048   0x55 0x50          DC8 "UPR"
   \              0x52 0x00    
   \   0000004C   0x42 0x54          DC8 "BTM"
   \              0x4D 0x00    
   \   00000050   0x4D 0x53          DC8 "MSM"
   \              0x4D 0x00    
   \   00000054   0x46 0x54          DC8 "FTL"
   \              0x4C 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::BOOTLOADERResetStringTable[8][4]
   \                     ??BOOTLOADERResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x47 0x4F          DC8 "GO "
   \              0x20 0x00    
   \   00000008   0x42 0x54          DC8 "BTL"
   \              0x4C 0x00    
   \   0000000C   0x42 0x41          DC8 "BAD"
   \              0x44 0x00    
   \   00000010   0x46 0x54          DC8 "FTL"
   \              0x4C 0x00    
   \   00000014   0x46 0x52          DC8 "FRC"
   \              0x43 0x00    
   \   00000018   0x4F 0x54          DC8 "OTA"
   \              0x41 0x00    
   \   0000001C   0x44 0x53          DC8 "DSL"
   \              0x4C 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::EXTERNALResetStringTable[2][4]
   \                     ??EXTERNALResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x50 0x49          DC8 "PIN"
   \              0x4E 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::POWERONResetStringTable[3][4]
   \                     ??POWERONResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x48 0x56          DC8 "HV "
   \              0x20 0x00    
   \   00000008   0x4C 0x56          DC8 "LV "
   \              0x20 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::WATCHDOGResetStringTable[3][4]
   \                     ??WATCHDOGResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x45 0x58          DC8 "EXP"
   \              0x50 0x00    
   \   00000008   0x4C 0x57          DC8 "LWM"
   \              0x4D 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::SOFTWAREResetStringTable[3][4]
   \                     ??SOFTWAREResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x52 0x42          DC8 "RBT"
   \              0x54 0x00    
   \   00000008   0x44 0x53          DC8 "DSL"
   \              0x4C 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::CRASHResetStringTable[2][4]
   \                     ??CRASHResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x41 0x53          DC8 "AST"
   \              0x54 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::FLASHResetStringTable[3][4]
   \                     ??FLASHResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x56 0x46          DC8 "VFY"
   \              0x59 0x00    
   \   00000008   0x49 0x4E          DC8 "INH"
   \              0x48 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::FATALResetStringTable[4][4]
   \                     ??FATALResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x4C 0x43          DC8 "LCK"
   \              0x4B 0x00    
   \   00000008   0x58 0x54          DC8 "XTL"
   \              0x4C 0x00    
   \   0000000C   0x4F 0x42          DC8 "OBF"
   \              0x46 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::FAULTResetStringTable[8][4]
   \                     ??FAULTResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x48 0x52          DC8 "HRD"
   \              0x44 0x00    
   \   00000008   0x4D 0x45          DC8 "MEM"
   \              0x4D 0x00    
   \   0000000C   0x42 0x55          DC8 "BUS"
   \              0x53 0x00    
   \   00000010   0x55 0x53          DC8 "USG"
   \              0x47 0x00    
   \   00000014   0x44 0x42          DC8 "DBG"
   \              0x47 0x00    
   \   00000018   0x44 0x4D          DC8 "DMA"
   \              0x41 0x00    
   \   0000001C   0x56 0x43          DC8 "VCT"
   \              0x54 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??extendedResetStringTablePtrs:
   \   00000000   0x........         DC32 ??UNKNOWNResetStringTable, ??FIBResetStringTable
   \              0x........   
   \   00000008   0x........         DC32 ??BOOTLOADERResetStringTable, ??EXTERNALResetStringTable
   \              0x........   
   \   00000010   0x........         DC32 ??POWERONResetStringTable, ??WATCHDOGResetStringTable
   \              0x........   
   \   00000018   0x........         DC32 ??SOFTWAREResetStringTable, ??CRASHResetStringTable
   \              0x........   
   \   00000020   0x........         DC32 ??FLASHResetStringTable, ??FATALResetStringTable
   \              0x........   
   \   00000028   0x........         DC32 ??FAULTResetStringTable
    347          
    348          // Translate EM3xx reset codes to the codes previously used by the EM2xx.
    349          // If there is no corresponding code, return the EM3xx base code with bit 7 set.

   \                                 In section .text, align 4, keep-with-next
    350          int8u halGetEm2xxResetInfo(void)
    351          {
   \                     halGetEm2xxResetInfo: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    352            int8u reset = halGetResetInfo();
   \   00000002   0x.... 0x....      BL       halGetResetInfo
   \   00000006   0x4604             MOV      R4,R0
    353          
    354            // Any reset with an extended value field of zero is considered an unknown
    355            // reset, except for FIB resets.
    356            if ( (RESET_EXTENDED_FIELD(halGetExtendedResetInfo()) == 0) &&
    357                 (reset != RESET_FIB) ) {
   \   00000008   0x.... 0x....      BL       halGetExtendedResetInfo
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0xB908             CBNZ.N   R0,??halGetEm2xxResetInfo_1
   \   00000010   0x2C01             CMP      R4,#+1
   \   00000012   0xD107             BNE.N    ??halGetEm2xxResetInfo_2
    358               return EM2XX_RESET_UNKNOWN;
    359            }
    360          
    361           switch (reset) {
   \                     ??halGetEm2xxResetInfo_1: (+1)
   \   00000014   0x2C07             CMP      R4,#+7
   \   00000016   0xD811             BHI.N    ??halGetEm2xxResetInfo_3
   \   00000018   0xE8DF 0xF004      TBB      [PC, R4]
   \                     ??halGetEm2xxResetInfo_0:
   \   0000001C   0x04 0x10          DC8      0x4,0x10,0x6,0x8
   \              0x06 0x08    
   \   00000020   0x08 0x0A          DC8      0x8,0xA,0xC,0xE
   \              0x0C 0x0E    
    362            case RESET_UNKNOWN:
    363              return EM2XX_RESET_UNKNOWN;
   \                     ??halGetEm2xxResetInfo_2: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD10             POP      {R4,PC}
    364            case RESET_BOOTLOADER:
    365              return EM2XX_RESET_BOOTLOADER;
   \                     ??halGetEm2xxResetInfo_4: (+1)
   \   00000028   0x2009             MOVS     R0,#+9
   \   0000002A   0xBD10             POP      {R4,PC}
    366            case RESET_EXTERNAL:      // map pin resets to poweron for EM2xx compatibility
    367          //    return EM2XX_RESET_EXTERNAL;
    368            case RESET_POWERON:
    369              return EM2XX_RESET_POWERON;
   \                     ??halGetEm2xxResetInfo_5: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xBD10             POP      {R4,PC}
    370            case RESET_WATCHDOG:
    371              return EM2XX_RESET_WATCHDOG;
   \                     ??halGetEm2xxResetInfo_6: (+1)
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0xBD10             POP      {R4,PC}
    372            case RESET_SOFTWARE:
    373              return EM2XX_RESET_SOFTWARE;
   \                     ??halGetEm2xxResetInfo_7: (+1)
   \   00000034   0x200B             MOVS     R0,#+11
   \   00000036   0xBD10             POP      {R4,PC}
    374            case RESET_CRASH:
    375              return EM2XX_RESET_ASSERT;
   \                     ??halGetEm2xxResetInfo_8: (+1)
   \   00000038   0x2006             MOVS     R0,#+6
   \   0000003A   0xBD10             POP      {R4,PC}
    376            default:
    377              return (reset | 0x80);      // set B7 for all other reset codes
   \                     ??halGetEm2xxResetInfo_3: (+1)
   \   0000003C   0xF044 0x0080      ORR      R0,R4,#0x80
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    378            }
    379          }

   \                                 In section .bss, align 4
    380          
    381          #ifdef  RHO_GPIO // BOARD_HEADER supports Radio HoldOff
    382          
    383          #ifdef  WAKE_ON_DFL_RHO_VAR // Only define this if needed per board header
    384          int8u WAKE_ON_DFL_RHO_VAR = WAKE_ON_DFL_RHO;
    385          #endif//WAKE_ON_DFL_RHO_VAR
    386          
    387          extern void emRadioHoldOffIsr(boolean active);
    388          
    389          #define RHO_ENABLED_MASK  0x01u // RHO is enabled
    390          #define RHO_RADIO_ON_MASK 0x02u // Radio is on (not sleeping)
    391          static int8u rhoState;
   \                     rhoState:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \                     gpioRadioPowerBoardMask:
   \   00000004                      DS8 4
    392          

   \                                 In section .text, align 2, keep-with-next
    393          boolean halGetRadioHoldOff(void)
    394          {
    395            return (!!(rhoState & RHO_ENABLED_MASK));
   \                     halGetRadioHoldOff: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable25_5
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000008   0x4770             BX       LR               ;; return
    396          }
    397          
    398          // Return active state of Radio HoldOff GPIO pin
    399          static boolean halInternalRhoPinIsActive(void)
    400          {
    401            return (!!(RHO_IN & BIT(RHO_GPIO&7)) == !!RHO_ASSERTED);
    402          }
    403          

   \                                 In section .text, align 2, keep-with-next
    404          void RHO_ISR(void)
    405          {
    406            if (rhoState & RHO_ENABLED_MASK) {
   \                     halIrqDIsr: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable25_5
   \   00000002   0x....             LDR.N    R0,??DataTable25_14  ;; 0x4000a814
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0x07C9             LSLS     R1,R1,#+31
   \   00000008   0xD50B             BPL.N    ??halIrqDIsr_0
    407              // Ack interrupt before reading GPIO to avoid potential of missing int
    408              INT_MISS = RHO_MISS_BIT;
   \   0000000A   0xF44F 0x4100      MOV      R1,#+32768
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
    409              INT_GPIOFLAG = RHO_FLAG_BIT; // acknowledge the interrupt
   \   00000010   0x2108             MOVS     R1,#+8
   \   00000012   0x6001             STR      R1,[R0, #+0]
    410              // Notify Radio land of state change
    411              emRadioHoldOffIsr(halInternalRhoPinIsActive());
   \   00000014   0x....             LDR.N    R0,??DataTable25_15  ;; 0x4000b008
   \   00000016   0x6800             LDR      R0,[R0, #+0]
    412            } else {
   \   00000018   0x0980             LSRS     R0,R0,#+6
   \   0000001A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000001E   0x.... 0x....      B.W      emRadioHoldOffIsr
    413             #ifdef  RHO_ISR_FOR_DFL
    414              // Defer to default GPIO config's ISR
    415              extern void RHO_ISR_FOR_DFL(void);
    416              RHO_ISR_FOR_DFL(); // This ISR is expected to acknowledge the interrupt
    417             #else //!RHO_ISR_FOR_DFL
    418              INT_GPIOFLAG = RHO_FLAG_BIT; // acknowledge the interrupt
   \                     ??halIrqDIsr_0: (+1)
   \   00000022   0x2108             MOVS     R1,#+8
   \   00000024   0x6001             STR      R1,[R0, #+0]
    419             #endif//RHO_ISR_FOR_DFL
    420            }
    421          }
   \   00000026   0x4770             BX       LR               ;; return
    422          

   \                                 In section .text, align 2, keep-with-next
    423          EmberStatus halSetRadioHoldOff(boolean enabled)
    424          {
   \                     halSetRadioHoldOff: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    425            // If enabling afresh or disabling after having been enabled
    426            // restart from a fresh state just in case.
    427            // Otherwise don't touch a setup that might already have been
    428            // put into place by the default 'DFL' use (e.g. a button).
    429            // When disabling after having been enabled, it is up to the
    430            // board header caller to reinit the default 'DFL' use if needed.
    431            if (enabled || (rhoState & RHO_ENABLED_MASK)) {
   \   00000004   0x....             LDR.N    R5,??DataTable25_5
   \   00000006   0x....             LDR.N    R6,??DataTable25_14  ;; 0x4000a814
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0x7828             LDRB     R0,[R5, #+0]
   \   0000000C   0xF44F 0x4800      MOV      R8,#+32768
   \   00000010   0xD101             BNE.N    ??halSetRadioHoldOff_0
   \   00000012   0x07C1             LSLS     R1,R0,#+31
   \   00000014   0xD50C             BPL.N    ??halSetRadioHoldOff_1
    432              RHO_INTCFG = 0;              //disable RHO triggering
   \                     ??halSetRadioHoldOff_0: (+1)
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x65B1             STR      R1,[R6, #+88]
    433              INT_CFGCLR = RHO_INT_EN_BIT; //clear RHO top level int enable
   \   0000001A   0x....             LDR.N    R1,??DataTable25_6  ;; 0xe000e180
   \   0000001C   0xF8C1 0x8000      STR      R8,[R1, #+0]
    434              INT_GPIOFLAG = RHO_FLAG_BIT; //clear stale RHO interrupt
   \   00000020   0x2108             MOVS     R1,#+8
   \   00000022   0x6031             STR      R1,[R6, #+0]
    435              INT_MISS = RHO_MISS_BIT;     //clear stale missed RHO interrupt
   \   00000024   0xF8C6 0x800C      STR      R8,[R6, #+12]
    436            }
    437          
    438            rhoState = (rhoState & ~RHO_ENABLED_MASK) | (enabled ? RHO_ENABLED_MASK : 0);
   \   00000028   0x0021             MOVS     R1,R4
   \   0000002A   0xD002             BEQ.N    ??halSetRadioHoldOff_2
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0xE000             B.N      ??halSetRadioHoldOff_2
   \                     ??halSetRadioHoldOff_1: (+1)
   \   00000030   0x2100             MOVS     R1,#+0
   \                     ??halSetRadioHoldOff_2: (+1)
   \   00000032   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   00000036   0x4308             ORRS     R0,R1,R0
   \   00000038   0x7028             STRB     R0,[R5, #+0]
    439          
    440            // Reconfigure GPIOs for desired state
    441            ADJUST_GPIO_CONFIG_DFL_RHO(enabled);
   \   0000003A   0x.... 0x....      BL       _disableBasePri
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0x....             LDR.N    R7,??DataTable25_9  ;; 0x4000b004
   \   00000042   0x....             LDR.N    R1,??DataTable25_2
   \   00000044   0x683A             LDR      R2,[R7, #+0]
   \   00000046   0xF422 0x6270      BIC      R2,R2,#0xF00
   \   0000004A   0xD014             BEQ.N    ??halSetRadioHoldOff_3
   \   0000004C   0xF442 0x6200      ORR      R2,R2,#0x800
   \   00000050   0x603A             STR      R2,[R7, #+0]
   \   00000052   0x68BA             LDR      R2,[R7, #+8]
   \   00000054   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000058   0x60BA             STR      R2,[R7, #+8]
   \   0000005A   0x2208             MOVS     R2,#+8
   \   0000005C   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000060   0xF002 0x02BF      AND      R2,R2,#0xBF
   \   00000064   0x700A             STRB     R2,[R1, #+0]
   \   00000066   0x2208             MOVS     R2,#+8
   \   00000068   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_18: (+1)
   \   0000006C   0xF002 0x02BF      AND      R2,R2,#0xBF
   \   00000070   0x710A             STRB     R2,[R1, #+4]
   \   00000072   0x2160             MOVS     R1,#+96
   \   00000074   0xE013             B.N      ??halSetRadioHoldOff_4
   \                     ??halSetRadioHoldOff_3: (+1)
   \   00000076   0xF442 0x7280      ORR      R2,R2,#0x100
   \   0000007A   0x603A             STR      R2,[R7, #+0]
   \   0000007C   0x68BA             LDR      R2,[R7, #+8]
   \   0000007E   0xF042 0x0240      ORR      R2,R2,#0x40
   \   00000082   0x60BA             STR      R2,[R7, #+8]
   \   00000084   0x2201             MOVS     R2,#+1
   \   00000086   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_17: (+1)
   \   0000008A   0xF042 0x0240      ORR      R2,R2,#0x40
   \   0000008E   0x700A             STRB     R2,[R1, #+0]
   \   00000090   0x2201             MOVS     R2,#+1
   \   00000092   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_19: (+1)
   \   00000096   0xF042 0x0240      ORR      R2,R2,#0x40
   \   0000009A   0x710A             STRB     R2,[R1, #+4]
   \   0000009C   0x2100             MOVS     R1,#+0
   \                     ??halSetRadioHoldOff_4: (+1)
   \   0000009E   0x65B1             STR      R1,[R6, #+88]
   \   000000A0   0x2106             MOVS     R1,#+6
   \   000000A2   0x....             LDR.N    R2,??DataTable25_16  ;; 0x4000bc18
   \   000000A4   0x6011             STR      R1,[R2, #+0]
   \   000000A6   0x.... 0x....      BL       _writeBasePri
    442          
    443            if (enabled) {
   \   000000AA   0xB164             CBZ.N    R4,??halSetRadioHoldOff_5
    444              // Only update radio if it's on, otherwise defer to when it gets turned on
    445              if (rhoState & RHO_RADIO_ON_MASK) {
   \   000000AC   0x7828             LDRB     R0,[R5, #+0]
   \   000000AE   0x0780             LSLS     R0,R0,#+30
   \   000000B0   0xD50C             BPL.N    ??halSetRadioHoldOff_6
    446                emRadioHoldOffIsr(halInternalRhoPinIsActive()); //Notify Radio land of current state
   \   000000B2   0x6878             LDR      R0,[R7, #+4]
   \   000000B4   0x0980             LSRS     R0,R0,#+6
   \   000000B6   0xF000 0x0001      AND      R0,R0,#0x1
   \   000000BA   0x.... 0x....      BL       emRadioHoldOffIsr
    447                INT_CFGSET = RHO_INT_EN_BIT; //set top level interrupt enable
   \   000000BE   0x....             LDR.N    R0,??DataTable25_11  ;; 0xe000e100
   \   000000C0   0xF8C0 0x8000      STR      R8,[R0, #+0]
   \   000000C4   0xE002             B.N      ??halSetRadioHoldOff_6
    448                // Interrupt on now, ISR will maintain proper state
    449              }
    450            } else {
    451              emRadioHoldOffIsr(FALSE); //Notify Radio land of configured state
   \                     ??halSetRadioHoldOff_5: (+1)
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x.... 0x....      BL       emRadioHoldOffIsr
    452              // Leave interrupt state untouched (probably turned off above)
    453            }
    454          
    455            return EMBER_SUCCESS;
   \                     ??halSetRadioHoldOff_6: (+1)
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    456          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x8ACB             LDRH     R3,[R1, #+22]
   \   00000002   0xF362 0x230B      BFI      R3,R2,#+8,#+4
   \   00000006   0x790A             LDRB     R2,[R1, #+4]
   \   00000008   0x82CB             STRH     R3,[R1, #+22]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x894B             LDRH     R3,[R1, #+10]
   \   00000002   0xF362 0x230B      BFI      R3,R2,#+8,#+4
   \   00000006   0x780A             LDRB     R2,[R1, #+0]
   \   00000008   0x814B             STRH     R3,[R1, #+10]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x4000BC00         DC32     0x4000bc00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x4000B800         DC32     0x4000b800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x........         DC32     gpioOutPowerUp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \   00000000   0x4000B000         DC32     0x4000b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_4:
   \   00000000   0x4000B400         DC32     0x4000b400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_5:
   \   00000000   0x........         DC32     rhoState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_6:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_7:
   \   00000000   0x4000B40C         DC32     0x4000b40c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_8:
   \   00000000   0x4000B80C         DC32     0x4000b80c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_9:
   \   00000000   0x4000B004         DC32     0x4000b004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_10:
   \   00000000   0x4000B404         DC32     0x4000b404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_11:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_12:
   \   00000000   0x4000B00C         DC32     0x4000b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_13:
   \   00000000   0x4000B804         DC32     0x4000b804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_14:
   \   00000000   0x4000A814         DC32     0x4000a814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_15:
   \   00000000   0x4000B008         DC32     0x4000b008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_16:
   \   00000000   0x4000BC18         DC32     0x4000bc18
    457          
    458          static void halStackRadioHoldOffPowerDown(void)
    459          {
    460            rhoState &= ~RHO_RADIO_ON_MASK;
    461            if (rhoState & RHO_ENABLED_MASK) {
    462              // When sleeping radio, no need to monitor RHO anymore
    463              INT_CFGCLR = RHO_INT_EN_BIT; //clear RHO top level int enable
    464            }
    465          }
    466          
    467          static void halStackRadioHoldOffPowerUp(void)
    468          {
    469            rhoState |= RHO_RADIO_ON_MASK;
    470            if (rhoState & RHO_ENABLED_MASK) {
    471              // When waking radio, set up initial state and resume monitoring
    472              INT_CFGCLR = RHO_INT_EN_BIT; //ensure RHO interrupt is off
    473              RHO_ISR(); // Manually call ISR to assess current state
    474              INT_CFGSET = RHO_INT_EN_BIT; //enable RHO interrupt
    475            }
    476          }
    477          
    478          #else //!RHO_GPIO
    479          
    480          // Stubs in case someone insists on referencing them
    481          
    482          boolean halGetRadioHoldOff(void)
    483          {
    484            return FALSE;
    485          }
    486          
    487          EmberStatus halSetRadioHoldOff(boolean enabled)
    488          {
    489            return (enabled ? EMBER_BAD_ARGUMENT : EMBER_SUCCESS);
    490          }
    491          
    492          #endif//RHO_GPIO // Board header supports Radio HoldOff

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   halGetEm2xxResetInfo
         8   -> halGetExtendedResetInfo
         8   -> halGetResetInfo
       8   halGetExtendedResetString
         8   -> halGetExtendedResetInfo
       0   halGetRadioHoldOff
       8   halGetResetString
         8   -> halGetResetInfo
      16   halInit
        16   -> halCommonCalibratePads
        16   -> halCommonSwitchToXtal
        16   -> halCommonTryToSwitchToXtal
        16   -> halInternalCalibrateFastRc
        16   -> halInternalEnableWatchDog
        16   -> halInternalInitAdc
        16   -> halInternalInitButton
        16   -> halInternalRestartUart
        16   -> halInternalSetRegTrim
         0   -> halInternalStartSystemTimer
        16   -> halStackRadioPowerDownBoard
       0   halIrqDIsr
         0   -> emRadioHoldOffIsr
       8   halPowerDown
         8   -> emDebugPowerDown
         8   -> halInternalPowerDownUart
       8   halPowerUp
         0   -> emDebugPowerUp
         8   -> halCommonCalibratePads
         8   -> halInternalBlockUntilXtal
         8   -> halInternalInitAdc
         8   -> halInternalPowerUpKickXtal
         8   -> halInternalPowerUpUart
         8   -> halStackRadioPowerDownBoard
       0   halReboot
         0   -> halInternalSysReset
       8   halResume
         8   -> halCommonCalibratePads
         8   -> halInternalBlockUntilXtal
         8   -> halInternalPowerUpKickXtal
         0   -> halInternalPowerUpUart
         8   -> halInternalResumeBoard
      24   halSetRadioHoldOff
        24   -> _disableBasePri
        24   -> _writeBasePri
        24   -> emRadioHoldOffIsr
       0   halStackProcessBootCount
         0   -> halInternalIncrementCounterToken
       8   halStackRadioPowerDownBoard
         0   -> rmwRadioPowerCfgReg
         8   -> rmwRadioPowerCfgReg
         8   -> rmwRadioPowerOutReg
      16   halStackRadioPowerUpBoard
        16   -> halIrqDIsr
         0   -> rmwRadioPowerCfgReg
        16   -> rmwRadioPowerCfgReg
        16   -> rmwRadioPowerOutReg
       8   halSuspend
         8   -> halInternalPowerDownUart
         0   -> halInternalSuspendBoard
      20   rmwRadioPowerCfgReg
      20   rmwRadioPowerOutReg


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_10
       4  ??DataTable25_11
       4  ??DataTable25_12
       4  ??DataTable25_13
       4  ??DataTable25_14
       4  ??DataTable25_15
       4  ??DataTable25_16
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable25_6
       4  ??DataTable25_7
       4  ??DataTable25_8
       4  ??DataTable25_9
       6  ?Subroutine0
      18  ?Subroutine1
       6  ?Subroutine2
      16  ?Subroutine3
       8  ?Subroutine4
       6  ?Subroutine5
      12  ?Subroutine6
      12  ?Subroutine7
      32  BOOTLOADERResetStringTable
       8  CRASHResetStringTable
       8  EXTERNALResetStringTable
      16  FATALResetStringTable
      32  FAULTResetStringTable
      88  FIBResetStringTable
      12  FLASHResetStringTable
      12  POWERONResetStringTable
      12  SOFTWAREResetStringTable
       4  UNKNOWNResetStringTable
      12  WATCHDOGResetStringTable
      44  extendedResetStringTablePtrs
      32  gpioOutPowerUp
          gpioOutPowerDown
          gpioCfgPowerUp
          gpioCfgPowerDown
      66  halGetEm2xxResetInfo
      26  halGetExtendedResetString
      10  halGetRadioHoldOff
      16  halGetResetString
      94  halInit
      40  halIrqDIsr
      64  halPowerDown
      66  halPowerUp
       8  halReboot
      26  halResume
     210  halSetRadioHoldOff
       6  halStackProcessBootCount
     112  halStackRadioPowerDownBoard
     120  halStackRadioPowerUpBoard
      14  halSuspend
      44  resetStringTable
       8  rhoState
          gpioRadioPowerBoardMask
      68  rmwRadioPowerCfgReg
      62  rmwRadioPowerOutReg

 
     8 bytes in section .bss
    32 bytes in section .data
   236 bytes in section .rodata
 1 248 bytes in section .text
 
 1 248 bytes of CODE  memory
   236 bytes of CONST memory
    40 bytes of DATA  memory

Errors: none
Warnings: 2

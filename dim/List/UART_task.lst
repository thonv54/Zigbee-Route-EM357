###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        28/Oct/2015  16:11:35
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\UART_task.c
#    Command line =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\UART_task.c -D
#        DIMMER -D NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D
#        CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"UART_task.c\"" -lC
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\List\
#        --diag_suppress Pa050 -o
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\Obj\ --debug
#        --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\List\UART_task.lst
#    Object file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\Obj\UART_task.o
#
###############################################################################

E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\UART_task.c
      1          
      2          
      3          
      4          
      5          
      6          
      7          //-----------------------------Khai bao thu vien---------------------//
      8          
      9          
     10          #include "app/framework/include/af.h"
     11          #include "task.h"
     12          #include "ButtonExe.h"
     13          #include "UART_task.h"
     14          #include "halDelay.h"
     15          #include "ConfigDevice.h"
     16          
     17          //-----------------------------Khai bao bien-------------------------//

   \                                 In section .data, align 2
     18          int8u UART_PACKET_KEY[2]	=	{0x4C,0x4D};
   \                     UART_PACKET_KEY:
   \   00000000   0x4C 0x4D          DC8 76, 77
     19          
     20          
     21          

   \                                 In section .bss, align 4
     22          int8u UartTxCommandBuff[256];
   \                     UartTxCommandBuff:
   \   00000000                      DS8 256
     23          #define MAX_RX_BUFFER  256

   \                                 In section .bss, align 2
     24          int16u UartTxCommandStartWaitTimer = 0;
   \                     UartTxCommandStartWaitTimer:
   \   00000000                      DS8 2
     25          int16u UartTxCommandCurrentTimeOut = 0;
   \                     UartTxCommandCurrentTimeOut:
   \   00000002                      DS8 2
     26          
     27          
     28          

   \                                 In section .bss, align 4
     29          int8u UartRxDataStep = 0;
   \                     UartRxDataStep:
   \   00000000                      DS8 1
     30          int8u UartRxPacketLength;
   \                     UartRxPacketLength:
   \   00000001                      DS8 1
     31          int8u UartRxPacketCheckXor = 0;
     32          int8u UartRxCommandData[64] = {0};
     33          int8u UartRxCurrentLength = 0;
   \                     UartRxCurrentLength:
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \                     UartRxCommandData:
   \   00000004                      DS8 64

   \                                 In section .bss, align 1
   \                     UartRxPacketCheckXor:
   \   00000000                      DS8 1
     34          
     35          //extern int8u McReadyStatus;
     36          
     37          
     38          
     39          //-------------------------------Enum------------------------------//
     40          
     41          
     42          typedef enum UartRxCommand_ID{
     43          	RelayStatusChange 	= 0xA0,
     44          	CurtainLevelChange 	= 0xA1,
     45          	DimmerLevelChange 	= 0xA2,
     46          	FanLevelChange 	  	= 0x03,
     47          	TouchButtonHold 	= 0xA7,
     48          	McTimmerCalibrate	= 0xAE,
     49          	CheckMcReady		= 0xD0,
     50          	McClockCalibrate	= 0xD1,
     51          };
                  ^
Warning[Pe375]: declaration requires a typedef name
     52          
     53          
     54          
     55          //-------------------------------CallTask------------------------------//
     56          
     57          
     58          //------------------------CallTaskRelayChangeCommand-------------------//
     59          typedef enum RelayStateCmd{
     60          	RelayOff			= 0,
     61          	RelayOn				= 1,
     62          };
                  ^
Warning[Pe375]: declaration requires a typedef name
     63          
     64          
     65          

   \                                 In section .text, align 2, keep-with-next
     66          void CallTaskRelayChangeCommand( unsigned char *Data){
   \                     CallTaskRelayChangeCommand: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
     67               int8u i;
     68          	 int8u RelayState = Data[1];
   \   00000002   0x7844             LDRB     R4,[R0, #+1]
     69          	 int8u CurrentState[4] = {0};
   \   00000004   0xA802             ADD      R0,SP,#+8
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6001             STR      R1,[R0, #+0]
     70          	 for(i=0;i<4;i++){
   \   0000000A   0x2500             MOVS     R5,#+0
     71          		emberAfReadServerAttribute(2*i+1, ZCL_ON_OFF_CLUSTER_ID,ZCL_ON_OFF_ATTRIBUTE_ID,
     72          						&CurrentState[i], sizeof(CurrentState[i]));
   \                     ??CallTaskRelayChangeCommand_0: (+1)
   \   0000000C   0x0068             LSLS     R0,R5,#+1
   \   0000000E   0x1C46             ADDS     R6,R0,#+1
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xA802             ADD      R0,SP,#+8
   \   00000018   0x182B             ADDS     R3,R5,R0
   \   0000001A   0x2106             MOVS     R1,#+6
   \   0000001C   0xB2F0             UXTB     R0,R6
   \   0000001E   0x.... 0x....      BL       emberAfReadServerAttribute
     73          		if(CurrentState[i] != ((RelayState >> i) & 0x01)){
   \   00000022   0xA802             ADD      R0,SP,#+8
   \   00000024   0xFA24 0xF705      LSR      R7,R4,R5
   \   00000028   0x5C28             LDRB     R0,[R5, R0]
   \   0000002A   0xF007 0x0101      AND      R1,R7,#0x1
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD02E             BEQ.N    ??CallTaskRelayChangeCommand_1
     74          			int8u Relay;
     75          			//call button press call back;
     76          			 CallButtonPress(i);
   \   00000032   0xB2E8             UXTB     R0,R5
   \   00000034   0x.... 0x....      BL       beButtonPress
     77          			// and always wtite relay attribute
     78          			 switch((RelayState >> i) & 0x01){
   \   00000038   0xF017 0x0001      ANDS     R0,R7,#0x1
   \   0000003C   0xD004             BEQ.N    ??CallTaskRelayChangeCommand_2
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD10C             BNE.N    ??CallTaskRelayChangeCommand_3
     79          				 case RelayOn:
     80          				 {
     81          					Relay = 1;
   \   00000042   0xF88D 0x0004      STRB     R0,[SP, #+4]
     82          					emberAfWriteServerAttribute(2*i+1,
     83          						ZCL_ON_OFF_CLUSTER_ID,ZCL_ON_OFF_ATTRIBUTE_ID, &Relay, sizeof(Relay));
   \   00000046   0xE002             B.N      ??CallTaskRelayChangeCommand_4
     84          				 }
     85          					break;
     86          				 case RelayOff:
     87          				 {
     88          					Relay = 0;
   \                     ??CallTaskRelayChangeCommand_2: (+1)
   \   00000048   0xF88D 0x0004      STRB     R0,[SP, #+4]
     89          					emberAfWriteServerAttribute(2*i+1,
     90          						ZCL_ON_OFF_CLUSTER_ID,ZCL_ON_OFF_ATTRIBUTE_ID, &Relay, sizeof(Relay));
   \   0000004C   0x2001             MOVS     R0,#+1
   \                     ??CallTaskRelayChangeCommand_4: (+1)
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0xAB01             ADD      R3,SP,#+4
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x2106             MOVS     R1,#+6
   \   00000056   0xB2F0             UXTB     R0,R6
   \   00000058   0x.... 0x....      BL       emberAfWriteServerAttribute
     91          				 }
     92          					break;
     93          				default:
     94          					break;
     95          			}
     96          			EmberNetworkStatus NetworkStatus;
     97          			NetworkStatus = emberAfNetworkState();
     98          
     99          			if(NetworkStatus == EMBER_JOINED_NETWORK) {
   \                     ??CallTaskRelayChangeCommand_3: (+1)
   \   0000005C   0x.... 0x....      BL       emberAfNetworkState
   \   00000060   0x2802             CMP      R0,#+2
   \   00000062   0xD10A             BNE.N    ??CallTaskRelayChangeCommand_5
    100                          EmberStatus sendStatus;
                                             ^
Warning[Pe550]: variable "sendStatus" was set but never used
    101          
    102          		//	 	Send to Bind Device
    103          				sendStatus = SendViaBindingTable(2*i+1,Relay,OnOffType);
   \   00000064   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000068   0x2201             MOVS     R2,#+1
   \   0000006A   0xB2F0             UXTB     R0,R6
   \   0000006C   0x.... 0x....      BL       SendViaBindingTable
    104          
    105          		//		Send On-Off AttributeResponse, Zipato stupid update :D-----------------------------//
    106          				SendOnOffControlReadAttribute(2*i+1,Relay);
   \   00000070   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000074   0xB2F0             UXTB     R0,R6
   \   00000076   0x.... 0x....      BL       SendOnOffControlReadAttribute
    107          			}
    108          
    109          		// on-off led
    110          
    111          			if(Relay == 1){
   \                     ??CallTaskRelayChangeCommand_5: (+1)
   \   0000007A   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000007E   0x1C68             ADDS     R0,R5,#+1
   \   00000080   0x2901             CMP      R1,#+1
   \   00000082   0xB2C0             UXTB     R0,R0
   \   00000084   0xD102             BNE.N    ??CallTaskRelayChangeCommand_6
    112          				CommonSetLed(i+1);
   \   00000086   0x.... 0x....      BL       CommonSetLed
   \   0000008A   0xE001             B.N      ??CallTaskRelayChangeCommand_1
    113          			}
    114          			else{
    115          				CommonClearLed(i+1);
   \                     ??CallTaskRelayChangeCommand_6: (+1)
   \   0000008C   0x.... 0x....      BL       CommonClearLed
    116          			}
    117          		}
    118          	}
   \                     ??CallTaskRelayChangeCommand_1: (+1)
   \   00000090   0x1C6D             ADDS     R5,R5,#+1
   \   00000092   0x2D04             CMP      R5,#+4
   \   00000094   0xDBBA             BLT.N    ??CallTaskRelayChangeCommand_0
    119          }
   \   00000096   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    120          
    121          //------------------------CallTaskLevelControlCommand-------------------//
    122          
    123          

   \                                 In section .text, align 2, keep-with-next
    124          void CallTaskDimmerLevelChangeCommand(int8u *Data){
   \                     CallTaskDimmerLevelChangeCommand: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    125          	int8u DimmerLevel;
    126          	DimmerLevel = Data[1];
   \   00000004   0x7840             LDRB     R0,[R0, #+1]
   \   00000006   0xF88D 0x0004      STRB     R0,[SP, #+4]
    127          
    128          
    129              int8u CurrentDimmerLevel;
    130          	emberAfReadServerAttribute(DimmerInClusterEndpoint, ZCL_LEVEL_CONTROL_CLUSTER_ID,ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    131          				&CurrentDimmerLevel, sizeof(CurrentDimmerLevel));
   \   0000000A   0xF10D 0x0306      ADD      R3,SP,#+6
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x2108             MOVS     R1,#+8
   \   00000016   0x.... 0x....      BL       emberAfReadServerAttribute
    132          	if(CurrentDimmerLevel != DimmerLevel) {
   \   0000001A   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   0000001E   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD027             BEQ.N    ??CallTaskDimmerLevelChangeCommand_0
    133          
    134          // 		write attribute
    135          		emberAfWriteServerAttribute(DimmerInClusterEndpoint,ZCL_LEVEL_CONTROL_CLUSTER_ID,
    136          									ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    137          									&DimmerLevel, sizeof(DimmerLevel));
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0xAB01             ADD      R3,SP,#+4
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x2108             MOVS     R1,#+8
   \   00000030   0x.... 0x....      BL       emberAfWriteServerAttribute
    138          		int8u OnOffValue;
    139          		if(DimmerLevel == 0){
   \   00000034   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xBF07             ITTEE    EQ 
    140          			OnOffValue = 0;
   \   0000003C   0xF88D 0x0005      STRBEQ   R0,[SP, #+5]
    141          			emberAfWriteServerAttribute(DimmerInClusterEndpoint,ZCL_ON_OFF_CLUSTER_ID,
    142          									ZCL_ON_OFF_ATTRIBUTE_ID,
    143          									&OnOffValue, sizeof(OnOffValue));
   \   00000040   0x2001             MOVEQ    R0,#+1
    144          		}
    145          		else{
    146          			OnOffValue = 1;
   \   00000042   0x2001             MOVNE    R0,#+1
   \   00000044   0xF88D 0x0005      STRBNE   R0,[SP, #+5]
    147          			emberAfWriteServerAttribute(DimmerInClusterEndpoint,ZCL_ON_OFF_CLUSTER_ID,
    148          						ZCL_ON_OFF_ATTRIBUTE_ID,
    149          						&OnOffValue, sizeof(OnOffValue));
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0xF10D 0x0305      ADD      R3,SP,#+5
   \   0000004E   0x2200             MOVS     R2,#+0
   \   00000050   0x2106             MOVS     R1,#+6
   \   00000052   0x.... 0x....      BL       emberAfWriteServerAttribute
    150          		}
    151          //	 	Send to Bind Device
    152          		EmberStatus sendStatus;
                 		            ^
Warning[Pe550]: variable "sendStatus" was set but never used
    153          		sendStatus = SendViaBindingTable(DimmerInClusterEndpoint,DimmerLevel,LevelWithOnOffType);
   \   00000056   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000005A   0x2203             MOVS     R2,#+3
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x.... 0x....      BL       SendViaBindingTable
    154          
    155          //		Send Level AttributeResponse, Zipato stupid update :D-----------------------------//
    156          		SendLevelControlReadAttribute(DimmerInClusterEndpoint,DimmerLevel);
   \   00000062   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x.... 0x....      BL       SendLevelControlReadAttribute
    157          //		Send On-Off AttributeResponse, Zipato stupid update :D-----------------------------//
    158          		SendOnOffControlReadAttribute(DimmerInClusterEndpoint,OnOffValue);
   \   0000006C   0xF89D 0x1005      LDRB     R1,[SP, #+5]
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x.... 0x....      BL       SendOnOffControlReadAttribute
    159          	}
    160          }
   \                     ??CallTaskDimmerLevelChangeCommand_0: (+1)
   \   00000076   0xBD07             POP      {R0-R2,PC}       ;; return
    161          
    162          
    163          
    164          //------------------------CallTaskMcClockCalibrate-------------------//
    165          
    166          
    167          

   \                                 In section .text, align 2, keep-with-next
    168          void CallTaskMcClockCalibrate(int8u *Data){
   \                     CallTaskMcClockCalibrate: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    169          	int8u DataCheckKey[16] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,
    170          										0xBB,0xCC,0xDD,0xEE,0xFF};
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1`
   \   0000000A   0x.... 0x....      BL       ?Subroutine6
    171          	if(MEMCOMPARE(&Data[1], DataCheckKey, 0) == 0){
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000000E   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000012   0xB908             CBNZ.N   R0,??CallTaskMcClockCalibrate_0
    172          		UartSendMcClockCalibrate();
   \   00000014   0x.... 0x....      BL       UartSendMcClockCalibrate
    173          	}
    174          }
   \                     ??CallTaskMcClockCalibrate_0: (+1)
   \   00000018   0xBD1F             POP      {R0-R4,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0xA900             ADD      R1,SP,#+0
   \   00000004   0x1C60             ADDS     R0,R4,#+1
   \   00000006   0x.... 0x....      B.W      halCommonMemCompare

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x2210             MOVS     R2,#+16
   \   00000002   0x.... 0x....      B.W      __aeabi_memcpy4
    175          //------------------------CallTaskCheckMcReady-------------------//
    176          // This Uart Command Indicator MC StartUp, or EM reset end StartUp

   \                                 In section .text, align 2, keep-with-next
    177          void CallTaskCheckMcReady(int8u *Data){
   \                     CallTaskCheckMcReady: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    178          	EmberNetworkStatus NetworkStatus;
    179          	int8u DataCheckKey[16] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,
    180          										0xBB,0xCC,0xDD,0xEE,0xFF};
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_1`
   \   0000000A   0x.... 0x....      BL       ?Subroutine6
    181          	if(MEMCOMPARE(&Data[1], DataCheckKey, 0) == 0){
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000000E   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000012   0xB9C0             CBNZ.N   R0,??CallTaskCheckMcReady_0
    182          
    183          		UartSendBlinkLed(0x0F, 2);
   \   00000014   0x2102             MOVS     R1,#+2
   \   00000016   0x200F             MOVS     R0,#+15
   \   00000018   0x.... 0x....      BL       UartSendBlinkLed
    184          #ifdef SWITCH_TYPE
    185          		UartSendSwitchControlStateMark(0x00);  // Get switch state after reset
    186          #endif
    187          
    188          		NetworkStatus = emberAfNetworkState();
    189          		if(NetworkStatus == EMBER_JOINED_NETWORK) {
   \   0000001C   0x.... 0x....      BL       emberAfNetworkState
   \   00000020   0x2802             CMP      R0,#+2
   \   00000022   0xD106             BNE.N    ??CallTaskCheckMcReady_1
    190          			UartSendBlinkLed(0x0F, 1);
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0x200F             MOVS     R0,#+15
   \   00000028   0x.... 0x....      BL       UartSendBlinkLed
    191          //		This Command is EM after reset, so all startup code can be set here.
    192          			GetHcActiveEndPoint();
                 			^
Warning[Pe223]: function "GetHcActiveEndPoint" declared implicitly
   \   0000002C   0x.... 0x....      BL       GetHcActiveEndPoint
   \   00000030   0xBD1F             POP      {R0-R4,PC}
    193          		}
    194          		else{
    195          		    CallJoinTask(0xFF,3000 + ((int8u)halCommonGetRandom()<<2));
   \                     ??CallTaskCheckMcReady_1: (+1)
   \   00000032   0x.... 0x....      BL       halCommonGetRandom
   \   00000036   0x0600             LSLS     R0,R0,#+24
   \   00000038   0x0D80             LSRS     R0,R0,#+22
   \   0000003A   0xF600 0x31B8      ADDW     R1,R0,#+3000
   \   0000003E   0xB289             UXTH     R1,R1
   \   00000040   0x20FF             MOVS     R0,#+255
   \   00000042   0x.... 0x....      BL       CallJoinTask
    196          		}
    197          	}
    198          }
   \                     ??CallTaskCheckMcReady_0: (+1)
   \   00000046   0xBD1F             POP      {R0-R4,PC}       ;; return
    199          //------------------------CallTaskTouchButtonHold--------------------//
    200          typedef enum ButtonHoldCmd{
    201          	ButtonUnpress		= 0,
    202          	ButtonShortHold		= 1,
    203          	ButtonLongHold		= 2,
    204              ButtonResetHold		= 3,
    205          };
                  ^
Warning[Pe375]: declaration requires a typedef name

   \                                 In section .text, align 2, keep-with-next
    206          void CallTaskTouchButtonHold(int8u *Data){
    207          	int8u ButtonPress = Data[1] + 1;
   \                     CallTaskTouchButtonHold: (+1)
   \   00000000   0x7841             LDRB     R1,[R0, #+1]
    208          	int8u ButtonHoldType = Data[2];
    209          
    210          	switch (ButtonHoldType & 0x03){
   \   00000002   0x7880             LDRB     R0,[R0, #+2]
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \   00000006   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000000A   0xD003             BEQ.N    ??CallTaskTouchButtonHold_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD007             BEQ.N    ??CallTaskTouchButtonHold_1
   \   00000010   0xD303             BCC.N    ??CallTaskTouchButtonHold_2
   \   00000012   0x4770             BX       LR
    211          		case ButtonUnpress:
    212          			CallButtonRelease(ButtonPress);
   \                     ??CallTaskTouchButtonHold_0: (+1)
   \   00000014   0xB2C8             UXTB     R0,R1
   \   00000016   0x.... 0x....      B.W      beButtonRealease
    213          		break;
    214          		case ButtonShortHold:
    215          			CallButtonShortHold(ButtonPress);
   \                     ??CallTaskTouchButtonHold_2: (+1)
   \   0000001A   0xB2C8             UXTB     R0,R1
   \   0000001C   0x.... 0x....      B.W      beButtonPress2Time
    216          		break;
    217          		case ButtonLongHold:
    218          			CallButtonLongHold(ButtonPress);
   \                     ??CallTaskTouchButtonHold_1: (+1)
   \   00000020   0xB2C8             UXTB     R0,R1
   \   00000022   0x.... 0x....      B.W      beButtonPress3Time
    219          		break;
    220          		case ButtonResetHold:
    221          		break;
    222          		default:
    223          		break;
    224          
    225          	}
    226          }
    227          //------------------------CallTaskCalibrateTimmer--------------------//

   \                                 In section .text, align 2, keep-with-next
    228          void CallTaskMcTimmerCalibrate(int8u *Data){
    229          	int8u Inverval = Data[1];
    230          	int8u Times	= Data[2];
    231          	CallMcTimmerCalibrateTask(Inverval,Times);
   \                     CallTaskMcTimmerCalibrate: (+1)
   \   00000000   0x7881             LDRB     R1,[R0, #+2]
   \   00000002   0x7840             LDRB     R0,[R0, #+1]
   \   00000004   0x.... 0x....      B.W      CallMcTimmerCalibrateTask
    232          
    233          }
    234          
    235          //----------------------------CallTask--------------------------------//
    236          

   \                                 In section .text, align 2, keep-with-next
    237          void CallUartTask(int8u *UartPacketCommand){
    238          	int8u UartPacketID = UartPacketCommand[0];
    239          
    240          	switch(UartPacketID){
   \                     CallUartTask: (+1)
   \   00000000   0x7801             LDRB     R1,[R0, #+0]
   \   00000002   0x29A0             CMP      R1,#+160
   \   00000004   0xD00A             BEQ.N    ??CallUartTask_0
   \   00000006   0x29A2             CMP      R1,#+162
   \   00000008   0xD009             BEQ.N    ??CallUartTask_1
   \   0000000A   0x29A7             CMP      R1,#+167
   \   0000000C   0xD008             BEQ.N    ??CallUartTask_2
   \   0000000E   0x29AE             CMP      R1,#+174
   \   00000010   0xD007             BEQ.N    ??CallUartTask_3
   \   00000012   0x29D0             CMP      R1,#+208
   \   00000014   0xD007             BEQ.N    ??CallUartTask_4
   \   00000016   0x29D1             CMP      R1,#+209
   \   00000018   0xD004             BEQ.N    ??CallUartTask_5
   \   0000001A   0x4770             BX       LR
    241          		case RelayStatusChange:
    242          			CallTaskRelayChangeCommand(UartPacketCommand);
   \                     ??CallUartTask_0: (+1)
   \   0000001C   0x....             B.N      CallTaskRelayChangeCommand
    243          			break;
    244          		case CurtainLevelChange:
    245          			break;
    246          		case DimmerLevelChange:
    247          			CallTaskDimmerLevelChangeCommand(UartPacketCommand);
   \                     ??CallUartTask_1: (+1)
   \   0000001E   0x....             B.N      CallTaskDimmerLevelChangeCommand
    248          			break;
    249          		case FanLevelChange:
    250          			break;
    251          		case TouchButtonHold:
    252          			CallTaskTouchButtonHold(UartPacketCommand);
   \                     ??CallUartTask_2: (+1)
   \   00000020   0x....             B.N      CallTaskTouchButtonHold
    253          			break;
    254          		case McTimmerCalibrate:
    255          			CallTaskMcTimmerCalibrate(UartPacketCommand);
   \                     ??CallUartTask_3: (+1)
   \   00000022   0x....             B.N      CallTaskMcTimmerCalibrate
    256          			break;
    257          		case McClockCalibrate:
    258          			CallTaskMcClockCalibrate(UartPacketCommand);
   \                     ??CallUartTask_5: (+1)
   \   00000024   0x....             B.N      CallTaskMcClockCalibrate
    259          			break;
    260          		case CheckMcReady:
    261          			CallTaskCheckMcReady(UartPacketCommand);
   \                     ??CallUartTask_4: (+1)
   \   00000026   0x....             B.N      CallTaskCheckMcReady
    262          			break;
    263          		default:
    264          			break;
    265          	}
    266          }
    267          
    268          
    269          
    270          

   \                                 In section .text, align 2, keep-with-next
    271          void UartScanCommand(void){
   \                     UartScanCommand: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    272          	int16u NumberOfByteReCeiver;
    273          	int8u ReadSerialData;
    274          	int8u ReadStatus;
    275          
    276          
    277          	NumberOfByteReCeiver = emberSerialReadAvailable (1);
    278          	if(NumberOfByteReCeiver > 0){
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       emberSerialReadAvailable
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD041             BEQ.N    ??UartScanCommand_0
    279          		ReadStatus = emberSerialReadByte(1, &ReadSerialData);
    280          		{
    281          			if(ReadStatus == EMBER_SUCCESS){
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       emberSerialReadByte
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD13B             BNE.N    ??UartScanCommand_0
    282          
    283          				switch (UartRxDataStep){
   \   00000018   0x.... 0x....      LDR.W    R4,??DataTable11
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0x7821             LDRB     R1,[R4, #+0]
   \   00000022   0xB129             CBZ.N    R1,??UartScanCommand_1
   \   00000024   0x2902             CMP      R1,#+2
   \   00000026   0xD00C             BEQ.N    ??UartScanCommand_2
   \   00000028   0xD306             BCC.N    ??UartScanCommand_3
   \   0000002A   0x2903             CMP      R1,#+3
   \   0000002C   0xD00F             BEQ.N    ??UartScanCommand_4
   \   0000002E   0xBD31             POP      {R0,R4,R5,PC}
    284          				case 0:
    285          					if(ReadSerialData == 0x4C){
   \                     ??UartScanCommand_1: (+1)
   \   00000030   0x284C             CMP      R0,#+76
   \   00000032   0xD12D             BNE.N    ??UartScanCommand_0
    286          						UartRxDataStep = 1;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE02A             B.N      ??UartScanCommand_5
    287          					}
    288          					else{
    289          						UartRxDataStep = 0;
    290          					}
    291          				break;
    292          				case 1:
    293          					if(ReadSerialData == 0x4D){
   \                     ??UartScanCommand_3: (+1)
   \   00000038   0x284D             CMP      R0,#+77
   \   0000003A   0xBF14             ITE      NE 
    294          						UartRxDataStep = 2;
    295          					}
    296          					else{
    297          						UartRxDataStep = 0;
   \   0000003C   0x2000             MOVNE    R0,#+0
    298          					}
   \   0000003E   0x2002             MOVEQ    R0,#+2
   \   00000040   0xE025             B.N      ??UartScanCommand_5
    299          				break;
    300          				case 2:
    301          					UartRxPacketLength = ReadSerialData;
   \                     ??UartScanCommand_2: (+1)
   \   00000042   0x7060             STRB     R0,[R4, #+1]
    302          					if(UartRxPacketLength >40){
   \   00000044   0x2829             CMP      R0,#+41
   \   00000046   0xBFB4             ITE      LT 
    303          						UartRxDataStep = 0;
    304          					}
    305          					else{
    306          						UartRxDataStep = 3;
   \   00000048   0x2003             MOVLT    R0,#+3
    307          					}
   \   0000004A   0x2000             MOVGE    R0,#+0
   \   0000004C   0xE01F             B.N      ??UartScanCommand_5
    308          				break;
    309          				case 3:
    310          					if(UartRxCurrentLength < UartRxPacketLength-1){
   \                     ??UartScanCommand_4: (+1)
   \   0000004E   0x7860             LDRB     R0,[R4, #+1]
   \   00000050   0x78A1             LDRB     R1,[R4, #+2]
   \   00000052   0x1E40             SUBS     R0,R0,#+1
   \   00000054   0x4281             CMP      R1,R0
   \   00000056   0xDA06             BGE.N    ??UartScanCommand_6
    311          						UartRxCommandData[UartRxCurrentLength] =  ReadSerialData;
   \   00000058   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000005C   0x190A             ADDS     R2,R1,R4
   \   0000005E   0x7110             STRB     R0,[R2, #+4]
    312          						UartRxCurrentLength ++;
   \   00000060   0x1C48             ADDS     R0,R1,#+1
   \   00000062   0x70A0             STRB     R0,[R4, #+2]
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}
    313          					}
    314          					else{
    315          						int8u PacketCheckXor;
    316          						int8u CheckXor =0;
   \                     ??UartScanCommand_6: (+1)
   \   00000066   0x2100             MOVS     R1,#+0
    317          						PacketCheckXor =  ReadSerialData;
   \   00000068   0xF89D 0x2000      LDRB     R2,[SP, #+0]
    318          						{
    319          							for(int8u j=0;j < UartRxPacketLength-1;j++){
   \   0000006C   0x2300             MOVS     R3,#+0
   \   0000006E   0xE003             B.N      ??UartScanCommand_7
    320          								CheckXor = CheckXor ^ UartRxCommandData[j];
   \                     ??UartScanCommand_8: (+1)
   \   00000070   0x191D             ADDS     R5,R3,R4
    321          							}
   \   00000072   0x1C5B             ADDS     R3,R3,#+1
   \   00000074   0x792D             LDRB     R5,[R5, #+4]
   \   00000076   0x4069             EORS     R1,R5,R1
   \                     ??UartScanCommand_7: (+1)
   \   00000078   0xB2DB             UXTB     R3,R3
   \   0000007A   0x4283             CMP      R3,R0
   \   0000007C   0xDBF8             BLT.N    ??UartScanCommand_8
    322          						}
    323          						if(PacketCheckXor == CheckXor){
   \   0000007E   0xB2C9             UXTB     R1,R1
   \   00000080   0x428A             CMP      R2,R1
   \   00000082   0xBF04             ITT      EQ 
    324          							CallUartTask(UartRxCommandData);
   \   00000084   0x1D20             ADDEQ    R0,R4,#+4
   \   00000086   0x.... 0x....      BLEQ     CallUartTask
    325          						}
    326          						UartRxCurrentLength = 0;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x70A0             STRB     R0,[R4, #+2]
    327          						UartRxDataStep = 0;
   \                     ??UartScanCommand_5: (+1)
   \   0000008E   0x7020             STRB     R0,[R4, #+0]
    328          					}
    329          				break;
    330          					default:
    331          				break;
    332          
    333          				}
    334          			}
    335          		}
    336          	}
    337          }
   \                     ??UartScanCommand_0: (+1)
   \   00000090   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    338          
    339          
    340          
    341          //--------------------------------------------UART Send Command--------------------------//
    342          
    343          
    344          typedef enum UartTxCommand_ID{
    345          	SwitchControlCmdId		=	0xB0,
    346          	DimmerLevelControlCmdID =	0xB2,
    347          	ChangeSpecialLedTxCmdId	=	0xB7,
    348          	AttributeSetupCmdId		=	0xBC,
    349          	McClockCalibrateCmdId  = 	0xC1,
    350          	McReadyCmdId			=	0xC0,
    351          	McTimerCalibrateCmdId	=	0xBE,
    352          };
                  ^
Warning[Pe375]: declaration requires a typedef name
    353          
    354          //----------------------------UART Send Command Utility-----------------------//
    355          

   \                                 In section .text, align 2, keep-with-next
    356          unsigned char GetLastTxUartCmd(void){
    357              unsigned char Head = 0;
   \                     GetLastTxUartCmd: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
    358              unsigned char Length = 0;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \   00000006   0xE002             B.N      ??GetLastTxUartCmd_0
    359              while(UartTxCommandBuff[Head] != 0){
    360                  if(UartTxCommandBuff[Head] != 0){
    361                      Length = UartTxCommandBuff[Head];
    362                      Head = Head+Length+2;
   \                     ??GetLastTxUartCmd_1: (+1)
   \   00000008   0x1810             ADDS     R0,R2,R0
   \   0000000A   0x1C80             ADDS     R0,R0,#+2
   \   0000000C   0xB2C0             UXTB     R0,R0
    363                  }
    364              }
   \                     ??GetLastTxUartCmd_0: (+1)
   \   0000000E   0x5C42             LDRB     R2,[R0, R1]
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD1F9             BNE.N    ??GetLastTxUartCmd_1
    365              return Head;
   \   00000014   0x4770             BX       LR               ;; return
    366          }
    367          
    368          //------------------------------Send Dimmer Level Control Command----------------//
    369           /*
    370          Mau ban tin:
    371          
    372          CommandID			Dimmer Level
    373          1byte				1 Byte
    374          0xB1
    375          */

   \                                 In section .text, align 2, keep-with-next
    376          void UartSendDimLevel (int8u currentDimLevel) {
   \                     UartSendDimLevel: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    377          	UartSendLevelControlDataBuffer UartSendLevelControlData;
    378          
    379          	UartSendLevelControlData.Length = 3;
   \   00000004   0x.... 0x....      BL       ?Subroutine9
    380          	UartSendLevelControlData.Id = DimmerLevelControlCmdID;
    381          	UartSendLevelControlData.Data = currentDimLevel;
    382              UartSendLevelControlData.CheckXor =  UartSendLevelControlData.Id ^ UartSendLevelControlData.Data;
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000008   0xF080 0x00B2      EOR      R0,R0,#0xB2
   \   0000000C   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000010   0x21B2             MOVS     R1,#+178
    383          	UartSendLevelControlData.TimeOut = NormalTimeOut;
   \   00000012   0x....             B.N      ?Subroutine0
    384          
    385          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendLevelControlData,
    386          			sizeof(UartSendLevelControlDataBuffer));
    387          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x20FF             MOVS     R0,#+255
   \   00000002   0xF88D 0x1001      STRB     R1,[SP, #+1]
   \                     ??Subroutine0_0: (+1)
   \   00000006   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   0000000A   0x.... 0x....      BL       GetLastTxUartCmd
   \   0000000E   0x2205             MOVS     R2,#+5
   \   00000010                      REQUIRE ??Subroutine13_0
   \   00000010                      ;; // Fall through to label ??Subroutine13_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine13_0: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable11_1
   \   00000002   0xA900             ADD      R1,SP,#+0
   \   00000004   0x18C0             ADDS     R0,R0,R3
   \   00000006   0x.... 0x....      BL       halCommonMemMove
   \   0000000A   0xBD07             POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x2103             MOVS     R1,#+3
   \   00000002   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   00000006   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \   0000000A   0x4770             BX       LR
    388          
    389          //------------------------------Send Switch Control Command----------------//
    390           /*
    391          Mau ban tin:
    392          
    393          CommandID			Switch State
    394          1byte				11Byte
    395          0xB0
    396          */
    397          
    398          
    399          
    400          // State off Relay Use SwitchStateEnum

   \                                 In section .text, align 2, keep-with-next
    401          void UartSendSwitchControlNumber(int8u SwitchNumber, int8u State){
   \                     UartSendSwitchControlNumber: (+1)
   \   00000000   0xB500             PUSH     {LR}
    402          	UartSendSwitchControlDataBuffer UartSendSwitchControlData;
    403          
    404          	UartSendSwitchControlData.Length = 3;
    405          	UartSendSwitchControlData.Id = SwitchControlCmdId;
    406          	UartSendSwitchControlData.Data = (State << 2*(SwitchNumber-1));
   \   00000002   0x1E40             SUBS     R0,R0,#+1
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_18: (+1)
   \   0000000A   0x2203             MOVS     R2,#+3
    407              UartSendSwitchControlData.CheckXor =  UartSendSwitchControlData.Id ^ UartSendSwitchControlData.Data;
   \   0000000C   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000010   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \   00000014   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000018   0x22B0             MOVS     R2,#+176
    408          	UartSendSwitchControlData.TimeOut = NormalTimeOut;
   \   0000001A   0x20FF             MOVS     R0,#+255
   \   0000001C   0xF88D 0x2001      STRB     R2,[SP, #+1]
   \   00000020   0x....             B.N      ??Subroutine0_0
    409          
    410          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendSwitchControlData,
    411          			sizeof(UartSendSwitchControlDataBuffer));
    412          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0xF080 0x00B0      EOR      R0,R0,#0xB0
   \   00000004   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x0040             LSLS     R0,R0,#+1
   \   00000002   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000006   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   0000000A   0x4770             BX       LR
    413          

   \                                 In section .text, align 2, keep-with-next
    414          void UartSendSwitchControlMark(int8u SwitchMark, int8u State){
   \                     UartSendSwitchControlMark: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    415          	int8u i;
    416          	UartSendSwitchControlDataBuffer UartSendSwitchControlData;
    417          
    418          	for(i=0;i<4;i++){
   \   00000002   0x.... 0x....      BL       ?Subroutine3
    419          		if(((SwitchMark >> i) & 0x01) == 1){
    420          			UartSendSwitchControlData.Data = UartSendSwitchControlData.Data | (State << 2*i);
    421          		}
    422          	}
    423          	UartSendSwitchControlData.Length = 3;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000006   0x2003             MOVS     R0,#+3
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
    424          	UartSendSwitchControlData.Id = SwitchControlCmdId;
   \   0000000C   0x20B0             MOVS     R0,#+176
   \   0000000E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    425          	UartSendSwitchControlData.CheckXor = UartSendSwitchControlData.Id ^ UartSendSwitchControlData.Data;
   \   00000012   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000016   0x.... 0x....      BL       ?Subroutine8
    426          	UartSendSwitchControlData.TimeOut = NormalTimeOut;
   \                     ??CrossCallReturnLabel_14: (+1)
   \   0000001A   0x20FF             MOVS     R0,#+255
   \   0000001C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    427          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendSwitchControlData,
    428          			sizeof(UartSendSwitchControlDataBuffer));
   \   00000020   0x.... 0x....      BL       GetLastTxUartCmd
   \   00000024   0x2205             MOVS     R2,#+5
   \   00000026   0x....             B.N      ??Subroutine14_0
    429          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \                     ??Subroutine3_0: (+1)
   \   00000002   0xFA40 0xF302      ASR      R3,R0,R2
   \   00000006   0x07DB             LSLS     R3,R3,#+31
   \   00000008   0xD507             BPL.N    ??Subroutine3_1
   \   0000000A   0xF89D 0x3002      LDRB     R3,[SP, #+2]
   \   0000000E   0x0054             LSLS     R4,R2,#+1
   \   00000010   0xFA01 0xF404      LSL      R4,R1,R4
   \   00000014   0x4323             ORRS     R3,R4,R3
   \   00000016   0xF88D 0x3002      STRB     R3,[SP, #+2]
   \                     ??Subroutine3_1: (+1)
   \   0000001A   0x1C52             ADDS     R2,R2,#+1
   \   0000001C   0x2A04             CMP      R2,#+4
   \   0000001E   0xDBF0             BLT.N    ??Subroutine3_0
   \   00000020   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine14_0: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable11_1
   \   00000002   0xA900             ADD      R1,SP,#+0
   \   00000004   0x18C0             ADDS     R0,R0,R3
   \   00000006   0x.... 0x....      BL       halCommonMemMove
   \   0000000A   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
    430          void UartSendSwitchControlStateMark(int8u SwitchStateMark){
   \                     UartSendSwitchControlStateMark: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    431          	UartSendSwitchControlDataBuffer UartSendSwitchControlData;
    432          
    433          	UartSendSwitchControlData.Length = 3;
   \   00000004   0x.... 0x....      BL       ?Subroutine9
    434          	UartSendSwitchControlData.Id = SwitchControlCmdId;
    435          	UartSendSwitchControlData.Data = SwitchStateMark;
    436              UartSendSwitchControlData.CheckXor =  UartSendSwitchControlData.Id ^ UartSendSwitchControlData.Data;
   \                     ??CrossCallReturnLabel_17: (+1)
   \   00000008   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_15: (+1)
   \   0000000C   0x21B0             MOVS     R1,#+176
    437          	UartSendSwitchControlData.TimeOut = NormalTimeOut;
   \   0000000E                      REQUIRE ?Subroutine0
   \   0000000E                      ;; // Fall through to label ?Subroutine0
    438          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendSwitchControlData,
    439          			sizeof(UartSendSwitchControlDataBuffer));
    440          }
    441          
    442          //------------------------------Send Attribute Setup Command----------------//
    443           /*
    444          Mau ban tin:
    445          
    446          CommandID			Attribute			Value
    447          1byte				1Byte               1 Byte
    448          0xBC
    449          */
    450          
    451          // Option of Store value use StoreAttributeEnum
    452          // AttribteId use SetupAttributeIdEnum

   \                                 In section .text, align 2, keep-with-next
    453          void UartSendStoreAttribute(int8u SwitchMark, int8u Option){
   \                     UartSendStoreAttribute: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    454          	UartSendAttributeSetupDataBuffer UartSendAttributeSetupData;
    455          	int8u i;
    456          	for(i=0;i<4;i++){
   \   00000004   0x2200             MOVS     R2,#+0
    457          		if(((SwitchMark<<i) & 0x01) == 1){
   \                     ??UartSendStoreAttribute_0: (+1)
   \   00000006   0xFA00 0xF302      LSL      R3,R0,R2
   \   0000000A   0x07DB             LSLS     R3,R3,#+31
   \   0000000C   0xD507             BPL.N    ??UartSendStoreAttribute_1
    458          			UartSendAttributeSetupData.Value[0] = UartSendAttributeSetupData.Value[0] | (Option<<(2*i));
   \   0000000E   0xF89D 0x3003      LDRB     R3,[SP, #+3]
   \   00000012   0x0054             LSLS     R4,R2,#+1
   \   00000014   0xFA01 0xF404      LSL      R4,R1,R4
   \   00000018   0x4323             ORRS     R3,R4,R3
   \   0000001A   0xF88D 0x3003      STRB     R3,[SP, #+3]
    459          		}
    460          	}
   \                     ??UartSendStoreAttribute_1: (+1)
   \   0000001E   0x1C52             ADDS     R2,R2,#+1
   \   00000020   0x2A04             CMP      R2,#+4
   \   00000022   0xDBF0             BLT.N    ??UartSendStoreAttribute_0
    461          
    462          
    463          	UartSendAttributeSetupData.Length = 8;
   \   00000024   0x2008             MOVS     R0,#+8
   \   00000026   0xF88D 0x0000      STRB     R0,[SP, #+0]
    464          	UartSendAttributeSetupData.Id = AttributeSetupCmdId;
   \   0000002A   0x20BC             MOVS     R0,#+188
   \   0000002C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    465          	UartSendAttributeSetupData.AttribteId = SaveState;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xF88D 0x0002      STRB     R0,[SP, #+2]
    466          	UartSendAttributeSetupData.CheckXor = UartSendAttributeSetupData.Value[0] ^ UartSendAttributeSetupData.AttribteId
    467          		^ UartSendAttributeSetupData.Id;
   \   00000036   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000003A   0xF080 0x00BD      EOR      R0,R0,#0xBD
   \   0000003E   0xF88D 0x0008      STRB     R0,[SP, #+8]
    468              UartSendAttributeSetupData.TimeOut = NormalTimeOut;
   \   00000042   0x20FF             MOVS     R0,#+255
   \   00000044   0xF88D 0x0009      STRB     R0,[SP, #+9]
    469          
    470              MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendAttributeSetupData,
    471          			sizeof(UartSendAttributeSetupDataBuffer));
   \   00000048   0x.... 0x....      BL       GetLastTxUartCmd
   \   0000004C   0x220A             MOVS     R2,#+10
   \   0000004E   0x.... 0x....      BL       ?Subroutine4
    472          }
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000052   0xBD1F             POP      {R0-R4,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x....             LDR.N    R3,??DataTable11_1
   \   00000002   0xA900             ADD      R1,SP,#+0
   \   00000004   0x18C0             ADDS     R0,R0,R3
   \   00000006   0x.... 0x....      B.W      halCommonMemMove
    473          
    474          
    475          
    476          
    477          //------------------------------Send MC Clock Calibrate Command----------------//
    478           /*
    479          Mau ban tin:
    480          
    481          CommandID			Calibrate Data
    482          1byte				16Byte
    483          0xC1				0x00 ->0xFF
    484          */
    485          
    486          
    487          

   \                                 In section .text, align 2, keep-with-next
    488          void UartSendMcClockCalibrate(void){
   \                     UartSendMcClockCalibrate: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    489          	UartSendMcClockCalibrateDataBuffer UartSendMcClockCalibrateData;
    490          	int8u DataCheckKey[16] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,
    491          										0xBB,0xCC,0xDD,0xEE,0xFF};
   \   00000004   0xA805             ADD      R0,SP,#+20
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_2`
   \   0000000A   0x.... 0x....      BL       ?Subroutine6
    492          	UartSendMcClockCalibrateData.Length = 18;
   \                     ??CrossCallReturnLabel_9: (+1)
   \   0000000E   0x2012             MOVS     R0,#+18
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    493          	UartSendMcClockCalibrateData.Id		= McClockCalibrateCmdId;
    494          	MEMCOPY(&UartSendMcClockCalibrateData.Data, DataCheckKey, sizeof(DataCheckKey));
   \   00000014   0x2210             MOVS     R2,#+16
   \   00000016   0x20C1             MOVS     R0,#+193
   \   00000018   0x.... 0x....      BL       ?Subroutine7
    495          	UartSendMcClockCalibrateData.CheckXor = McClockCalibrateCmdId;
   \                     ??CrossCallReturnLabel_12: (+1)
   \   0000001C   0x20C1             MOVS     R0,#+193
   \   0000001E   0x....             B.N      ?Subroutine2
    496          	UartSendMcClockCalibrateData.TimeOut = NormalTimeOut;
    497          
    498          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendMcClockCalibrateData,
    499          			sizeof(UartSendMcClockCalibrateData));
    500          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xF88D 0x0012      STRB     R0,[SP, #+18]
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0xF88D 0x0013      STRB     R0,[SP, #+19]
   \   0000000A   0x.... 0x....      BL       GetLastTxUartCmd
   \   0000000E   0x2214             MOVS     R2,#+20
   \   00000010   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000014   0xB009             ADD      SP,SP,#+36
   \   00000016   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000004   0xA905             ADD      R1,SP,#+20
   \   00000006   0xF10D 0x0002      ADD      R0,SP,#+2
   \   0000000A   0x.... 0x....      B.W      halCommonMemMove
    501          
    502          
    503          //----------------------------------Send Special Led Command------------------------//
    504           /*
    505          Mau ban tin:
    506          
    507          CommandID			State			Extra
    508          1byte				1Byte			1Byte
    509          0xB7
    510          */
    511          
    512          
    513          // State off Special Led use LedStateEnum
    514          // State off Led after Blink use LedStateEnum

   \                                 In section .text, align 2, keep-with-next
    515          void UartSendRefreshAllLed(void){
    516          	UartSendSpecialLedMark(0x0F, 0);
   \                     UartSendRefreshAllLed: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x200F             MOVS     R0,#+15
   \   00000004   0x....             B.N      UartSendSpecialLedMark
    517          }

   \                                 In section .text, align 2, keep-with-next
    518          void UartSendRefreshLedNumber(int8u LedNumber){
    519          	UartSendSpecialLedNumber(LedNumber, 0);
   \                     UartSendRefreshLedNumber: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      UartSendSpecialLedNumber
    520          }

   \                                 In section .text, align 2, keep-with-next
    521          void UartSendSpecialLedMark (int8u LedNumberMark, int8u State){
   \                     UartSendSpecialLedMark: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    522          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    523          	int8u i;
    524          
    525          	for(i=0;i<4;i++){
   \   00000002   0x.... 0x....      BL       ?Subroutine3
    526          		if(((LedNumberMark >> i) & 0x01) == 1){
    527          			UartSendSpecialLedMarkData.State = UartSendSpecialLedMarkData.State | (State << 2*i);
    528          		}
    529          	}
    530          	UartSendSpecialLedMarkData.Extra = 0;
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000006   0x....             B.N      ?Subroutine1
    531          	UartSendSpecialLedMarkData.Length = 4;
    532          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    533          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    534          		UartSendSpecialLedMarkData.Extra;
    535          
    536          	UartSendSpecialLedMarkData.TimeOut = NormalTimeOut;
    537          
    538             	MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    539          			sizeof(UartSendSpecialLedDataBuffer));
    540          
    541          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xF88D 0x0003      STRB     R0,[SP, #+3]
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000C   0x20B7             MOVS     R0,#+183
   \   0000000E   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000012   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000016   0xF080 0x00B7      EOR      R0,R0,#0xB7
   \   0000001A   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \   0000001E   0x20FF             MOVS     R0,#+255
   \   00000020   0xF88D 0x0005      STRB     R0,[SP, #+5]
   \   00000024   0x.... 0x....      BL       GetLastTxUartCmd
   \   00000028   0x2206             MOVS     R2,#+6
   \   0000002A                      REQUIRE ??Subroutine14_0
   \   0000002A                      ;; // Fall through to label ??Subroutine14_0
    542          
    543          

   \                                 In section .text, align 2, keep-with-next
    544          void UartSendSpecialLedNumber (int8u LedNumber, int8u State){
   \                     UartSendSpecialLedNumber: (+1)
   \   00000000   0xB500             PUSH     {LR}
    545          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    546          
    547          
    548          	UartSendSpecialLedMarkData.State =  (State << (2*(LedNumber -1)));
   \   00000002   0x1E40             SUBS     R0,R0,#+1
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x.... 0x....      BL       ?Subroutine10
    549          	UartSendSpecialLedMarkData.Extra = 0;
   \                     ??CrossCallReturnLabel_19: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    550          	UartSendSpecialLedMarkData.Length = 4;
   \   00000010   0x.... 0x....      BL       ?Subroutine11
    551          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    552          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    553          		UartSendSpecialLedMarkData.Extra;
   \                     ??CrossCallReturnLabel_20: (+1)
   \   00000014   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000018   0xF080 0x00B7      EOR      R0,R0,#0xB7
   \   0000001C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    554              UartSendSpecialLedMarkData.TimeOut = NormalTimeOut;
   \   00000020   0x20FF             MOVS     R0,#+255
   \   00000022   0xF88D 0x0005      STRB     R0,[SP, #+5]
    555          	MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    556          			sizeof(UartSendSpecialLedDataBuffer));
   \   00000026   0x.... 0x....      BL       GetLastTxUartCmd
   \   0000002A   0x2206             MOVS     R2,#+6
   \   0000002C   0x....             B.N      ??Subroutine13_0
    557          
    558          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0x2004             MOVS     R0,#+4
   \   00000002   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000006   0x20B7             MOVS     R0,#+183
   \   00000008   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000000C   0x4770             BX       LR
    559          
    560          
    561          

   \                                 In section .text, align 2, keep-with-next
    562          void UartSendPinkLed(int8u LedNumberMark){
   \                     UartSendPinkLed: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    563          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    564          
    565          	int8u i;
    566          
    567          	for(i=0;i<4;i++){
   \   00000002   0x2100             MOVS     R1,#+0
    568          		if(((LedNumberMark >> i) & 0x01) == 1){
   \                     ??UartSendPinkLed_0: (+1)
   \   00000004   0xFA40 0xF201      ASR      R2,R0,R1
   \   00000008   0x07D2             LSLS     R2,R2,#+31
   \   0000000A   0xD504             BPL.N    ??CrossCallReturnLabel_22
    569          			UartSendSpecialLedMarkData.State = UartSendSpecialLedMarkData.State | (PinkState << 2*i);
   \   0000000C   0xF89D 0x2002      LDRB     R2,[SP, #+2]
   \   00000010   0x2302             MOVS     R3,#+2
   \   00000012   0x.... 0x....      BL       ?Subroutine12
    570          		}
    571          	}
   \                     ??CrossCallReturnLabel_22: (+1)
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0x2904             CMP      R1,#+4
   \   0000001A   0xDBF3             BLT.N    ??UartSendPinkLed_0
    572          	UartSendSpecialLedMarkData.Extra = 0;
   \   0000001C                      REQUIRE ?Subroutine1
   \   0000001C                      ;; // Fall through to label ?Subroutine1
    573          	UartSendSpecialLedMarkData.Length = 4;
    574          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    575          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    576          		UartSendSpecialLedMarkData.Extra;
    577          
    578          	UartSendSpecialLedMarkData.TimeOut = NormalTimeOut;
    579              MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    580          			sizeof(UartSendSpecialLedDataBuffer));
    581          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \   00000000   0x004C             LSLS     R4,R1,#+1
   \   00000002   0x40A3             LSLS     R3,R3,R4
   \   00000004   0x431A             ORRS     R2,R3,R2
   \   00000006   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \   0000000A   0x4770             BX       LR
    582          
    583          

   \                                 In section .text, align 2, keep-with-next
    584          void UartSendOffLed(int8u LedNumberMark){
   \                     UartSendOffLed: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    585          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    586          
    587          	int8u i;
    588          
    589          	for(i=0;i<4;i++){
   \   00000002   0x2100             MOVS     R1,#+0
    590          		if(((LedNumberMark >> i) & 0x01) == 1){
   \                     ??UartSendOffLed_0: (+1)
   \   00000004   0xFA40 0xF201      ASR      R2,R0,R1
   \   00000008   0x07D2             LSLS     R2,R2,#+31
   \   0000000A   0xD504             BPL.N    ??CrossCallReturnLabel_23
    591          			UartSendSpecialLedMarkData.State = UartSendSpecialLedMarkData.State | (OffState << 2*i);
   \   0000000C   0xF89D 0x2002      LDRB     R2,[SP, #+2]
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x.... 0x....      BL       ?Subroutine12
    592          		}
    593          	}
   \                     ??CrossCallReturnLabel_23: (+1)
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0x2904             CMP      R1,#+4
   \   0000001A   0xDBF3             BLT.N    ??UartSendOffLed_0
    594          
    595          	UartSendSpecialLedMarkData.Extra = 0;
   \   0000001C   0x....             B.N      ?Subroutine1
    596          	UartSendSpecialLedMarkData.Length = 4;
    597          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    598          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    599          		UartSendSpecialLedMarkData.Extra;
    600          	UartSendSpecialLedMarkData.TimeOut = NormalTimeOut;
    601          	MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    602          			sizeof(UartSendSpecialLedDataBuffer));
    603          }
    604          
    605          
    606          

   \                                 In section .text, align 2, keep-with-next
    607          void UartSendBlinkLed(int8u LedNumberMark, int8u BlinkTime){
   \                     UartSendBlinkLed: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    608          	UartSendSpecialLedDataBuffer UartSendSpecialLedMarkData;
    609          
    610              BlinkStateExtra BlinkStateExtraData;
    611          	int8u i;
    612          
    613          	for(i=0;i<4;i++){
   \   00000004   0x2100             MOVS     R1,#+0
    614          		if(((LedNumberMark >> i) & 0x01) == 1){
   \                     ??UartSendBlinkLed_0: (+1)
   \   00000006   0xFA40 0xF201      ASR      R2,R0,R1
   \   0000000A   0x07D2             LSLS     R2,R2,#+31
   \   0000000C   0xD507             BPL.N    ??UartSendBlinkLed_1
    615          			UartSendSpecialLedMarkData.State = UartSendSpecialLedMarkData.State | (BlinkState << 2*i);
   \   0000000E   0xF89D 0x2002      LDRB     R2,[SP, #+2]
   \   00000012   0x2303             MOVS     R3,#+3
   \   00000014   0x004D             LSLS     R5,R1,#+1
   \   00000016   0x40AB             LSLS     R3,R3,R5
   \   00000018   0x431A             ORRS     R2,R3,R2
   \   0000001A   0xF88D 0x2002      STRB     R2,[SP, #+2]
    616          		}
    617          	}
   \                     ??UartSendBlinkLed_1: (+1)
   \   0000001E   0x1C49             ADDS     R1,R1,#+1
   \   00000020   0x2904             CMP      R1,#+4
   \   00000022   0xDBF0             BLT.N    ??UartSendBlinkLed_0
    618          	BlinkStateExtraData.BlinkTime = BlinkTime;
    619          	BlinkStateExtraData.LedState = NormalState;
    620          	BlinkStateExtraData.RelayStatus = NoChange;
   \   00000024   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000028   0xF000 0x001F      AND      R0,R0,#0x1F
   \   0000002C   0xEA40 0x1044      ORR      R0,R0,R4, LSL #+5
   \   00000030   0xF000 0x00E1      AND      R0,R0,#0xE1
   \   00000034   0xF88D 0x0008      STRB     R0,[SP, #+8]
    621          
    622          	MEMCOPY(&UartSendSpecialLedMarkData.Extra, &BlinkStateExtraData, sizeof(UartSendSpecialLedMarkData.Extra));
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0xA902             ADD      R1,SP,#+8
   \   0000003C   0xF10D 0x0003      ADD      R0,SP,#+3
   \   00000040   0x.... 0x....      BL       halCommonMemMove
    623          	UartSendSpecialLedMarkData.Length = 4;
   \   00000044   0x.... 0x....      BL       ?Subroutine11
    624          	UartSendSpecialLedMarkData.Id = ChangeSpecialLedTxCmdId;
    625          	UartSendSpecialLedMarkData.CheckXor =	UartSendSpecialLedMarkData.Id ^ UartSendSpecialLedMarkData.State ^
    626          		UartSendSpecialLedMarkData.Extra;
    627          	UartSendSpecialLedMarkData.TimeOut = BlinkTime;
   \                     ??CrossCallReturnLabel_21: (+1)
   \   00000048   0xF88D 0x4005      STRB     R4,[SP, #+5]
   \   0000004C   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000050   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   00000054   0x4048             EORS     R0,R1,R0
   \   00000056   0xF080 0x00B7      EOR      R0,R0,#0xB7
   \   0000005A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    628          	MEMCOPY(&UartTxCommandBuff[GetLastTxUartCmd()],&UartSendSpecialLedMarkData,
    629          			sizeof(UartSendSpecialLedDataBuffer));
   \   0000005E   0x.... 0x....      BL       GetLastTxUartCmd
   \   00000062   0x2206             MOVS     R2,#+6
   \   00000064   0x.... 0x....      BL       ?Subroutine4
    630          }
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000068   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
    631          void UartSendToggleLed(int8u LedNumberMark){
    632          	UartSendBlinkLed(LedNumberMark,0);
   \                     UartSendToggleLed: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             B.N      UartSendBlinkLed
    633          }
    634          
    635          //----------------------------------Send Check MC Ready------------------------//
    636           /*
    637          Mau ban tin:
    638          
    639          CommandID			 Data
    640          1byte				16Byte
    641          0xB0				0x00 -> 0xFF
    642          */

   \                                 In section .text, align 2, keep-with-next
    643          void UartSendCheckMcReady(void){
   \                     UartSendCheckMcReady: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    644          	UartSendCheckMcReadyDataBuffer UartSendCheckMcReadyData;
    645          	int8u DataCheckKey[16] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,
    646          										0xBB,0xCC,0xDD,0xEE,0xFF};
   \   00000004   0xA805             ADD      R0,SP,#+20
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_3`
   \   0000000A   0x.... 0x....      BL       ?Subroutine6
    647          	UartSendCheckMcReadyData.Length = 18;
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000000E   0x2012             MOVS     R0,#+18
   \   00000010   0xF88D 0x0000      STRB     R0,[SP, #+0]
    648          	UartSendCheckMcReadyData.Id		= McReadyCmdId;
    649          	MEMCOPY(&UartSendCheckMcReadyData.Data, DataCheckKey, sizeof(DataCheckKey));
   \   00000014   0x2210             MOVS     R2,#+16
   \   00000016   0x20C0             MOVS     R0,#+192
   \   00000018   0x.... 0x....      BL       ?Subroutine7
    650          	UartSendCheckMcReadyData.CheckXor = McReadyCmdId;
   \                     ??CrossCallReturnLabel_11: (+1)
   \   0000001C   0x20C0             MOVS     R0,#+192
   \   0000001E                      REQUIRE ?Subroutine2
   \   0000001E                      ;; // Fall through to label ?Subroutine2
    651          	UartSendCheckMcReadyData.TimeOut = NormalTimeOut;
    652          
    653          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendCheckMcReadyData,
    654          			sizeof(UartSendCheckMcReadyData));
    655          //	McReadyStatus = McChecking;
    656          }
    657          
    658          
    659          //----------------------------------Send MC Timmer Calibrate ------------------------//
    660           /*
    661          Mau ban tin:
    662          
    663          CommandID			 Interval		TotalTime			TimeCounter
    664          1byte				1Byte           1byte                1byte
    665          0xBE
    666          */

   \                                 In section .text, align 2, keep-with-next
    667          void UartSendMcTimerCalibrate(int8u inverval, int8u totalTimes, int8u timesCounter){
   \                     UartSendMcTimerCalibrate: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    668          	UartSendMcTimerCalibrateDataBuffer UartSendMcTimerCalibrateData;
    669          
    670          	UartSendMcTimerCalibrateData.Length = 5;
   \   00000004   0x2305             MOVS     R3,#+5
    671          	UartSendMcTimerCalibrateData.Id		= McTimerCalibrateCmdId;
    672          	UartSendMcTimerCalibrateData.Inverval = inverval;
   \   00000006   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   0000000A   0xF88D 0x3000      STRB     R3,[SP, #+0]
    673          	UartSendMcTimerCalibrateData.TotalTimes = totalTimes;
    674          	UartSendMcTimerCalibrateData.TimesCounter= timesCounter;
    675          	UartSendMcTimerCalibrateData.CheckXor = McTimerCalibrateCmdId ^ inverval ^ totalTimes ^ timesCounter;
   \   0000000E   0x4048             EORS     R0,R1,R0
   \   00000010   0x4050             EORS     R0,R2,R0
   \   00000012   0xF080 0x00BE      EOR      R0,R0,#0xBE
   \   00000016   0xF88D 0x0005      STRB     R0,[SP, #+5]
   \   0000001A   0x23BE             MOVS     R3,#+190
    676          	UartSendMcTimerCalibrateData.TimeOut = NormalTimeOut;
   \   0000001C   0x20FF             MOVS     R0,#+255
   \   0000001E   0xF88D 0x3001      STRB     R3,[SP, #+1]
   \   00000022   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \   00000026   0xF88D 0x2004      STRB     R2,[SP, #+4]
   \   0000002A   0xF88D 0x0006      STRB     R0,[SP, #+6]
    677          
    678          	MEMCOPY(&UartTxCommandBuff [GetLastTxUartCmd()], &UartSendMcTimerCalibrateData,
    679          			sizeof(UartSendMcTimerCalibrateDataBuffer));
   \   0000002E   0x.... 0x....      BL       GetLastTxUartCmd
   \   00000032   0x2207             MOVS     R2,#+7
   \   00000034   0x....             B.N      ??Subroutine13_0
    680          //	McReadyStatus = McChecking;
    681          }
    682          
    683          
    684          
    685          
    686          //---------------------------------Check Uart Status And Send Quere Data Buffer-------------------------------//
    687          typedef enum {
    688          	CmdReady,
    689          	CmdBusy,
    690          }uartSendCommandStatus;
    691          

   \                                 In section .text, align 2, keep-with-next
    692          int8u CheckWaitTimeOut(void){
   \                     CheckWaitTimeOut: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    693          
    694          	if(UartTxCommandStartWaitTimer !=0 ){
   \   00000002   0x....             LDR.N    R4,??DataTable11_2
   \   00000004   0x8820             LDRH     R0,[R4, #+0]
   \   00000006   0xB140             CBZ.N    R0,??CheckWaitTimeOut_0
    695          		if(CommonGetDurationTime(UartTxCommandStartWaitTimer) >= UartTxCommandCurrentTimeOut){
   \   00000008   0x.... 0x....      BL       CommonGetDurationTime
   \   0000000C   0x8861             LDRH     R1,[R4, #+2]
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD302             BCC.N    ??CheckWaitTimeOut_1
    696          			//clear timer
    697          			UartTxCommandStartWaitTimer = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    698          			return CmdReady;
   \   00000016   0xBD10             POP      {R4,PC}
    699          		}
    700          		else{
    701          			return CmdBusy;
   \                     ??CheckWaitTimeOut_1: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
    702          		}
    703          	}
    704          	else{
    705          		return CmdReady;
   \                     ??CheckWaitTimeOut_0: (+1)
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    706          	}
    707          }

   \                                 In section .text, align 2, keep-with-next
    708          void UartSendCommand(void){
   \                     UartSendCommand: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    709          	//	Check buff
    710          	if(UartTxCommandBuff[0] != 0){
   \   00000002   0x....             LDR.N    R4,??DataTable11_1
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xB328             CBZ.N    R0,??UartSendCommand_0
    711          		//	Check Timeout
    712          
    713          
    714          		switch (CheckWaitTimeOut()){
   \   00000008   0x.... 0x....      BL       CheckWaitTimeOut
   \   0000000C   0xBB10             CBNZ.N   R0,??UartSendCommand_0
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x1900             ADDS     R0,R0,R4
   \   00000012   0x7840             LDRB     R0,[R0, #+1]
   \   00000014   0x28FF             CMP      R0,#+255
   \   00000016   0xBF0E             ITEE     EQ 
    715          			case CmdBusy:
    716          			break;
    717          			case CmdReady:
    718          				//	Send buff
    719          				if(UartTxCommandBuff[UartTxCommandBuff[0]+1] == NormalTimeOut){
    720          					UartTxCommandCurrentTimeOut = NORMAL_TIMEOUT;
   \   00000018   0x201E             MOVEQ    R0,#+30
    721          				}
    722          				else{
    723          					UartTxCommandCurrentTimeOut = UartTxCommandBuff[UartTxCommandBuff[0]+1] * MinimumTimeOut;
   \   0000001A   0xF44F 0x717A      MOVNE    R1,#+1000
   \   0000001E   0x4348             MULNE    R0,R1,R0
   \   00000020   0x....             LDR.N    R5,??DataTable11_2
    724          				}
    725          				emberSerialWriteData(1,UART_PACKET_KEY,2);
   \   00000022   0x....             LDR.N    R1,??DataTable11_3
   \   00000024   0x8068             STRH     R0,[R5, #+2]
   \   00000026   0x2202             MOVS     R2,#+2
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       emberSerialWriteData
    726          				emberSerialWriteData(1,UartTxCommandBuff, (UartTxCommandBuff[0]+1));
   \   0000002E   0x7820             LDRB     R0,[R4, #+0]
   \   00000030   0x1C42             ADDS     R2,R0,#+1
   \   00000032   0xB2D2             UXTB     R2,R2
   \   00000034   0x4621             MOV      R1,R4
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       emberSerialWriteData
    727          				MEMCOPY(UartTxCommandBuff, &UartTxCommandBuff[UartTxCommandBuff[0]+2],
    728          						(MAX_RX_BUFFER - (UartTxCommandBuff[0]+2)));
   \   0000003C   0x7820             LDRB     R0,[R4, #+0]
   \   0000003E   0xF1C0 0x02FE      RSB      R2,R0,#+254
   \   00000042   0x1900             ADDS     R0,R0,R4
   \   00000044   0x1C81             ADDS     R1,R0,#+2
   \   00000046   0xB292             UXTH     R2,R2
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       halCommonMemMove
    729          				UartTxCommandStartWaitTimer = (int16u)halCommonGetInt32uMillisecondTick();
   \   0000004E   0x.... 0x....      BL       halCommonGetInt32uMillisecondTick
   \   00000052   0x8028             STRH     R0,[R5, #+0]
    730          			break;
    731          			default:
    732          			break;
    733          		}
    734          	}
    735          }
   \                     ??UartSendCommand_0: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     UartRxDataStep

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     UartTxCommandBuff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     UartTxCommandStartWaitTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     UART_PACKET_KEY

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1`:
   \   00000000   0x00 0x11          DC8 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238
   \              0x22 0x33    
   \              0x44 0x55    
   \              0x66 0x77    
   \              0x88 0x99    
   \              0xAA 0xBB    
   \              0xCC 0xDD    
   \              0xEE         
   \   0000000F   0xFF               DC8 255

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_1`:
   \   00000000   0x00 0x11          DC8 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238
   \              0x22 0x33    
   \              0x44 0x55    
   \              0x66 0x77    
   \              0x88 0x99    
   \              0xAA 0xBB    
   \              0xCC 0xDD    
   \              0xEE         
   \   0000000F   0xFF               DC8 255

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_2`:
   \   00000000   0x00 0x11          DC8 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238
   \              0x22 0x33    
   \              0x44 0x55    
   \              0x66 0x77    
   \              0x88 0x99    
   \              0xAA 0xBB    
   \              0xCC 0xDD    
   \              0xEE         
   \   0000000F   0xFF               DC8 255

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_3`:
   \   00000000   0x00 0x11          DC8 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238
   \              0x22 0x33    
   \              0x44 0x55    
   \              0x66 0x77    
   \              0x88 0x99    
   \              0xAA 0xBB    
   \              0xCC 0xDD    
   \              0xEE         
   \   0000000F   0xFF               DC8 255

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    736          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   CallTaskCheckMcReady
        24   -> CallJoinTask
        24   -> GetHcActiveEndPoint
        24   -> UartSendBlinkLed
        24   -> __aeabi_memcpy4
        24   -> emberAfNetworkState
        24   -> halCommonGetRandom
        24   -> halCommonMemCompare
      16   CallTaskDimmerLevelChangeCommand
        16   -> SendLevelControlReadAttribute
        16   -> SendOnOffControlReadAttribute
        16   -> SendViaBindingTable
        16   -> emberAfReadServerAttribute
        16   -> emberAfWriteServerAttribute
      24   CallTaskMcClockCalibrate
        24   -> UartSendMcClockCalibrate
        24   -> __aeabi_memcpy4
        24   -> halCommonMemCompare
       0   CallTaskMcTimmerCalibrate
         0   -> CallMcTimmerCalibrateTask
      32   CallTaskRelayChangeCommand
        32   -> CommonClearLed
        32   -> CommonSetLed
        32   -> SendOnOffControlReadAttribute
        32   -> SendViaBindingTable
        32   -> beButtonPress
        32   -> emberAfNetworkState
        32   -> emberAfReadServerAttribute
        32   -> emberAfWriteServerAttribute
       0   CallTaskTouchButtonHold
         0   -> beButtonPress2Time
         0   -> beButtonPress3Time
         0   -> beButtonRealease
       0   CallUartTask
         0   -> CallTaskCheckMcReady
         0   -> CallTaskDimmerLevelChangeCommand
         0   -> CallTaskMcClockCalibrate
         0   -> CallTaskMcTimmerCalibrate
         0   -> CallTaskRelayChangeCommand
         0   -> CallTaskTouchButtonHold
       8   CheckWaitTimeOut
         8   -> CommonGetDurationTime
       0   GetLastTxUartCmd
      16   UartScanCommand
        16   -> CallUartTask
        16   -> emberSerialReadAvailable
        16   -> emberSerialReadByte
      24   UartSendBlinkLed
        24   -> GetLastTxUartCmd
        24   -> halCommonMemMove
      40   UartSendCheckMcReady
        40   -> GetLastTxUartCmd
        40   -> __aeabi_memcpy4
        40   -> halCommonMemMove
      16   UartSendCommand
        16   -> CheckWaitTimeOut
        16   -> emberSerialWriteData
        16   -> halCommonGetInt32uMillisecondTick
        16   -> halCommonMemMove
      16   UartSendDimLevel
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      40   UartSendMcClockCalibrate
        40   -> GetLastTxUartCmd
        40   -> __aeabi_memcpy4
        40   -> halCommonMemMove
      16   UartSendMcTimerCalibrate
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      16   UartSendOffLed
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      16   UartSendPinkLed
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
       0   UartSendRefreshAllLed
         0   -> UartSendSpecialLedMark
       0   UartSendRefreshLedNumber
         0   -> UartSendSpecialLedNumber
      16   UartSendSpecialLedMark
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      16   UartSendSpecialLedNumber
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      24   UartSendStoreAttribute
        24   -> GetLastTxUartCmd
        24   -> halCommonMemMove
      16   UartSendSwitchControlMark
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      16   UartSendSwitchControlNumber
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
      16   UartSendSwitchControlStateMark
        16   -> GetLastTxUartCmd
        16   -> halCommonMemMove
       0   UartSendToggleLed
         0   -> UartSendBlinkLed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1
      16  ?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_1
      16  ?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_2
      16  ?<Constant {0, 17, 34, 51, 68, 85, 102, 119, 1_3
       4  ?<Constant {0}>
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
      12  ??Subroutine13_0
      12  ??Subroutine14_0
      16  ?Subroutine0
      42  ?Subroutine1
      12  ?Subroutine10
      14  ?Subroutine11
      12  ?Subroutine12
      24  ?Subroutine2
      34  ?Subroutine3
      10  ?Subroutine4
      10  ?Subroutine5
       6  ?Subroutine6
      14  ?Subroutine7
      10  ?Subroutine8
      12  ?Subroutine9
      72  CallTaskCheckMcReady
     120  CallTaskDimmerLevelChangeCommand
      26  CallTaskMcClockCalibrate
       8  CallTaskMcTimmerCalibrate
     152  CallTaskRelayChangeCommand
      38  CallTaskTouchButtonHold
      40  CallUartTask
      28  CheckWaitTimeOut
      22  GetLastTxUartCmd
       2  UART_PACKET_KEY
      68  UartRxDataStep
          UartRxPacketLength
          UartRxCurrentLength
          UartRxCommandData
       1  UartRxPacketCheckXor
     146  UartScanCommand
     106  UartSendBlinkLed
      30  UartSendCheckMcReady
      86  UartSendCommand
      20  UartSendDimLevel
      32  UartSendMcClockCalibrate
      54  UartSendMcTimerCalibrate
      30  UartSendOffLed
      28  UartSendPinkLed
       6  UartSendRefreshAllLed
       4  UartSendRefreshLedNumber
       8  UartSendSpecialLedMark
      46  UartSendSpecialLedNumber
      84  UartSendStoreAttribute
      40  UartSendSwitchControlMark
      34  UartSendSwitchControlNumber
      14  UartSendSwitchControlStateMark
       4  UartSendToggleLed
     256  UartTxCommandBuff
       4  UartTxCommandStartWaitTimer
          UartTxCommandCurrentTimeOut

 
   329 bytes in section .bss
     2 bytes in section .data
     4 bytes in section .rodata
 1 598 bytes in section .text
 
 1 598 bytes of CODE  memory
     4 bytes of CONST memory
   331 bytes of DATA  memory

Errors: none
Warnings: 7

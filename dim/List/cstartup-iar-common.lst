###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        22/Oct/2015  09:33:09
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\hal\micro\cortexm3\cstartup-iar-common.c
#    Command line =  
#        E:\Zigbee\EmberZNet5.6.0-GA\hal\micro\cortexm3\cstartup-iar-common.c
#        -D DIMMER -D NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D
#        CORTEXM3_EM357 -D PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"cstartup-iar-common.c\"" -lC
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\List\
#        --diag_suppress Pa050 -o
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\Obj\ --debug
#        --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\Zigbee\EmberZNet5.6.0-GA\hal\micro\cortexm3\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\List\cstartup-iar-common.lst
#    Object file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\Obj\cstartup-iar-common.o
#
###############################################################################

E:\Zigbee\EmberZNet5.6.0-GA\hal\micro\cortexm3\cstartup-iar-common.c
      1          //=============================================================================
      2          // FILE
      3          //   cstartup.c - Startup and low-level utility code for Ember's Cortex based
      4          //                SOCs when using the IAR toolchain.
      5          //
      6          // DESCRIPTION
      7          //   This file defines the basic information needed to go from reset up to
      8          //   the main() found in C code.
      9          //
     10          //   Copyright 2013 Silicon Laboratories, Inc.                             *80*
     11          //=============================================================================
     12          
     13          #include PLATFORM_HEADER
     14          #include "hal/micro/cortexm3/diagnostic.h"
     15          #include "hal/micro/cortexm3/mpu.h"
     16          #include "hal/micro/micro.h"
     17          #include "hal/micro/cortexm3/memmap.h"
     18          #include "hal/micro/cortexm3/cstartup-iar-common.h"
     19          #include "hal/micro/cortexm3/internal-storage.h"
     20          
     21          #include "stack/include/ember-types.h"
     22          #include "hal/micro/bootloader-interface.h"
     23          
     24          // Pull in the SOFTWARE_VERSION and EMBER_BUILD_NUMBER from the stack
     25          #include "stack/config/config.h"
     26          
     27          // Define the CUSTOMER_APPLICATION_VERSION if it wasn't set
     28          #ifndef CUSTOMER_APPLICATION_VERSION
     29            #define CUSTOMER_APPLICATION_VERSION 0
     30          #endif
     31          // Define the CUSTOMER_BOOTLOADER_VERSION if it wasn't set
     32          #ifndef CUSTOMER_BOOTLOADER_VERSION
     33            #define CUSTOMER_BOOTLOADER_VERSION 0
     34          #endif
     35          
     36          // Verify the various bootloader options that may be specified.  Use of some
     37          //   options is now deprecated and will be removed in a future release.
     38          // On the 35x platform, the use of these options is only important to specify
     39          //   the size of the bootloader, rather than the bootloader type.
     40          // By default, the lack of any option will indicate an 8k bootloader size
     41          // The NULL_BTL option indicates no bootloader is used.
     42          #ifdef APP_BTL
     43            #pragma message("The APP_BTL build option is deprecated.  Removing this option will build for any 8k bootloader type.")
     44          #endif
     45          #ifdef SERIAL_UART_BTL
     46            #pragma message("The SERIAL_UART_BTL build option is deprecated.  Removing this option will build for any 8k bootloader type.")
     47          #endif
     48          #ifdef SERIAL_OTA_BTL
     49            #pragma message("The SERIAL_UART_OTA build option is deprecated.  Removing this option will build for any 8k bootloader type.")
     50          #endif
     51          #ifdef NULL_BTL
     52            // Fully supported, no error
     53          #endif
     54          #ifdef SMALL_BTL
     55            #error SMALL_BTL is not supported
     56          #endif
     57          
     58          
     59          //=============================================================================
     60          // Define the size of the call stack and define a block of memory for it.
     61          //
     62          // Place the cstack area in a segment named CSTACK.  This segment is
     63          // defined soley for the purpose of placing the stack.  Refer to reset handler
     64          // for the initialization code and iar-cfg-common.icf for segment placement
     65          // in memory.
     66          //
     67          // halResetInfo, used to store crash information and bootloader parameters, is
     68          // overlayed on top of the base of this segment so it can be overwritten by the
     69          // call stack.
     70          // This assumes that the stack will not go that deep between reset and
     71          // use of the crash or the bootloader data.
     72          //=============================================================================
     73          #ifndef CSTACK_SIZE
     74            #ifdef RTOS
     75              // The RTOS will handle the actual CSTACK sizing per-task, but we must
     76              // still allocate some space for startup and exceptions.
     77              #define CSTACK_SIZE (128)  // *4 = 512 bytes
     78            #else
     79              #if (! defined(EMBER_STACK_IP))
     80                // Pro Stack
     81          
     82              // Right now we define the stack size to be for the worst case scenario,
     83              // ECC.  The ECC 163k1 library  and the ECC 283k1 Library both use the stack 
     84              // for calculations. Empirically I have seen it use as much as 1900 bytes 
     85              // for the 'key bit generate' operation.
     86              // So we add a 25% buffer: 1900 * 1.25 = 2375
     87              #define CSTACK_SIZE  (600)  // *4 = 2400 bytes
     88          
     89              #else
     90                // IP Stack
     91                #define CSTACK_SIZE (950) // *4 = 3800 bytes
     92              #endif // !EMBER_STACK_IP
     93            #endif
     94          #endif

   \                                 In section CSTACK, align 4, root
     95          VAR_AT_SEGMENT(NO_STRIPPING int32u cstackMemory[CSTACK_SIZE], __CSTACK__);
   \                     cstackMemory:
   \   00000000                      DS8 2400
     96          
     97          #ifndef HTOL_EM3XX
     98            // Create an array to hold space for the guard region. Do not actually use this
     99            // array in code as we will move the guard region around programatically. This
    100            // is only here so that the linker takes into account the size of the guard
    101            // region when configuring the RAM.
    102            ALIGNMENT(HEAP_GUARD_REGION_SIZE_BYTES)  

   \                                 In section GUARD_REGION, align 32, root
    103            VAR_AT_SEGMENT(NO_STRIPPING int8u guardRegionPlaceHolder[HEAP_GUARD_REGION_SIZE_BYTES], __GUARD_REGION__);
   \                     guardRegionPlaceHolder:
   \   00000000                      DS8 32
    104          #endif
    105          
    106          // Reset cause and crash info live in a special RAM segment that is
    107          // not modified during startup.  This segment is overlayed on top of the
    108          // bottom of the cstack.

   \                                 In section RESETINFO, align 4, root
    109          VAR_AT_SEGMENT(NO_STRIPPING HalResetInfoType halResetInfo, __RESETINFO__);
   \                     halResetInfo:
   \   00000000                      DS8 152
    110          
    111          // If space is needed in the flash for data storage like for the local storage
    112          // bootloader then create an array here to hold a place for this data.
    113          #if INTERNAL_STORAGE_SIZE_B > 0
    114            // Define the storage region as an uninitialized array in the
    115            // __INTERNAL_STORAGE__ region which the linker knows how to place.  
    116            VAR_AT_SEGMENT(NO_STRIPPING int8u internalStorage[INTERNAL_STORAGE_SIZE_B], __INTERNAL_STORAGE__);
    117          #endif
    118          
    119          //=============================================================================
    120          // Declare the address tables which will always live at well known addresses
    121          //=============================================================================

   \                                 In section FAT, align 4, root
    122          VAR_AT_SEGMENT(NO_STRIPPING __no_init const HalFixedAddressTableType halFixedAddressTable, __FAT__);
   \                     halFixedAddressTable:
   \   00000000                      DS8 44
    123          
    124          #ifdef NULL_BTL
    125          // In the case of a NULL_BTL application, we define a dummy BAT

   \                                 In section BAT, align 4, root
    126          VAR_AT_SEGMENT(NO_STRIPPING const HalBootloaderAddressTableType halBootloaderAddressTable, __BAT__) = {
   \                     halBootloaderAddressTable:
   \   00000000   0x........         DC32 SFE(CSTACK), halEntryPoint, halNmiIsr, halHardFaultIsr
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x0BA7 0x0000      DC16 2983, 0
   \   00000014   0x00000000         DC32 0H
   \   00000018   0x0000 0xFFFF      DC16 0, 65535
   \   0000001C   0x........         DC32 halAppAddressTable
   \   00000020   0x04 0x03          DC8 4, 3, 3, 0
   \              0x03 0x00    
   \   00000024   0x00000000         DC32 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \   0000004C   0x00E7 0x0000      DC16 231, 0
   \   00000050   0x00000000         DC32 0
    127            { __section_end("CSTACK"),
    128              halEntryPoint,
    129              halNmiIsr,
    130              halHardFaultIsr,
    131              BOOTLOADER_ADDRESS_TABLE_TYPE,
    132              BAT_NULL_VERSION,
    133              NULL                    // No other vector table.
    134            },
    135            BL_EXT_TYPE_NULL,           //int16u bootloaderType;
    136            BOOTLOADER_INVALID_VERSION, //int16u bootloaderVersion;
    137            &halAppAddressTable,
    138            PLAT,   //int8u platInfo;   // type of platform, defined in micro.h
    139            MICRO,  //int8u microInfo;  // type of micro, defined in micro.h
    140            PHY,    //int8u phyInfo;    // type of phy, defined in micro.h
    141            0,      //int8u reserved;   // reserved for future use
    142            NULL,   // eblProcessInit
    143            NULL,   // eblProcess
    144            NULL,   // eblDataFuncs
    145            NULL,   // eepromInit
    146            NULL,   // eepromRead
    147            NULL,   // eepromWrite
    148            NULL,   // eepromShutdown
    149            NULL,   // eepromInfo
    150            NULL,   // eepromErase
    151            NULL,   // eepromBusy
    152            EMBER_BUILD_NUMBER, // int16u softwareBuild;
    153            0,                  // int16u reserved2;
    154            CUSTOMER_BOOTLOADER_VERSION  // int32u customerBootloaderVersion;
    155          };
    156          #else
    157          // otherwise we just define a variable that maps to the real bootloader BAT
    158          VAR_AT_SEGMENT(NO_STRIPPING __no_init const HalBootloaderAddressTableType halBootloaderAddressTable, __BAT__);
    159          #endif
    160          

   \                                 In section AAT, align 4, root
    161          VAR_AT_SEGMENT(NO_STRIPPING const HalAppAddressTableType halAppAddressTable, __AAT__) = {
   \                     halAppAddressTable:
   \   00000000   0x........         DC32 SFE(CSTACK), halEntryPoint, halNmiIsr, halHardFaultIsr
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x0AA7 0x0108      DC16 2727, 264
   \   00000014   0x........         DC32 __vector_table
   \   00000018   0x04 0x03          DC8 4, 3, 3, 172
   \              0x03 0xAC    
   \   0000001C   0x5600 0x00E7      DC16 22016, 231
   \   00000020   0x00000000         DC32 0
   \   00000024   0x00               DC8 ""
   \   00000025   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000035   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000044   0x00000000         DC32 0
   \   00000048   0xFF 0xFF          DC8 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \   00000054   0x........         DC32 SFB(SIMEE), 0, SFB(INTERNAL_STORAGE)
   \              0x00000000   
   \              0x........   
   \   00000060   0xFF 0xFF          DC8 255, 255, 255, 255, 255, 255, 255, 255
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \   00000068   0xFFFFFFFF         DC32 4294967295, 4294967295, 4294967295, 4294967295, 4294967295
   \              0xFFFFFFFF   
   \              0xFFFFFFFF   
   \              0xFFFFFFFF   
   \              0xFFFFFFFF   
   \   0000007C   0xFFFFFFFF         DC32 4294967295, SFB(DEBUG_CHANNEL), SFB(`.noinit`), SFE(`.bss`)
   \              0x........   
   \              0x........   
   \              0x........   
   \   0000008C   0x........         DC32 SFE(`.bss`), SFE(CSTACK), SFE(`.data_init`), SFE(`.text`)
   \              0x........   
   \              0x........   
   \              0x........   
   \   0000009C   0x........         DC32 SFB(CSTACK), SFE(EMHEAP_overlay), SFE(SIMEE), SFE(DEBUG_CHANNEL)
   \              0x........   
   \              0x........   
   \              0x........   
    162            { __section_end("CSTACK"),
    163              halEntryPoint,
    164              halNmiIsr,
    165              halHardFaultIsr,
    166              APP_ADDRESS_TABLE_TYPE,
    167              AAT_VERSION,
    168              __vector_table
    169            },
    170            PLAT,  //int8u platInfo;   // type of platform, defined in micro.h
    171            MICRO, //int8u microInfo;  // type of micro, defined in micro.h
    172            PHY,   //int8u phyInfo;    // type of phy, defined in micro.h
    173            sizeof(HalAppAddressTableType),  // size of aat itself
    174            SOFTWARE_VERSION,   // int16u softwareVersion
    175            EMBER_BUILD_NUMBER, // int16u softwareBuild
    176            0,  //int32u timestamp; // Unix epoch time of .ebl file, filled in by ebl gen
    177            "", //int8u imageInfo[IMAGE_INFO_SZ];  // string, filled in by ebl generation
    178            0,  //int32u imageCrc;  // CRC over following pageRanges, filled in by ebl gen
    179            { {0xFF, 0xFF},   //pageRange_t pageRanges[6];  // Flash pages used by app,
    180              {0xFF, 0xFF},                                 // filled in by ebl gen
    181              {0xFF, 0xFF},
    182              {0xFF, 0xFF},
    183              {0xFF, 0xFF},
    184              {0xFF, 0xFF}
    185            },
    186            __section_begin(__SIMEE__),                         //void *simeeBottom;
    187            CUSTOMER_APPLICATION_VERSION,                       //int32u customerApplicationVersion;
    188            __section_begin(__INTERNAL_STORAGE__),              //void *internalStorageBottom;
    189            { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0XFF }, // image stamp (filled in by em3xx_convert)
    190            {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,    // bootloaderReserved
    191             0xFFFFFFFF, 0xFFFFFFFF },
    192            __section_begin(__DEBUG_CHANNEL__),   //void *debugChannelBottom;
    193            __section_begin(__NO_INIT__),         //void *noInitBottom;
    194            __section_end(__BSS__),               //void *appRamTop; NO LONGER USED! (set to __BSS__ for 3xx convert)
    195            __section_end(__BSS__),               //void *globalTop;
    196            __section_end(__CSTACK__),            //void *cstackTop;
    197            __section_end(__DATA_INIT__),         //void *initcTop;
    198            __section_end(__TEXT__),              //void *codeTop;
    199            __section_begin(__CSTACK__),          //void *cstackBottom;
    200            __section_end(__EMHEAP_OVERLAY__),    //void *heapTop;
    201            __section_end(__SIMEE__),             //void *simeeTop;
    202            __section_end(__DEBUG_CHANNEL__)      //void *debugChannelTop;
    203          };
    204          
    205          
    206          
    207          //=============================================================================
    208          // Define the vector table as a HalVectorTableType.  NO_STRIPPING ensures the
    209          // compiler will not strip the table.  const ensures the table is placed into 
    210          // flash. The VAR_AT_SEGMENT() macro tells the compiler/linker to place the
    211          // vector table in the INTVEC segment which holds the reset/interrupt vectors
    212          // at address 0x00000000.
    213          //
    214          // All Handlers point to a corresponding ISR.  The ISRs are prototyped above.
    215          // The file isr-stubs.s79 provides a weak definition for all ISRs.  To
    216          // "register" its own ISR, an application simply has to define the function
    217          // and the weak stub will be overridden.
    218          //
    219          // The list of handlers are extracted from the NVIC configuration file.  The
    220          // order of the handlers in the NVIC configuration file is critical since it
    221          // translates to the order they are placed into the vector table here.
    222          //=============================================================================

   \                                 In section .intvec, align 4, root
    223          VAR_AT_SEGMENT(NO_STRIPPING const HalVectorTableType __vector_table[], __INTVEC__) =
   \                     __vector_table:
   \   00000000   0x........         DC32 SFE(CSTACK), halEntryPoint, halNmiIsr, halHardFaultIsr
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x........         DC32 halMemoryFaultIsr, halBusFaultIsr, halUsageFaultIsr
   \              0x........   
   \              0x........   
   \   0000001C   0x........         DC32 halReserved07Isr, halReserved08Isr, halReserved09Isr
   \              0x........   
   \              0x........   
   \   00000028   0x........         DC32 halReserved10Isr, halSvCallIsr, halDebugMonitorIsr
   \              0x........   
   \              0x........   
   \   00000034   0x........         DC32 halReserved13Isr, halPendSvIsr, halInternalSysTickIsr
   \              0x........   
   \              0x........   
   \   00000040   0x........         DC32 halTimer1Isr, halTimer2Isr, halManagementIsr, halBaseBandIsr
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000050   0x........         DC32 halSleepTimerIsr, halSc1Isr, halSc2Isr, halSecurityIsr
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000060   0x........         DC32 halStackMacTimerIsr, emRadioTransmitIsr, emRadioReceiveIsr
   \              0x........   
   \              0x........   
   \   0000006C   0x........         DC32 halAdcIsr, halIrqAIsr, halIrqBIsr, halIrqCIsr, halIrqDIsr
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000080   0x........         DC32 halDebugIsr, halSc3Isr, halSc4Isr, halUsbIsr
   \              0x........   
   \              0x........   
   \              0x........   
    224          {
    225            { .topOfStack = __section_end(__CSTACK__) },
    226            #ifndef INTERRUPT_DEBUGGING
    227              #define EXCEPTION(vectorNumber, functionName, priorityLevel, subpriority) \
    228                functionName,
    229            #else //INTERRUPT_DEBUGGING
    230              // The interrupt debug behavior inserts a special shim handler before
    231              // the actual interrupt.  The shim handler then redirects to the
    232              // actual table, defined below
    233              #define EXCEPTION(vectorNumber, functionName, priorityLevel, subpriority) \
    234                halInternalIntDebuggingIsr,
    235              // PERM_EXCEPTION is used for any vectors that cannot be redirected
    236              // throught the shim handler.  (such as the reset vector)
    237              #define PERM_EXCEPTION(vectorNumber, functionName, priorityLevel) \
    238                functionName,
    239            #endif //INTERRUPT_DEBUGGING
    240            #include NVIC_CONFIG
    241            #undef  EXCEPTION
    242            #undef PERM_EXCEPTION
    243          };
    244          
    245          // halInternalClassifyReset() records the cause of the last reset and any 
    246          // assert information here. If the last reset was not due to an assert,
    247          // the saved assert filename and line number will be NULL and 0 respectively.

   \                                 In section .bss, align 4
    248          static int16u savedResetCause;
    249          static HalAssertInfoType savedAssertInfo;
   \                     savedAssertInfo:
   \   00000000                      DS8 8
   \   00000008                      DS8 2
    250          

   \                                 In section .text, align 2, keep-with-next
    251          void halInternalClassifyReset(void)
    252          {
   \                     halInternalClassifyReset: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    253            // Table used to convert from RESET_EVENT register bits to reset types
    254            static const int16u resetEventTable[] = {
    255              RESET_POWERON_HV,            // bit 0: RESET_PWRHV_BIT
    256              RESET_POWERON_LV,            // bit 1: RESET_PWRLV_BIT
    257              RESET_EXTERNAL_PIN,          // bit 2: RESET_NRESET_BIT
    258              RESET_WATCHDOG_EXPIRED,      // bit 3: RESET_WDOG_BIT
    259              RESET_SOFTWARE,              // bit 4: RESET_SW_BIT
    260              RESET_BOOTLOADER_DEEPSLEEP,  // bit 5: RESET_DSLEEP_BIT
    261              RESET_FATAL_OPTIONBYTE,      // bit 6: RESET_OPTBYTEFAIL_BIT
    262              RESET_FATAL_LOCKUP,          // bit 7: RESET_CPULOCKUP_BIT
    263            };
    264          
    265            // It is possible for RSTB and POWER_HV to be set at the same time, which
    266            // happens when RSTB releases between HV power good and LV power good. (All
    267            // other reset events are mutually exclusive.) When both RSTB and POWER_HV
    268            // are set, POWER_HV should be returned as the cause. The bit test order --
    269            // from LSB to MSB -- ensures that it will.
    270            int16u resetEvent = RESET_EVENT &
    271                                  ( RESET_CPULOCKUP_MASK   |
    272                                    RESET_OPTBYTEFAIL_MASK |
    273                                    RESET_DSLEEP_MASK      |
    274                                    RESET_SW_MASK          |
    275                                    RESET_WDOG_MASK        |
    276                                    RESET_NRESET_MASK      |
    277                                    RESET_PWRLV_MASK       |
    278                                    RESET_PWRHV_MASK );
   \   00000002   0x....             LDR.N    R0,??DataTable4  ;; 0x4000002c
   \   00000004   0x6801             LDR      R1,[R0, #+0]
    279          
    280            int16u cause = RESET_UNKNOWN;
   \   00000006   0x2000             MOVS     R0,#+0
    281            int16u i;
    282          
    283            for (i = 0; i < sizeof(resetEventTable)/sizeof(resetEventTable[0]); i++) {
   \   00000008   0x2200             MOVS     R2,#+0
    284              if (resetEvent & (1 << i)) {
   \                     ??halInternalClassifyReset_0: (+1)
   \   0000000A   0x2401             MOVS     R4,#+1
   \   0000000C   0x4094             LSLS     R4,R4,R2
   \   0000000E   0xB2CB             UXTB     R3,R1
   \   00000010   0x4223             TST      R3,R4
   \   00000012   0xD013             BEQ.N    ??halInternalClassifyReset_1
    285                cause = resetEventTable[i];
   \   00000014   0x.... 0x....      ADR.W    R0,??resetEventTable
    286                break;
    287              }
    288            }
    289          
    290            if (cause == RESET_SOFTWARE) {
   \   00000018   0x....             LDR.N    R4,??DataTable4_1
   \   0000001A   0xF830 0x0012      LDRH     R0,[R0, R2, LSL #+1]
   \   0000001E   0xF24C 0x323C      MOVW     R2,#+49980
   \   00000022   0xF24F 0x030F      MOVW     R3,#+61455
   \   00000026   0x2806             CMP      R0,#+6
   \   00000028   0xD11D             BNE.N    ??halInternalClassifyReset_2
    291              if((halResetInfo.crash.resetSignature == RESET_VALID_SIGNATURE) &&
    292                 (RESET_BASE_TYPE(halResetInfo.crash.resetReason) < NUM_RESET_BASE_TYPES)) {
   \   0000002A   0x8860             LDRH     R0,[R4, #+2]
   \   0000002C   0x4298             CMP      R0,R3
   \   0000002E   0xD116             BNE.N    ??halInternalClassifyReset_3
   \   00000030   0x8821             LDRH     R1,[R4, #+0]
   \   00000032   0x0A08             LSRS     R0,R1,#+8
   \   00000034   0x280B             CMP      R0,#+11
   \   00000036   0xDA12             BGE.N    ??halInternalClassifyReset_3
    293                // The extended reset cause is recovered from RAM
    294                // This can be trusted because the hardware reset event was software
    295                //  and additionally because the signature is valid
    296                savedResetCause = halResetInfo.crash.resetReason;
   \   00000038   0x4608             MOV      R0,R1
   \   0000003A   0xE012             B.N      ??halInternalClassifyReset_4
    297              } else {
   \                     ??halInternalClassifyReset_1: (+1)
   \   0000003C   0x1C52             ADDS     R2,R2,#+1
   \   0000003E   0xB292             UXTH     R2,R2
   \   00000040   0x2A08             CMP      R2,#+8
   \   00000042   0xD3E2             BCC.N    ??halInternalClassifyReset_0
    298                savedResetCause = RESET_SOFTWARE_UNKNOWN;
    299              }
    300              // mark the signature as invalid
    301              halResetInfo.crash.resetSignature = RESET_INVALID_SIGNATURE;
    302            } else if (    (cause == RESET_BOOTLOADER_DEEPSLEEP)
    303                        && (halResetInfo.crash.resetSignature == RESET_VALID_SIGNATURE)
    304                        && (halResetInfo.crash.resetReason == RESET_BOOTLOADER_DEEPSLEEP)) {
    305              // Save the crash info for bootloader deep sleep (even though it's not used
    306              // yet) and invalidate the resetSignature.
    307              halResetInfo.crash.resetSignature = RESET_INVALID_SIGNATURE;
    308              savedResetCause = halResetInfo.crash.resetReason;
    309            } else {
    310              savedResetCause = cause;
   \                     ??halInternalClassifyReset_5: (+1)
   \   00000044   0x....             LDR.N    R1,??DataTable4_2
   \   00000046   0x8108             STRH     R0,[R1, #+8]
    311            }
    312            // If the last reset was due to an assert, save the assert info.
    313            if (savedResetCause == RESET_CRASH_ASSERT) {
   \   00000048   0xF240 0x7201      MOVW     R2,#+1793
   \   0000004C   0x8908             LDRH     R0,[R1, #+8]
   \   0000004E   0x4290             CMP      R0,R2
   \   00000050   0xD104             BNE.N    ??halInternalClassifyReset_6
    314              savedAssertInfo = halResetInfo.crash.data.assertInfo;
   \   00000052   0x....             LDR.N    R0,??DataTable4_3
   \   00000054   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   00000058   0xE9C1 0x2300      STRD     R2,R3,[R1, #+0]
    315            }
    316          }
   \                     ??halInternalClassifyReset_6: (+1)
   \   0000005C   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??halInternalClassifyReset_3: (+1)
   \   0000005E   0xF44F 0x60C0      MOV      R0,#+1536
   \                     ??halInternalClassifyReset_4: (+1)
   \   00000062   0x8062             STRH     R2,[R4, #+2]
   \   00000064   0xE7EE             B.N      ??halInternalClassifyReset_5
   \                     ??halInternalClassifyReset_2: (+1)
   \   00000066   0xF240 0x2507      MOVW     R5,#+519
   \   0000006A   0x42A8             CMP      R0,R5
   \   0000006C   0xBF01             ITTTT    EQ 
   \   0000006E   0x8861             LDRHEQ   R1,[R4, #+2]
   \   00000070   0x4299             CMPEQ    R1,R3
   \   00000072   0x8821             LDRHEQ   R1,[R4, #+0]
   \   00000074   0x42A9             CMPEQ    R1,R5
   \   00000076   0xD1E5             BNE.N    ??halInternalClassifyReset_5
   \   00000078   0x8062             STRH     R2,[R4, #+2]
   \   0000007A   0x4608             MOV      R0,R1
   \   0000007C   0xE7E2             B.N      ??halInternalClassifyReset_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??resetEventTable:
   \   00000000   0x0401 0x0402      DC16 1025, 1026, 769, 1281, 6, 519, 2307, 2305
   \              0x0301 0x0501
   \              0x0006 0x0207
   \              0x0903 0x0901
    317          

   \                                 In section .text, align 2, keep-with-next
    318          int8u halGetResetInfo(void)
    319          {
    320            return RESET_BASE_TYPE(savedResetCause);
   \                     halGetResetInfo: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_2
   \   00000002   0x8900             LDRH     R0,[R0, #+8]
   \   00000004   0x0A00             LSRS     R0,R0,#+8
   \   00000006   0x4770             BX       LR               ;; return
    321          }
    322          

   \                                 In section .text, align 2, keep-with-next
    323          int16u halGetExtendedResetInfo(void)
    324          {
    325            return savedResetCause;
   \                     halGetExtendedResetInfo: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_2
   \   00000002   0x8900             LDRH     R0,[R0, #+8]
   \   00000004   0x4770             BX       LR               ;; return
    326          }
    327          

   \                                 In section .text, align 2, keep-with-next
    328          const HalAssertInfoType *halGetAssertInfo(void)
    329          {
    330            return &savedAssertInfo;
   \                     halGetAssertInfo: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_2
   \   00000002   0x4770             BX       LR               ;; return
    331          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x4000002C         DC32     0x4000002c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     halResetInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     savedAssertInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     halResetInfo+0x90
    332          
    333          #ifdef INTERRUPT_DEBUGGING
    334          //=============================================================================
    335          // If interrupt debugging is enabled, the actual ISRs are listed in this
    336          // secondary interrupt table.  The halInternalIntDebuggingIsr will use this
    337          // table to jump to the appropriate handler
    338          //=============================================================================
    339          NO_STRIPPING const HalVectorTableType __real_vector_table[] =
    340          {
    341            { .topOfStack = __section_end("CSTACK") },
    342            #define EXCEPTION(vectorNumber, functionName, priorityLevel, subpriority) \
    343              functionName,
    344              #include NVIC_CONFIG
    345            #undef EXCEPTION
    346          };
    347          
    348          
    349          
    350          
    351          
    352          //=============================================================================
    353          // The halInternalDebuggingIsr will intercept all exceptions in order to
    354          // set interrupt debugging IO flags so that interrupt latency and other timings
    355          // may be measured with a logic analyzer
    356          //=============================================================================
    357          void halInternalIntDebuggingIsr(void)
    358          {
    359            boolean prevState = I_STATE(I_PORT,I_PIN);
    360            int32u exception;
    361          
    362          
    363          
    364          
    365          
    366          
    367          
    368          
    369          
    370          
    371            I_SET(I_PORT, I_PIN);
    372          
    373            // call the actual exception we were supposed to go to.  The exception
    374            // number is conveniently available in the SCS_ICSR register
    375            exception = (SCS_ICSR & SCS_ICSR_VECACTIVE_MASK) >> SCS_ICSR_VECACTIVE_BIT;
    376          
    377          
    378          
    379          
    380          
    381          
    382          
    383          
    384          
    385          
    386          
    387          
    388          
    389          
    390          
    391          
    392          
    393            __real_vector_table[exception].ptrToHandler();
    394          
    395            // In order to deal with the possibility of nesting, only clear the status
    396            // output if it was clear when we entered
    397            if(!prevState)
    398              I_CLR(I_PORT, I_PIN);
    399          
    400          
    401          
    402          
    403          
    404          
    405          
    406          
    407          
    408          
    409          
    410          
    411          
    412          
    413          
    414          
    415          
    416          
    417          
    418          
    419          
    420          
    421          
    422          
    423          
    424          
    425          
    426          
    427          
    428          
    429          
    430          
    431          
    432          
    433          
    434          
    435          
    436          
    437          
    438          
    439          
    440          
    441          
    442          
    443          
    444          
    445          
    446          
    447          
    448          
    449          
    450          
    451          
    452          
    453          
    454          
    455          
    456          
    457          
    458          
    459          
    460          
    461          
    462          
    463          
    464          
    465          
    466          
    467          
    468          
    469          
    470          
    471          
    472          
    473          }
    474          #endif //INTERRUPT_DEBUGGING

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   halGetAssertInfo
       0   halGetExtendedResetInfo
       0   halGetResetInfo
      12   halInternalClassifyReset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
     144  __vector_table
    2400  cstackMemory
      32  guardRegionPlaceHolder
     172  halAppAddressTable
      84  halBootloaderAddressTable
      44  halFixedAddressTable
       4  halGetAssertInfo
       6  halGetExtendedResetInfo
       8  halGetResetInfo
     126  halInternalClassifyReset
     152  halResetInfo
      16  resetEventTable
      10  savedAssertInfo
          savedResetCause

 
    10 bytes in section .bss
   144 bytes in section .intvec
   176 bytes in section .text
   172 bytes in section AAT
    84 bytes in section BAT
 2 400 bytes in section CSTACK
    44 bytes in section FAT
    32 bytes in section GUARD_REGION
   152 bytes in section RESETINFO
 
   176 bytes of CODE  memory
   400 bytes of CONST memory
 2 638 bytes of DATA  memory

Errors: none
Warnings: none

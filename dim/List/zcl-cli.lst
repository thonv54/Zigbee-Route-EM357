###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        22/Oct/2015  09:34:23
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  E:\Zigbee\EmberZNet5.6.0-GA\app\framework\cli\zcl-cli.c
#    Command line =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\framework\cli\zcl-cli.c -D DIMMER -D
#        NULL_BTL -D CORTEXM3 -D CORTEXM3_EMBER_MICRO -D CORTEXM3_EM357 -D
#        PHY_EM3XX -D
#        "APPLICATION_TOKEN_HEADER=\"app/framework/util/tokens.h\"" -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"app/builder/ZigbeeRoute/ZigbeeRoute_endpoint_config.h\""
#        -D "BOARD_HEADER=\"app\builder\ZigbeeRoute\ZigbeeRoute_board.h\"" -D
#        "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute_tokens.h\""
#        -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\"" -D
#        "ZA_GENERATED_HEADER=\"app/builder/ZigbeeRoute/ZigbeeRoute.h\"" -D
#        "__SOURCEFILE__=\"zcl-cli.c\"" -lC
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\List\
#        --diag_suppress Pa050 -o
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\Obj\ --debug
#        --endian=little --cpu=Cortex-M3 --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\framework\cli\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\ -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\framework\include\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\app\util\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\stack\
#        -I E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\
#        -I
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\..\..\..\hal\..\
#        -Ohz --use_c++_inline
#    List file    =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\List\zcl-cli.lst
#    Object file  =  
#        E:\Zigbee\EmberZNet5.6.0-GA\app\builder\ZigbeeRoute\dim\Obj\zcl-cli.o
#
###############################################################################

E:\Zigbee\EmberZNet5.6.0-GA\app\framework\cli\zcl-cli.c
      1          // *******************************************************************
      2          // * zcl-cli.c
      3          // *
      4          // *
      5          // * Copyright 2013 Silicon Laboratories, Inc.                              *80*
      6          // *******************************************************************
      7          
      8          // common include file
      9          #include "app/framework/util/common.h"
     10          
     11          #include "app/framework/util/af-main.h"
     12          #include "app/framework/util/attribute-storage.h"
     13          #include "app/framework/util/service-discovery.h"
     14          
     15          #include "app/util/serial/command-interpreter2.h"
     16          #include "app/framework/cli/security-cli.h"
     17          
     18          #include "app/util/common/library.h"
     19          
     20          #ifdef EZSP_HOST
     21            // the EM260 host needs to include the config file
     22            #include "app/framework/util/config.h"
     23          #endif
     24          
     25          #if defined(EMBER_AF_PLUGIN_ZIGBEE_INTERNET_CLIENT)
     26          #include "app/framework/plugin/zigbee-internet-device-common/zigbee-internet-device-common.h"
     27          #include "app/framework/plugin/zigbee-internet-client/zigbee-internet-client.h"
     28          #endif
     29          
     30          //------------------------------------------------------------------------------
     31          // Globals
     32          
     33          // EMBER_AF_MAXIMUM_SEND_PAYLOAD_LENGTH is set in config.h
     34          #define APP_ZCL_BUFFER_SIZE EMBER_AF_MAXIMUM_SEND_PAYLOAD_LENGTH
     35          
     36          // The command-interpreter doesn't handle individual arguments longer than
     37          // 255 bytes (since it is uses a 1-byte max-length value
     38          #define APP_ZCL_BUFFER_SIZE_CLI \
     39            (APP_ZCL_BUFFER_SIZE > 255    \
     40             ? 255                        \
     41             : APP_ZCL_BUFFER_SIZE)
     42          

   \                                 In section .bss, align 4
     43          int8u appZclBuffer[APP_ZCL_BUFFER_SIZE];
   \                     appZclBuffer:
   \   00000000                      DS8 84

   \                                 In section .bss, align 4
     44          int16u appZclBufferLen;
     45          boolean zclCmdIsBuilt = FALSE;
     46          
     47          int16u mfgSpecificId = EMBER_AF_NULL_MANUFACTURER_CODE;
     48          int8u disableDefaultResponse = 0;
     49          EmberApsFrame globalApsFrame;
   \                     globalApsFrame:
   \   00000000                      DS8 12
   \                     zclCmdIsBuilt:
   \   0000000C                      DS8 1
   \                     disableDefaultResponse:
   \   0000000D                      DS8 1
   \   0000000E                      DS8 1
   \   0000000F                      DS8 1
   \                     appZclBufferLen:
   \   00000010                      DS8 2
   \                     mfgSpecificId:
   \   00000012                      DS8 2
     50          
     51          // a variable containing the number of messages sent from the CLI since the 
     52          // last reset
     53          
     54          #ifdef EMBER_AF_ENABLE_STATISTICS 
     55          int32u haZclCliNumPktsSent = 0;
     56          #endif
     57          
     58          // flag to keep track of the fact that we just sent a read attr for time and
     59          // we should set our time to the result of the read attr response
     60          extern boolean emAfSyncingTime;
     61          
     62          // The direction of global commands, changeable via the "zcl global direction"
     63          // command.  By default, send from client to server, which is how the CLI always
     64          // functioned in the past.
     65          static int8u zclGlobalDirection = ZCL_FRAME_CONTROL_CLIENT_TO_SERVER;
     66          
     67          
     68          // ******************************************************
     69          // zcl command functions
     70          // ******************************************************
     71          

   \                                 In section .text, align 2, keep-with-next
     72          void emAfApsFrameEndpointSetup(int8u srcEndpoint,
     73                                                int8u dstEndpoint) {
   \                     emAfApsFrameEndpointSetup: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
     74            globalApsFrame.sourceEndpoint = (srcEndpoint == 0
     75                                             ? emberAfPrimaryEndpointForCurrentNetworkIndex()
     76                                             : srcEndpoint);
   \   00000004   0xB908             CBNZ.N   R0,??emAfApsFrameEndpointSetup_0
   \   00000006   0x.... 0x....      BL       emberAfPrimaryEndpointForCurrentNetworkIndex
   \                     ??emAfApsFrameEndpointSetup_0: (+1)
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable34
   \   0000000E   0x7108             STRB     R0,[R1, #+4]
     77            globalApsFrame.destinationEndpoint = dstEndpoint;
   \   00000010   0x714C             STRB     R4,[R1, #+5]
     78          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
     79          
     80          // used by zclBufferSetup and emAfCliRawCommand

   \                                 In section .text, align 2, keep-with-next
     81          void emAfApsFrameClusterIdSetup(int16u clusterId)
     82          {
     83            // setup the global options and cluster ID
     84            // send command will setup profile ID and endpoints.
     85            globalApsFrame.options = EMBER_AF_DEFAULT_APS_OPTIONS;
   \                     emAfApsFrameClusterIdSetup: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable34
   \   00000004   0xF44F 0x5288      MOV      R2,#+4352
   \   00000008   0x80CA             STRH     R2,[R1, #+6]
     86            globalApsFrame.clusterId = clusterId;
   \   0000000A   0x8048             STRH     R0,[R1, #+2]
     87          }
   \   0000000C   0x4770             BX       LR               ;; return
     88          
     89          // used by zclCommand and emAfCliRawCommand

   \                                 In section .text, align 2, keep-with-next
     90          void cliBufferPrint(void)
     91          {
   \                     cliBufferPrint: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
     92            int8u cmdIndex = (appZclBuffer[0] & ZCL_MANUFACTURER_SPECIFIC_MASK) ? 4 : 2;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable34_1
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x0740             LSLS     R0,R0,#+29
   \   0000000C   0xBF4C             ITE      MI 
   \   0000000E   0x2004             MOVMI    R0,#+4
   \   00000010   0x2002             MOVPL    R0,#+2
     93            zclCmdIsBuilt = TRUE;
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable34
     94            emberAfGuaranteedPrintln("Msg: clus 0x%2x, cmd 0x%x, len %d",
     95                                     globalApsFrame.clusterId, 
     96                                     appZclBuffer[cmdIndex], 
     97                                     appZclBufferLen);
   \   00000016   0x886A             LDRH     R2,[R5, #+2]
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x7329             STRB     R1,[R5, #+12]
   \   0000001C   0xF64F 0x76FF      MOVW     R6,#+65535
   \   00000020   0x8A29             LDRH     R1,[R5, #+16]
   \   00000022   0x9100             STR      R1,[SP, #+0]
   \   00000024   0x5D03             LDRB     R3,[R0, R4]
   \   00000026   0x.... 0x....      ADR.W    R1,`?<Constant "Msg: clus 0x%2x, cmd ...">`
   \   0000002A   0x4630             MOV      R0,R6
   \   0000002C   0x.... 0x....      BL       emberAfPrintln
     98            emberAfGuaranteedPrint("buffer: ", appZclBufferLen);
   \   00000030   0x8A2A             LDRH     R2,[R5, #+16]
   \   00000032   0x.... 0x....      ADR.W    R1,`?<Constant "buffer: ">`
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0x.... 0x....      BL       emberAfPrint
     99            emberAfGuaranteedPrintBuffer(appZclBuffer, appZclBufferLen, TRUE);
   \   0000003C   0x8A2A             LDRH     R2,[R5, #+16]
   \   0000003E   0x2301             MOVS     R3,#+1
   \   00000040   0x4621             MOV      R1,R4
   \   00000042   0x4630             MOV      R0,R6
   \   00000044   0x.... 0x....      BL       emberAfPrintBuffer
    100            emberAfGuaranteedPrintln("");
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0xE8BD 0x407C      POP      {R2-R6,LR}
   \   0000004E   0x....             ADR.N    R1,??DataTable15  ;; ""
   \   00000050   0x.... 0x....      B.W      emberAfPrintln
    101          }
    102          
    103          // for sending raw (user defined) ZCL messages 
    104          // raw <cluster> <data bytes>
    105          // note: limited to 0xff bytes in length
    106          

   \                                 In section .text, align 2, keep-with-next
    107          void emAfCliRawCommand(void)
    108          {
   \                     emAfCliRawCommand: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    109            int8u seqNumIndex, length;
    110            emAfApsFrameClusterIdSetup((int16u)emberUnsignedCommandArgument(0));
   \   00000002   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000006   0xB280             UXTH     R0,R0
   \   00000008   0x.... 0x....      BL       emAfApsFrameClusterIdSetup
    111            emberCopyStringArgument(1, appZclBuffer, APP_ZCL_BUFFER_SIZE_CLI, FALSE);
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable34_1
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x2252             MOVS     R2,#+82
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x.... 0x....      BL       emberCopyStringArgument
    112            seqNumIndex = (appZclBuffer[0] & ZCL_MANUFACTURER_SPECIFIC_MASK) ? 3 : 1;
   \   0000001C   0x7820             LDRB     R0,[R4, #+0]
   \   0000001E   0x0740             LSLS     R0,R0,#+29
   \   00000020   0xBF4C             ITE      MI 
   \   00000022   0x2503             MOVMI    R5,#+3
   \   00000024   0x2501             MOVPL    R5,#+1
    113            appZclBuffer[seqNumIndex] = emberAfNextSequence();
   \   00000026   0x.... 0x....      BL       emberAfNextSequence
   \   0000002A   0x5528             STRB     R0,[R5, R4]
    114            emberStringCommandArgument(1, &length);
   \   0000002C   0xA900             ADD      R1,SP,#+0
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x.... 0x....      BL       emberStringCommandArgument
    115            appZclBufferLen = length;
   \   00000034   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable34
   \   0000003C   0x8208             STRH     R0,[R1, #+16]
    116            cliBufferPrint();
   \   0000003E   0x.... 0x....      BL       cliBufferPrint
    117          }
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \                     ??Subroutine5_0: (+1)
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      B.W      emberUnsignedCommandArgument
    118          

   \                                 In section .text, align 2, keep-with-next
    119          void zclBufferSetup(int8u frameType, int16u clusterId, int8u commandId) 
    120          {
   \                     zclBufferSetup: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4608             MOV      R0,R1
   \   00000008   0x4614             MOV      R4,R2
    121            int8u index = 0;
    122            emAfApsFrameClusterIdSetup(clusterId);
   \   0000000A   0x.... 0x....      BL       emAfApsFrameClusterIdSetup
    123            appZclBuffer[index++] = (frameType
    124                                     | ZCL_FRAME_CONTROL_CLIENT_TO_SERVER
    125                                     | (mfgSpecificId != EMBER_AF_NULL_MANUFACTURER_CODE
    126                                        ? ZCL_MANUFACTURER_SPECIFIC_MASK
    127                                        : 0)
    128                                     | (disableDefaultResponse
    129                                        ? ZCL_DISABLE_DEFAULT_RESPONSE_MASK
    130                                        : 0));
   \   0000000E   0x.... 0x....      LDR.W    R5,??DataTable34
   \   00000012   0x8A68             LDRH     R0,[R5, #+18]
   \   00000014   0x2701             MOVS     R7,#+1
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xBF14             ITE      NE 
   \   0000001A   0x2104             MOVNE    R1,#+4
   \   0000001C   0x2100             MOVEQ    R1,#+0
   \   0000001E   0x7B6A             LDRB     R2,[R5, #+13]
   \   00000020   0xB102             CBZ.N    R2,??zclBufferSetup_0
   \   00000022   0x2210             MOVS     R2,#+16
   \                     ??zclBufferSetup_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R6,??DataTable34_1
   \   00000028   0xEA41 0x0108      ORR      R1,R1,R8
   \   0000002C   0x4311             ORRS     R1,R2,R1
   \   0000002E   0x7031             STRB     R1,[R6, #+0]
    131            if (mfgSpecificId != EMBER_AF_NULL_MANUFACTURER_CODE) {
   \   00000030   0xB118             CBZ.N    R0,??zclBufferSetup_1
    132              appZclBuffer[index++] = (int8u)mfgSpecificId;
   \   00000032   0x7070             STRB     R0,[R6, #+1]
    133              appZclBuffer[index++] = (int8u)(mfgSpecificId >> 8);
   \   00000034   0x2703             MOVS     R7,#+3
   \   00000036   0x0A00             LSRS     R0,R0,#+8
   \   00000038   0x70B0             STRB     R0,[R6, #+2]
    134            }
    135            appZclBuffer[index++] = emberAfNextSequence();
   \                     ??zclBufferSetup_1: (+1)
   \   0000003A   0x.... 0x....      BL       emberAfNextSequence
   \   0000003E   0x55B8             STRB     R0,[R7, R6]
   \   00000040   0x1C78             ADDS     R0,R7,#+1
    136            appZclBuffer[index++] = commandId;  
   \   00000042   0xB2C0             UXTB     R0,R0
   \   00000044   0x5584             STRB     R4,[R0, R6]
    137            appZclBufferLen = index;
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0xB2C0             UXTB     R0,R0
   \   0000004A   0x8228             STRH     R0,[R5, #+16]
    138          }
   \   0000004C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    139          

   \                                 In section .text, align 2, keep-with-next
    140          void zclBufferAddByte(int8u byte)
    141          {
    142            appZclBuffer[appZclBufferLen] = byte;
   \                     zclBufferAddByte: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable34
   \   00000004   0x.... 0x....      LDR.W    R3,??DataTable34_1
   \   00000008   0x8A0A             LDRH     R2,[R1, #+16]
   \   0000000A   0x54D0             STRB     R0,[R2, R3]
    143            appZclBufferLen += 1;
   \   0000000C   0x1C50             ADDS     R0,R2,#+1
   \   0000000E   0x8208             STRH     R0,[R1, #+16]
    144          }
   \   00000010   0x4770             BX       LR               ;; return
    145          

   \                                 In section .text, align 2, keep-with-next
    146          void zclBufferAddWord(int16u word)
    147          {
   \                     zclBufferAddWord: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    148            zclBufferAddByte(LOW_BYTE(word));
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x.... 0x....      BL       zclBufferAddByte
    149            zclBufferAddByte(HIGH_BYTE(word));
   \   0000000A   0x0A20             LSRS     R0,R4,#+8
   \   0000000C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000010   0x....             B.N      zclBufferAddByte
    150          }
    151          

   \                                 In section .text, align 2, keep-with-next
    152          void zclBufferAddInt32(int32u value)
    153          {
   \                     zclBufferAddInt32: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    154            int8u i;
    155            for (i = 0; i < 4; i++) {
   \   00000004   0x2504             MOVS     R5,#+4
    156              zclBufferAddByte(LOW_BYTE(value));
   \                     ??zclBufferAddInt32_0: (+1)
   \   00000006   0xB2E0             UXTB     R0,R4
   \   00000008   0x.... 0x....      BL       zclBufferAddByte
    157              value = value >> 8;
   \   0000000C   0x0A24             LSRS     R4,R4,#+8
    158            }
   \   0000000E   0x1E6D             SUBS     R5,R5,#+1
   \   00000010   0xD1F9             BNE.N    ??zclBufferAddInt32_0
    159          }
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    160          

   \                                 In section .text, align 2, keep-with-next
    161          void zclBufferAddBuffer(const int8u *buffer, int8u length)
    162          {
   \                     zclBufferAddBuffer: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    163            MEMMOVE(appZclBuffer + appZclBufferLen, buffer, length);
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable34
   \   00000008   0x.... 0x....      LDR.W    R3,??DataTable34_1
   \   0000000C   0x4601             MOV      R1,R0
   \   0000000E   0x8A28             LDRH     R0,[R5, #+16]
   \   00000010   0x4622             MOV      R2,R4
   \   00000012   0x18C0             ADDS     R0,R0,R3
   \   00000014   0x.... 0x....      BL       halCommonMemMove
    164            appZclBufferLen += length;
   \   00000018   0x8A28             LDRH     R0,[R5, #+16]
   \   0000001A   0x1820             ADDS     R0,R4,R0
   \   0000001C   0x8228             STRH     R0,[R5, #+16]
    165          }
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    166          
    167          // Made non-to remove warnings

   \                                 In section .text, align 2, keep-with-next
    168          void zclBufferAddString(const int8u *buffer)
    169          {
   \                     zclBufferAddString: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    170            zclBufferAddBuffer(buffer, emberAfStringLength(buffer) + 1);
   \   00000004   0x.... 0x....      BL       emberAfStringLength
   \   00000008   0x1C41             ADDS     R1,R0,#+1
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000010   0xB2C9             UXTB     R1,R1
   \   00000012   0x....             B.N      zclBufferAddBuffer
    171          }
    172          

   \                                 In section .text, align 2, keep-with-next
    173          void zclBufferAddByteFromArgument(int8u index)
    174          {
   \                     zclBufferAddByteFromArgument: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    175            zclBufferAddByte((int8u)emberUnsignedCommandArgument(index));
   \   00000002   0x.... 0x....      BL       emberUnsignedCommandArgument
   \   00000006   0x....             B.N      ?Subroutine0
    176          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xE8BD 0x4002      POP      {R1,LR}
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x....             B.N      zclBufferAddByte
    177          

   \                                 In section .text, align 2, keep-with-next
    178          void zclBufferAddInt8sFromArgument(int8u index)
    179          {
   \                     zclBufferAddInt8sFromArgument: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    180            zclBufferAddByte((int8u)((int8s)emberSignedCommandArgument(index)));
   \   00000002   0x.... 0x....      BL       emberSignedCommandArgument
   \   00000006                      REQUIRE ?Subroutine0
   \   00000006                      ;; // Fall through to label ?Subroutine0
    181          }
    182          

   \                                 In section .text, align 2, keep-with-next
    183          void zclBufferAddWordFromArgument(int8u index)
    184          {
   \                     zclBufferAddWordFromArgument: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    185            zclBufferAddWord((int16u)emberUnsignedCommandArgument(index));
   \   00000002   0x.... 0x....      BL       emberUnsignedCommandArgument
   \   00000006   0xE8BD 0x4002      POP      {R1,LR}
   \   0000000A   0xB280             UXTH     R0,R0
   \   0000000C   0x....             B.N      zclBufferAddWord
    186          }
    187          

   \                                 In section .text, align 2, keep-with-next
    188          void zclBufferAddInt32FromArgument(int8u index)
    189          {
   \                     zclBufferAddInt32FromArgument: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    190            zclBufferAddInt32(emberUnsignedCommandArgument(index));
   \   00000002   0x.... 0x....      BL       emberUnsignedCommandArgument
   \   00000006   0xE8BD 0x4002      POP      {R1,LR}
   \   0000000A   0x....             B.N      zclBufferAddInt32
    191          }
    192          
    193          // Writes the length and contents of the string found at argIndex
    194          // into the zcl buffer.

   \                                 In section .text, align 2, keep-with-next
    195          void zclBufferAddLengthAndStringFromArgument(int8u argIndex)
    196          {
   \                     zclBufferAddLengthAndStringFromArgument: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    197            // We protect against copying outside of the appZclBuffer
    198            // by passing the maximum length of the buffer, or a maximum
    199            // value of an int8u.
    200            int16u maxLength = APP_ZCL_BUFFER_SIZE - (appZclBufferLen + 1);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable34
   \   00000006   0x8A21             LDRH     R1,[R4, #+16]
   \   00000008   0xF1C1 0x0251      RSB      R2,R1,#+81
   \   0000000C   0xB292             UXTH     R2,R2
    201            if (maxLength > MAX_INT8U_VALUE)
   \   0000000E   0x2AFF             CMP      R2,#+255
   \   00000010   0xBFC8             IT       GT 
    202              maxLength = MAX_INT8U_VALUE;
   \   00000012   0x22FF             MOVGT    R2,#+255
    203            int8u length = emberCopyStringArgument(argIndex,
    204                                                   appZclBuffer + appZclBufferLen + 1,
    205                                                   maxLength,
    206                                                   FALSE);
   \   00000014   0x.... 0x....      LDR.W    R5,??DataTable34_1
   \   00000018   0x1949             ADDS     R1,R1,R5
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0xB2D2             UXTB     R2,R2
   \   0000001E   0x1C49             ADDS     R1,R1,#+1
   \   00000020   0xB240             SXTB     R0,R0
   \   00000022   0x.... 0x....      BL       emberCopyStringArgument
    207            appZclBuffer[appZclBufferLen] = length;
   \   00000026   0x8A21             LDRH     R1,[R4, #+16]
   \   00000028   0x5548             STRB     R0,[R1, R5]
    208            appZclBufferLen += length + 1;
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x1840             ADDS     R0,R0,R1
   \   0000002E   0x8220             STRH     R0,[R4, #+16]
    209          }
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    210          
    211          // This function fully formats the zcl buffer given all the necessary data.
    212          // The format string describes how the subsequent arguments are to be
    213          // written into the zcl buffer.  The format characters are the same as
    214          // those used by the command interpreter, namely:
    215          // 'u'   A one-byte unsigned value.
    216          // 'v'   A two-byte unsigned value encoded low byte first.
    217          // 'w'   A four-byte unsigned value encoded from low to high byte.
    218          // 'b'   A sequence of unsigned bytes.  The first supplied value is a
    219          //       pointer to the data and the second value is the number of bytes.
    220          

   \                                 In section .text, align 2, keep-with-next
    221          void makeZclBuffer(int8u frameControl,
    222                             int16u clusterId,
    223                             int8u commandId,
    224                             char *format,
    225                             ...)
    226          {
   \                     makeZclBuffer: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x461C             MOV      R4,R3
    227            int8u i = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    228            va_list argPointer = { 0 };
    229            zclBufferSetup(frameControl, clusterId, commandId);
   \   00000008   0x.... 0x....      BL       zclBufferSetup
    230            va_start(argPointer, format);
   \   0000000C   0xAE08             ADD      R6,SP,#+32
   \   0000000E   0x.... 0x....      ADR.W    R9,`?<Constant "zcl-cli.c">`
   \   00000012   0xE005             B.N      ??makeZclBuffer_0
    231            
    232            while (format[i] != 0) {
    233              char command = format[i];
    234              switch (command) {
    235              case 'u':
    236                zclBufferAddByte(va_arg(argPointer, int));
    237                break;
    238              case 'v':
    239                zclBufferAddWord(va_arg(argPointer, int));
    240                break;
    241              case 'w':
    242                zclBufferAddInt32(va_arg(argPointer, int));
    243                break;
    244              case 'b': {
    245                int8u *contents = va_arg(argPointer, int8u *);
    246                int8u count = va_arg(argPointer, int);
    247                zclBufferAddByte(count);
    248                zclBufferAddBuffer(contents, count);
    249                break;
    250              }
    251              default:
    252                assert(FALSE);
   \                     ??makeZclBuffer_1: (+1)
   \   00000014   0x21FC             MOVS     R1,#+252
   \   00000016   0x4648             MOV      R0,R9
   \   00000018   0x.... 0x....      BL       halInternalAssertFailed
    253              }
    254              i += 1;
   \                     ??makeZclBuffer_2: (+1)
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   \   0000001E   0xB2ED             UXTB     R5,R5
   \                     ??makeZclBuffer_0: (+1)
   \   00000020   0x5D28             LDRB     R0,[R5, R4]
   \   00000022   0xB328             CBZ.N    R0,??makeZclBuffer_3
   \   00000024   0x2862             CMP      R0,#+98
   \   00000026   0xD017             BEQ.N    ??makeZclBuffer_4
   \   00000028   0x2875             CMP      R0,#+117
   \   0000002A   0xD004             BEQ.N    ??makeZclBuffer_5
   \   0000002C   0x2876             CMP      R0,#+118
   \   0000002E   0xD008             BEQ.N    ??makeZclBuffer_6
   \   00000030   0x2877             CMP      R0,#+119
   \   00000032   0xD00C             BEQ.N    ??makeZclBuffer_7
   \   00000034   0xE7EE             B.N      ??makeZclBuffer_1
   \                     ??makeZclBuffer_5: (+1)
   \   00000036   0xF856 0x0B04      LDR      R0,[R6], #+4
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0x.... 0x....      BL       zclBufferAddByte
   \   00000040   0xE7EC             B.N      ??makeZclBuffer_2
   \                     ??makeZclBuffer_6: (+1)
   \   00000042   0xF856 0x0B04      LDR      R0,[R6], #+4
   \   00000046   0xB280             UXTH     R0,R0
   \   00000048   0x.... 0x....      BL       zclBufferAddWord
   \   0000004C   0xE7E6             B.N      ??makeZclBuffer_2
   \                     ??makeZclBuffer_7: (+1)
   \   0000004E   0xF856 0x0B04      LDR      R0,[R6], #+4
   \   00000052   0x.... 0x....      BL       zclBufferAddInt32
   \   00000056   0xE7E1             B.N      ??makeZclBuffer_2
   \                     ??makeZclBuffer_4: (+1)
   \   00000058   0xF856 0x8B04      LDR      R8,[R6], #+4
   \   0000005C   0xF856 0x7B04      LDR      R7,[R6], #+4
   \   00000060   0xB2F8             UXTB     R0,R7
   \   00000062   0x.... 0x....      BL       zclBufferAddByte
   \   00000066   0xB2F9             UXTB     R1,R7
   \   00000068   0x4640             MOV      R0,R8
   \   0000006A   0x.... 0x....      BL       zclBufferAddBuffer
   \   0000006E   0xE7D5             B.N      ??makeZclBuffer_2
    255            }
    256          
    257            va_end(argPointer);
    258            cliBufferPrint();
   \                     ??makeZclBuffer_3: (+1)
   \   00000070   0x.... 0x....      BL       cliBufferPrint
    259          }
   \   00000074   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    260          
    261          // Handles any zcl command where the argument list of the
    262          // command is simply appended to the zcl buffer.  Handles argument types
    263          // 'u', 'v', 'w', and 'b'.  String arguments are written with a length
    264          // byte first.

   \                                 In section .text, align 2, keep-with-next
    265          void zclSimpleCommand(int8u frameControl,
    266                                       int16u clusterId, 
    267                                       int8u commandId)
    268          {
   \                     zclSimpleCommand: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
    269            int8u argumentIndex, typeIndex;
    270            int8u count = emberCommandArgumentCount();
   \   00000008   0x.... 0x....      BL       emberCommandArgumentCount
   \   0000000C   0x4604             MOV      R4,R0
    271            int8u type;
    272          
    273            zclBufferSetup(frameControl, clusterId, commandId);
   \   0000000E   0x463A             MOV      R2,R7
   \   00000010   0x4631             MOV      R1,R6
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       zclBufferSetup
    274            for (argumentIndex = 0, typeIndex = 0;
   \   00000018   0x2600             MOVS     R6,#+0
   \   0000001A   0x2500             MOVS     R5,#+0
   \   0000001C   0xE003             B.N      ??zclSimpleCommand_0
    275                 argumentIndex < count;
    276                 argumentIndex++) {
    277              type = emberCurrentCommand->argumentTypes[typeIndex];
    278              if (typeIndex + 1 < count
    279                  && emberCurrentCommand->argumentTypes[typeIndex + 1] != '*') {
    280                typeIndex++;
    281              }
    282          
    283              switch (type) {
    284              case 'u':
    285                zclBufferAddByteFromArgument(argumentIndex);
    286                break;
    287              case 'v':
    288                zclBufferAddWordFromArgument(argumentIndex);
    289                break;
    290              case 'w':
    291                zclBufferAddInt32FromArgument(argumentIndex);
    292                break;
    293              case 's':
    294                zclBufferAddInt8sFromArgument(argumentIndex);
    295                break;
    296              case 'b':
    297                zclBufferAddLengthAndStringFromArgument(argumentIndex);
   \                     ??zclSimpleCommand_1: (+1)
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0x.... 0x....      BL       zclBufferAddLengthAndStringFromArgument
    298                break;
   \                     ??zclSimpleCommand_2: (+1)
   \   00000024   0x1C76             ADDS     R6,R6,#+1
   \                     ??zclSimpleCommand_0: (+1)
   \   00000026   0xB2F6             UXTB     R6,R6
   \   00000028   0x42A6             CMP      R6,R4
   \   0000002A   0xDA2A             BGE.N    ??zclSimpleCommand_3
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x6880             LDR      R0,[R0, #+8]
   \   00000034   0x5C29             LDRB     R1,[R5, R0]
   \   00000036   0x1C6A             ADDS     R2,R5,#+1
   \   00000038   0x42A2             CMP      R2,R4
   \   0000003A   0xDA05             BGE.N    ??zclSimpleCommand_4
   \   0000003C   0x1828             ADDS     R0,R5,R0
   \   0000003E   0x7840             LDRB     R0,[R0, #+1]
   \   00000040   0x282A             CMP      R0,#+42
   \   00000042   0xBF1C             ITT      NE 
   \   00000044   0x1C6D             ADDNE    R5,R5,#+1
   \   00000046   0xB2ED             UXTBNE   R5,R5
   \                     ??zclSimpleCommand_4: (+1)
   \   00000048   0x292A             CMP      R1,#+42
   \   0000004A   0xD0EB             BEQ.N    ??zclSimpleCommand_2
   \   0000004C   0x2962             CMP      R1,#+98
   \   0000004E   0xD0E6             BEQ.N    ??zclSimpleCommand_1
   \   00000050   0x2973             CMP      R1,#+115
   \   00000052   0xD012             BEQ.N    ??zclSimpleCommand_5
   \   00000054   0x2975             CMP      R1,#+117
   \   00000056   0xD004             BEQ.N    ??zclSimpleCommand_6
   \   00000058   0x2976             CMP      R1,#+118
   \   0000005A   0xD006             BEQ.N    ??zclSimpleCommand_7
   \   0000005C   0x2977             CMP      R1,#+119
   \   0000005E   0xD008             BEQ.N    ??zclSimpleCommand_8
   \   00000060   0xE00F             B.N      ??zclSimpleCommand_3
   \                     ??zclSimpleCommand_6: (+1)
   \   00000062   0x4630             MOV      R0,R6
   \   00000064   0x.... 0x....      BL       zclBufferAddByteFromArgument
   \   00000068   0xE7DC             B.N      ??zclSimpleCommand_2
   \                     ??zclSimpleCommand_7: (+1)
   \   0000006A   0x4630             MOV      R0,R6
   \   0000006C   0x.... 0x....      BL       zclBufferAddWordFromArgument
   \   00000070   0xE7D8             B.N      ??zclSimpleCommand_2
   \                     ??zclSimpleCommand_8: (+1)
   \   00000072   0x4630             MOV      R0,R6
   \   00000074   0x.... 0x....      BL       zclBufferAddInt32FromArgument
   \   00000078   0xE7D4             B.N      ??zclSimpleCommand_2
   \                     ??zclSimpleCommand_5: (+1)
   \   0000007A   0x4630             MOV      R0,R6
   \   0000007C   0x.... 0x....      BL       zclBufferAddInt8sFromArgument
   \   00000080   0xE7D0             B.N      ??zclSimpleCommand_2
    299              case '*':
    300                break;
    301              case '?':
    302                //lint -fallthrough
    303              case 0:
    304                //lint -fallthrough
    305              default:
    306                goto kickout;
    307              }
    308            }
    309          
    310          kickout:
    311            cliBufferPrint();
   \                     ??zclSimpleCommand_3: (+1)
   \   00000082   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000086   0x....             B.N      cliBufferPrint
    312          }
    313          

   \                                 In section .text, align 2, keep-with-next
    314          void zclGlobalSetup(int8u commandId)
    315          {
   \                     zclGlobalSetup: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine5
    316            int16u clusterId = (int16u)emberUnsignedCommandArgument(0);
    317            zclBufferSetup(ZCL_PROFILE_WIDE_COMMAND | zclGlobalDirection,
    318                           clusterId,
    319                           commandId);
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000006   0x.... 0x....      BL       ?Subroutine12
    320            zclBufferAddWordFromArgument(1);  // attr id
   \                     ??CrossCallReturnLabel_44: (+1)
   \   0000000A   0x.... 0x....      BL       ?Subroutine9
    321            if (commandId != ZCL_READ_ATTRIBUTES_COMMAND_ID) {
   \                     ??CrossCallReturnLabel_38: (+1)
   \   0000000E   0xB11C             CBZ.N    R4,??zclGlobalSetup_0
    322              zclBufferAddByteFromArgument(2);
   \   00000010   0xE8BD 0x4010      POP      {R4,LR}
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x....             B.N      zclBufferAddByteFromArgument
    323            } 
    324          }
   \                     ??zclGlobalSetup_0: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             B.N      zclBufferAddWordFromArgument

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \   00000000   0xB281             UXTH     R1,R0
   \   00000002   0x....             LDR.N    R0,??DataTable34
   \   00000004   0x7B80             LDRB     R0,[R0, #+14]
   \   00000006   0x4622             MOV      R2,R4
   \   00000008   0x....             B.N      zclBufferSetup
    325          
    326          // zcl global direction <direction:1>

   \                                 In section .text, align 2, keep-with-next
    327          void zclGlobalDirectionCommand(void) 
    328          {
   \                     zclGlobalDirectionCommand: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    329            zclGlobalDirection = ((((int8u)emberUnsignedCommandArgument(0))
    330                                   == ZCL_DIRECTION_CLIENT_TO_SERVER)
    331                                  ? ZCL_FRAME_CONTROL_CLIENT_TO_SERVER
    332                                  : ZCL_FRAME_CONTROL_SERVER_TO_CLIENT);
   \   00000002   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0xB100             CBZ.N    R0,??zclGlobalDirectionCommand_0
   \   0000000A   0x2008             MOVS     R0,#+8
   \                     ??zclGlobalDirectionCommand_0: (+1)
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable34
   \   00000010   0x7388             STRB     R0,[R1, #+14]
    333          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    334          
    335          // zcl global read <cluster:2> <attribute:2>

   \                                 In section .text, align 2, keep-with-next
    336          void zclGlobalReadCommand(void) 
    337          {
   \                     zclGlobalReadCommand: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    338            zclGlobalSetup(ZCL_READ_ATTRIBUTES_COMMAND_ID);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             B.N      ?Subroutine1
    339            cliBufferPrint();
    340          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x.... 0x....      BL       zclGlobalSetup
   \   00000004                      REQUIRE ??Subroutine14_0
   \   00000004                      ;; // Fall through to label ??Subroutine14_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine14_0: (+1)
   \   00000000   0xE8BD 0x4001      POP      {R0,LR}
   \   00000004   0x....             B.N      cliBufferPrint
    341          
    342          
    343          // zcl global write <cluster:2> <attrID:2> <type:1> <data>
    344          // zcl global uwrite <cluster:2> <attrID:2> <type:1> <data>
    345          // zcl global nwrite <cluster:2> <attrID:2> <type:1> <data>

   \                                 In section .text, align 2, keep-with-next
    346          void zclGlobalWriteCommand(void) 
    347          {
   \                     zclGlobalWriteCommand: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    348            int8u type = (int8u)emberUnsignedCommandArgument(2);
   \   00000002   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_21: (+1)
   \   00000006   0x4604             MOV      R4,R0
    349            int8u commandChar = emberCurrentCommand->name[0];
   \   00000008   0x.... 0x....      BL       ?Subroutine11
    350            int8u commandId = (commandChar == 'u'
    351                               ? ZCL_WRITE_ATTRIBUTES_UNDIVIDED_COMMAND_ID
    352                               : (commandChar == 'n'
    353                                  ? ZCL_WRITE_ATTRIBUTES_NO_RESPONSE_COMMAND_ID
    354                                  : ZCL_WRITE_ATTRIBUTES_COMMAND_ID));
   \                     ??CrossCallReturnLabel_41: (+1)
   \   0000000C   0x2875             CMP      R0,#+117
   \   0000000E   0xBF08             IT       EQ 
   \   00000010   0x2003             MOVEQ    R0,#+3
   \   00000012   0xD003             BEQ.N    ??zclGlobalWriteCommand_0
   \   00000014   0x286E             CMP      R0,#+110
   \   00000016   0xBF0C             ITE      EQ 
   \   00000018   0x2005             MOVEQ    R0,#+5
   \   0000001A   0x2002             MOVNE    R0,#+2
    355            zclGlobalSetup(commandId);
   \                     ??zclGlobalWriteCommand_0: (+1)
   \   0000001C   0x.... 0x....      BL       zclGlobalSetup
    356          
    357            if (emberAfIsThisDataTypeAStringType(type)) {
   \   00000020   0xB2E0             UXTB     R0,R4
   \   00000022   0x.... 0x....      BL       emberAfIsThisDataTypeAStringType
   \   00000026   0xB118             CBZ.N    R0,??zclGlobalWriteCommand_1
    358              // TODO: the maximum length of the string should be obtained from
    359              // the attribute size table.  Currently the following helper function
    360              // has a hard-coded maximum length of 16.
    361              zclBufferAddLengthAndStringFromArgument(3);
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x.... 0x....      BL       zclBufferAddLengthAndStringFromArgument
   \   0000002E   0xE011             B.N      ??zclGlobalWriteCommand_2
    362            } else {
    363              int8u length = emberAfGetDataSize(type);
   \                     ??zclGlobalWriteCommand_1: (+1)
   \   00000030   0xB2E0             UXTB     R0,R4
   \   00000032   0x.... 0x....      BL       emberAfGetDataSize
    364              emberCopyStringArgument(3, 
    365                                      appZclBuffer + appZclBufferLen, 
    366                                      length, 
    367                                      TRUE);  // pad with zeroes
   \   00000036   0x.... 0x....      LDR.W    R5,??DataTable34
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable34_1
   \   0000003E   0x4604             MOV      R4,R0
   \   00000040   0x8A28             LDRH     R0,[R5, #+16]
   \   00000042   0x1841             ADDS     R1,R0,R1
   \   00000044   0x2301             MOVS     R3,#+1
   \   00000046   0x4622             MOV      R2,R4
   \   00000048   0x2003             MOVS     R0,#+3
   \   0000004A   0x.... 0x....      BL       emberCopyStringArgument
    368              appZclBufferLen += length;    
   \   0000004E   0x8A28             LDRH     R0,[R5, #+16]
   \   00000050   0x1820             ADDS     R0,R4,R0
   \   00000052   0x8228             STRH     R0,[R5, #+16]
    369            }
    370          
    371            cliBufferPrint();
   \                     ??zclGlobalWriteCommand_2: (+1)
   \   00000054   0x....             B.N      ?Subroutine2
    372          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000004   0x....             B.N      cliBufferPrint

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable34_2
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   \                     ??Subroutine6_0: (+1)
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x.... 0x....      B.W      emberUnsignedCommandArgument
    373          
    374          // zcl global discover <cluster> <attrID:2> <max # to report:1>

   \                                 In section .text, align 2, keep-with-next
    375          void zclGlobalDiscoverCommand(void)
    376          {
   \                     zclGlobalDiscoverCommand: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    377            zclGlobalSetup(ZCL_DISCOVER_ATTRIBUTES_COMMAND_ID);
   \   00000002   0x200C             MOVS     R0,#+12
   \   00000004                      REQUIRE ?Subroutine1
   \   00000004                      ;; // Fall through to label ?Subroutine1
    378            cliBufferPrint();
    379          }
    380          
    381          // zcl global report <src endpoint id:1> <cluster id:2> <attribute id:2> <mask:1>

   \                                 In section .text, align 2, keep-with-next
    382          void zclGlobalReportCommand(void)
    383          {
   \                     zclGlobalReportCommand: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
    384            EmberAfStatus status;
    385            EmberAfClusterId clusterId = (EmberAfClusterId)emberUnsignedCommandArgument(1);
   \   00000004   0x.... 0x....      BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_27: (+1)
   \   00000008   0x4604             MOV      R4,R0
    386            EmberAfAttributeId attributeId = (EmberAfAttributeId)emberUnsignedCommandArgument(2);
   \   0000000A   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_20: (+1)
   \   0000000E   0x4605             MOV      R5,R0
    387            int8u mask = (int8u)emberUnsignedCommandArgument(3);
   \   00000010   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_34: (+1)
   \   00000014   0xB2C6             UXTB     R6,R0
    388            EmberAfAttributeType type;
    389            int8u size;
    390            int8u data[ATTRIBUTE_LARGEST];
    391          
    392            status = emberAfReadAttribute((int8u)emberUnsignedCommandArgument(0), // endpoint
    393                                          clusterId,
    394                                          attributeId,
    395                                          (mask == 0
    396                                           ? CLUSTER_MASK_CLIENT
    397                                           : CLUSTER_MASK_SERVER),
    398                                          data,
    399                                          sizeof(data),
    400                                          &type);
    401            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xBF0C             ITE      EQ 
   \   0000001A   0x2780             MOVEQ    R7,#+128
   \   0000001C   0x2740             MOVNE    R7,#+64
   \   0000001E   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000022   0xA903             ADD      R1,SP,#+12
   \   00000024   0x9102             STR      R1,[SP, #+8]
   \   00000026   0x463B             MOV      R3,R7
   \   00000028   0x2121             MOVS     R1,#+33
   \   0000002A   0x9101             STR      R1,[SP, #+4]
   \   0000002C   0xB2AA             UXTH     R2,R5
   \   0000002E   0xA904             ADD      R1,SP,#+16
   \   00000030   0x9100             STR      R1,[SP, #+0]
   \   00000032   0xB2C0             UXTB     R0,R0
   \   00000034   0xB2A1             UXTH     R1,R4
   \   00000036   0x.... 0x....      BL       emberAfReadAttribute
   \   0000003A   0xBB58             CBNZ.N   R0,??zclGlobalReportCommand_0
    402              emberAfReportingPrintln("ERR: reading attribute %x", status);
    403              return;
    404            }
    405          
    406            zclBufferSetup(ZCL_PROFILE_WIDE_COMMAND
    407                           | (mask == 0
    408                              ? ZCL_FRAME_CONTROL_CLIENT_TO_SERVER
    409                              : ZCL_FRAME_CONTROL_SERVER_TO_CLIENT),
    410                           clusterId,
    411                           ZCL_REPORT_ATTRIBUTES_COMMAND_ID);
   \   0000003C   0xB106             CBZ.N    R6,??zclGlobalReportCommand_1
   \   0000003E   0x2008             MOVS     R0,#+8
   \                     ??zclGlobalReportCommand_1: (+1)
   \   00000040   0x220A             MOVS     R2,#+10
   \   00000042   0xB2A1             UXTH     R1,R4
   \   00000044   0x.... 0x....      BL       zclBufferSetup
    412            zclBufferAddWord(attributeId);
   \   00000048   0xB2A8             UXTH     R0,R5
   \   0000004A   0x.... 0x....      BL       zclBufferAddWord
    413            zclBufferAddByte(type);
   \   0000004E   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000052   0x.... 0x....      BL       zclBufferAddByte
    414          
    415            size = (emberAfIsThisDataTypeAStringType(type)
    416                    ? emberAfStringLength(data) + 1
    417                    : emberAfGetDataSize(type));
   \   00000056   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000005A   0x.... 0x....      BL       emberAfIsThisDataTypeAStringType
   \   0000005E   0xB120             CBZ.N    R0,??zclGlobalReportCommand_2
   \   00000060   0xA804             ADD      R0,SP,#+16
   \   00000062   0x.... 0x....      BL       emberAfStringLength
   \   00000066   0x1C44             ADDS     R4,R0,#+1
   \   00000068   0xE004             B.N      ??zclGlobalReportCommand_3
   \                     ??zclGlobalReportCommand_2: (+1)
   \   0000006A   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000006E   0x.... 0x....      BL       emberAfGetDataSize
   \   00000072   0x4604             MOV      R4,R0
    418          #if (BIGENDIAN_CPU)
    419            if (isThisDataTypeSentLittleEndianOTA(type)) {
    420              emberReverseMemCopy(appZclBuffer + appZclBufferLen, data, size);
    421            } else {
    422              MEMMOVE(appZclBuffer + appZclBufferLen, data, size);
    423            }
    424          #else
    425            MEMMOVE(appZclBuffer + appZclBufferLen, data, size);
   \                     ??zclGlobalReportCommand_3: (+1)
   \   00000074   0x.... 0x....      LDR.W    R5,??DataTable34
   \   00000078   0x.... 0x....      LDR.W    R3,??DataTable34_1
   \   0000007C   0x8A28             LDRH     R0,[R5, #+16]
   \   0000007E   0xB2E4             UXTB     R4,R4
   \   00000080   0x4622             MOV      R2,R4
   \   00000082   0xA904             ADD      R1,SP,#+16
   \   00000084   0x18C0             ADDS     R0,R0,R3
   \   00000086   0x.... 0x....      BL       halCommonMemMove
    426          #endif
    427            appZclBufferLen += size;
   \   0000008A   0x8A28             LDRH     R0,[R5, #+16]
   \   0000008C   0x1820             ADDS     R0,R4,R0
   \   0000008E   0x8228             STRH     R0,[R5, #+16]
    428          
    429            cliBufferPrint();
   \   00000090   0x.... 0x....      BL       cliBufferPrint
    430          }
   \                     ??zclGlobalReportCommand_0: (+1)
   \   00000094   0xB00D             ADD      SP,SP,#+52
   \   00000096   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \                     ??Subroutine7_0: (+1)
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      B.W      emberUnsignedCommandArgument

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x2003             MOVS     R0,#+3
   \   00000002   0x.... 0x....      B.W      emberUnsignedCommandArgument
    431          
    432          // zcl global report-read <cluster> <attrID:2> <direction:1>

   \                                 In section .text, align 2, keep-with-next
    433          void zclGlobalReportReadCommand(void)
    434          {
   \                     zclGlobalReportReadCommand: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    435            zclBufferSetup(ZCL_PROFILE_WIDE_COMMAND | zclGlobalDirection,
    436                           (EmberAfClusterId)emberUnsignedCommandArgument(0), // cluster id
    437                           ZCL_READ_REPORTING_CONFIGURATION_COMMAND_ID);
   \   00000002   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000006   0xB281             UXTH     R1,R0
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable34
   \   0000000C   0x7B80             LDRB     R0,[R0, #+14]
   \   0000000E   0x2208             MOVS     R2,#+8
   \   00000010   0x.... 0x....      BL       zclBufferSetup
    438            zclBufferAddByteFromArgument(2); // direction
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x.... 0x....      BL       zclBufferAddByteFromArgument
    439            zclBufferAddWordFromArgument(1); // attribute id
   \   0000001A   0x.... 0x....      BL       ?Subroutine9
    440            cliBufferPrint();
   \                     ??CrossCallReturnLabel_37: (+1)
   \   0000001E   0x....             B.N      ??Subroutine14_0
    441          }
    442          
    443          // zcl global send-me-a-report <cluster id:2> <attribute id:2> <type:1> ...
    444          // ... <min interval:2> <max interval:2> <reportable change:1-4>

   \                                 In section .text, align 2, keep-with-next
    445          void zclGlobalSendMeAReportCommand(void)
    446          {
   \                     zclGlobalSendMeAReportCommand: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    447            int8u type = (int8u)emberUnsignedCommandArgument(2);
   \   00000002   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_19: (+1)
   \   00000006   0x.... 0x....      BL       ?Subroutine5
    448          
    449            zclBufferSetup(ZCL_PROFILE_WIDE_COMMAND | zclGlobalDirection,
    450                           (EmberAfClusterId)emberUnsignedCommandArgument(0), // cluster id
    451                           ZCL_CONFIGURE_REPORTING_COMMAND_ID);
   \                     ??CrossCallReturnLabel_14: (+1)
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable34
   \   0000000E   0xB281             UXTH     R1,R0
   \   00000010   0x7BA8             LDRB     R0,[R5, #+14]
   \   00000012   0x2206             MOVS     R2,#+6
   \   00000014   0x.... 0x....      BL       zclBufferSetup
    452            zclBufferAddByte(EMBER_ZCL_REPORTING_DIRECTION_REPORTED);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       zclBufferAddByte
    453            zclBufferAddWordFromArgument(1);  // attribute id
   \   0000001E   0x.... 0x....      BL       ?Subroutine9
    454            zclBufferAddByte(type);           // type
   \                     ??CrossCallReturnLabel_36: (+1)
   \   00000022   0xB2E0             UXTB     R0,R4
   \   00000024   0x.... 0x....      BL       zclBufferAddByte
    455            zclBufferAddWordFromArgument(3);  // minimum reporting interval
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0x.... 0x....      BL       zclBufferAddWordFromArgument
    456            zclBufferAddWordFromArgument(4);  // maximum reporting interval
   \   0000002E   0x2004             MOVS     R0,#+4
   \   00000030   0x.... 0x....      BL       zclBufferAddWordFromArgument
    457          
    458            // If the data type is analog, then the reportable change field is the same
    459            // size as the data type.  Otherwise, it is omitted.
    460            if (emberAfGetAttributeAnalogOrDiscreteType(type)
    461                == EMBER_AF_DATA_TYPE_ANALOG) {
   \   00000034   0xB2E0             UXTB     R0,R4
   \   00000036   0x.... 0x....      BL       emberAfGetAttributeAnalogOrDiscreteType
   \   0000003A   0xB970             CBNZ.N   R0,??zclGlobalSendMeAReportCommand_0
    462              int8u dataSize = emberAfGetDataSize(type);
   \   0000003C   0xB2E0             UXTB     R0,R4
   \   0000003E   0x.... 0x....      BL       emberAfGetDataSize
   \   00000042   0x4604             MOV      R4,R0
    463              emberCopyStringArgument(5,
    464                                      appZclBuffer + appZclBufferLen,
    465                                      dataSize,
    466                                      FALSE);
   \   00000044   0x8A28             LDRH     R0,[R5, #+16]
   \   00000046   0x....             LDR.N    R1,??DataTable34_1
   \   00000048   0x1841             ADDS     R1,R0,R1
   \   0000004A   0x2300             MOVS     R3,#+0
   \   0000004C   0x4622             MOV      R2,R4
   \   0000004E   0x2005             MOVS     R0,#+5
   \   00000050   0x.... 0x....      BL       emberCopyStringArgument
    467              appZclBufferLen += dataSize;
   \   00000054   0x8A28             LDRH     R0,[R5, #+16]
   \   00000056   0x1820             ADDS     R0,R4,R0
   \   00000058   0x8228             STRH     R0,[R5, #+16]
    468            }
    469            cliBufferPrint();
   \                     ??zclGlobalSendMeAReportCommand_0: (+1)
   \   0000005A                      REQUIRE ?Subroutine2
   \   0000005A                      ;; // Fall through to label ?Subroutine2
    470          }
    471          
    472          // zcl global expect-report-from-me <cluster id:2> <attribute id:2> <timeout:2>

   \                                 In section .text, align 2, keep-with-next
    473          void zclGlobalExpectReportFromMeCommand(void)
    474          {
   \                     zclGlobalExpectReportFromMeCommand: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    475            zclBufferSetup(ZCL_PROFILE_WIDE_COMMAND | zclGlobalDirection,
    476                           (EmberAfClusterId)emberUnsignedCommandArgument(0), // cluster id
    477                           ZCL_CONFIGURE_REPORTING_COMMAND_ID);
   \   00000002   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000006   0xB281             UXTH     R1,R0
   \   00000008   0x....             LDR.N    R0,??DataTable34
   \   0000000A   0x7B80             LDRB     R0,[R0, #+14]
   \   0000000C   0x2206             MOVS     R2,#+6
   \   0000000E   0x.... 0x....      BL       zclBufferSetup
    478            zclBufferAddByte(EMBER_ZCL_REPORTING_DIRECTION_RECEIVED);
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       zclBufferAddByte
    479            zclBufferAddWordFromArgument(1); // attribute id
   \   00000018   0x.... 0x....      BL       ?Subroutine9
    480            zclBufferAddWordFromArgument(2); // timeout
   \                     ??CrossCallReturnLabel_35: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x.... 0x....      BL       zclBufferAddWordFromArgument
    481            cliBufferPrint();
   \   00000022   0x....             B.N      ??Subroutine14_0
    482          }
    483          
    484          // zcl global disc-com-gen <cluster id:2> <start command id:1> <max command id:1>
    485          // zcl global disc-com-rec <cluster id:2> <start command id:1> <max command id:1>

   \                                 In section .text, align 2, keep-with-next
    486          void zclGlobalCommandDiscoveryCommand(void)
    487          {
   \                     zclGlobalCommandDiscoveryCommand: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    488            	zclBufferSetup(ZCL_PROFILE_WIDE_COMMAND | zclGlobalDirection,
    489          	                 (EmberAfClusterId)emberUnsignedCommandArgument(0), // cluster id
    490          	                 (emberCurrentCommand->name[9] == 'g' ? 
    491          					   ZCL_DISCOVER_COMMANDS_GENERATED_COMMAND_ID :
    492          					   ZCL_DISCOVER_COMMANDS_RECEIVED_COMMAND_ID));
   \   00000002   0x....             LDR.N    R0,??DataTable34_2
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x7A40             LDRB     R0,[R0, #+9]
   \   0000000A   0x2867             CMP      R0,#+103
   \   0000000C   0xBF0C             ITE      EQ 
   \   0000000E   0x2413             MOVEQ    R4,#+19
   \   00000010   0x2411             MOVNE    R4,#+17
   \   00000012   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000016   0x.... 0x....      BL       ?Subroutine12
    493              zclBufferAddByteFromArgument(1); // start command id
   \                     ??CrossCallReturnLabel_43: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x.... 0x....      BL       zclBufferAddByteFromArgument
    494          	zclBufferAddByteFromArgument(2); // max command ids
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x.... 0x....      BL       zclBufferAddByteFromArgument
    495          	cliBufferPrint();
   \   00000026   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002A   0x....             B.N      cliBufferPrint
    496          }
    497          
    498          // zcl test response on

   \                                 In section .text, align 2, keep-with-next
    499          void zclTestResponseOnCommand(void)
    500          {
    501            emberAfSetNoReplyForNextMessage(FALSE);  
   \                     zclTestResponseOnCommand: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      B.W      emberAfSetNoReplyForNextMessage
    502          }
    503          
    504          // zcl test response off

   \                                 In section .text, align 2, keep-with-next
    505          void zclTestResponseOffCommand(void)
    506          {
    507            emberAfSetNoReplyForNextMessage(TRUE);
   \                     zclTestResponseOffCommand: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      B.W      emberAfSetNoReplyForNextMessage
    508          }
    509          
    510          #ifdef ZCL_USING_BASIC_CLUSTER_CLIENT
    511          // zcl basic rtfd
    512          void zclBasicRtfdCommand(void)
    513          {
    514            zclSimpleClientCommand(ZCL_BASIC_CLUSTER_ID, 
    515                                   ZCL_RESET_TO_FACTORY_DEFAULTS_COMMAND_ID);
    516          }
    517          #endif
    518          

   \                                 In section .text, align 2, keep-with-next
    519          void zclMfgCodeCommand(void)
    520          {
   \                     zclMfgCodeCommand: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    521            if (zclCmdIsBuilt) {
   \   00000002   0x....             LDR.N    R4,??DataTable34
   \   00000004   0x7B20             LDRB     R0,[R4, #+12]
   \   00000006   0xB910             CBNZ.N   R0,??zclMfgCodeCommand_0
    522              emberAfAppPrintln("Command already built.  Cannot set MFG specific code for command.");
    523              return;
    524            }
    525            mfgSpecificId = (int16u)emberUnsignedCommandArgument(0);
   \   00000008   0x.... 0x....      BL       emberUnsignedCommandArgument
   \   0000000C   0x8260             STRH     R0,[R4, #+18]
    526            emberAfAppPrintln("MFG Code Set for next command: 0x%2X", mfgSpecificId);
    527          }
   \                     ??zclMfgCodeCommand_0: (+1)
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    528          

   \                                 In section .text, align 2, keep-with-next
    529          void zclXDefaultRespCommand(void)
    530          {
   \                     zclXDefaultRespCommand: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    531            disableDefaultResponse = (int8u)emberUnsignedCommandArgument(0);
   \   00000002   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000006   0x....             LDR.N    R1,??DataTable34
   \   00000008   0x7348             STRB     R0,[R1, #+13]
    532            emberAfAppPrintln("Disable Default Response Set for next command: 0x%X", disableDefaultResponse);
    533          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    534          

   \                                 In section .text, align 2, keep-with-next
    535          void zclTimeCommand(void)
    536          {
   \                     zclTimeCommand: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    537            emberAfSetTime(emberUnsignedCommandArgument(0));
   \   00000002   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000006   0xE8BD 0x4002      POP      {R1,LR}
   \   0000000A   0x.... 0x....      B.W      emberAfSetTime
    538          }
    539          
    540          #ifdef ZCL_USING_IDENTIFY_CLUSTER_CLIENT
    541          // zcl identify id <identify time:2>

   \                                 In section .text, align 2, keep-with-next
    542          void zclIdentifyIdCommand(void)
    543          {
    544            zclSimpleClientCommand(ZCL_IDENTIFY_CLUSTER_ID, ZCL_IDENTIFY_COMMAND_ID);
   \                     zclIdentifyIdCommand: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x....             B.N      ?Subroutine3
    545          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2103             MOVS     R1,#+3
   \                     ??Subroutine3_0: (+1)
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x....             B.N      zclSimpleCommand
    546          
    547          // zcl identify query

   \                                 In section .text, align 2, keep-with-next
    548          void zclIdentifyQueryCommand(void)
    549          {
    550            zclSimpleClientCommand(ZCL_IDENTIFY_CLUSTER_ID, ZCL_IDENTIFY_QUERY_COMMAND_ID);
   \                     zclIdentifyQueryCommand: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002                      REQUIRE ?Subroutine3
   \   00000002                      ;; // Fall through to label ?Subroutine3
    551          }
    552          
    553          // zcl identify trigger <effect id:1> <effect variant:1>

   \                                 In section .text, align 2, keep-with-next
    554          void zclIdentifyTriggerEffectCommand(void)
    555          {
    556            zclSimpleClientCommand(ZCL_IDENTIFY_CLUSTER_ID, ZCL_TRIGGER_EFFECT_COMMAND_ID);
   \                     zclIdentifyTriggerEffectCommand: (+1)
   \   00000000   0x2240             MOVS     R2,#+64
   \   00000002   0x....             B.N      ?Subroutine3
    557          }
    558          #endif // ZCL_USING_IDENTIFY_CLUSTER_CLIENT
    559          
    560          #ifdef ZCL_USING_IDENTIFY_CLUSTER_SERVER
    561          // zcl identify on <endpoint:1> <time:2>

   \                                 In section .text, align 2, keep-with-next
    562          void zclIdentifyOnCommand(void)
    563          {
   \                     zclIdentifyOnCommand: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    564            int16u time = (int16u)emberUnsignedCommandArgument(1);
   \   00000002   0x.... 0x....      BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_26: (+1)
   \   00000006   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    565            if (time == 0) {
   \   0000000A   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000000E   0xB910             CBNZ.N   R0,??zclIdentifyOnCommand_0
    566              time = 60;
   \   00000010   0x203C             MOVS     R0,#+60
   \   00000012   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    567            }
    568            emberAfWriteAttribute((int8u)emberUnsignedCommandArgument(0), // endpoint
    569                                  ZCL_IDENTIFY_CLUSTER_ID,
    570                                  ZCL_IDENTIFY_TIME_ATTRIBUTE_ID,
    571                                  CLUSTER_MASK_SERVER,
    572                                  (int8u *)&time,
    573                                  ZCL_INT16U_ATTRIBUTE_TYPE);
   \                     ??zclIdentifyOnCommand_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x....             B.N      ?Subroutine4
    574          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x.... 0x....      BL       emberUnsignedCommandArgument
   \   00000004   0x2121             MOVS     R1,#+33
   \   00000006   0x9101             STR      R1,[SP, #+4]
   \   00000008   0x2340             MOVS     R3,#+64
   \   0000000A   0xA902             ADD      R1,SP,#+8
   \   0000000C   0x9100             STR      R1,[SP, #+0]
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x2103             MOVS     R1,#+3
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x.... 0x....      BL       emberAfWriteAttribute
   \   00000018   0xBD07             POP      {R0-R2,PC}       ;; return
    575          
    576          // zcl identify off <endpoint:1>

   \                                 In section .text, align 2, keep-with-next
    577          void zclIdentifyOffCommand(void)
    578          {
   \                     zclIdentifyOffCommand: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    579            int16u time = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    580            emberAfWriteAttribute((int8u)emberUnsignedCommandArgument(0), // endpoint
    581                                  ZCL_IDENTIFY_CLUSTER_ID,
    582                                  ZCL_IDENTIFY_TIME_ATTRIBUTE_ID,
    583                                  CLUSTER_MASK_SERVER,
    584                                  (int8u *)&time,
    585                                  ZCL_INT16U_ATTRIBUTE_TYPE);
   \   00000008                      REQUIRE ?Subroutine4
   \   00000008                      ;; // Fall through to label ?Subroutine4
    586          }
    587          #else
    588          // TODO: the generated CLI is sucking in these methods regardless of whether or not it should;
    589          // I suspect it has to do with the segmentaton of CLI commands, and it should be fixed, but 
    590          // for now I'm stubbing them. - Jeremy
    591          void zclIdentifyOnCommand(void)
    592          {
    593          }
    594          
    595          void zclIdentifyOffCommand(void)
    596          {
    597          }
    598          #endif // ZCL_USING_IDENTIFY_CLUSTER_SERVER
    599          
    600          
    601          #ifdef ZCL_USING_GROUPS_CLUSTER_CLIENT
    602          // zcl groups add <group id:2> <name:16>
    603          // zcl groups ad-if-id <group id:2> <name:16>
    604          void zclGroupsAddCommand(void)
    605          {
    606            int8u commandId = (emberCurrentCommand->name[2] == 'd'
    607                               ? ZCL_ADD_GROUP_COMMAND_ID
    608                               : ZCL_ADD_GROUP_IF_IDENTIFYING_COMMAND_ID);
    609            zclSimpleClientCommand(ZCL_GROUPS_CLUSTER_ID, commandId);
    610          }
    611          
    612          // zcl groups view <group id:2>
    613          void zclGroupsViewCommand(void)
    614          {
    615            zclSimpleClientCommand(ZCL_GROUPS_CLUSTER_ID, ZCL_VIEW_GROUP_COMMAND_ID);
    616          }
    617          
    618          // zcl groups get <count:1> [<group id:2> * count]
    619          void zclGroupsGetCommand(void)
    620          {
    621            int8u i;
    622            int8u count = (int8u)emberUnsignedCommandArgument(0);
    623            zclBufferSetup(ZCL_CLUSTER_SPECIFIC_COMMAND
    624                           | ZCL_FRAME_CONTROL_CLIENT_TO_SERVER,
    625                           ZCL_GROUPS_CLUSTER_ID,
    626                           ZCL_GET_GROUP_MEMBERSHIP_COMMAND_ID);
    627            zclBufferAddByte(count); // group count
    628            for (i = 0; i < count; i++) {
    629              zclBufferAddWordFromArgument(1 + i);
    630            }
    631            cliBufferPrint();
    632          }
    633          
    634          // zcl groups remove <group id:2>
    635          void zclGroupsRemoveCommand(void)
    636          {
    637            zclSimpleClientCommand(ZCL_GROUPS_CLUSTER_ID, ZCL_REMOVE_GROUP_COMMAND_ID);
    638          }
    639          
    640          // zcl groups rmall
    641          void zclGroupsRemoveAllCommand(void)
    642          {
    643            zclSimpleClientCommand(ZCL_GROUPS_CLUSTER_ID, 
    644                                   ZCL_REMOVE_ALL_GROUPS_COMMAND_ID);
    645          }
    646          #else
    647          // TODO: the generated CLI is sucking in this method regardless of whether or not it should;
    648          // I suspect it has to do with the segmentaton of CLI commands, and it should be fixed, but 
    649          // for now I'm stubbing it. - Jeremy

   \                                 In section .text, align 2, keep-with-next
    650          void zclGroupsGetCommand(void) 
    651          {
    652          }
   \                     zclGroupsGetCommand: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    653          #endif //ZCL_USING_GROUPS_CLUSTER_CLIENT
    654          
    655          #ifdef ZCL_USING_SCENES_CLUSTER_CLIENT
    656          #ifdef ZCL_USING_ON_OFF_CLUSTER_CLIENT
    657          boolean addScenesOnOffValue;
    658          #endif
    659          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_CLIENT
    660          int8u addScenesLevelValue;
    661          #endif
    662          
    663          // zcl scenes add <groupId:2> <sceneId:1> <trans time:2> <name> <extensionFieldSets>
    664          // zcl scenes eadd <groupId:2> <sceneId:1> <trans time:2> <name> <extensionFieldSets>
    665          void zclScenesAddCommand(void)
    666          {
    667            zclBufferSetup(ZCL_CLUSTER_SPECIFIC_COMMAND
    668                           | ZCL_FRAME_CONTROL_CLIENT_TO_SERVER,
    669                           ZCL_SCENES_CLUSTER_ID,
    670                           (emberCurrentCommand->name[0] != 'e'
    671                            ? ZCL_ADD_SCENE_COMMAND_ID
    672                            : ZCL_ENHANCED_ADD_SCENE_COMMAND_ID));
    673            zclBufferAddWordFromArgument(0);
    674            zclBufferAddByteFromArgument(1);
    675            zclBufferAddWordFromArgument(2);
    676            zclBufferAddLengthAndStringFromArgument(3);
    677          
    678          #ifdef ZCL_USING_ON_OFF_CLUSTER_CLIENT
    679            // cluster:2 len:1 value:1 (on/off extension)
    680            zclBufferAddWord(ZCL_ON_OFF_CLUSTER_ID);
    681            zclBufferAddByte(1);
    682            zclBufferAddByte(addScenesOnOffValue);
    683          #endif //ZCL_USING_ON_OFF_CLUSTER_CLIENT
    684          
    685          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_CLIENT
    686            // cluster:2 len:1 value:1 (level control extension)
    687            zclBufferAddWord(ZCL_LEVEL_CONTROL_CLUSTER_ID);
    688            zclBufferAddByte(1);
    689            zclBufferAddByte(addScenesLevelValue);
    690          #endif //ZCL_USING_LEVEL_CONTROL_CLUSTER_CLIENT
    691          
    692            cliBufferPrint();
    693          }
    694          
    695          // zcl scenes view <groupId:2> <sceneId:1>
    696          // zcl scenes eview <groupId:2> <sceneId:1>
    697          void zclScenesViewCommand(void)
    698          {
    699            zclSimpleClientCommand(ZCL_SCENES_CLUSTER_ID,
    700                                   (emberCurrentCommand->name[0] != 'e'
    701                                    ? ZCL_VIEW_SCENE_COMMAND_ID
    702                                    : ZCL_ENHANCED_VIEW_SCENE_COMMAND_ID));
    703          }
    704          
    705          // zcl scenes remove <groupId:2> <sceneId:1>
    706          void zclScenesRemoveCommand(void)
    707          {
    708            zclSimpleClientCommand(ZCL_SCENES_CLUSTER_ID, ZCL_REMOVE_SCENE_COMMAND_ID);
    709          }
    710          
    711          // zcl scenes rmall <groupId:2>
    712          void zclScenesRemoveAllCommand(void)
    713          {
    714            zclSimpleClientCommand(ZCL_SCENES_CLUSTER_ID, ZCL_REMOVE_ALL_SCENES_COMMAND_ID);
    715          }
    716          
    717          // zcl scenes store <groupId:2> <sceneId:1>
    718          void zclScenesStoreCommand(void)
    719          {
    720            zclSimpleClientCommand(ZCL_SCENES_CLUSTER_ID, ZCL_STORE_SCENE_COMMAND_ID);
    721          }
    722          
    723          // zcl scenes recall <groupId:2> <sceneId:1>
    724          void zclScenesRecallCommand(void)
    725          {
    726            zclSimpleClientCommand(ZCL_SCENES_CLUSTER_ID, ZCL_RECALL_SCENE_COMMAND_ID);
    727          }
    728          
    729          // zcl scenes get <groupId:2>
    730          void zclScenesGetMembershipCommand(void)
    731          {
    732            zclSimpleClientCommand(ZCL_SCENES_CLUSTER_ID, ZCL_GET_SCENE_MEMBERSHIP_COMMAND_ID);
    733          }
    734          
    735          // zcl scenes copy <mode:1> <group id from:2> <scenes id from:1> <group id to:2> <scene id:1>
    736          void zclScenesCopyCommand(void)
    737          {
    738            zclSimpleClientCommand(ZCL_SCENES_CLUSTER_ID, ZCL_COPY_SCENE_COMMAND_ID);
    739          }
    740          
    741          // zcl scenes set [on|off] <level:1>
    742          void zclScenesSetCommand(void)
    743          {
    744          #ifdef ZCL_USING_ON_OFF_CLUSTER_CLIENT
    745            addScenesOnOffValue = (emberCurrentCommand->name[1] == 'n');
    746          #endif
    747          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_CLIENT
    748            addScenesLevelValue = (int8u)emberUnsignedCommandArgument(0);
    749          #endif
    750          }
    751          #endif //ZCL_USING_SCENES_CLUSTER_CLIENT
    752          
    753          #ifdef ZCL_USING_ON_OFF_CLUSTER_CLIENT
    754          // zcl on-off [ off | on | toggle ]

   \                                 In section .text, align 2, keep-with-next
    755          void zclOnOffCommand(void)
    756          {
    757            int8u secondChar = emberCurrentCommand->name[1];
   \                     zclOnOffCommand: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable34_2
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x7840             LDRB     R0,[R0, #+1]
    758            int8u commandId = (secondChar == 'n'
    759                               ? ZCL_ON_COMMAND_ID
    760                               : (secondChar == 'f'
    761                                  ? ZCL_OFF_COMMAND_ID
    762                                  : ZCL_TOGGLE_COMMAND_ID));
   \   00000008   0x286E             CMP      R0,#+110
   \   0000000A   0xBF08             IT       EQ 
   \   0000000C   0x2201             MOVEQ    R2,#+1
   \   0000000E   0xD003             BEQ.N    ??zclOnOffCommand_0
   \   00000010   0x2866             CMP      R0,#+102
   \   00000012   0xBF0C             ITE      EQ 
   \   00000014   0x2200             MOVEQ    R2,#+0
   \   00000016   0x2202             MOVNE    R2,#+2
    763            zclSimpleClientCommand(ZCL_ON_OFF_CLUSTER_ID, commandId);
   \                     ??zclOnOffCommand_0: (+1)
   \   00000018   0x2106             MOVS     R1,#+6
   \   0000001A   0x....             B.N      ??Subroutine3_0
    764          }
    765          
    766          // zcl on-off offeffect <effect id:1> <effect variant:1>

   \                                 In section .text, align 2, keep-with-next
    767          void zclOnOffOffWithEffectCommand(void)
    768          {
    769            zclSimpleClientCommand(ZCL_ON_OFF_CLUSTER_ID, ZCL_OFF_WITH_EFFECT_COMMAND_ID);
   \                     zclOnOffOffWithEffectCommand: (+1)
   \   00000000   0x2240             MOVS     R2,#+64
   \   00000002   0x2106             MOVS     R1,#+6
   \   00000004   0x....             B.N      ??Subroutine3_0
    770          }
    771          
    772          // zcl on-off onrecall

   \                                 In section .text, align 2, keep-with-next
    773          void zclOnOffOnWithRecallGlobalSceneCommand(void)
    774          {
    775            zclSimpleClientCommand(ZCL_ON_OFF_CLUSTER_ID,
    776                                   ZCL_ON_WITH_RECALL_GLOBAL_SCENE_COMMAND_ID);
   \                     zclOnOffOnWithRecallGlobalSceneCommand: (+1)
   \   00000000   0x2241             MOVS     R2,#+65
   \   00000002   0x2106             MOVS     R1,#+6
   \   00000004   0x....             B.N      ??Subroutine3_0
    777          }
    778          
    779          // zcl on-off ontimedoff <on off control:1> <on time:2> <off wait time:2>

   \                                 In section .text, align 2, keep-with-next
    780          void zclOnOffOnWithTimedOffCommand(void)
    781          {
    782            zclSimpleClientCommand(ZCL_ON_OFF_CLUSTER_ID,
    783                                   ZCL_ON_WITH_TIMED_OFF_COMMAND_ID);
   \                     zclOnOffOnWithTimedOffCommand: (+1)
   \   00000000   0x2242             MOVS     R2,#+66
   \   00000002   0x2106             MOVS     R1,#+6
   \   00000004   0x....             B.N      ??Subroutine3_0
    784          }
    785          
    786          #endif //ZCL_USING_ON_OFF_CLUSTER_CLIENT
    787          
    788          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_CLIENT
    789          // zcl level-control mv-to-level [level:1] [trans time:2]
    790          // zcl level-control o-mv-to-level [level:1] [trans time:2]

   \                                 In section .text, align 2, keep-with-next
    791          void zclLevelControlMoveToLevelCommand(void) 
    792          {
    793            int8u commandId = (emberCurrentCommand->name[0] == 'o'
    794                               ? ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID
    795                               : ZCL_MOVE_TO_LEVEL_COMMAND_ID);
   \                     zclLevelControlMoveToLevelCommand: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable34_2
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x286F             CMP      R0,#+111
   \   0000000A   0xBF0C             ITE      EQ 
   \   0000000C   0x2204             MOVEQ    R2,#+4
   \   0000000E   0x2200             MOVNE    R2,#+0
    796            zclSimpleClientCommand(ZCL_LEVEL_CONTROL_CLUSTER_ID, commandId);
   \   00000010   0x2108             MOVS     R1,#+8
   \   00000012   0x....             B.N      ??Subroutine3_0
    797          }
    798          
    799          // zcl level-control move [mode:1] [rate:1]
    800          // zcl level-control o-move [mode:1] [rate:1]

   \                                 In section .text, align 2, keep-with-next
    801          void zclLevelControlMoveCommand(void) 
    802          {
    803            int8u commandId = (emberCurrentCommand->name[0] == 'o'
    804                               ? ZCL_MOVE_WITH_ON_OFF_COMMAND_ID
    805                               : ZCL_MOVE_COMMAND_ID);
   \                     zclLevelControlMoveCommand: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable34_2
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x286F             CMP      R0,#+111
   \   0000000A   0xBF0C             ITE      EQ 
   \   0000000C   0x2205             MOVEQ    R2,#+5
   \   0000000E   0x2201             MOVNE    R2,#+1
    806            zclSimpleClientCommand(ZCL_LEVEL_CONTROL_CLUSTER_ID, commandId);
   \   00000010   0x2108             MOVS     R1,#+8
   \   00000012   0x....             B.N      ??Subroutine3_0
    807          }
    808          
    809          // zcl level-control step [step:1] [step size:1] [trans time:2]
    810          // zcl level-control o-step [step:1] [step size:1] [trans time:2]

   \                                 In section .text, align 2, keep-with-next
    811          void zclLevelControlStepCommand(void) 
    812          {
    813            int8u commandId = (emberCurrentCommand->name[0] == 'o'
    814                               ? ZCL_STEP_WITH_ON_OFF_COMMAND_ID
    815                               : ZCL_STEP_COMMAND_ID);
   \                     zclLevelControlStepCommand: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable34_2
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x286F             CMP      R0,#+111
   \   0000000A   0xBF0C             ITE      EQ 
   \   0000000C   0x2206             MOVEQ    R2,#+6
   \   0000000E   0x2202             MOVNE    R2,#+2
    816            zclSimpleClientCommand(ZCL_LEVEL_CONTROL_CLUSTER_ID, commandId);
   \   00000010   0x2108             MOVS     R1,#+8
   \   00000012   0x....             B.N      ??Subroutine3_0
    817          }
    818          
    819          // zcl level-control stop
    820          // zcl level-control ostop

   \                                 In section .text, align 2, keep-with-next
    821          void zclLevelControlStopCommand(void) 
    822          {
    823            int8u commandId = (emberCurrentCommand->name[0] == 'o'
    824                               ? ZCL_STOP_WITH_ON_OFF_COMMAND_ID
    825                               : ZCL_STOP_COMMAND_ID);
   \                     zclLevelControlStopCommand: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable34_2
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x286F             CMP      R0,#+111
   \   0000000A   0xBF0C             ITE      EQ 
   \   0000000C   0x2207             MOVEQ    R2,#+7
   \   0000000E   0x2203             MOVNE    R2,#+3
    826            zclSimpleClientCommand(ZCL_LEVEL_CONTROL_CLUSTER_ID, commandId);
   \   00000010   0x2108             MOVS     R1,#+8
   \   00000012   0x....             B.N      ??Subroutine3_0
    827          }
    828          #endif //ZCL_USING_LEVEL_CONTROL_CLUSTER_CLIENT
    829          
    830          #ifdef ZCL_USING_THERMOSTAT_CLUSTER_CLIENT
    831          // zcl tstat set <mode:1 int> <amount:1 int>
    832          void zclThermostatSetCommand(void)
    833          {
    834            zclSimpleClientCommand(ZCL_THERMOSTAT_CLUSTER_ID, 
    835                                   ZCL_SETPOINT_RAISE_LOWER_COMMAND_ID);
    836          }
    837          #endif // ZCL_USING_THERMOSTAT_CLUSTER_CLIENT
    838          
    839          #ifdef ZCL_USING_IAS_ZONE_CLUSTER_SERVER
    840          // zcl ias-zone enroll <zone type: 2 int> <manuf code: 2 int>
    841          void zclIasZoneEnrollCommand(void)
    842          {
    843            zclSimpleServerCommand(ZCL_IAS_ZONE_CLUSTER_ID, 
    844                                   ZCL_ZONE_ENROLL_REQUEST_COMMAND_ID);
    845            globalApsFrame.options |= EMBER_APS_OPTION_SOURCE_EUI64;
    846          }
    847          
    848          // zcl ias-zone sc <zone status: 2 int> <ext status: 1 int> <zone id: 1 int> <delay: 2 int>
    849          void zclIasZoneStatusChangeCommand(void)
    850          {
    851            zclSimpleServerCommand(ZCL_IAS_ZONE_CLUSTER_ID,
    852                                   ZCL_ZONE_STATUS_CHANGE_NOTIFICATION_COMMAND_ID);
    853            globalApsFrame.options |= EMBER_APS_OPTION_SOURCE_EUI64;
    854          }
    855          #endif // ZCL_USING_IAS_ZONE_CLUSTER_SERVER
    856          
    857          #ifdef ZCL_USING_IAS_ACE_CLUSTER_CLIENT
    858          // zcl ias-ace a <int:1>
    859          void zclIasAceArmCommand(void)
    860          {
    861            zclSimpleClientCommand(ZCL_IAS_ACE_CLUSTER_ID, ZCL_ARM_COMMAND_ID);
    862          }
    863          
    864          // zcl ias-ace b <zones as hex string>
    865          void zclIasAceBypassCommand(void)
    866          {
    867            zclSimpleClientCommand(ZCL_IAS_ACE_CLUSTER_ID, ZCL_BYPASS_COMMAND_ID);
    868          }
    869          
    870          // zcl ias-ace e
    871          void zclIasAceEmergencyCommand(void)
    872          {
    873            zclSimpleClientCommand(ZCL_IAS_ACE_CLUSTER_ID, ZCL_EMERGENCY_COMMAND_ID);
    874          }
    875          
    876          // zcl ias-ace f
    877          void zclIasAceFireCommand(void)
    878          {
    879            zclSimpleClientCommand(ZCL_IAS_ACE_CLUSTER_ID, ZCL_FIRE_COMMAND_ID);
    880          }
    881          
    882          // zcl ias-ace p
    883          void zclIasAcePanicCommand(void)
    884          {
    885            zclSimpleClientCommand(ZCL_IAS_ACE_CLUSTER_ID, ZCL_PANIC_COMMAND_ID);
    886          }
    887          
    888          // zcl ias-ace getzm
    889          void zclIasAceGetZoneMapCommand(void)
    890          {
    891            zclSimpleClientCommand(ZCL_IAS_ACE_CLUSTER_ID, 
    892                                   ZCL_GET_ZONE_ID_MAP_COMMAND_ID);
    893          }
    894          
    895          // zcl ias-ace getzi <zone id:1>
    896          void zclIasAceGetZoneInfoCommand(void)
    897          {
    898            zclSimpleClientCommand(ZCL_IAS_ACE_CLUSTER_ID, 
    899                                   ZCL_GET_ZONE_INFORMATION_COMMAND_ID);
    900          }
    901          #endif // ZCL_USING_IAS_ACE_CLUSTER_CLIENT
    902          
    903          #ifdef ZCL_USING_COLOR_CONTROL_CLUSTER_CLIENT
    904          // zcl colorcontrol movetohue <hue:1> <direction:1> <transition time:2>
    905          // zcl colorcontrol emovetohue <enhanced hue:2> <direction:1> <transition time:2>
    906          void zclColorControlMoveToHueCommand(void)
    907          {
    908            zclSimpleClientCommand(ZCL_COLOR_CONTROL_CLUSTER_ID,
    909                                   (emberCurrentCommand->name[0] != 'e'
    910                                    ? ZCL_MOVE_TO_HUE_COMMAND_ID
    911                                    : ZCL_ENHANCED_MOVE_TO_HUE_COMMAND_ID));
    912          }
    913          
    914          // zcl colorcontrol movehue <move mode:1> <rate:1>
    915          // zcl colorcontrol emovehue <move mode:1> <rate:2>
    916          void zclColorControlMoveHueCommand(void)
    917          {
    918            zclSimpleClientCommand(ZCL_COLOR_CONTROL_CLUSTER_ID,
    919                                   (emberCurrentCommand->name[0] != 'e'
    920                                    ? ZCL_MOVE_HUE_COMMAND_ID
    921                                    : ZCL_ENHANCED_MOVE_HUE_COMMAND_ID));
    922          }
    923          
    924          // zcl colorcontrol stephue <step mode:1> <step size:1> <transition time:1>
    925          // zcl colorcontrol estephue <step mode:1> <step size:2> <transition time:2>
    926          void zclColorControlStepHueCommand(void)
    927          {
    928            zclSimpleClientCommand(ZCL_COLOR_CONTROL_CLUSTER_ID,
    929                                   (emberCurrentCommand->name[0] != 'e'
    930                                    ? ZCL_STEP_HUE_COMMAND_ID
    931                                    : ZCL_ENHANCED_STEP_HUE_COMMAND_ID));
    932          }
    933          
    934          // zcl colorcontrol movetosat <saturation:1> <transition time:2>
    935          void zclColorControlMoveToSatCommand(void)
    936          {
    937            zclSimpleClientCommand(ZCL_COLOR_CONTROL_CLUSTER_ID,
    938                                   ZCL_MOVE_TO_SATURATION_COMMAND_ID);
    939          }
    940          
    941          // zcl colorcontrol movesat <move mode:1> <rate:1>
    942          void zclColorControlMoveSatCommand(void)
    943          {
    944            zclSimpleClientCommand(ZCL_COLOR_CONTROL_CLUSTER_ID,
    945                                   ZCL_MOVE_SATURATION_COMMAND_ID);
    946          }
    947          
    948          // zcl colorcontrol stepsat <step mode:1> <step size:1> <transition time:1>
    949          void zclColorControlStepSatCommand(void)
    950          {
    951            zclSimpleClientCommand(ZCL_COLOR_CONTROL_CLUSTER_ID,
    952                                   ZCL_STEP_SATURATION_COMMAND_ID);
    953          }
    954          
    955          // zcl colorcontrol movetohueandsat <hue:1> <saturation:1> <transition time:2>
    956          // zcl colorcontrol emovetohueandsat <enhanced hue:2> <saturation:1> <transition time:2>
    957          void zclColorControlMoveToHueAndSatCommand(void)
    958          {
    959            zclSimpleClientCommand(ZCL_COLOR_CONTROL_CLUSTER_ID,
    960                                   (emberCurrentCommand->name[0] != 'e'
    961                                    ? ZCL_MOVE_TO_HUE_AND_SATURATION_COMMAND_ID
    962                                    : ZCL_ENHANCED_MOVE_TO_HUE_AND_SATURATION_COMMAND_ID));
    963          }
    964          
    965          // zcl colorcontrol movetocolor <color x:2> <color y:2> <transition time:2>
    966          void zclColorControlMoveToColorCommand(void)
    967          {
    968            zclSimpleClientCommand(ZCL_COLOR_CONTROL_CLUSTER_ID,
    969                                   ZCL_MOVE_TO_COLOR_COMMAND_ID);
    970          }
    971          
    972          // zcl colorcontrol movecolor <rate x:2> <rate y:2>
    973          // zcl colorcontrol movecolortemp <move mode:1> <rate:2> <color temperature min:2> <color temperature max:2>
    974          void zclColorControlMoveColorCommand(void)
    975          {
    976            zclSimpleClientCommand(ZCL_COLOR_CONTROL_CLUSTER_ID,
    977                                   (emberCurrentCommand->argumentTypes[0] == 'v'
    978                                    ? ZCL_MOVE_COLOR_COMMAND_ID
    979                                    : ZCL_MOVE_COLOR_TEMPERATURE_COMMAND_ID));
    980          }
    981          
    982          // zcl colorcontrol stepcolor <step x:2> <step y:2> <transition time:2>
    983          // zcl colorcontrol stepcolortemp <step mode:1> <step size:2> <transition time:2> <color temperature min:2> <color temperature max:2>
    984          void zclColorControlStepColorCommand(void)
    985          {
    986            zclSimpleClientCommand(ZCL_COLOR_CONTROL_CLUSTER_ID,
    987                                   (emberCurrentCommand->argumentTypes[0] == 'v'
    988                                    ? ZCL_STEP_COLOR_COMMAND_ID
    989                                    : ZCL_STEP_COLOR_TEMPERATUE_COMMAND_ID));
    990          }
    991          
    992          // zcl colorcontrol movetocolortemp <color temperature:2> <transition time:2>
    993          void zclColorControlMoveToColorTemperatureCommand(void)
    994          {
    995            zclSimpleClientCommand(ZCL_COLOR_CONTROL_CLUSTER_ID,
    996                                   ZCL_MOVE_TO_COLOR_TEMPERATURE_COMMAND_ID);
    997          }
    998          
    999          // zcl colorcontrol loop <update flags:1> <action:1> <direction:1> <time:2> <start hue:2>
   1000          void zclColorControlColorLoopSetCommand(void)
   1001          {
   1002            zclSimpleClientCommand(ZCL_COLOR_CONTROL_CLUSTER_ID,
   1003                                   ZCL_COLOR_LOOP_SET_COMMAND_ID);
   1004          }
   1005          
   1006          // zcl colorcontrol stopmovestep
   1007          void zclColorControlStopMoveStepCommand(void)
   1008          {
   1009            zclSimpleClientCommand(ZCL_COLOR_CONTROL_CLUSTER_ID,
   1010                                   ZCL_STOP_MOVE_STEP_COMMAND_ID);
   1011          }
   1012          #endif // ZCL_USING_COLOR_CONTROL_CLUSTER_CLIENT
   1013          
   1014          #ifdef ZCL_USING_POLL_CONTROL_CLUSTER_CLIENT
   1015          void zclPollControlFastPollStopCommand(void)
   1016          {
   1017            zclSimpleClientCommand(ZCL_POLL_CONTROL_CLUSTER_ID,
   1018                                   ZCL_FAST_POLL_STOP_COMMAND_ID);
   1019          }
   1020          
   1021          // zcl poll-control long <long poll interval:4>
   1022          // zcl poll-control short <short poll interval:2>
   1023          void zclPollControlSetPollIntervalCommand(void)
   1024          {
   1025            zclSimpleClientCommand(ZCL_POLL_CONTROL_CLUSTER_ID,
   1026                                   (emberCurrentCommand->name[0] == 'l'
   1027                                    ? ZCL_SET_LONG_POLL_INTERVAL_COMMAND_ID
   1028                                    : ZCL_SET_SHORT_POLL_INTERVAL_COMMAND_ID));
   1029          }
   1030          #endif
   1031          
   1032          #ifdef ZCL_USING_POWER_PROFILE_CLUSTER_CLIENT
   1033          //zcl power-profile profile <profile id:1>
   1034          void zclPowerProfileRequestCommand(void)
   1035          {
   1036            zclSimpleClientCommand(ZCL_POWER_PROFILE_CLUSTER_ID,
   1037                                   ZCL_POWER_PROFILE_REQUEST_COMMAND_ID);
   1038          }
   1039          
   1040          //zcl power-profile state
   1041          void zclPowerProfileStateRequestCommand(void)
   1042          {
   1043            zclSimpleClientCommand(ZCL_POWER_PROFILE_CLUSTER_ID,
   1044                                   ZCL_POWER_PROFILE_STATE_REQUEST_COMMAND_ID);
   1045          }
   1046          
   1047          //zcl power-profile energy-phases-schedule <profile id:1> <num scheduled phases:1> [<energy phase ID:1> <scheduled time:2> * num scheduled phases]
   1048          void zclPowerProfileEnergyPhasesScheduleNotificationCommand(void)
   1049          {
   1050            int8u i;
   1051            int8u numScheduledPhases = (int8u)emberUnsignedCommandArgument(1);
   1052            
   1053            //Check if an even number of args and minimum number of args were supplied
   1054            if(emberCommandArgumentCount()&1 || emberCommandArgumentCount() < 2)
   1055            {
   1056              emberAfGuaranteedPrintln("Wrong number of args");
   1057              emberAfGuaranteedPrintln("Usage:");
   1058              emberAfGuaranteedPrint("<profile id:1> <num scheduled phases:1> ");
   1059              emberAfGuaranteedPrint("[<energy phase ID:1> <scheduled time:2> * ");
   1060              emberAfGuaranteedPrintln("num scheduled phases]");
   1061            } else {
   1062              zclBufferSetup(ZCL_CLUSTER_SPECIFIC_COMMAND
   1063                           | ZCL_FRAME_CONTROL_CLIENT_TO_SERVER,
   1064                           ZCL_POWER_PROFILE_CLUSTER_ID,
   1065                           ZCL_ENERGY_PHASES_SCHEDULE_NOTIFICATION_COMMAND_ID);
   1066                
   1067              zclBufferAddByteFromArgument(0);   // profile id
   1068              zclBufferAddByte(numScheduledPhases); // number scheduled phase count
   1069              
   1070              //Add energy phase ID and scheduled time pairs
   1071              for (i = 2; (i+1) < emberCommandArgumentCount(); i+=2) {
   1072                zclBufferAddByteFromArgument(i);
   1073                zclBufferAddWordFromArgument(i+1);
   1074              }
   1075              cliBufferPrint();
   1076            }
   1077          }
   1078          
   1079          //zcl power-profile schedule-constraints <profile id:1>
   1080          void zclPowerProfileScheduleConstraintsRequestCommand(void)
   1081          {
   1082            zclSimpleClientCommand(ZCL_POWER_PROFILE_CLUSTER_ID,
   1083                                   ZCL_POWER_PROFILE_SCHEDULE_CONSTRAINTS_REQUEST_COMMAND_ID);
   1084          }
   1085          
   1086          //zcl power-profile energy-phases-schedule-states <profile id:1>
   1087          void zclPowerProfileEnergyPhasesScheduleStateRequestCommand(void)
   1088          {
   1089            zclSimpleClientCommand(ZCL_POWER_PROFILE_CLUSTER_ID,
   1090                                   ZCL_ENERGY_PHASES_SCHEDULE_STATE_REQUEST_COMMAND_ID);
   1091          }
   1092          #endif //ZCL_USING_POWER_PROFILE_CLUSTER_CLIENT
   1093          
   1094          #ifdef ZCL_USING_WINDOW_COVERING_CLUSTER_CLIENT
   1095          static void zclWindowCoveringUpCommand(void)
   1096          {
   1097            zclSimpleClientCommand(ZCL_WINDOW_COVERING_CLUSTER_ID,
   1098                                   ZCL_WINDOW_COVERING_UP_OPEN_COMMAND_ID);
   1099          }
   1100          
   1101          static void zclWindowCoveringDownCommand(void)
   1102          {
   1103            zclSimpleClientCommand(ZCL_WINDOW_COVERING_CLUSTER_ID,
   1104                                   ZCL_WINDOW_COVERING_DOWN_CLOSE_COMMAND_ID);
   1105          }
   1106          
   1107          static void zclWindowCoveringStopCommand(void)
   1108          {
   1109            zclSimpleClientCommand(ZCL_WINDOW_COVERING_CLUSTER_ID,
   1110                                   ZCL_WINDOW_COVERING_STOP_COMMAND_ID);
   1111          }
   1112          
   1113          static void zclWindowCoveringGoToLiftValueCommand(void)
   1114          {
   1115            zclSimpleClientCommand(ZCL_WINDOW_COVERING_CLUSTER_ID,
   1116                                   ZCL_WINDOW_COVERING_GO_TO_LIFT_VALUE_COMMAND_ID);
   1117          }
   1118          
   1119          static void zclWindowCoveringGoToLiftPercentageCommand(void)
   1120          {
   1121            zclSimpleClientCommand(ZCL_WINDOW_COVERING_CLUSTER_ID,
   1122                                   ZCL_WINDOW_COVERING_GO_TO_LIFT_PERCENTAGE_COMMAND_ID);
   1123          }
   1124          
   1125          static void zclWindowCoveringGoToTiltValueCommand(void)
   1126          {
   1127            zclSimpleClientCommand(ZCL_WINDOW_COVERING_CLUSTER_ID,
   1128                                   ZCL_WINDOW_COVERING_GO_TO_TILT_VALUE_COMMAND_ID);
   1129          }
   1130          
   1131          static void zclWindowCoveringGoToTiltPercentageCommand(void)
   1132          {
   1133            zclSimpleClientCommand(ZCL_WINDOW_COVERING_CLUSTER_ID,
   1134                                   ZCL_WINDOW_COVERING_GO_TO_TILT_PERCENTAGE_COMMAND_ID);
   1135          }
   1136          #endif //ZCL_USING_WINDOW_COVERING_CLUSTER_CLIENT
   1137          
   1138          #ifdef ZCL_USING_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_SERVER
   1139          // zcl drlc lce <eventId:4> <start:4> <duration:2> <event control:1>
   1140          void zclDrlcLoadControlEventCommand(void)
   1141          {
   1142            zclBufferSetup(ZCL_CLUSTER_SPECIFIC_COMMAND
   1143                           | ZCL_FRAME_CONTROL_SERVER_TO_CLIENT,
   1144                           ZCL_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_ID,
   1145                           ZCL_LOAD_CONTROL_EVENT_COMMAND_ID);
   1146            zclBufferAddInt32FromArgument(0);  // event id
   1147            zclBufferAddWord(0x0fff);          // all device classes
   1148            zclBufferAddByte(0);               // all uegs
   1149            zclBufferAddInt32FromArgument(1);  // start
   1150            zclBufferAddWordFromArgument(2);   // duration
   1151            zclBufferAddByte(1);               // criticality level, normal
   1152            zclBufferAddByte(0);               // 1.1c cooling temp offset
   1153            zclBufferAddByte(0);               // 1.1c heating temp offset
   1154            zclBufferAddWord(0x1a09);          // cool temp set point 23.3c
   1155            zclBufferAddWord(0x1a09);          // heat temp set point
   1156            zclBufferAddByte(0x0a);            // -10% avg load percent
   1157            zclBufferAddByte(0);               // duty cycle
   1158            zclBufferAddByteFromArgument(3);   // event control
   1159            globalApsFrame.options |= EMBER_APS_OPTION_SOURCE_EUI64;
   1160            cliBufferPrint();
   1161          }
   1162          
   1163          // zcl drlc cl <eventId:4> <device class:2> <ueg: 1> <cancel control: 1> <start time:4>
   1164          void zclDrlcCancelCommand(void)
   1165          {
   1166            zclSimpleServerCommand(ZCL_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_ID,
   1167                                   ZCL_CANCEL_LOAD_CONTROL_EVENT_COMMAND_ID);
   1168            globalApsFrame.options |= EMBER_APS_OPTION_SOURCE_EUI64;
   1169          }
   1170          
   1171          // zcl drlc ca
   1172          void zclDrlcCancelAllCommand(void)
   1173          {
   1174            zclBufferSetup(ZCL_CLUSTER_SPECIFIC_COMMAND
   1175                           | ZCL_FRAME_CONTROL_SERVER_TO_CLIENT,
   1176                           ZCL_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_ID,
   1177                           ZCL_CANCEL_ALL_LOAD_CONTROL_EVENTS_COMMAND_ID);
   1178            zclBufferAddByte(0);  // bogus time
   1179            globalApsFrame.options |= EMBER_APS_OPTION_SOURCE_EUI64;
   1180            cliBufferPrint();
   1181          }
   1182          
   1183          #else
   1184          // TODO: the generated CLI is sucking in this method regardless of whether or not it should;
   1185          // I suspect it has to do with the segmentaton of CLI commands, and it should be fixed, but 
   1186          // for now I'm stubbing it. - Jeremy

   \                                 In section .text, align 2, keep-with-next
   1187          void zclDrlcLoadControlEventCommand(void)
   1188          {
   1189          }
   \                     zclDrlcLoadControlEventCommand: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1190          
   1191          #endif //ZCL_USING_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_SERVER
   1192          
   1193          #ifdef ZCL_USING_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_CLIENT
   1194          // zcl drlc gse <start time:4> <number of events:1>
   1195          void zclDrlcGetScheduledEventsCommand(void)
   1196          {
   1197            zclSimpleClientCommand(ZCL_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_ID,
   1198                                   ZCL_GET_SCHEDULED_EVENTS_COMMAND_ID);
   1199          }
   1200          
   1201          #endif //ZCL_USING_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_CLIENT
   1202          
   1203          
   1204          #ifdef ZCL_USING_SIMPLE_METERING_CLUSTER_CLIENT
   1205          // zcl sm  gp <type:1> <time:4> <intervals:1>
   1206          void zclSimpleMeteringGetProfileCommand(void)
   1207          {
   1208            zclSimpleClientCommand(ZCL_SIMPLE_METERING_CLUSTER_ID,
   1209                                   ZCL_GET_PROFILE_COMMAND_ID);
   1210          }
   1211          
   1212          // zcl sm fp <update period:1> <duration:1>
   1213          void zclSimpleMeteringFastPollCommand(void)
   1214          {
   1215            zclSimpleClientCommand(ZCL_SIMPLE_METERING_CLUSTER_ID,
   1216                                   ZCL_REQUEST_FAST_POLL_MODE_COMMAND_ID);
   1217          }
   1218          #endif //ZCL_USING_SIMPLE_METERING_CLUSTER_CLIENT
   1219          
   1220          #ifdef ZCL_USING_SIMPLE_METERING_CLUSTER_SERVER
   1221          // zcl sm rm
   1222          void zclSimpleMeteringRequestMirrorCommand(void)
   1223          {
   1224            zclSimpleServerCommand(ZCL_SIMPLE_METERING_CLUSTER_ID,
   1225                                   ZCL_REQUEST_MIRROR_COMMAND_ID);
   1226          }
   1227          
   1228          // zcl sm dm
   1229          void zclSimpleMeteringDeleteMirrorCommand(void)
   1230          {
   1231            zclSimpleServerCommand(ZCL_SIMPLE_METERING_CLUSTER_ID,
   1232                                   ZCL_MIRROR_REMOVED_COMMAND_ID);
   1233          }
   1234          #endif //ZCL_USING_SIMPLE_METERING_CLUSTER_SERVER
   1235          
   1236          #ifdef ZCL_USING_PRICE_CLUSTER_CLIENT
   1237          // zcl price current
   1238          void zclPriceGetCurrentCommand(void)
   1239          {
   1240            zclBufferSetup(ZCL_CLUSTER_SPECIFIC_COMMAND
   1241                           | ZCL_FRAME_CONTROL_CLIENT_TO_SERVER,
   1242                           ZCL_PRICE_CLUSTER_ID,
   1243                           ZCL_GET_CURRENT_PRICE_COMMAND_ID);
   1244            zclBufferAddByte(0);  // command options
   1245            cliBufferPrint();
   1246          }
   1247          
   1248          // zcl price scheduled <startTime:4> <num-events:1>
   1249          void zclPriceGetScheduleCommand(void)
   1250          {
   1251            zclSimpleClientCommand(ZCL_PRICE_CLUSTER_ID,
   1252                                   ZCL_GET_SCHEDULED_PRICES_COMMAND_ID);
   1253          }
   1254          #endif //ZCL_USING_PRICE_CLUSTER_CLIENT
   1255          
   1256          
   1257          #ifdef ZCL_USING_MESSAGING_CLUSTER_CLIENT
   1258          // zcl message get
   1259          void zclMessageGetCommand(void)
   1260          {
   1261            zclSimpleClientCommand(ZCL_MESSAGING_CLUSTER_ID,
   1262                                   ZCL_GET_LAST_MESSAGE_COMMAND_ID);
   1263          }
   1264          #endif //ZCL_USING_MESSAGING_CLUSTER_CLIENT
   1265          
   1266          #ifdef ZCL_USING_GENERIC_TUNNEL_CLUSTER_CLIENT
   1267          // zcl tunnel match <address bytes>
   1268          void zclTunnelMatchCommand(void)
   1269          {
   1270            zclSimpleClientCommand(ZCL_GENERIC_TUNNEL_CLUSTER_ID,
   1271                                   ZCL_MATCH_PROTOCOL_ADDRESS_COMMAND_ID);
   1272          }
   1273          #endif //ZCL_USING_GENERIC_TUNNEL_CLUSTER_CLIENT
   1274          
   1275          #ifdef ZCL_USING_GENERIC_TUNNEL_CLUSTER_SERVER
   1276          // zcl tunnel advertise <address bytes>
   1277          void zclTunnelAdvertiseCommand(void)
   1278          {
   1279            zclSimpleServerCommand(ZCL_GENERIC_TUNNEL_CLUSTER_ID,
   1280                                   ZCL_ADVERTISE_PROTOCOL_ADDRESS_COMMAND_ID);
   1281          }
   1282          
   1283          // zcl tunnel response
   1284          void zclTunnelResponseCommand(void)
   1285          {
   1286            zclSimpleServerCommand(ZCL_GENERIC_TUNNEL_CLUSTER_ID,
   1287                                   ZCL_MATCH_PROTOCOL_ADDRESS_RESPONSE_COMMAND_ID);
   1288          }
   1289          #endif //ZCL_USING_GENERIC_TUNNEL_CLUSTER_SERVER
   1290          
   1291          #ifdef ZCL_USING_BACNET_PROTOCOL_TUNNEL_CLUSTER_CLIENT
   1292          // zcl bacnet transfer-npdu fixed <length:1> <bytes>
   1293          void zclBacnetTransferFixedCommand(void)
   1294          {
   1295            // not done yet
   1296          }
   1297          
   1298          // zcl bacnet transfer-npdu random <length:1>
   1299          void zclBacnetTransferRandomCommand(void)
   1300          {
   1301            int8u i;
   1302            int8u length = (int8u)emberUnsignedCommandArgument(0);
   1303            zclBufferSetup(ZCL_CLUSTER_SPECIFIC_COMMAND
   1304                           | ZCL_FRAME_CONTROL_CLIENT_TO_SERVER,
   1305                           ZCL_BACNET_PROTOCOL_TUNNEL_CLUSTER_ID,
   1306                           ZCL_TRANSFER_NPDU_COMMAND_ID);
   1307            zclBufferAddByte(length);
   1308            for (i = 0; i < length; i++) {
   1309              zclBufferAddByte(LOW_BYTE(halCommonGetRandom()));
   1310            }
   1311            cliBufferPrint();  
   1312          }
   1313          
   1314          // zcl bacnet transfer-npdu whois
   1315          void zclBacnetTransferWhoisCommand(void)
   1316          {
   1317            zclBufferSetup(ZCL_CLUSTER_SPECIFIC_COMMAND
   1318                           | ZCL_FRAME_CONTROL_CLIENT_TO_SERVER,
   1319                           ZCL_BACNET_PROTOCOL_TUNNEL_CLUSTER_ID,
   1320                           ZCL_TRANSFER_NPDU_COMMAND_ID);
   1321            //zclBufferAddByte(0);            // what is this?
   1322            zclBufferAddInt32(0xFFFF2001);
   1323            zclBufferAddInt32(0x0810FF00);
   1324            cliBufferPrint();
   1325          }
   1326          #endif //ZCL_USING_BACNET_PROTOCOL_TUNNEL_CLUSTER_CLIENT
   1327          
   1328          #ifdef ZCL_USING_DOOR_LOCK_CLUSTER_CLIENT
   1329          // zcl lock [ lock | unlock ]
   1330          void zclDoorLockCommand(void)
   1331          {
   1332            zclSimpleClientCommand(ZCL_DOOR_LOCK_CLUSTER_ID,
   1333                                   (emberCurrentCommand->name[0] == 'l'
   1334                                    ? ZCL_LOCK_DOOR_COMMAND_ID
   1335                                    : ZCL_UNLOCK_DOOR_COMMAND_ID));
   1336          }
   1337          #endif //ZCL_USING_DOOR_LOCK_CLUSTER_CLIENT
   1338          
   1339          #ifdef ZCL_USING_TUNNELING_CLUSTER_CLIENT
   1340          // zcl tunneling request <protocol id:1> <manufacturer code:2> <flow control:1> <maxIncomingTxSize:2>
   1341          void zclTunnelingRequestCommand(void)
   1342          {
   1343            zclSimpleClientCommand(ZCL_TUNNELING_CLUSTER_ID,
   1344                                   ZCL_REQUEST_TUNNEL_COMMAND_ID);
   1345            globalApsFrame.options |= EMBER_APS_OPTION_SOURCE_EUI64;
   1346          }
   1347          
   1348          // zcl tunneling close <tunnel id:2>
   1349          void zclTunnelingCloseCommand(void)
   1350          {
   1351            zclSimpleClientCommand(ZCL_TUNNELING_CLUSTER_ID,
   1352                                   ZCL_CLOSE_TUNNEL_COMMAND_ID);
   1353            globalApsFrame.options |= EMBER_APS_OPTION_SOURCE_EUI64;
   1354          }
   1355          
   1356          // zcl tunneling transfer-to-server <tunnel id:2> <data>
   1357          void zclTunnelingTransferToServerCommand(void)
   1358          {
   1359            zclBufferSetup(ZCL_CLUSTER_SPECIFIC_COMMAND
   1360                           | ZCL_FRAME_CONTROL_CLIENT_TO_SERVER,
   1361                           ZCL_TUNNELING_CLUSTER_ID,
   1362                           ZCL_TRANSFER_DATA_CLIENT_TO_SERVER_COMMAND_ID);
   1363            zclBufferAddWordFromArgument(0);              // tunnel id
   1364            appZclBufferLen += emberCopyStringArgument(1, // data
   1365                                                       appZclBuffer + appZclBufferLen,
   1366                                                       0xFF,   // copy as much data as possible
   1367                                                       FALSE); // no padding
   1368            globalApsFrame.options |= EMBER_APS_OPTION_SOURCE_EUI64;
   1369            cliBufferPrint();
   1370          }
   1371          
   1372          // zcl tunneling random-to-server <tunnel id:2> <length:2>
   1373          void zclTunnelingRandomToServerCommand(void)
   1374          {
   1375            int16u length = (int16u)emberUnsignedCommandArgument(1); // length of random data
   1376            zclBufferSetup(ZCL_CLUSTER_SPECIFIC_COMMAND
   1377                           | ZCL_FRAME_CONTROL_CLIENT_TO_SERVER,
   1378                           ZCL_TUNNELING_CLUSTER_ID,
   1379                           ZCL_TRANSFER_DATA_CLIENT_TO_SERVER_COMMAND_ID);
   1380            zclBufferAddWordFromArgument(0); // tunnel id
   1381            appZclBufferLen = (appZclBufferLen + length < APP_ZCL_BUFFER_SIZE
   1382                               ? appZclBufferLen + length
   1383                               : APP_ZCL_BUFFER_SIZE);
   1384            globalApsFrame.options |= EMBER_APS_OPTION_SOURCE_EUI64;
   1385            cliBufferPrint();
   1386          }
   1387          #endif //ZCL_USING_TUNNELING_CLUSTER_CLIENT
   1388          
   1389          #ifdef ZCL_USING_TUNNELING_CLUSTER_SERVER
   1390          // zcl tunneling transfer-to-client <tunnel id:2> <data>
   1391          void zclTunnelingTransferToClientCommand(void)
   1392          {
   1393            zclBufferSetup(ZCL_CLUSTER_SPECIFIC_COMMAND
   1394                           | ZCL_FRAME_CONTROL_SERVER_TO_CLIENT,
   1395                           ZCL_TUNNELING_CLUSTER_ID,
   1396                           ZCL_TRANSFER_DATA_SERVER_TO_CLIENT_COMMAND_ID);
   1397            zclBufferAddWordFromArgument(0);              // tunnel id
   1398            appZclBufferLen += emberCopyStringArgument(1, // data
   1399                                                       appZclBuffer + appZclBufferLen,
   1400                                                       0xFF,   // copy as much data as possible
   1401                                                       FALSE); // no padding
   1402            globalApsFrame.options |= EMBER_APS_OPTION_SOURCE_EUI64;
   1403            cliBufferPrint();
   1404          }
   1405          
   1406          // zcl tunneling random-to-client <tunnel id:2> <length:2>
   1407          void zclTunnelingRandomToClientCommand(void)
   1408          {
   1409            int16u length = (int16u)emberUnsignedCommandArgument(1); // length of random data
   1410            zclBufferSetup(ZCL_CLUSTER_SPECIFIC_COMMAND
   1411                           | ZCL_FRAME_CONTROL_SERVER_TO_CLIENT,
   1412                           ZCL_TUNNELING_CLUSTER_ID,
   1413                           ZCL_TRANSFER_DATA_SERVER_TO_CLIENT_COMMAND_ID);
   1414            zclBufferAddWordFromArgument(0); // tunnel id
   1415            appZclBufferLen = (appZclBufferLen + length < APP_ZCL_BUFFER_SIZE
   1416                               ? appZclBufferLen + length
   1417                               : APP_ZCL_BUFFER_SIZE);
   1418            globalApsFrame.options |= EMBER_APS_OPTION_SOURCE_EUI64;
   1419            cliBufferPrint();
   1420          }
   1421          #endif //ZCL_USING_TUNNELING_CLUSTER_SERVER
   1422          
   1423          // ******************************************************
   1424          // send <id> <src endpoint> <dst endpoint>
   1425          // send_multicast <group id> <src endpoint>
   1426          //
   1427          // FFFC = all routers
   1428          // FFFD = all non-sleepy
   1429          // FFFF = all devices, include sleepy
   1430          // ******************************************************

   \                                 In section .text, align 2, keep-with-next
   1431          void emAfCliSendCommand(void)
   1432          {
   \                     emAfCliSendCommand: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1433            int16u destination = (int16u)emberUnsignedCommandArgument(0);
   \   00000002   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000006   0x.... 0x....      BL       ?Subroutine7
   1434            int8u srcEndpoint = (int8u)emberUnsignedCommandArgument(1);
   \                     ??CrossCallReturnLabel_30: (+1)
   \   0000000A   0x4606             MOV      R6,R0
   1435            int8u dstEndpoint = (int8u)emberUnsignedCommandArgument(2);
   \   0000000C   0x.... 0x....      BL       ??Subroutine6_0
   1436            int8u *commandName = (int8u *)emberCurrentCommand->name;
   \                     ??CrossCallReturnLabel_18: (+1)
   \   00000010   0x....             LDR.N    R1,??DataTable34_2
   1437            EmberStatus status;
   1438            int8u label;
   1439          
   1440            // check that cmd is built
   1441            if (zclCmdIsBuilt == FALSE) {
   \   00000012   0x....             LDR.N    R5,??DataTable34
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x680F             LDR      R7,[R1, #+0]
   \   00000018   0x7B29             LDRB     R1,[R5, #+12]
   \   0000001A   0xB371             CBZ.N    R1,??emAfCliSendCommand_0
   1442              emberAfCorePrintln("no cmd");
   1443              return;
   1444            }
   1445          
   1446            emAfApsFrameEndpointSetup(srcEndpoint, dstEndpoint);
   \   0000001C   0xB2C1             UXTB     R1,R0
   \   0000001E   0xB2F0             UXTB     R0,R6
   \   00000020   0x.... 0x....      BL       emAfApsFrameEndpointSetup
   1447          
   1448            if (emberAfPreCliSendCallback(&globalApsFrame,
   1449                                          emberAfGetNodeId(),
   1450                                          destination,
   1451                                          appZclBuffer,
   1452                                          appZclBufferLen)) {
   \   00000024   0x.... 0x....      BL       emberAfGetNodeId
   \   00000028   0x4601             MOV      R1,R0
   \   0000002A   0x8A28             LDRH     R0,[R5, #+16]
   \   0000002C   0x....             LDR.N    R6,??DataTable34_1
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0x4633             MOV      R3,R6
   \   00000032   0xB2A2             UXTH     R2,R4
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       emberAfPreCliSendCallback
   \   0000003A   0xB9F0             CBNZ.N   R0,??emAfCliSendCommand_0
   1453              return;
   1454            }
   1455          
   1456          
   1457            if (commandName[4] == '_') {
   \   0000003C   0x7938             LDRB     R0,[R7, #+4]
   \   0000003E   0x8A2A             LDRH     R2,[R5, #+16]
   \   00000040   0x285F             CMP      R0,#+95
   \   00000042   0xD105             BNE.N    ??emAfCliSendCommand_1
   1458              label = 'M';
   1459              status = emberAfSendMulticast(destination,
   1460                                            &globalApsFrame,
   1461                                            appZclBufferLen,
   1462                                            appZclBuffer);
   \   00000044   0x4633             MOV      R3,R6
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0xB2A0             UXTH     R0,R4
   \   0000004A   0x.... 0x....      BL       emberAfSendMulticast
   \   0000004E   0xE011             B.N      ??emAfCliSendCommand_2
   1463            } else if (destination >= EMBER_BROADCAST_ADDRESS) {
   \                     ??emAfCliSendCommand_1: (+1)
   \   00000050   0xB2A4             UXTH     R4,R4
   \   00000052   0xF64F 0x70FC      MOVW     R0,#+65532
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xDB05             BLT.N    ??emAfCliSendCommand_3
   1464              label = 'B';
   1465              status = emberAfSendBroadcast(destination,
   1466                                            &globalApsFrame,
   1467                                            appZclBufferLen,
   1468                                            appZclBuffer);
   \   0000005A   0x4633             MOV      R3,R6
   \   0000005C   0x4629             MOV      R1,R5
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       emberAfSendBroadcast
   \   00000064   0xE006             B.N      ??emAfCliSendCommand_2
   1469            } else {
   1470              label = 'U';
   1471              status = emberAfSendUnicast(EMBER_OUTGOING_DIRECT,
   1472                                          destination,
   1473                                          &globalApsFrame,
   1474                                          appZclBufferLen,
   1475                                          appZclBuffer);
   \                     ??emAfCliSendCommand_3: (+1)
   \   00000066   0x4613             MOV      R3,R2
   \   00000068   0x9600             STR      R6,[SP, #+0]
   \   0000006A   0x462A             MOV      R2,R5
   \   0000006C   0x4621             MOV      R1,R4
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x.... 0x....      BL       emberAfSendUnicast
   1476            }
   1477          
   1478            if (status != EMBER_SUCCESS) {
   1479              emberAfCorePrintln("Error: CLI Send failed, status: 0x%X", status);
   1480            }
   1481            UNUSED_VAR(label);
   1482            emberAfDebugPrintln("T%4x:TX (%p) %ccast 0x%x%p",
   1483                                emberAfGetCurrentTime(),
   1484                                "CLI",
   1485                                label,
   1486                                status,
   1487                                ((globalApsFrame.options & EMBER_APS_OPTION_ENCRYPTION)
   1488                                 ? " w/ link key" : ""));
   1489            emberAfDebugPrint("TX buffer: [");
   1490            emberAfDebugFlush();
   1491            emberAfDebugPrintBuffer(appZclBuffer, appZclBufferLen, TRUE);
   1492            emberAfDebugPrintln("]");
   1493            emberAfDebugFlush();
   1494          
   1495            zclCmdIsBuilt = FALSE;
   \                     ??emAfCliSendCommand_2: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x81A8             STRH     R0,[R5, #+12]
   1496            mfgSpecificId = EMBER_AF_NULL_MANUFACTURER_CODE;
   \   00000078   0x8268             STRH     R0,[R5, #+18]
   1497            disableDefaultResponse = 0;
   1498          }
   \                     ??emAfCliSendCommand_0: (+1)
   \   0000007A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1499          
   1500          // **********************************************************************
   1501          // bsend <src endpoint> - send using a binding based on the clusterId in
   1502          //            the globalApsFrame and the srcEndpoint specified (if the
   1503          //            src endpoint is zero it only sends based on the clusterId)
   1504          //
   1505          // **********************************************************************

   \                                 In section .text, align 2, keep-with-next
   1506          void emAfCliBsendCommand(void)
   1507          {
   \                     emAfCliBsendCommand: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   1508            int8u srcEndpointToUse, i;
   1509            EmberStatus status;
   1510            EmberBindingTableEntry candidate;
   1511          
   1512            // check that cmd is built
   1513            if (zclCmdIsBuilt == FALSE) {
   \   00000002   0x....             LDR.N    R4,??DataTable34
   \   00000004   0x7B20             LDRB     R0,[R4, #+12]
   \   00000006   0xB085             SUB      SP,SP,#+20
   \   00000008   0xB318             CBZ.N    R0,??emAfCliBsendCommand_0
   1514              emberAfCorePrintln("cmd not built");
   1515              return;
   1516            }
   1517          
   1518            srcEndpointToUse = (int8u)emberUnsignedCommandArgument(0);
   \   0000000A   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000000E   0xB2C5             UXTB     R5,R0
   1519          
   1520            emberAfCorePrintln("src ep %x, clus %2x",
   1521                               srcEndpointToUse, 
   1522                               globalApsFrame.clusterId);
   1523          
   1524            // find a binding to send on
   1525            for (i = 0; i < EMBER_BINDING_TABLE_SIZE; i++) {
   \   00000010   0x2600             MOVS     R6,#+0
   \   00000012   0x....             LDR.N    R7,??DataTable34_1
   1526              status = emberGetBinding(i, &candidate);
   1527          
   1528              // if we can read the binding, it is unicast, the endpoint is the
   1529              // one we want (or we have no preference) and the cluster matches
   1530              // then use that binding to send the message
   1531              if (status == EMBER_SUCCESS
   1532                  && candidate.type == EMBER_UNICAST_BINDING
   1533                  && (srcEndpointToUse == 0
   1534                      || candidate.local == srcEndpointToUse)
   1535                  && candidate.clusterId == globalApsFrame.clusterId) {
   \                     ??emAfCliBsendCommand_1: (+1)
   \   00000014   0xA901             ADD      R1,SP,#+4
   \   00000016   0x4630             MOV      R0,R6
   \   00000018   0x.... 0x....      BL       emberGetBinding
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xBF04             ITT      EQ 
   \   00000020   0xF89D 0x0004      LDRBEQ   R0,[SP, #+4]
   \   00000024   0x2801             CMPEQ    R0,#+1
   \   00000026   0xD111             BNE.N    ??emAfCliBsendCommand_2
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xBF1C             ITT      NE 
   \   0000002C   0xF89D 0x0005      LDRBNE   R0,[SP, #+5]
   \   00000030   0x42A8             CMPNE    R0,R5
   \   00000032   0xBF02             ITTT     EQ 
   \   00000034   0xF8BD 0x0006      LDRHEQ   R0,[SP, #+6]
   \   00000038   0x8861             LDRHEQ   R1,[R4, #+2]
   \   0000003A   0x4288             CMPEQ    R0,R1
   \   0000003C   0xD106             BNE.N    ??emAfCliBsendCommand_2
   1536                emberAfCorePrintln("sending to bind %x", i);
   1537          
   1538                status = emberAfSendUnicast(EMBER_OUTGOING_VIA_BINDING,
   1539                                            i,
   1540                                            &globalApsFrame,
   1541                                            appZclBufferLen,
   1542                                            appZclBuffer);
   \   0000003E   0x8A23             LDRH     R3,[R4, #+16]
   \   00000040   0x9700             STR      R7,[SP, #+0]
   \   00000042   0x4622             MOV      R2,R4
   \   00000044   0x4631             MOV      R1,R6
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x.... 0x....      BL       emberAfSendUnicast
   1543          
   1544                emberAfDebugPrintln("T%4x:TX (%p) %ccast 0x%x%p",
   1545                                   emberAfGetCurrentTime(),
   1546                                   "CLI",
   1547                                   'U',
   1548                                   status,
   1549                                   ((globalApsFrame.options & EMBER_APS_OPTION_ENCRYPTION)
   1550                                    ? " w/ link key" : ""));
   1551                emberAfDebugPrint("TX buffer: [");
   1552                emberAfDebugFlush();
   1553                emberAfDebugPrintBuffer(appZclBuffer, appZclBufferLen, TRUE);
   1554                emberAfDebugPrintln("]");
   1555                emberAfDebugFlush();
   1556              }
   1557            }
   \                     ??emAfCliBsendCommand_2: (+1)
   \   0000004C   0x1C76             ADDS     R6,R6,#+1
   \   0000004E   0x2E0A             CMP      R6,#+10
   \   00000050   0xDBE0             BLT.N    ??emAfCliBsendCommand_1
   1558          }
   \                     ??emAfCliBsendCommand_0: (+1)
   \   00000052   0xB005             ADD      SP,SP,#+20
   \   00000054   0xBDF0             POP      {R4-R7,PC}       ;; return
   1559          
   1560          // This function has been temporarily deprecated.
   1561          
   1562          // ******************************************************
   1563          // send <EUI64> <src endpoint> <dst endpoint>
   1564          // Sends a ZCL packet over a Zcl Ip interface. It checks for a valid 
   1565          // source Endpoint before it sends it over IP.
   1566          // ******************************************************
   1567          
   1568          // void emAfCliSendZclIpCommand(void)
   1569          // {
   1570          //   EmberEUI64 eui64;
   1571          //   // emberCopyStringArgument(0,
   1572          //   //                         eui64,
   1573          //   //                         8,
   1574          //   //                         FALSE);
   1575          //   emberCopyBigEndianEui64Argument(0,eui64);
   1576          //   emberAfCorePrintln("EUI: %x %x %x %x %x %x %x %x",eui64[0],eui64[1],eui64[2],eui64[3],eui64[4],eui64[5],eui64[6],eui64[7]);
   1577          //   int8u sourceEndpoint = (int8u)emberUnsignedCommandArgument(1);
   1578          //   int8u destEndpoint = (int8u)emberUnsignedCommandArgument(2);
   1579          
   1580          //   emAfApsFrameEndpointSetup(sourceEndpoint, destEndpoint);
   1581          
   1582          //   emberAfCliInternetServerSendCallback(&globalApsFrame,
   1583          //                                        eui64,
   1584          //                                        appZclBuffer,
   1585          //                                        appZclBufferLen);
   1586          // }
   1587          
   1588          // timesync <id> <src endpoint> <dest endpoint>
   1589          //
   1590          // This sends a read attr for the time of the device specified. It sets a flag
   1591          // so when it gets the response it writes the time to its own time attr

   \                                 In section .text, align 2, keep-with-next
   1592          void emAfCliTimesyncCommand(void)
   1593          {
   \                     emAfCliTimesyncCommand: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1594            // send a read attr for time 
   1595            zclBufferSetup(ZCL_PROFILE_WIDE_COMMAND | ZCL_FRAME_CONTROL_CLIENT_TO_SERVER,
   1596                           ZCL_TIME_CLUSTER_ID,
   1597                           ZCL_READ_ATTRIBUTES_COMMAND_ID);
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x210A             MOVS     R1,#+10
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       zclBufferSetup
   1598            zclBufferAddWord(ZCL_TIME_ATTRIBUTE_ID);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       zclBufferAddWord
   1599            emAfSyncingTime = TRUE;
   \   00000012   0x....             LDR.N    R1,??DataTable34_3
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7008             STRB     R0,[R1, #+0]
   1600            cliBufferPrint();
   \   00000018   0x.... 0x....      BL       cliBufferPrint
   1601            emAfCliSendCommand();
   \   0000001C   0xE8BD 0x4001      POP      {R0,LR}
   \   00000020   0x....             B.N      emAfCliSendCommand
   1602          }
   1603          
   1604          
   1605          // interpan group <groupId:2> <destPAN:2> <destProfileID:2>
   1606          // interpan short <shortId:2> <destPAN:2> <destProfileID:2>

   \                                 In section .text, align 2, keep-with-next
   1607          void interpanCommand(void) 
   1608          {
   \                     interpanCommand: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   1609            EmberStatus status;
   1610            EmberAfInterpanHeader header;
   1611            int16u shortOrGroupId;
   1612          
   1613            if (zclCmdIsBuilt == FALSE) {
   \   00000002   0x....             LDR.N    R4,??DataTable34
   \   00000004   0x7B20             LDRB     R0,[R4, #+12]
   \   00000006   0xB087             SUB      SP,SP,#+28
   \   00000008   0xB1B8             CBZ.N    R0,??CrossCallReturnLabel_40
   1614              emberAfCorePrintln("no cmd");
   1615              return;
   1616            }
   1617          
   1618            MEMSET(&header, 0, sizeof(EmberAfInterpanHeader));
   \   0000000A   0x.... 0x....      BL       ?Subroutine13
   1619            shortOrGroupId = (int16u)emberUnsignedCommandArgument(0);
   \                     ??CrossCallReturnLabel_46: (+1)
   \   0000000E   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_3: (+1)
   \   00000012   0x4605             MOV      R5,R0
   1620            header.panId = (int16u)emberUnsignedCommandArgument(1);
   \   00000014   0x.... 0x....      BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_25: (+1)
   \   00000018   0x.... 0x....      BL       ?Subroutine6
   1621            header.profileId = (int16u)emberUnsignedCommandArgument(2);
   \                     ??CrossCallReturnLabel_23: (+1)
   \   0000001C   0xF8AD 0x000E      STRH     R0,[SP, #+14]
   1622            header.clusterId = globalApsFrame.clusterId;
   \   00000020   0x8860             LDRH     R0,[R4, #+2]
   \   00000022   0xF8AD 0x0010      STRH     R0,[SP, #+16]
   1623          
   1624            if (emberCurrentCommand->name[0] == 'g') {
   \   00000026   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_42: (+1)
   \   0000002A   0x2867             CMP      R0,#+103
   \   0000002C   0xBF0C             ITE      EQ 
   1625              header.groupId = shortOrGroupId;
   \   0000002E   0xF8AD 0x5012      STRHEQ   R5,[SP, #+18]
   1626              emberAfDebugPrintln("interpan %p %2x", "group", header.groupId);    
   1627            } else {
   1628              header.shortAddress = shortOrGroupId;
   \   00000032   0xF8AD 0x500A      STRHNE   R5,[SP, #+10]
   1629              emberAfDebugPrintln("interpan %p %2x", "short", shortOrGroupId);
   1630            }
   1631          
   1632            status = emberAfInterpanSendMessageCallback(&header,
   1633                                                        appZclBufferLen,
   1634                                                        appZclBuffer);
   \   00000036   0x.... 0x....      BL       ?Subroutine10
   1635            if (status != EMBER_SUCCESS) {
   1636              emberAfDebugPrintln("%psend failed: 0x%X",
   1637                                  "ERR: Inter-PAN ",
   1638                                  status);
   1639            }
   1640          }
   \                     ??CrossCallReturnLabel_40: (+1)
   \   0000003A   0xB007             ADD      SP,SP,#+28
   \   0000003C   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \   00000000   0x2216             MOVS     R2,#+22
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      B.W      halCommonMemSet

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x8A21             LDRH     R1,[R4, #+16]
   \   00000002   0x....             LDR.N    R2,??DataTable34_1
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      B.W      emberAfInterpanSendMessageCallback
   1641          
   1642          // interpan long  <longId:8>  <destPAN:2> <destProfileID:2> <options:2>
   1643          //    Options: Bit(0) = encrypt.  Can only encrypt with this CLI command
   1644          //    since long address must be present.

   \                                 In section .text, align 2, keep-with-next
   1645          void interpanLongCommand(void) 
   1646          {
   \                     interpanLongCommand: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1647            EmberStatus status;
   1648            EmberAfInterpanHeader header;
   1649          
   1650            if (zclCmdIsBuilt == FALSE) {
   \   00000002   0x....             LDR.N    R4,??DataTable34
   \   00000004   0x7B20             LDRB     R0,[R4, #+12]
   \   00000006   0xB086             SUB      SP,SP,#+24
   \   00000008   0xB1B8             CBZ.N    R0,??CrossCallReturnLabel_39
   1651              emberAfCorePrintln("no cmd");
   1652              return;
   1653            }
   1654          
   1655            MEMSET(&header, 0, sizeof(EmberAfInterpanHeader));
   \   0000000A   0x.... 0x....      BL       ?Subroutine13
   1656            header.panId = (int16u)emberUnsignedCommandArgument(1);
   \                     ??CrossCallReturnLabel_45: (+1)
   \   0000000E   0x.... 0x....      BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_24: (+1)
   \   00000012   0x.... 0x....      BL       ?Subroutine6
   1657            header.profileId = (int16u)emberUnsignedCommandArgument(2);
   \                     ??CrossCallReturnLabel_22: (+1)
   \   00000016   0xF8AD 0x000E      STRH     R0,[SP, #+14]
   1658            header.options = ((int16u)emberUnsignedCommandArgument(3)
   1659                              | EMBER_AF_INTERPAN_OPTION_MAC_HAS_LONG_ADDRESS);
   \   0000001A   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_33: (+1)
   \   0000001E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000022   0xF8AD 0x0014      STRH     R0,[SP, #+20]
   1660            header.clusterId = globalApsFrame.clusterId;
   1661            
   1662            emberCopyBigEndianEui64Argument(0, header.longAddress);
   \   00000026   0xF10D 0x0101      ADD      R1,SP,#+1
   \   0000002A   0x8860             LDRH     R0,[R4, #+2]
   \   0000002C   0xF8AD 0x0010      STRH     R0,[SP, #+16]
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       emberCopyBigEndianEui64Argument
   1663          
   1664            status = emberAfInterpanSendMessageCallback(&header,
   1665                                                        appZclBufferLen,
   1666                                                        appZclBuffer);
   \   00000036   0x.... 0x....      BL       ?Subroutine10
   1667            if (status != EMBER_SUCCESS) {
   1668              emberAfDebugPrintln("%psend failed: 0x%X",
   1669                                  "ERR: Inter-PAN ",
   1670                                  status);
   1671            }
   1672          }
   \                     ??CrossCallReturnLabel_39: (+1)
   \   0000003A   0xB006             ADD      SP,SP,#+24
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   1673          

   \                                 In section .text, align 2, keep-with-next
   1674          void printTimeCommand(void) 
   1675          {
   \                     printTimeCommand: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1676            emberAfPrintTime(emberAfGetCurrentTime());
   \   00000002   0x.... 0x....      BL       emberAfGetCurrentTime
   \   00000006   0xE8BD 0x4002      POP      {R1,LR}
   \   0000000A   0x.... 0x....      B.W      emberAfPrintTime
   1677          }
   1678          
   1679          // read <endpoint:1> <cluster:2> <attribute:2> <mask:1>

   \                                 In section .text, align 2, keep-with-next
   1680          void emAfCliReadCommand(void)
   1681          {
   \                     emAfCliReadCommand: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08E             SUB      SP,SP,#+56
   1682            EmberAfStatus status;
   1683            int8u endpoint = (int8u)emberUnsignedCommandArgument(0);
   \   00000004   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000008   0x.... 0x....      BL       ?Subroutine7
   1684            EmberAfClusterId cluster = (EmberAfClusterId)emberUnsignedCommandArgument(1);
   \                     ??CrossCallReturnLabel_29: (+1)
   \   0000000C   0x4605             MOV      R5,R0
   1685            EmberAfAttributeId attribute = (EmberAfAttributeId)emberUnsignedCommandArgument(2);
   \   0000000E   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_17: (+1)
   \   00000012   0x4606             MOV      R6,R0
   1686            boolean serverAttribute = (boolean)emberUnsignedCommandArgument(3);
   \   00000014   0x.... 0x....      BL       ?Subroutine8
   1687            int8u data[ATTRIBUTE_LARGEST];
   1688            int8u dataType;
   1689            
   1690            emberAfCorePrint("%p: ep: %d, cl: 0x%2X, attr: 0x%2X", 
   1691                             "read",
   1692                             endpoint,
   1693                             cluster,
   1694                             attribute);
   1695            emberAfCorePrintln(", svr: %c", (serverAttribute ? 'y' : 'n'));
   1696          
   1697            status = emberAfReadAttribute(endpoint,
   1698                                          cluster,
   1699                                          attribute,
   1700                                          (serverAttribute
   1701                                           ? CLUSTER_MASK_SERVER
   1702                                           : CLUSTER_MASK_CLIENT),
   1703                                          data,
   1704                                          sizeof(data),
   1705                                          &dataType);
   1706            if (status == EMBER_ZCL_STATUS_SUCCESS) {
   \                     ??CrossCallReturnLabel_32: (+1)
   \   00000018   0xB2C0             UXTB     R0,R0
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xBF14             ITE      NE 
   \   0000001E   0x2340             MOVNE    R3,#+64
   \   00000020   0x2380             MOVEQ    R3,#+128
   \   00000022   0xA803             ADD      R0,SP,#+12
   \   00000024   0x9002             STR      R0,[SP, #+8]
   \   00000026   0xB2B2             UXTH     R2,R6
   \   00000028   0x2021             MOVS     R0,#+33
   \   0000002A   0x9001             STR      R0,[SP, #+4]
   \   0000002C   0xB2A9             UXTH     R1,R5
   \   0000002E   0xA804             ADD      R0,SP,#+16
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0xB2E0             UXTB     R0,R4
   \   00000034   0x.... 0x....      BL       emberAfReadAttribute
   \   00000038   0xB918             CBNZ.N   R0,??emAfCliReadCommand_0
   1707              if (emberAfIsThisDataTypeAStringType(dataType)) {
   \   0000003A   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000003E   0x.... 0x....      BL       emberAfIsThisDataTypeAStringType
   1708                emberAfCorePrintString(data);
   1709              } else {
   1710                emberAfCorePrintBuffer(data, emberAfGetDataSize(dataType), TRUE);
   1711              }
   1712              emberAfCorePrintln("");
   1713            } else {
   1714              emberAfCorePrintln("%p: read: 0x%x", "Error", status);
   1715            }
   1716          }
   \                     ??emAfCliReadCommand_0: (+1)
   \   00000042   0xB00E             ADD      SP,SP,#+56
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
   1717          
   1718          // ******************************************************
   1719          // write <ep> <cluster> <attrID> <mask> <dataType> <data bytes>
   1720          // ******************************************************

   \                                 In section .text, align 2, keep-with-next
   1721          void emAfCliWriteCommand(void) 
   1722          {
   \                     emAfCliWriteCommand: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   1723            //int8u i;
   1724            boolean result;
   1725            int8u data[ATTRIBUTE_LARGEST];
   1726          
   1727            int8u  endpoint  = (int8u)emberUnsignedCommandArgument(0);
   \   00000006   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000000A   0x.... 0x....      BL       ?Subroutine7
   1728            int16u cluster   = (int16u)emberUnsignedCommandArgument(1);
   \                     ??CrossCallReturnLabel_28: (+1)
   \   0000000E   0x4605             MOV      R5,R0
   1729            int16u attribute = (int16u)emberUnsignedCommandArgument(2);
   \   00000010   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000014   0x4680             MOV      R8,R0
   1730            boolean serverAttribute = (boolean)emberUnsignedCommandArgument(3);
   \   00000016   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_31: (+1)
   \   0000001A   0x4607             MOV      R7,R0
   1731            int8u  dataType  = (int8u)emberUnsignedCommandArgument(4);
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0x.... 0x....      BL       emberUnsignedCommandArgument
   \   00000022   0x4606             MOV      R6,R0
   1732            
   1733            emberAfCorePrint("%p: ep: %d, cl: 0x%2X, attr: 0x%2X",
   1734                             "write",
   1735                             endpoint, 
   1736                             cluster, 
   1737                             attribute);
   1738            emberAfCorePrintln(", svr: %c, dtype: 0x%X",
   1739                               (serverAttribute ? 'y' : 'n'),
   1740                               dataType);
   1741          
   1742            // If the data type is a string, automatically prepend a length to the data;
   1743            // otherwise, just copy the raw bytes.
   1744            MEMSET(data, 0, ATTRIBUTE_LARGEST);
   \   00000024   0x2221             MOVS     R2,#+33
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xA802             ADD      R0,SP,#+8
   \   0000002A   0x.... 0x....      BL       halCommonMemSet
   1745            if (emberAfIsThisDataTypeAStringType(dataType)) {
   \   0000002E   0xB2F0             UXTB     R0,R6
   \   00000030   0x.... 0x....      BL       emberAfIsThisDataTypeAStringType
   \   00000034   0xB148             CBZ.N    R0,??emAfCliWriteCommand_0
   1746              data[0] = emberCopyStringArgument(5,
   1747                                                data + 1,
   1748                                                ATTRIBUTE_LARGEST - 1,
   1749                                                FALSE);
   \   00000036   0x2300             MOVS     R3,#+0
   \   00000038   0x2220             MOVS     R2,#+32
   \   0000003A   0xF10D 0x0109      ADD      R1,SP,#+9
   \   0000003E   0x2005             MOVS     R0,#+5
   \   00000040   0x.... 0x....      BL       emberCopyStringArgument
   \   00000044   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \   00000048   0xE008             B.N      ??emAfCliWriteCommand_1
   1750            } else {
   1751               emberCopyStringArgument(5,
   1752                                       data,
   1753                                       emberAfGetDataSize(dataType),
   1754                                       FALSE);
   \                     ??emAfCliWriteCommand_0: (+1)
   \   0000004A   0xB2F0             UXTB     R0,R6
   \   0000004C   0x.... 0x....      BL       emberAfGetDataSize
   \   00000050   0x4602             MOV      R2,R0
   \   00000052   0x2300             MOVS     R3,#+0
   \   00000054   0xA902             ADD      R1,SP,#+8
   \   00000056   0x2005             MOVS     R0,#+5
   \   00000058   0x.... 0x....      BL       emberCopyStringArgument
   1755            }
   1756          
   1757          
   1758            result = emberAfWriteAttribute(endpoint,
   1759                                           cluster,
   1760                                           attribute,
   1761                                           (serverAttribute
   1762                                            ? CLUSTER_MASK_SERVER
   1763                                            : CLUSTER_MASK_CLIENT),
   1764                                           data,
   1765                                           dataType);
   \                     ??emAfCliWriteCommand_1: (+1)
   \   0000005C   0xB2FF             UXTB     R7,R7
   \   0000005E   0x2F00             CMP      R7,#+0
   \   00000060   0xBF14             ITE      NE 
   \   00000062   0x2340             MOVNE    R3,#+64
   \   00000064   0x2380             MOVEQ    R3,#+128
   \   00000066   0xB2F0             UXTB     R0,R6
   \   00000068   0x9001             STR      R0,[SP, #+4]
   \   0000006A   0xFA1F 0xF288      UXTH     R2,R8
   \   0000006E   0xA802             ADD      R0,SP,#+8
   \   00000070   0x9000             STR      R0,[SP, #+0]
   \   00000072   0xB2A9             UXTH     R1,R5
   \   00000074   0xB2E0             UXTB     R0,R4
   \   00000076   0x.... 0x....      BL       emberAfWriteAttribute
   \   0000007A   0x4601             MOV      R1,R0
   1766            emAfPrintStatus("write", result);
   \   0000007C   0x.... 0x....      ADR.W    R0,`?<Constant "write">`
   \   00000080   0x.... 0x....      BL       emAfPrintStatus
   1767            emberAfCorePrintln("");
   1768          }
   \   00000084   0xB00C             ADD      SP,SP,#+48
   \   00000086   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1769          

   \                                 In section .text, align 2, keep-with-next
   1770          void eraseKeyTableEntry(int8u index)
   1771          {
   \                     eraseKeyTableEntry: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1772            EmberStatus status = emberEraseKeyTableEntry(index);
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x9100             STR      R1,[SP, #+0]
   \   00000006   0x460A             MOV      R2,R1
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       emSetKeyTableEntry
   1773            
   1774            if (status != EMBER_SUCCESS) {
   1775              emberAfCorePrintln("%perase key %d: 0x%x",
   1776                                 "ERROR: ",
   1777                                 index,
   1778                                 status);
   1779            }
   1780          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
   1781          
   1782          // keys clear

   \                                 In section .text, align 2, keep-with-next
   1783          void keysClearCommand(void)
   1784          {
   1785          #if EMBER_KEY_TABLE_SIZE
   1786            int8u i;
   1787            for (i = 0; i < EMBER_KEY_TABLE_SIZE; i++) {
   1788              eraseKeyTableEntry(i);
   1789            }
   1790          #endif
   1791          }
   \                     keysClearCommand: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1792          
   1793          // keys print

   \                                 In section .text, align 2, keep-with-next
   1794          void keysPrintCommand(void)
   1795          {
   1796            emberAfCorePrintln("%pSECURITY_LEVEL: %x",
   1797                               "EMBER_",
   1798                               EMBER_SECURITY_LEVEL);
   1799            printKeyInfo();
   \                     keysPrintCommand: (+1)
   \   00000000   0x.... 0x....      B.W      printKeyInfo
   1800          }
   1801          
   1802          // keys delete <index:1>

   \                                 In section .text, align 2, keep-with-next
   1803          void keysDeleteCommand(void)
   1804          {
   \                     keysDeleteCommand: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1805            int8u index = (int8u)emberUnsignedCommandArgument(0);
   \   00000002   0x.... 0x....      BL       ??Subroutine5_0
   1806            eraseKeyTableEntry(index);
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000006   0xE8BD 0x4002      POP      {R1,LR}
   \   0000000A   0xB2C0             UXTB     R0,R0
   \   0000000C   0x....             B.N      eraseKeyTableEntry
   1807          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x00 0x00          DC8      "",0x0,0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0x........         DC32     globalApsFrame

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   0x........         DC32     appZclBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_2:
   \   00000000   0x........         DC32     emberCurrentCommand

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_3:
   \   00000000   0x........         DC32     emAfSyncingTime

   \                                 In section .rodata, align 1, keep-with-next
   \                     `?<Constant "">`:
   \   00000000   0x00               DC8 ""

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Msg: clus 0x%2x, cmd ...">`:
   \   00000000   0x4D 0x73          DC8 "Msg: clus 0x%2x, cmd 0x%x, len %d"
   \              0x67 0x3A    
   \              0x20 0x63    
   \              0x6C 0x75    
   \              0x73 0x20    
   \              0x30 0x78    
   \              0x25 0x32    
   \              0x78 0x2C    
   \              0x20 0x63    
   \              0x6D 0x64    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x78 0x2C    
   \              0x20 0x6C    
   \              0x65 0x6E    
   \              0x20 0x25    
   \              0x64 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "buffer: ">`:
   \   00000000   0x62 0x75          DC8 "buffer: "
   \              0x66 0x66    
   \              0x65 0x72    
   \              0x3A 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "zcl-cli.c">`:
   \   00000000   0x7A 0x63          DC8 "zcl-cli.c"
   \              0x6C 0x2D    
   \              0x63 0x6C    
   \              0x69 0x2E    
   \              0x63 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "write">`:
   \   00000000   0x77 0x72          DC8 "write"
   \              0x69 0x74    
   \              0x65 0x00    
   \   00000006   0x00 0x00          DC8 0, 0
   1808          
   1809          #ifdef CERTIFICATION_TESTING
   1810          void attributeReadCausingFragmentedResponseCommand(void)
   1811          {
   1812            zclBufferSetup(ZCL_PROFILE_WIDE_COMMAND | ZCL_FRAME_CONTROL_CLIENT_TO_SERVER,
   1813                           0x0000,
   1814                           ZCL_READ_ATTRIBUTES_COMMAND_ID);
   1815            zclBufferAddWord(0x0000);
   1816            zclBufferAddWord(0x1000);
   1817            zclBufferAddWord(0x1001);
   1818            zclBufferAddWord(0x1002);
   1819            zclBufferAddWord(0x1003);
   1820            zclBufferAddWord(0x1004);
   1821            zclBufferAddWord(0x1005);
   1822            zclBufferAddWord(0x1006);
   1823            zclBufferAddWord(0x1007);
   1824            zclBufferAddWord(0x1008);
   1825            zclBufferAddWord(0x1009);
   1826            zclBufferAddWord(0x100A);
   1827            zclBufferAddWord(0x100B);
   1828            zclBufferAddWord(0x100C);
   1829            zclBufferAddWord(0x100D);
   1830            zclBufferAddWord(0x100E);
   1831            zclBufferAddWord(0x100F);
   1832            zclBufferAddWord(0x1010);
   1833            zclBufferAddWord(0x1011);
   1834            zclBufferAddWord(0x1012);
   1835            zclBufferAddWord(0x1013);
   1836            zclBufferAddWord(0x1014);
   1837            zclBufferAddWord(0x1015);
   1838            zclBufferAddWord(0x1016);
   1839            zclBufferAddWord(0x1017);
   1840            zclBufferAddWord(0x1018);
   1841            zclBufferAddWord(0x1019);
   1842            zclBufferAddWord(0x101A);
   1843            zclBufferAddWord(0x2001);
   1844            zclBufferAddWord(0x2002);
   1845            zclBufferAddWord(0x2003);
   1846            zclBufferAddWord(0x2004);
   1847            zclBufferAddWord(0x2005);
   1848            zclBufferAddWord(0x2006);
   1849            zclBufferAddWord(0x2007);
   1850            zclBufferAddWord(0x2008);
   1851            zclBufferAddWord(0x2009);
   1852            cliBufferPrint();
   1853          }
   1854          #endif //CERTIFICATION_TESTING
   1855          
   1856          //******************************************************************
   1857          // zcl command table entries
   1858          //******************************************************************
   1859          
   1860          #ifndef EMBER_AF_GENERATE_CLI
   1861          
   1862          /**
   1863           * @addtogroup cli
   1864           * @{
   1865           */
   1866          /**
   1867           * @brief Commands used to send global commands in the zcl
   1868           *
   1869           *        <b>zcl global read &lt;cluster&gt; &lt;attribute id&gt; </b>
   1870           *        - <i> Creates a global read command message to read from 
   1871           *              the cluster and attribute specified.
   1872           *          - cluster - int16u. The cluster id to read from.
   1873           *          - attribute id - int16u. The attribute id to read from</i>
   1874           *
   1875           *        <b>zcl global write &lt;cluster&gt; &lt;attribute id&gt; &lt;data type&gt; &lt;data&gt;</b>
   1876           *        - <i> Creates a global write  command message to write to 
   1877           *              the cluster and attribute specified.
   1878           *          - cluster - int16u. The cluster id to read from.
   1879           *          - attribute id - int16u. The attribute id to read from
   1880           *          - data type - int8u. The two byte zigbee type value
   1881           *          - data - byte array. The data to write</i>
   1882           *
   1883           *        <b>zcl global uwrite &lt;cluster&gt; &lt;attribute id&gt; &lt;data type&gt; &lt;data&gt;</b>
   1884           *        - <i> Creates a global write command message to write to the 
   1885           *              cluster and attribute specified. 
   1886           *          - cluster - int16u. The cluster id to read from.
   1887           *          - attribute id - int16u. The attribute id to read from
   1888           *          - data type - int8u. The two byte zigbee type value
   1889           *          - data - byte array. The data to write</i>
   1890           *
   1891           *        <b>zcl global nwrite &lt;cluster&gt; &lt;attribute id&gt; &lt;data type&gt; &lt;data&gt;</b>
   1892           *        - <i> Creates a global write command message to write to the 
   1893           *              cluster and attribute specified. 
   1894           *          - cluster - int16u. The cluster id to read from.
   1895           *          - attribute id - int16u. The attribute id to read from
   1896           *          - data type - int8u. The two byte zigbee type value
   1897           *          - data - byte array. The data to write</i>
   1898           *
   1899           *        <b>zcl global discover &lt;cluster&gt; &lt;attribute id&gt; &lt;max&gt;</b>
   1900           *        - <i> Creates discovery message for devices with the associated 
   1901           *              cluster and attribute 
   1902           *          - cluster - int16u. The cluster id to read from.
   1903           *          - attribute id - int16u. The attribute id to read from
   1904           *          - max - int8u. Max number of discovery responses.</i>
   1905           *
   1906           *        <b>zcl global report-read &lt;cluster&gt; &lt;attribute id&gt; &lt;direction&gt;</b>
   1907           *        - <i> Creates a global read reporting command for the associated 
   1908           *              cluster, attribute and server/client direction.
   1909           *          - cluster - int16u. The cluster id to read from.
   1910           *          - attribute id - int16u. The attribute id to read from
   1911           *          - direction - int8u. 0 for client-to-server, 1 for server-to-client.</i>
   1912           *
   1913           *        <b>zcl global send-me-a-report &lt;cluster&gt; &lt;attribute id&gt; &lt;data type&gt; 
   1914           *           &lt;min report time&gt; &lt;max report time&gt; &lt;reportable change&gt;</b>
   1915           *        - <i> Creates a global send me a report command for the associated values.
   1916           *          - cluster - int16u. The cluster id for requested report.
   1917           *          - attribute id - int16u. The attribute for requested report.
   1918           *          - data type - int8u. The two byte zigbee type value for the requested report
   1919           *          - min report time - int16u. Minimum number of seconds between reports.
   1920           *          - max report time - int16u. Maximum number of seconds between reports.
   1921           *          - reportable change - byte array. Amount of change to trigger a report.
   1922           *
   1923           *        <b>zcl global expect-report-from-me &lt;cluster&gt &lt;attribute id&gt; &lt;timeout&gt;</b>
   1924           *        - <i> Create a expect-report-from-me message with associated values.
   1925           *          - cluster - int16u. The cluster id for requested report.
   1926           *          - attribute id - int16u. The attribute for requested report.
   1927           *          - timeout - int16u. The maximum amount of time between reports.
   1928           *
   1929           *        <b>zcl global direction &lt;direction&gt;</b>
   1930           *        - <i> Sets the direction for global commands, either client to server 
   1931           *              or server to client.
   1932           *          - direction - int8u. The direction for global commands.
   1933           *            client-to-server == 0, server-to-client == 1.</i>
   1934           *
   1935           *        <b>zcl global disc-com-gen &lt;start command id&gt; &lt;max command ids&gt;</b>
   1936           *        - <i> Sends a global Discover Commands Generated command.
   1937           *          - start command id - int8u. The command id to start discovery at.
   1938           *          - max command ids - int8u. The maximum number of command ids to return.
   1939           *
   1940           *        <b>zcl global disc-com-rec &lt;start command id&gt; &lt;max command ids&gt;</b>
   1941           *        - <i> Sends a global Discover Commands Received command.
   1942           *          - start command id - int8u. The command id to start discovery at.
   1943           *          - max command ids - int8u. The maximum number of command ids to return.
   1944           */
   1945          #define EMBER_AF_DOXYGEN_CLI__ZCL_GLOBAL_COMMANDS
   1946          /** @} END addtogroup */
   1947          EmberCommandEntry zclGlobalCommands[] = {
   1948            {"read", zclGlobalReadCommand, "vv"},
   1949            {"write", zclGlobalWriteCommand, "vvub"},
   1950            {"uwrite", zclGlobalWriteCommand, "vvub"},
   1951            {"nwrite", zclGlobalWriteCommand, "vvub"},
   1952            {"discover", zclGlobalDiscoverCommand, "vvu"},
   1953            {"report-read", zclGlobalReportReadCommand, "vvu"},
   1954            {"send-me-a-report", zclGlobalSendMeAReportCommand, "vvuvvb"},
   1955            {"expect-report-from-me", zclGlobalExpectReportFromMeCommand, "vvv"},
   1956            {"report", zclGlobalReportCommand, "uvvu"},
   1957            {"direction", zclGlobalDirectionCommand, "u"},
   1958            {"disc-com-gen", zclGlobalCommandDiscoveryCommand, "vuu"},
   1959            {"disc-com-rec", zclGlobalCommandDiscoveryCommand, "vuu"},
   1960            { NULL }
   1961          };
   1962          
   1963          EmberCommandEntry zclTestResponseCommands[] = {
   1964            {"on", zclTestResponseOnCommand, ""},
   1965            {"off", zclTestResponseOffCommand, ""},  
   1966            { NULL }
   1967          };
   1968          
   1969          EmberCommandEntry zclTestCommands[] = {
   1970            {"response", NULL, (PGM_P)zclTestResponseCommands},
   1971            { NULL }
   1972          };
   1973          
   1974          #ifdef ZCL_USING_BASIC_CLUSTER_CLIENT
   1975          EmberCommandEntry zclBasicCommands[] = {
   1976            {"rtfd", zclBasicRtfdCommand, ""},
   1977            { NULL }
   1978          };
   1979          #endif
   1980          
   1981          #if defined(ZCL_USING_IDENTIFY_CLUSTER_CLIENT) || defined(ZCL_USING_IDENTIFY_CLUSTER_SERVER)
   1982          EmberCommandEntry zclIdentifyCommands[] = {
   1983            #ifdef ZCL_USING_IDENTIFY_CLUSTER_CLIENT
   1984            {"id", zclIdentifyIdCommand, "v"},
   1985            {"query", zclIdentifyQueryCommand, ""},
   1986            {"trigger", zclIdentifyTriggerEffectCommand, "uu"},
   1987            #endif
   1988            #ifdef ZCL_USING_IDENTIFY_CLUSTER_SERVER
   1989            {"on", zclIdentifyOnCommand, "uv"},
   1990            {"off", zclIdentifyOffCommand, "u"},
   1991            #endif
   1992            { NULL }
   1993          };
   1994          #endif
   1995          
   1996          #ifdef ZCL_USING_GROUPS_CLUSTER_CLIENT
   1997          EmberCommandEntry zclGroupsCommands[] = {
   1998            {"add", zclGroupsAddCommand, "vb"},
   1999            {"ad-if-id", zclGroupsAddCommand, "vb"},
   2000            {"view", zclGroupsViewCommand, "v"},
   2001            {"get", zclGroupsGetCommand, "uv*"},
   2002            {"remove", zclGroupsRemoveCommand, "v"},
   2003            {"rmall", zclGroupsRemoveAllCommand, ""},
   2004            { NULL }
   2005          };
   2006          #endif
   2007          
   2008          #ifdef ZCL_USING_SCENES_CLUSTER_CLIENT
   2009          EmberCommandEntry zclScenesSetCommands[] = {
   2010            {"on", zclScenesSetCommand, "u"},
   2011            {"off", zclScenesSetCommand, "u"},
   2012            { NULL }
   2013          };
   2014          
   2015          EmberCommandEntry zclScenesCommands[] = {
   2016            {"add", zclScenesAddCommand, "vuvb"},
   2017            {"view", zclScenesViewCommand, "vu"},
   2018            {"remove", zclScenesRemoveCommand, "vu"},
   2019            {"rmall", zclScenesRemoveAllCommand, "v"},
   2020            {"store", zclScenesStoreCommand, "vu"},
   2021            {"recall", zclScenesRecallCommand, "vu"},
   2022            {"get", zclScenesGetMembershipCommand, "v"},
   2023            {"eadd", zclScenesAddCommand, "vuvb"},
   2024            {"eview", zclScenesViewCommand, "vu"},
   2025            {"copy", zclScenesCopyCommand, "uvuvu"},
   2026            {"set", NULL, (PGM_P)zclScenesSetCommands},
   2027            { NULL }
   2028          };
   2029          #endif
   2030          
   2031          #ifdef ZCL_USING_ON_OFF_CLUSTER_CLIENT
   2032          EmberCommandEntry zclOnOffCommands[] = {
   2033            {"on", zclOnOffCommand, ""},
   2034            {"off", zclOnOffCommand, ""},
   2035            {"toggle", zclOnOffCommand, ""},
   2036            {"offeffect", zclOnOffOffWithEffectCommand, "uu"},
   2037            {"onrecall", zclOnOffOnWithRecallGlobalSceneCommand, ""},
   2038            {"ontimedoff", zclOnOffOnWithTimedOffCommand, "uvv"},
   2039            { NULL }
   2040          };
   2041          #endif
   2042          
   2043          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_CLIENT
   2044          EmberCommandEntry zclLevelControlCommands[] = {
   2045            {"mv-to-level", zclLevelControlMoveToLevelCommand, "uv"},
   2046            {"move", zclLevelControlMoveCommand, "uu"},
   2047            {"step", zclLevelControlStepCommand, "uuv"},
   2048            {"stop", zclLevelControlStopCommand, ""},
   2049            {"o-mv-to-level", zclLevelControlMoveToLevelCommand, "uv"},
   2050            {"o-move", zclLevelControlMoveCommand, "uu"},
   2051            {"o-step", zclLevelControlStepCommand, "uuv"},
   2052            {"o-stop", zclLevelControlStopCommand, ""},
   2053            { NULL }
   2054          };
   2055          #endif
   2056          
   2057          #ifdef ZCL_USING_THERMOSTAT_CLUSTER_CLIENT
   2058          EmberCommandEntry zclThermostatCommands[] = {
   2059            {"set", zclThermostatSetCommand, "uu"},
   2060            { NULL }
   2061          };
   2062          #endif
   2063          
   2064          #ifdef ZCL_USING_IAS_ZONE_CLUSTER_SERVER
   2065          EmberCommandEntry zclIasZoneCommands[] = {
   2066            {"enroll", zclIasZoneEnrollCommand, "vv"},
   2067            {"sc", zclIasZoneStatusChangeCommand, "vuuv"},
   2068            { NULL }
   2069          };
   2070          #endif
   2071          
   2072          #ifdef ZCL_USING_IAS_ACE_CLUSTER_CLIENT
   2073          EmberCommandEntry zclIasAceCommands[] = {
   2074            {"a", zclIasAceArmCommand, "ubu"},
   2075            {"b", zclIasAceBypassCommand, "b"},
   2076            {"e", zclIasAceEmergencyCommand, ""},
   2077            {"f", zclIasAceFireCommand, ""},
   2078            {"p", zclIasAcePanicCommand, ""},
   2079            {"getzm", zclIasAceGetZoneMapCommand, ""},
   2080            {"getzi", zclIasAceGetZoneInfoCommand, "u"},
   2081            { NULL }
   2082          };
   2083          #endif
   2084          
   2085          #ifdef ZCL_USING_COLOR_CONTROL_CLUSTER_CLIENT
   2086          EmberCommandEntry zclColorControlCommands[] = {
   2087            {"movetohue", zclColorControlMoveToHueCommand, "uuv"},
   2088            {"movehue", zclColorControlMoveHueCommand, "uu"},
   2089            {"stephue", zclColorControlStepHueCommand, "uuu"},
   2090            {"movetosat", zclColorControlMoveToSatCommand, "uv"},
   2091            {"movesat", zclColorControlMoveSatCommand, "uu"},
   2092            {"stepsat", zclColorControlStepSatCommand, "uuu"},
   2093            {"movetohueandsat", zclColorControlMoveToHueAndSatCommand, "uuv"},
   2094            {"movetocolor",     zclColorControlMoveToColorCommand, "vvv"},
   2095            {"movecolor",       zclColorControlMoveColorCommand, "vv"},
   2096            {"stepcolor",       zclColorControlStepColorCommand, "vvv"},
   2097            {"movetocolortemp", zclColorControlMoveToColorTemperatureCommand, "vv"},
   2098            {"emovetohue", zclColorControlMoveToHueCommand, "vuv"},
   2099            {"emovehue", zclColorControlMoveHueCommand, "uv"},
   2100            {"estephue", zclColorControlStepHueCommand, "uvv"},
   2101            {"emovetohueandsat", zclColorControlMoveToHueAndSatCommand, "vuv"},
   2102            {"loop", zclColorControlColorLoopSetCommand, "uuuvv"},
   2103            {"stopmovestep", zclColorControlStopMoveStepCommand, ""},
   2104            {"movecolortemp", zclColorControlMoveColorCommand, "uvvv"},
   2105            {"stepcolortemp", zclColorControlStepColorCommand, "uvvvv"},
   2106            { NULL }
   2107          };
   2108          #endif
   2109          
   2110          #ifdef ZCL_USING_POLL_CONTROL_CLUSTER_CLIENT
   2111          EmberCommandEntry zclPollControlCommands[] = {
   2112            emberCommandEntryAction("stop",  zclPollControlFastPollStopCommand,    "",  "Fast Poll Stop"),
   2113            emberCommandEntryAction("long",  zclPollControlSetPollIntervalCommand, "w", "Set Long Poll Interval"),
   2114            emberCommandEntryAction("short", zclPollControlSetPollIntervalCommand, "v", "Set Short Poll Interval"),
   2115            emberCommandEntryTerminator(),
   2116          };
   2117          #endif
   2118          
   2119          #ifdef ZCL_USING_POWER_PROFILE_CLUSTER_CLIENT
   2120          EmberCommandEntry zclPowerProfileCommands[] = {
   2121            emberCommandEntryAction("profile",  zclPowerProfileRequestCommand,
   2122                                    "u", "Request Profile"),
   2123            emberCommandEntryAction("state",  zclPowerProfileStateRequestCommand,
   2124                                    "", "Request State"),
   2125            emberCommandEntryAction("energy-phases-schedule",
   2126                                    zclPowerProfileEnergyPhasesScheduleNotificationCommand,
   2127                                    "?", "Notify Energy Phase Schedule"),
   2128            emberCommandEntryAction("schedule-constraints",
   2129                                    zclPowerProfileScheduleConstraintsRequestCommand,
   2130                                    "u", "Request Schedule Constraints"),
   2131            emberCommandEntryAction("energy-phases-schedule-states",
   2132                                    zclPowerProfileEnergyPhasesScheduleStateRequestCommand,
   2133                                    "u", "Request Energy Phases Schedule States"),
   2134            emberCommandEntryTerminator(),
   2135          };
   2136          #endif //ZCL_USING_POWER_PROFILE_CLUSTER_CLIENT
   2137          
   2138          #ifdef ZCL_USING_WINDOW_COVERING_CLUSTER_CLIENT
   2139          EmberCommandEntry zclWindowCoveringCommands[] = {
   2140            emberCommandEntryAction("up",  zclWindowCoveringUpCommand,
   2141                                    "", "Up"),
   2142            emberCommandEntryAction("down",  zclWindowCoveringDownCommand,
   2143                                    "", "Down"),
   2144            emberCommandEntryAction("stop",
   2145                                    zclWindowCoveringStopCommand,
   2146                                    "", "Stop"),
   2147            emberCommandEntryAction("go-to-lift-value",
   2148                                    zclWindowCoveringGoToLiftValueCommand,
   2149                                    "v", "Go To Lift Value"),
   2150            emberCommandEntryAction("go-to-lift-percent",
   2151                                    zclWindowCoveringGoToLiftPercentageCommand,
   2152                                    "u", "Go To Lift Percentage"),
   2153            emberCommandEntryAction("go-to-tilt-value",
   2154                                    zclWindowCoveringGoToTiltValueCommand,
   2155                                    "v", "Go To Tilt Value"),
   2156            emberCommandEntryAction("go-to-tilt-percentage",
   2157                                    zclWindowCoveringGoToTiltPercentageCommand,
   2158                                    "u", "Go To Tilt Percentage"),
   2159            emberCommandEntryTerminator(),
   2160          };
   2161          #endif //ZCL_USING_WINDOW_COVERING_CLUSTER_CLIENT
   2162          
   2163          #if defined(ZCL_USING_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_CLIENT) || defined(ZCL_USING_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_SERVER)
   2164          
   2165          EmberCommandEntry zclDrlcCommands[] = {
   2166            #ifdef ZCL_USING_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_SERVER
   2167            
   2168            {"lce", zclDrlcLoadControlEventCommand, "wwvu"},
   2169            {"cl", zclDrlcCancelCommand, "wvuuw"},
   2170            {"ca", zclDrlcCancelAllCommand, ""},
   2171            #endif
   2172            #ifdef ZCL_USING_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_CLIENT
   2173            {"gse", zclDrlcGetScheduledEventsCommand, "wu"},
   2174            #endif
   2175            { NULL }
   2176          };
   2177          #endif //ZCL_USING_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_CLIENT || SERVER
   2178          
   2179          
   2180          
   2181          #if defined(ZCL_USING_SIMPLE_METERING_CLUSTER_CLIENT) || defined(ZCL_USING_SIMPLE_METERING_CLUSTER_SERVER)
   2182          EmberCommandEntry zclSimpleMeteringCommands[] = {
   2183          #ifdef ZCL_USING_SIMPLE_METERING_CLUSTER_CLIENT
   2184            {"gp", zclSimpleMeteringGetProfileCommand, "uwu"},
   2185            {"fp", zclSimpleMeteringFastPollCommand, "uu"},
   2186          #endif //ZCL_USING_SIMPLE_METERING_CLUSTER_CLIENT
   2187          #ifdef ZCL_USING_SIMPLE_METERING_CLUSTER_SERVER
   2188            {"rm", zclSimpleMeteringRequestMirrorCommand, ""},
   2189            {"dm", zclSimpleMeteringDeleteMirrorCommand, ""},
   2190          #endif //ZCL_USING_SIMPLE_METERING_CLUSTER_SERVER
   2191            { NULL }
   2192          };
   2193          #endif //ZCL_USING_SIMPLE_METERING_CLUSTER_CLIENT || ZCL_USING_SIMPLE_METERING_CLUSTER_SERVER
   2194          
   2195          #ifdef ZCL_USING_PRICE_CLUSTER_CLIENT
   2196          EmberCommandEntry zclPriceClientCommands[] = {
   2197            {"cu", zclPriceGetCurrentCommand, ""},
   2198            {"sc", zclPriceGetScheduleCommand, "wu"},
   2199            { NULL }
   2200          };
   2201          #endif //ZCL_USING_PRICE_CLUSTER_CLIENT
   2202          
   2203          EmberCommandEntry zclMessageCommands[] = {
   2204          #ifdef ZCL_USING_MESSAGING_CLUSTER_CLIENT
   2205            {"get", zclMessageGetCommand, ""},
   2206          #endif //ZCL_USING_MESSAGING_CLUSTER_CLIENT
   2207            { NULL }
   2208          };
   2209          
   2210          #if defined(ZCL_USING_GENERIC_TUNNEL_CLUSTER_CLIENT) || defined(ZCL_USING_GENERIC_TUNNEL_CLUSTER_SERVER)
   2211          EmberCommandEntry zclTunnelCommands[] = {
   2212          #ifdef ZCL_USING_GENERIC_TUNNEL_CLUSTER_CLIENT
   2213            {"match", zclTunnelMatchCommand, "b"},
   2214          #endif //ZCL_USING_GENERIC_TUNNEL_CLUSTER_CLIENT
   2215          #ifdef ZCL_USING_GENERIC_TUNNEL_CLUSTER_SERVER
   2216            {"advertise", zclTunnelAdvertiseCommand, "b"},
   2217            {"response", zclTunnelResponseCommand, ""},
   2218          #endif //ZCL_USING_GENERIC_TUNNEL_CLUSTER_SERVER
   2219            { NULL }
   2220          };
   2221          #endif //ZCL_USING_GENERIC_TUNNEL_CLUSTER_CLIENT || ZCL_USING_GENERIC_TUNNEL_CLUSTER_SERVER
   2222          
   2223          #ifdef ZCL_USING_BACNET_PROTOCOL_TUNNEL_CLUSTER_CLIENT
   2224          EmberCommandEntry zclBacnetTransferCommands[] = {
   2225            {"fixed", zclBacnetTransferFixedCommand, "ub"},
   2226            {"random", zclBacnetTransferRandomCommand, "u"},
   2227            {"whois", zclBacnetTransferWhoisCommand, ""}, //removed length byte from whois
   2228            { NULL },
   2229          };
   2230          
   2231          EmberCommandEntry zclBacnetCommands[] = {
   2232            {"transfer-npdu", NULL, (PGM_P)zclBacnetTransferCommands},
   2233            { NULL }
   2234          };
   2235          #endif
   2236          
   2237          #ifdef ZCL_USING_DOOR_LOCK_CLUSTER_CLIENT
   2238          EmberCommandEntry zclDoorLockCommands[] = {
   2239            {"lock", zclDoorLockCommand, ""},
   2240            {"unlock", zclDoorLockCommand, ""},
   2241            { NULL }
   2242          };
   2243          #endif //ZCL_USING_DOOR_LOCK_CLUSTER_CLIENT
   2244          
   2245          #if defined(ZCL_USING_TUNNELING_CLUSTER_CLIENT) || defined(ZCL_USING_TUNNELING_CLUSTER_SERVER)
   2246          EmberCommandEntry zclTunnelingCommands[] = {
   2247          #ifdef ZCL_USING_TUNNELING_CLUSTER_CLIENT
   2248            {"request", zclTunnelingRequestCommand, "uvuv"},
   2249            {"close", zclTunnelingCloseCommand, "v"},
   2250            {"transfer-to-server", zclTunnelingTransferToServerCommand, "vb"},
   2251            {"random-to-server", zclTunnelingRandomToServerCommand, "vv"},
   2252          #endif //ZCL_USING_TUNNELING_CLUSTER_CLIENT
   2253          #ifdef ZCL_USING_TUNNELING_CLUSTER_SERVER
   2254            {"transfer-to-client", zclTunnelingTransferToClientCommand, "vb"},
   2255            {"random-to-client", zclTunnelingRandomToClientCommand, "vv"},
   2256          #endif //ZCL_USING_TUNNELING_CLUSTER_SERVER
   2257            { NULL }
   2258          };
   2259          #endif //defined(ZCL_USING_TUNNELING_CLUSTER_CLIENT) || defined(ZCL_USING_TUNNELING_CLUSTER_SERVER)
   2260          
   2261          EmberCommandEntry zclCommands[] = {
   2262          
   2263          //#define CERTIFICATION_TESTING
   2264          #ifdef CERTIFICATION_TESTING
   2265            {"attr-read-frag-resp", attributeReadCausingFragmentedResponseCommand, ""},
   2266          #endif //CERTIFICATION_TESTING
   2267          
   2268            {"mfg-code", zclMfgCodeCommand, "v" },
   2269            {"x-default-resp", zclXDefaultRespCommand, "u" },
   2270          
   2271            {"global", NULL, (PGM_P)zclGlobalCommands},
   2272            {"test", NULL, (PGM_P)zclTestCommands},
   2273            {"time", zclTimeCommand, "w"},
   2274            #ifdef ZCL_USING_BASIC_CLUSTER_CLIENT  
   2275            {"basic", NULL, (PGM_P)zclBasicCommands},
   2276            #endif
   2277          
   2278            #if defined(ZCL_USING_IDENTIFY_CLUSTER_CLIENT) || defined(ZCL_USING_IDENTIFY_CLUSTER_SERVER)
   2279            {"identify", NULL, (PGM_P)zclIdentifyCommands},
   2280            #endif //ZCL_USING_IDENTIFY_CLUSTER_CLIENT || SERVER
   2281            #ifdef ZCL_USING_GROUPS_CLUSTER_CLIENT
   2282            {"groups", NULL, (PGM_P)zclGroupsCommands},
   2283            #endif
   2284            #ifdef ZCL_USING_SCENES_CLUSTER_CLIENT
   2285            {"scenes", NULL, (PGM_P)zclScenesCommands},
   2286            #endif
   2287            #ifdef ZCL_USING_ON_OFF_CLUSTER_CLIENT
   2288            {"on-off", NULL, (PGM_P)zclOnOffCommands},
   2289            #endif
   2290            #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_CLIENT
   2291            {"level-control", NULL, (PGM_P)zclLevelControlCommands},
   2292            #endif
   2293            #ifdef ZCL_USING_THERMOSTAT_CLUSTER_CLIENT
   2294            {"tstat", NULL, (PGM_P)zclThermostatCommands},
   2295            #endif
   2296            #ifdef ZCL_USING_IAS_ZONE_CLUSTER_SERVER
   2297            {"ias-zone", NULL, (PGM_P)zclIasZoneCommands},
   2298            #endif
   2299            #ifdef ZCL_USING_IAS_ACE_CLUSTER_CLIENT
   2300            {"ias-ace", NULL, (PGM_P)zclIasAceCommands},
   2301            #endif
   2302            #ifdef ZCL_USING_POLL_CONTROL_CLUSTER_CLIENT
   2303            emberCommandEntrySubMenu("poll-control", zclPollControlCommands, "Poll Control commands"),
   2304            #endif
   2305            #ifdef ZCL_USING_POWER_PROFILE_CLUSTER_CLIENT
   2306            emberCommandEntrySubMenu("power-profile", zclPowerProfileCommands, "Power Profile commands"),
   2307            #endif
   2308            #ifdef ZCL_USING_WINDOW_COVERING_CLUSTER_CLIENT
   2309            emberCommandEntrySubMenu("window-covering", zclWindowCoveringCommands, "Window Covering commands"),
   2310            #endif
   2311            #ifdef ZCL_USING_COLOR_CONTROL_CLUSTER_CLIENT
   2312            {"colorcontrol", NULL, (PGM_P)zclColorControlCommands},
   2313            #endif
   2314          #if defined(ZCL_USING_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_CLIENT) || defined(ZCL_USING_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_SERVER)
   2315            {"drlc", NULL, (PGM_P)zclDrlcCommands},
   2316          #endif //ZCL_USING_DEMAND_RESPONSE_LOAD_CONTROL_CLUSTER_CLIENT || SERVER
   2317          #if defined(ZCL_USING_SIMPLE_METERING_CLUSTER_CLIENT) || defined(ZCL_USING_SIMPLE_METERING_CLUSTER_SERVER)
   2318            {"sm", NULL, (PGM_P)zclSimpleMeteringCommands},
   2319          #endif //ZCL_USING_SIMPLE_METERING_CLUSTER_CLIENT || ZCL_USING_SIMPLE_METERING_CLUSTER_SERVER
   2320            #ifdef ZCL_USING_PRICE_CLUSTER_CLIENT
   2321            {"pr", NULL, (PGM_P)zclPriceClientCommands},
   2322            #endif
   2323            #if defined(ZCL_USING_MESSAGING_CLUSTER_CLIENT) 
   2324            {"message", NULL, (PGM_P)zclMessageCommands},
   2325            #endif
   2326          #if defined(ZCL_USING_GENERIC_TUNNEL_CLUSTER_CLIENT) || defined(ZCL_USING_GENERIC_TUNNEL_CLUSTER_SERVER)
   2327            {"tunnel", NULL, (PGM_P)zclTunnelCommands},
   2328          #endif //ZCL_USING_GENERIC_TUNNEL_CLUSTER_CLIENT || ZCL_USING_GENERIC_TUNNEL_CLUSTER_SERVER
   2329            #ifdef ZCL_USING_BACNET_PROTOCOL_TUNNEL_CLUSTER_CLIENT
   2330            {"bacnet", NULL, (PGM_P)zclBacnetCommands},
   2331            #endif
   2332          
   2333            #ifdef ZCL_USING_DOOR_LOCK_CLUSTER_CLIENT
   2334            {"lock", NULL, (PGM_P)zclDoorLockCommands},
   2335            #endif //ZCL_USING_DOOR_LOCK_CLUSTER_CLIENT
   2336          
   2337          #if defined(ZCL_USING_TUNNELING_CLUSTER_CLIENT) || defined(ZCL_USING_TUNNELING_CLUSTER_SERVER)
   2338            {"tunneling", NULL, (PGM_P)zclTunnelingCommands},
   2339          #endif //defined(ZCL_USING_TUNNELING_CLUSTER_CLIENT) || defined(ZCL_USING_TUNNELING_CLUSTER_SERVER)
   2340          
   2341          
   2342            { NULL }
   2343          };
   2344          
   2345          // ******************************************************
   2346          // keys command functions
   2347          // ******************************************************
   2348          
   2349          EmberCommandEntry keysCommands[] = {
   2350            emberCommandEntryAction("clear", keysClearCommand, "", "Clear all link keys"),
   2351            emberCommandEntryAction("print", keysPrintCommand, "", "Print the NWK and link key table"),
   2352            emberCommandEntryAction("delete", keysDeleteCommand, "u", "Delete the specified link key index"),
   2353            emberCommandEntryTerminator(),
   2354          };
   2355          
   2356          // ******************************************************
   2357          // Print commands.
   2358          //
   2359          // print attr
   2360          // print time
   2361          // ******************************************************
   2362          
   2363          EmberCommandEntry printCommands[] = {
   2364            emberCommandEntryAction("time", printTimeCommand, "", "Print current time attribute"),
   2365            emberCommandEntryAction("attr", emberAfPrintAttributeTable, "", "Print the attribute table"),
   2366            emberCommandEntryTerminator(),
   2367          };
   2368          
   2369          // ******************************************************
   2370          // interpan commands
   2371          //
   2372          // mac is     : [FC 2; seq 1; dest PAN 2; dest addr 2|8; src pan 2; src addr 8]
   2373          // stub nwk is: [Frame Control 2]
   2374          // stub APS is: [FC 1; groupId 0|2; clusterId 2; appProfileId 2]
   2375          //
   2376          // MAC FC = bits 0,1,2: frame type (Data) 1
   2377          //          bit 3: security enabled = false (0)
   2378          //          bit 4: frame pending  = false (0)
   2379          //          bit 5: ack required = true (1)
   2380          //          bit 6: intra PAN = false (0)
   2381          //          bit 7,8,9: reserved (0)
   2382          //          bit 10,11: dest addr mode = group (1), short (2), long(3)
   2383          //          bit 12,13: reserved (0)
   2384          //          bit 14,15: src addr mode = long(3)
   2385          //   for GROUP_DEST FC is: 0xC421
   2386          //   for SHORT_DEST FC is: 0xC821
   2387          //   for LONG_DEST FC is : 0xCC21
   2388          //
   2389          // Stub NWK FC: bits 0,1: frame type 3 (0b11)
   2390          //              bits 2-5: protocol version 2 (0b0010)
   2391          //              bits 6-15: reserved (0)
   2392          //   this is always 0x000B
   2393          //
   2394          // stub APS FC: bits 0,1: 3 (0b11)
   2395          //              bits 2,3: delivery mode unicast(0), bcast(2), group(3)
   2396          //              bit 4: reserved (0)
   2397          //              bit 5: security: none (0)
   2398          //              bit 6: ack request: NO ack (0)
   2399          //              bit 7: ext header present: No (0)
   2400          //   this is 03 for unicast, 0B for bcast, 0F for group
   2401          //
   2402          // ******************************************************
   2403          
   2404          EmberCommandEntry interpanCommands[] = {
   2405            {"group", interpanCommand, "vvv"},
   2406            {"short", interpanCommand, "vvv"},
   2407            {"long",  interpanLongCommand, "bvvv"},
   2408            { NULL }
   2409          };
   2410          
   2411          #endif // EMBER_AF_GENERATE_CLI
   2412          
   2413          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   cliBufferPrint
        24   -> emberAfPrint
        24   -> emberAfPrintBuffer
         0   -> emberAfPrintln
        24   -> emberAfPrintln
       0   emAfApsFrameClusterIdSetup
       8   emAfApsFrameEndpointSetup
         8   -> emberAfPrimaryEndpointForCurrentNetworkIndex
      40   emAfCliBsendCommand
        40   -> emberAfSendUnicast
        40   -> emberGetBinding
        40   -> emberUnsignedCommandArgument
      16   emAfCliRawCommand
        16   -> cliBufferPrint
        16   -> emAfApsFrameClusterIdSetup
        16   -> emberAfNextSequence
        16   -> emberCopyStringArgument
        16   -> emberStringCommandArgument
        16   -> emberUnsignedCommandArgument
      72   emAfCliReadCommand
        72   -> emberAfIsThisDataTypeAStringType
        72   -> emberAfReadAttribute
        72   -> emberUnsignedCommandArgument
      24   emAfCliSendCommand
        24   -> emAfApsFrameEndpointSetup
        24   -> emberAfGetNodeId
        24   -> emberAfPreCliSendCallback
        24   -> emberAfSendBroadcast
        24   -> emberAfSendMulticast
        24   -> emberAfSendUnicast
        24   -> emberUnsignedCommandArgument
       8   emAfCliTimesyncCommand
         8   -> cliBufferPrint
         0   -> emAfCliSendCommand
         8   -> zclBufferAddWord
         8   -> zclBufferSetup
      72   emAfCliWriteCommand
        72   -> emAfPrintStatus
        72   -> emberAfGetDataSize
        72   -> emberAfIsThisDataTypeAStringType
        72   -> emberAfWriteAttribute
        72   -> emberCopyStringArgument
        72   -> emberUnsignedCommandArgument
        72   -> halCommonMemSet
       8   eraseKeyTableEntry
         8   -> emSetKeyTableEntry
      40   interpanCommand
        40   -> emberAfInterpanSendMessageCallback
        40   -> emberUnsignedCommandArgument
        40   -> halCommonMemSet
      32   interpanLongCommand
        32   -> emberAfInterpanSendMessageCallback
        32   -> emberCopyBigEndianEui64Argument
        32   -> emberUnsignedCommandArgument
        32   -> halCommonMemSet
       0   keysClearCommand
       8   keysDeleteCommand
         8   -> emberUnsignedCommandArgument
         0   -> eraseKeyTableEntry
       0   keysPrintCommand
         0   -> printKeyInfo
      32   makeZclBuffer
        32   -> cliBufferPrint
        32   -> halInternalAssertFailed
        32   -> zclBufferAddBuffer
        32   -> zclBufferAddByte
        32   -> zclBufferAddInt32
        32   -> zclBufferAddWord
        32   -> zclBufferSetup
       8   printTimeCommand
         8   -> emberAfGetCurrentTime
         0   -> emberAfPrintTime
      16   zclBufferAddBuffer
        16   -> halCommonMemMove
       0   zclBufferAddByte
       8   zclBufferAddByteFromArgument
         8   -> emberUnsignedCommandArgument
         0   -> zclBufferAddByte
      16   zclBufferAddInt32
        16   -> zclBufferAddByte
       8   zclBufferAddInt32FromArgument
         8   -> emberUnsignedCommandArgument
         0   -> zclBufferAddInt32
       8   zclBufferAddInt8sFromArgument
         8   -> emberSignedCommandArgument
         0   -> zclBufferAddByte
      16   zclBufferAddLengthAndStringFromArgument
        16   -> emberCopyStringArgument
       8   zclBufferAddString
         8   -> emberAfStringLength
         0   -> zclBufferAddBuffer
       8   zclBufferAddWord
         0   -> zclBufferAddByte
         8   -> zclBufferAddByte
       8   zclBufferAddWordFromArgument
         8   -> emberUnsignedCommandArgument
         0   -> zclBufferAddWord
      24   zclBufferSetup
        24   -> emAfApsFrameClusterIdSetup
        24   -> emberAfNextSequence
       0   zclDrlcLoadControlEventCommand
       8   zclGlobalCommandDiscoveryCommand
         0   -> cliBufferPrint
         8   -> emberUnsignedCommandArgument
         8   -> zclBufferAddByteFromArgument
         8   -> zclBufferSetup
       8   zclGlobalDirectionCommand
         8   -> emberUnsignedCommandArgument
       8   zclGlobalDiscoverCommand
         0   -> cliBufferPrint
         8   -> zclGlobalSetup
       8   zclGlobalExpectReportFromMeCommand
         0   -> cliBufferPrint
         8   -> emberUnsignedCommandArgument
         8   -> zclBufferAddByte
         8   -> zclBufferAddWordFromArgument
         8   -> zclBufferSetup
       8   zclGlobalReadCommand
         0   -> cliBufferPrint
         8   -> zclGlobalSetup
      72   zclGlobalReportCommand
        72   -> cliBufferPrint
        72   -> emberAfGetDataSize
        72   -> emberAfIsThisDataTypeAStringType
        72   -> emberAfReadAttribute
        72   -> emberAfStringLength
        72   -> emberUnsignedCommandArgument
        72   -> halCommonMemMove
        72   -> zclBufferAddByte
        72   -> zclBufferAddWord
        72   -> zclBufferSetup
       8   zclGlobalReportReadCommand
         0   -> cliBufferPrint
         8   -> emberUnsignedCommandArgument
         8   -> zclBufferAddByteFromArgument
         8   -> zclBufferAddWordFromArgument
         8   -> zclBufferSetup
      16   zclGlobalSendMeAReportCommand
         0   -> cliBufferPrint
        16   -> emberAfGetAttributeAnalogOrDiscreteType
        16   -> emberAfGetDataSize
        16   -> emberCopyStringArgument
        16   -> emberUnsignedCommandArgument
        16   -> zclBufferAddByte
        16   -> zclBufferAddWordFromArgument
        16   -> zclBufferSetup
       8   zclGlobalSetup
         8   -> emberUnsignedCommandArgument
         0   -> zclBufferAddByteFromArgument
         8   -> zclBufferAddWordFromArgument
         8   -> zclBufferSetup
      16   zclGlobalWriteCommand
         0   -> cliBufferPrint
        16   -> emberAfGetDataSize
        16   -> emberAfIsThisDataTypeAStringType
        16   -> emberCopyStringArgument
        16   -> emberUnsignedCommandArgument
        16   -> zclBufferAddLengthAndStringFromArgument
        16   -> zclGlobalSetup
       0   zclGroupsGetCommand
       0   zclIdentifyIdCommand
         0   -> zclSimpleCommand
      16   zclIdentifyOffCommand
        16   -> emberAfWriteAttribute
        16   -> emberUnsignedCommandArgument
      16   zclIdentifyOnCommand
        16   -> emberAfWriteAttribute
        16   -> emberUnsignedCommandArgument
       0   zclIdentifyQueryCommand
         0   -> zclSimpleCommand
       0   zclIdentifyTriggerEffectCommand
         0   -> zclSimpleCommand
       0   zclLevelControlMoveCommand
         0   -> zclSimpleCommand
       0   zclLevelControlMoveToLevelCommand
         0   -> zclSimpleCommand
       0   zclLevelControlStepCommand
         0   -> zclSimpleCommand
       0   zclLevelControlStopCommand
         0   -> zclSimpleCommand
       8   zclMfgCodeCommand
         8   -> emberUnsignedCommandArgument
       0   zclOnOffCommand
         0   -> zclSimpleCommand
       0   zclOnOffOffWithEffectCommand
         0   -> zclSimpleCommand
       0   zclOnOffOnWithRecallGlobalSceneCommand
         0   -> zclSimpleCommand
       0   zclOnOffOnWithTimedOffCommand
         0   -> zclSimpleCommand
      24   zclSimpleCommand
         0   -> cliBufferPrint
        24   -> emberCommandArgumentCount
        24   -> zclBufferAddByteFromArgument
        24   -> zclBufferAddInt32FromArgument
        24   -> zclBufferAddInt8sFromArgument
        24   -> zclBufferAddLengthAndStringFromArgument
        24   -> zclBufferAddWordFromArgument
        24   -> zclBufferSetup
       0   zclTestResponseOffCommand
         0   -> emberAfSetNoReplyForNextMessage
       0   zclTestResponseOnCommand
         0   -> emberAfSetNoReplyForNextMessage
       8   zclTimeCommand
         0   -> emberAfSetTime
         8   -> emberUnsignedCommandArgument
       8   zclXDefaultRespCommand
         8   -> emberUnsignedCommandArgument


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Constant "">
      36  ?<Constant "Msg: clus 0x%2x, cmd ...">
      12  ?<Constant "buffer: ">
       8  ?<Constant "write">
      12  ?<Constant "zcl-cli.c">
       4  ??DataTable15
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       4  ??DataTable34_3
       6  ??Subroutine14_0
       8  ?Subroutine0
       4  ?Subroutine1
      10  ?Subroutine10
      10  ?Subroutine11
      10  ?Subroutine12
      10  ?Subroutine13
       6  ?Subroutine2
       6  ?Subroutine3
      26  ?Subroutine4
       8  ?Subroutine5
      10  ?Subroutine6
       8  ?Subroutine7
       6  ?Subroutine8
       4  ?Subroutine9
      84  appZclBuffer
      84  cliBufferPrint
      14  emAfApsFrameClusterIdSetup
      20  emAfApsFrameEndpointSetup
      86  emAfCliBsendCommand
      68  emAfCliRawCommand
      70  emAfCliReadCommand
     124  emAfCliSendCommand
      34  emAfCliTimesyncCommand
     138  emAfCliWriteCommand
      20  eraseKeyTableEntry
      20  globalApsFrame
          zclCmdIsBuilt
          disableDefaultResponse
          zclGlobalDirection
          appZclBufferLen
          mfgSpecificId
      62  interpanCommand
      62  interpanLongCommand
       2  keysClearCommand
      14  keysDeleteCommand
       4  keysPrintCommand
     120  makeZclBuffer
      14  printTimeCommand
      32  zclBufferAddBuffer
      18  zclBufferAddByte
       8  zclBufferAddByteFromArgument
      20  zclBufferAddInt32
      12  zclBufferAddInt32FromArgument
       6  zclBufferAddInt8sFromArgument
      50  zclBufferAddLengthAndStringFromArgument
      20  zclBufferAddString
      18  zclBufferAddWord
      14  zclBufferAddWordFromArgument
      80  zclBufferSetup
       2  zclDrlcLoadControlEventCommand
      44  zclGlobalCommandDiscoveryCommand
      20  zclGlobalDirectionCommand
       4  zclGlobalDiscoverCommand
      36  zclGlobalExpectReportFromMeCommand
       6  zclGlobalReadCommand
     152  zclGlobalReportCommand
      32  zclGlobalReportReadCommand
      90  zclGlobalSendMeAReportCommand
      26  zclGlobalSetup
      86  zclGlobalWriteCommand
       2  zclGroupsGetCommand
       4  zclIdentifyIdCommand
       8  zclIdentifyOffCommand
      26  zclIdentifyOnCommand
       2  zclIdentifyQueryCommand
       4  zclIdentifyTriggerEffectCommand
      20  zclLevelControlMoveCommand
      20  zclLevelControlMoveToLevelCommand
      20  zclLevelControlStepCommand
      20  zclLevelControlStopCommand
      16  zclMfgCodeCommand
      28  zclOnOffCommand
       6  zclOnOffOffWithEffectCommand
       6  zclOnOffOnWithRecallGlobalSceneCommand
       6  zclOnOffOnWithTimedOffCommand
     136  zclSimpleCommand
       6  zclTestResponseOffCommand
       6  zclTestResponseOnCommand
      14  zclTimeCommand
      12  zclXDefaultRespCommand

 
   104 bytes in section .bss
     1 byte  in section .rodata
 2 294 bytes in section .text
 
 2 294 bytes of CODE  memory
     1 byte  of CONST memory
   104 bytes of DATA  memory

Errors: none
Warnings: none
